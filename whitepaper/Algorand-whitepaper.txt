arXiv:1607.01341v9 [cs.CR] 26 May 2017

ALGORAND∗
Silvio Micali
CSAIL
MIT
Cambridge, MA 02139, USA
silvio@csail.mit.edu

Jing Chen
Computer Science Department
Stony Brook University
Stony Brook, NY 11794, USA
jingchen@cs.stonybrook.edu

Abstract
A public ledger is a tamperproof sequence of data that can be read and augmented by everyone.
Public ledgers have innumerable and compelling uses. They can secure, in plain sight, all kinds
of transactions —such as titles, sales, and payments— in the exact order in which they occur.
Public ledgers not only curb corruption, but also enable very sophisticated applications —such as
cryptocurrencies and smart contracts. They stand to revolutionize the way a democratic society
operates. As currently implemented, however, they scale poorly and cannot achieve their potential.
Algorand is a truly democratic and efficient way to implement a public ledger. Unlike prior
implementations based on proof of work, it requires a negligible amount of computation, and
generates a transaction history that will not “fork” with overwhelmingly high probability.
Algorand is based on (a novel and super fast) message-passing Byzantine agreement.

For concreteness, we shall describe Algorand only as a money platform.

1

Introduction

Money is becoming increasingly virtual. It has been estimated that about 80% of United States
dollars today only exist as ledger entries [5]. Other financial instruments are following suit.
In an ideal world, in which we could count on a universally trusted central entity, immune
to all possible cyber attacks, money and other financial transactions could be solely electronic.
Unfortunately, we do not live in such a world. Accordingly, decentralized cryptocurrencies, such
as Bitcoin [29], and “smart contract” systems, such as Ethereum, have been proposed [4]. At
the heart of these systems is a shared ledger that reliably records a sequence of transactions,
∗

This is the more formal (and asynchronous) version of the ArXiv paper by the second author [24], a paper
itself based on that of Gorbunov and Micali [18]. Algorand’s technologies are the object of the following
patent applications: US62/117,138 US62/120,916 US62/142,318 US62/218,817 US62/314,601 PCT/US2016/018300
US62/326,865 62/331,654 US62/333,340 US62/343,369 US62/344,667 US62/346,775 US62/351,011 US62/653,482
US62/352,195 US62/363,970 US62/369,447 US62/378,753 US62/383,299 US62/394,091 US62/400,361 US62/403,403
US62/410,721 US62/416,959 US62/422,883 US62/455,444 US62/458,746 US62/459,652 US62/460,928 US62/465,931

1

as varied as payments and contracts, in a tamperproof way. The technology of choice to
guarantee such tamperproofness is the blockchain. Blockchains are behind applications such as
cryptocurrencies [29], financial applications [4], and the Internet of Things [3]. Several techniques
to manage blockchain-based ledgers have been proposed: proof of work [29], proof of stake [2],
practical Byzantine fault-tolerance [8], or some combination.
Currently, however, ledgers can be inefficient to manage. For example, Bitcoin’s proof-of-work
approach (based on the original concept of [14]) requires a vast amount of computation, is wasteful
and scales poorly [1]. In addition, it de facto concentrates power in very few hands.
We therefore wish to put forward a new method to implement a public ledger that offers the
convenience and efficiency of a centralized system run by a trusted and inviolable authority, without
the inefficiencies and weaknesses of current decentralized implementations. We call our approach
Algorand, because we use algorithmic randomness to select, based on the ledger constructed so far,
a set of verifiers who are in charge of constructing the next block of valid transactions. Naturally,
we ensure that such selections are provably immune from manipulations and unpredictable until
the last minute, but also that they ultimately are universally clear.
Algorand’s approach is quite democratic, in the sense that neither in principle nor de facto it
creates different classes of users (as “miners” and “ordinary users” in Bitcoin). In Algorand “all
power resides with the set of all users”.
One notable property of Algorand is that its transaction history may fork only with very small
probability (e.g., one in a trillion, that is, or even 10−18 ). Algorand can also address some legal
and political concerns.
The Algorand approach applies to blockchains and, more generally, to any method of generating
a tamperproof sequence of blocks. We actually put forward a new method —alternative to, and
more efficient than, blockchains— that may be of independent interest.

1.1

Bitcoin’s Assumption and Technical Problems

Bitcoin is a very ingenious system and has inspired a great amount of subsequent research. Yet, it
is also problematic. Let us summarize its underlying assumption and technical problems —which
are actually shared by essentially all cryptocurrencies that, like Bitcoin, are based on proof-of-work.
For this summary, it suffices to recall that, in Bitcoin, a user may own multiple public keys
of a digital signature scheme, that money is associated with public keys, and that a payment is a
digital signature that transfers some amount of money from one public key to another. Essentially,
Bitcoin organizes all processed payments in a chain of blocks, B1 , B2 , . . ., each consisting of multiple
payments, such that, all payments of B1 , taken in any order, followed by those of B2 , in any order,
etc., constitute a sequence of valid payments. Each block is generated, on average, every 10 minutes.
This sequence of blocks is a chain, because it is structured so as to ensure that any change, even
in a single block, percolates into all subsequent blocks, making it easier to spot any alteration of
the payment history. (As we shall see, this is achieved by including in each block a cryptographic
hash of the previous one.) Such block structure is referred to as a blockchain.
Assumption: Honest Majority of Computational Power Bitcoin assumes that no malicious
entity (nor a coalition of coordinated malicious entities) controls the majority of the computational
power devoted to block generation. Such an entity, in fact, would be able to modify the blockchain,

2

and thus re-write the payment history, as it pleases. In particular, it could make a payment ℘,
obtain the benefits paid for, and then “erase” any trace of ℘.
Technical Problem 1: Computational Waste Bitcoin’s proof-of-work approach to block
generation requires an extraordinary amount of computation. Currently, with just a few hundred
thousands public keys in the system, the top 500 most powerful supercomputers can only muster
a mere 12.8% percent of the total computational power required from the Bitcoin players. This
amount of computation would greatly increase, should significantly more users join the system.
Technical Problem 2: Concentration of Power Today, due to the exorbitant amount of
computation required, a user, trying to generate a new block using an ordinary desktop (let alone a
cell phone), expects to lose money. Indeed, for computing a new block with an ordinary computer,
the expected cost of the necessary electricity to power the computation exceeds the expected reward.
Only using pools of specially built computers (that do nothing other than “mine new blocks”), one
might expect to make a profit by generating new blocks. Accordingly, today there are, de facto, two
disjoint classes of users: ordinary users, who only make payments, and specialized mining pools,
that only search for new blocks.
It should therefore not be a surprise that, as of recently, the total computing power for block
generation lies within just five pools. In such conditions, the assumption that a majority of the
computational power is honest becomes less credible.
Technical Problem 3: Ambiguity In Bitcoin, the blockchain is not necessarily unique. Indeed
′
′
, according to
, Bk+2
its latest portion often forks: the blockchain may be —say— B1 , . . . , Bk , Bk+1
′′
′′
′′
one user, and B1 , . . . , Bk , Bk+1 , Bk+2 , Bk+3 according another user. Only after several blocks have
been added to the chain, can one be reasonably sure that the first k + 3 blocks will be the same
for all users. Thus, one cannot rely right away on the payments contained in the last block of
the chain. It is more prudent to wait and see whether the block becomes sufficiently deep in the
blockchain and thus sufficiently stable.
Separately, law-enforcement and monetary-policy concerns have also been raised about Bitcoin.1

1.2

Algorand, in a Nutshell

Setting Algorand works in a very tough setting. Briefly,
(a) Permissionless and Permissioned Environments. Algorand works efficiently and securely even
in a totally permissionless environment, where arbitrarily many users are allowed to join the
system at any time, without any vetting or permission of any kind. Of course, Algorand works
even better in a permissioned environment.
1

The (pseudo) anonymity offered by Bitcoin payments may be misused for money laundering and/or the financing
of criminal individuals or terrorist organizations. Traditional banknotes or gold bars, that in principle offer perfect
anonymity, should pose the same challenge, but the physicality of these currencies substantially slows down money
transfers, so as to permit some degree of monitoring by law-enforcement agencies.
The ability to “print money” is one of the very basic powers of a nation state. In principle, therefore, the massive
adoption of an independently floating currency may curtail this power. Currently, however, Bitcoin is far from being
a threat to governmental monetary policies, and, due to its scalability problems, may never be.

3

(b) Very Adversarial Environments. Algorand withstands a very powerful Adversary, who can
(1) instantaneously corrupt any user he wants, at any time he wants, provided that, in a
permissionless environment, 2/3 of the money in the system belongs to honest user. (In a
permissioned environment, irrespective of money, it suffices that 2/3 of the users are honest.)
(2) totally control and perfectly coordinate all corrupted users; and
(3) schedule the delivery of all messages, provided that each message m sent by a honest user
reaches 95% of the honest users within a time λm , which solely depends on the size of m.
Main Properties

Despite the presence of our powerful adversary, in Algorand

• The amount of computation required is minimal. Essentially, no matter how many users are
present in the system, each of fifteen hundred users must perform at most a few seconds of
computation.
• A New Block is Generated in less than 10 minutes, and will de facto never leave the blockchain.
For instance, in expectation, the time to generate a block in the first embodiment is less
than Λ + 12.4λ, where Λ is the time necessary to propagate a block, in a peer-to-peer gossip
fashion, no matter what block size one may choose, and λ is the time to propagate 1,500 200Blong messages. (Since in a truly decentralized system, Λ essentially is an intrinsic latency, in
Algorand the limiting factor in block generation is network speed.) The second embodiment has
actually been tested experimentally ( by ?), indicating that a block is generated in less than 40
seconds.
In addition, Algorand’s blockchain may fork only with negligible probability (i.e., less than one
in a trillion), and thus users can relay on the payments contained in a new block as soon as the
block appears.
• All power resides with the users themselves. Algorand is a truy distributed system. In particular,
there are no exogenous entities (as the “miners” in Bitcoin), who can control which transactions
are recognized.
Algorand’s Techniques.
1. A New and Fast Byzantine Agreement Protocol. Algorand generates a new block via
a new cryptographic, message-passing, binary Byzantine agreement (BA) protocol, BA⋆ . Protocol
BA⋆ not only satisfies some additional properties (that we shall soon discuss), but is also very fast.
Roughly said, its binary-input version consists of a 3-step loop, in which a player i sends a single
message mi to all other players. Executed in a complete and synchronous network, with more
than 2/3 of the players being honest, with probability > 1/3, after each loop the protocol ends in
agreement. (We stress that protocol BA⋆ satisfies the original definition of Byzantine agreement
of Pease, Shostak, and Lamport [31], without any weakenings.)
Algorand leverages this binary BA protocol to reach agreement, in our different communication
model, on each new block. The agreed upon block is then certified, via a prescribed number of
digital signature of the proper verifiers, and propagated through the network.
2. Cryptographic Sortition. Although very fast, protocol BA⋆ would benefit from further
speed when played by millions of users. Accordingly, Algorand chooses the players of BA⋆ to be
4

a much smaller subset of the set of all users. To avoid a different kind of concentration-of-power
problem, each new block B r will be constructed and agreed upon, via a new execution of BA⋆ ,
by a separate set of selected verifiers, SV r . In principle, selecting such a set might be as hard as
selecting B r directly. We traverse this potential problem by an approach that we term, embracing
the insightful suggestion of Maurice Herlihy, cryptographic sortition. Sortition is the practice of
selecting officials at random from a large set of eligible individuals [6]. (Sortition was practiced
across centuries: for instance, by the republics of Athens, Florence, and Venice. In modern judicial
systems, random selection is often used to choose juries. Random sampling has also been recently
advocated for elections by David Chaum [9].) In a decentralized system, of course, choosing the
random coins necessary to randomly select the members of each verifier set SV r is problematic.
We thus resort to cryptography in order to select each verifier set, from the population of all users,
in a way that is guaranteed to be automatic (i.e., requiring no message exchange) and random.
In essence, we use a cryptographic function to automatically determine, from the previous block
B r−1 , a user, the leader, in charge of proposing the new block B r , and the verifier set SV r , in
charge to reach agreement on the block proposed by the leader. Since malicious users can affect
the composition of B r−1 (e.g., by choosing some of its payments), we specially construct and use
additional inputs so as to prove that the leader for the rth block and the verifier set SV r are indeed
randomly chosen.
3. The Quantity (Seed) Qr . We use the the last block B r−1 in the blockchain in order to
automatically determine the next verifier set and leader in charge of constructing the new block
B r . The challenge with this approach is that, by just choosing a slightly different payment in the
previous round, our powerful Adversary gains a tremendous control over the next leader. Even if he
only controlled only 1/1000 of the players/money in the system, he could ensure that all leaders are
malicious. (See the Intuition Section 4.1.) This challenge is central to all proof-of-stake approaches,
and, to the best of our knowledge, it has not, up to now, been satisfactorily solved.
To meet this challenge, we purposely construct, and continually update, a separate and carefully
defined quantity, Qr , which provably is, not only unpredictable, but also not influentiable, by our
powerful Adversary. We may refer to Qr as the rth seed, as it is from Qr that Algorand selects,
via secret cryptographic sortition, all the users that will play a special role in the generation of the
rth block.
4. Secret Crytographic Sortition and Secret Credentials. Randomly and unambiguously using the current last block, B r−1 , in order to choose the verifier set and the leader in charge
of constructing the new block, B r , is not enough. Since B r−1 must be known before generating B r ,
the last non-influentiable quantity Qr−1 contained in B r−1 must be known too. Accordingly, so
are the verifiers and the leader in charge to compute the block B r . Thus, our powerful Adversary
might immediately corrupt all of them, before they engage in any discussion about B r , so as to get
full control over the block they certify.
To prevent this problem, leaders (and actually verifiers too) secretly learn of their role, but can
compute a proper credential, capable of proving to everyone that indeed have that role. When
a user privately realizes that he is the leader for the next block, first he secretly assembles his
own proposed new block, and then disseminates it (so that can be certified) together with his own
credential. This way, though the Adversary will immediately realize who the leader of the next
block is, and although he can corrupt him right away, it will be too late for the Adversary to
influence the choice of a new block. Indeed, he cannot “call back” the leader’s message no more
5

than a powerful government can put back into the bottle a message virally spread by WikiLeaks.
As we shall see, we cannot guarantee leader uniqueness, nor that everyone is sure who the leader
is, including the leader himself! But, in Algorand, unambiguous progress will be guaranteed.
5. Player Replaceability. After he proposes a new block, the leader might as well “die” (or be
corrupted by the Adversary), because his job is done. But, for the verifiers in SV r , things are less
simple. Indeed, being in charge of certifying the new block B r with sufficiently many signatures,
they must first run Byzantine agreement on the block proposed by the leader. The problem is that,
no matter how efficient it is, BA⋆ requires multiple steps and the honesty of > 2/3 of its players.
This is a problem, because, for efficiency reasons, the player set of BA⋆ consists the small set SV r
randomly selected among the set of all users. Thus, our powerful Adversary, although unable to
corrupt 1/3 of all the users, can certainly corrupt all members of SV r !
Fortunately we’ll prove that protocol BA⋆ , executed by propagating messages in a peer-topeer fashion, is player-replaceable. This novel requirement means that the protocol correctly and
efficiently reaches consensus even if each of its step is executed by a totally new, and randomly
and independently selected, set of players. Thus, with millions of users, each small set of players
associated to a step of BA⋆ most probably has empty intersection with the next set.
In addition, the sets of players of different steps of BA⋆ will probably have totally different
cardinalities. Furthermore, the members of each set do not know who the next set of players will
be, and do not secretly pass any internal state.
The replaceable-player property is actually crucial to defeat the dynamic and very powerful
Adversary we envisage. We believe that replaceable-player protocols will prove crucial in lots of
contexts and applications. In particular, they will be crucial to execute securely small sub-protocols
embedded in a larger universe of players with a dynamic adversary, who, being able to corrupt even
a small fraction of the total players, has no difficulty in corrupting all the players in the smaller
sub-protocol.
An Additional Property/Technique: Lazy Honesty A honest user follows his prescribed
instructions, which include being online and run the protocol. Since, Algorand has only modest
computation and communication requirement, being online and running the protocol “in the
background” is not a major sacrifice. Of course, a few “absences” among honest players, as those
due to sudden loss of connectivity or the need of rebooting, are automatically tolerated (because
we can always consider such few players to be temporarily malicious). Let us point out, however,
that Algorand can be simply adapted so as to work in a new model, in which honest users to be
offline most of the time. Our new model can be informally introduced as follows.
Lazy Honesty. Roughly speaking, a user i is lazy-but-honest if (1) he follows all his prescribed
instructions, when he is asked to participate to the protocol, and (2) he is asked to participate
to the protocol only rarely, and with a suitable advance notice.
With such a relaxed notion of honesty, we may be even more confident that honest people will be
at hand when we need them, and Algorand guarantee that, when this is the case,
The system operates securely even if, at a given point in time,
the majority of the participating players are malicious.

6

1.3

Closely Related work

Proof-of-work approaches (like the cited [29] and [4]) are quite orthogonal to our ours. So are the
approaches based on message-passing Byzantine agreement or practical Byzantine fault tolerance
(like the cited [8]). Indeed, these protocols cannot be run among the set of all users and cannot,
in our model, be restricted to a suitably small set of users. In fact, our powerful adversary my
immediately corrupt all the users involved in a small set charged to actually running a BA protocol.
Our approach could be considered related to proof of stake [2], in the sense that users’ “power”
in block building is proportional to the money they own in the system (as opposed to —say— to
the money they have put in “escrow”).
The paper closest to ours is the Sleepy Consensus Model of Pass and Shi [30]. To avoid the
heavy computation required in the proof-of-work approach, their paper relies upon (and kindly
credits) Algorand’s secret cryptographic sortition. With this crucial aspect in common, several
significant differences exist between our papers. In particular,
(1) Their setting is only permissioned. By contrast, Algorand is also a permissionless system.
(2) They use a Nakamoto-style protocol, and thus their blockchain forks frequently. Although
dispensing with proof-of-work, in their protocol a secretly selected leader is asked to elongate the
longest valid (in a richer sense) blockchain. Thus, forks are unavoidable and one has to wait that
the block is sufficiently “deep” in the chain. Indeed, to achieve their goals with an adversary
capable of adaptive corruptions, they require a block to be poly(N ) deep, where N represents the
total number of users in the system. Notice that, even assuming that a block could be produced
in a minute, if there were N = 1M users, then one would have to wait for about 2M years for
a block to become N 2 -deep, and for about 2 years for a block to become N -deep. By contrast,
Algorand’s blockchain forks only with negligible probability, even though the Adversary corrupt
users immediately and adaptively, and its new blocks can immediately be relied upon.
(3) They do not handle individual Byzantine agreements. In a sense, they only guarantee
“eventual consensus on a growing sequence of values”. Theirs is a state replication protocol, rather
than a BA one, and cannot be used to reach Byzantine agreement on an individual value of interest.
By contrast, Algorand can also be used only once, if so wanted, to enable millions of users to quickly
reach Byzantine agreement on a specific value of interest.
(4) They require weakly synchronized clocks. That is, all users’ clocks are offset by a small time
δ. By contrast, in Algorand, clocks need only have (essentially) the same “speed”.
(5) Their protocol works with lazy-but-honest users or with honest majority of online users.
They kindly credit Algorand for raising the issue of honest users going offline en masse, and for
putting forward the lazy honesty model in response. Their protocol not only works in the lazy
honesty model, but also in their adversarial sleepy model, where an adversary chooses which users
are online and which are offline, provided that, at all times, the majority of online users are honest.2
2
The original version of their paper actually considered only security in their adversarial sleepy model. The
original version of Algorand, which precedes theirs, also explicitly envisaged assuming that a given majority of the
online players is always honest, but explicitly excluded it from consideration, in favor of the lazy honesty model.
(For instance, if at some point in time half of the honest users choose to go off-line, then the majority of the users
on-line may very well be malicious. Thus, to prevent this from happening, the Adversary should force most of his
corrupted players to go off-line too, which clearly is against his own interest.) Notice that a protocol with a majority
of lazy-but-honest players works just fine if the majority of the users on-line are always malicious. This is so, because
a sufficient number of honest players, knowing that they are going to be crucial at some rare point in time, will elect
not to go off-line in those moments, nor can they be forced off-line by the Adversary, since he does not know who the
crucial honest players might be.

7

(6) They require a simple honest majority. By contrast, the current version of Algorand requires
a 2/3 honest majority.
Another paper close to us is Ouroboros: A Provably Secure Proof-of-Stake Blockchain Protocol,
by Kiayias, Russell, David, and Oliynykov [20]. Also their system appeared after ours. It also
uses crytpographic sortition to dispense with proof of work in a provable manner. However, their
system is, again, a Nakamoto-style protocol, in which forks are both unavoidable and frequent.
(However, in their model, blocks need not as deep as the sleepy-consensus model.) Moreover,
their system relies on the following assumptions: in the words of the authors themselves, “(1) the
network is highly synchronous, (2) the majority of the selected stakeholders is available as needed
to participate in each epoch, (3) the stakeholders do not remain offline for long periods of time,
(4) the adaptivity of corruptions is subject to a small delay that is measured in rounds linear in
the security parameter.” By contrast, Algorand is, with overwhelming probability, fork-free, and
does not rely on any of these 4 assumptions. In particular, in Algorand, the Adversary is able to
instantaneously corrupt the users he wants to control.

2

Preliminaries

2.1

Cryptographic Primitives

Ideal Hashing. We shall rely on an efficiently computable cryptographic hash function, H, that
maps arbitrarily long strings to binary strings of fixed length. Following a long tradition, we model
H as a random oracle, essentially a function mapping each possible string s to a randomly and
independently selected (and then fixed) binary string, H(s), of the chosen length.
In this paper, H has 256-bit long outputs. Indeed, such length is short enough to make the
system efficient and long enough to make the system secure. For instance, we want H to be collisionresilient. That is, it should be hard to find two different strings x and y such that H(x) = H(y).
When H is a random oracle with 256-bit long outputs, finding any such pair of strings is indeed
difficult. (Trying at random, and relying on the birthday paradox, would require 2256/2 = 2128
trials.)
Digital Signing. Digital signatures allow users to to authenticate information to each other
without sharing any sharing any secret keys. A digital signature scheme consists of three fast
algorithms: a probabilistic key generator G, a signing algorithm S, and a verification algorithm V .
Given a security parameter k, a sufficiently high integer, a user i uses G to produce a pair of
k-bit keys (i.e., strings): a “public” key pki and a matching “secret” signing key ski . Crucially, a
public key does not “betray” its corresponding secret key. That is, even given knowledge of pki , no
one other than i is able to compute ski in less than astronomical time.
User i uses ski to digitally sign messages. For each possible message (binary string) m, i first
hashes m and then runs algorithm S on inputs H(m) and ski so as to produce the k-bit string
sigpki (m) , S(H(m), ski ) .3
3

Since H is collision-resilient it is practically impossible that, by signing m one “accidentally signs” a different
message m′ .

8

The binary string sigpki (m) is referred to as i’s digital signature of m (relative to pki ), and can be
more simply denoted by sigi (m), when the public key pki is clear from context.
Everyone knowing pki can use it to verify the digital signatures produced by i. Specifically, on
inputs (a) the public key pki of a player i, (b) a message m, and (c) a string s, that is, i’s alleged
digital signature of the message m, the verification algorithm V outputs either YES or NO.
The properties we require from a digital signature scheme are:
1. Legitimate signatures are always verified: If s = sigi (m), then V (pki , m, s) = Y ES; and
2. Digital signatures are hard to forge: Without knowledge of ski the time to find a string s such
that V (pki , m, s) = Y ES, for a message m never signed by i, is astronomically long.
(Following the strong security requirement of Goldwasser, Micali, and Rivest [17], this is true
even if one can obtain the signature of any other message.)
Accordingly, to prevent anyone else from signing messages on his behalf, a player i must keep his
signing key ski secret (hence the term “secret key”), and to enable anyone to verify the messages
he does sign, i has an interest in publicizing his key pki (hence the term “public key”).
In general, a message m is not retrievable from its signature sigi (m). In order to virtually deal
with digital signatures that satisfy the conceptually convenient “retrievability” property (i.e., to
guarantee that the signer and the message are easily computable from a signature, we define
SIGpki (m) = (i, m, sigpki (m))

and

SIGi (m) = (i, m, sigi (m)), if pki is clear.

Unique Digital Signing. We also consider digital signature schemes (G, S, V ) satisfying the
following additional property.
3. Uniqueness. It is hard to find strings pk ′ , m, s, and s′ such that
s 6= s′

and

V (pk ′ , m, s) = V (pk′ , m, s′ ) = 1.

(Note that the uniqueness property holds also for strings pk ′ that are not legitimately generated
public keys. In particular, however, the uniqueness property implies that, if one used the
specified key generator G to compute a public key pk together with a matching secret key sk,
and thus knew sk, it would be essentially impossible also for him to find two different digital
signatures of a same message relative to pk.)
Remarks
• From Unique signatures to verifiable random functions. Relative to a digital
signature scheme with the uniqueness property, the mapping m → H(sigi (m)) associates to
each possible string m, a unique, randomly selected, 256-bit string, and the correctness of this
mapping can be proved given the signature sigi (m).
That is, ideal hashing and digital signature scheme satisfying the uniqueness property essentially
provide an elementary implementation of a verifiable random function, as introduced and by
Micali, Rabin, and Vadhan [27]. (Their original implementation was necessarily more complex,
since they did not rely on ideal hashing.)

9

• Three different needs for digital signatures. In Algorand, a user i relies on digital
signatures for
(1) Authenticating i’s own payments. In this application, keys can be “long-term” (i.e., used to
sign many messages over a long period of time) and come from a ordinary signature scheme.
(2) Generating credentials proving that i is entitled to act at some step s of a round r. Here,
keys can be long-term, but must come from a scheme satisfying the uniqueness property.
(3) Authenticating the message i sends in each step in which he acts. Here, keys must be
ephemeral (i.e., destroyed after their first use), but can come from an ordinary signature scheme.
• A small-cost simplification. For simplicity, we envision each user i to have a single longterm key. Accordingly, such a key must come from a signature scheme with the uniqueness
property. Such simplicity has a small computational cost. Typically, in fact, unique digital
signatures are slightly more expensive to produce and verify than ordinary signatures.

2.2

The Idealized Public Ledger

Algorand tries to mimic the following payment system, based on an idealized public ledger.
1. The Initial Status. Money is associated with individual public keys (privately generated and
owned by users). Letting pk1 , . . . , pkj be the initial public keys and a1 , . . . , aj their respective
initial amounts of money units, then the initial status is
S0 = (pk1 , a1 ), . . . , (pkj , aj ) ,
which is assumed to be common knowledge in the system.
2. Payments. Let pk be a public key currently having a ≥ 0 money units, pk′ another public
key, and a′ a non-negative number no greater than a. Then, a (valid) payment ℘ is a digital
signature, relative to pk, specifying the transfer of a′ monetary units from pk to pk′ , together
with some additional information. In symbols,
℘ = SIGpk (pk, pk′ , a′ , I, H(I)),
where I represents any additional information deemed useful but not sensitive (e.g., time
information and a payment identifier), and I any additional information deemed sensitive (e.g.,
the reason for the payment, possibly the identities of the owners of pk and the pk ′ , and so on).
We refer to pk (or its owner) as the payer, to each pk ′ (or its owner) as a payee, and to a′ as
the amount of the payment ℘.
Free Joining Via Payments. Note that users may join the system whenever they want by
generating their own public/secret key pairs. Accordingly, the public key pk ′ that appears in
the payment ℘ above may be a newly generated public key that had never “owned” any money
before.
3. The Magic Ledger. In the Idealized System, all payments are valid and appear in a tamper-proof
list L of sets of payments “posted on the sky” for everyone to see:
L = P AY 1 , P AY 2 , . . . ,
10

Each block P AY r+1 consists of the set of all payments made since the appearance of block
P AY r . In the ideal system, a new block appears after a fixed (or finite) amount of time.
Discussion.
• More General Payments and Unspent Transaction Output. More generally, if a public key
pk owns an amount a, then a valid payment P
℘ of pk may transfer the amounts a′1 , a′2 , . . .,
′
′
respectively to the keys pk1 , pk2 , . . ., so long as j a′j ≤ a.

In Bitcoin and similar systems, the money owned by a public key pk is segregated into separate
amounts, and a payment ℘ made by pk must transfer such a segregated amount a in its entirety.
If pk wishes to transfer only a fraction a′ < a of a to another key, then it must also transfer the
balance, the unspent transaction output, to another key, possibly pk itself.

Algorand also works with keys having segregated amounts. However, in order to focus on the
novel aspects of Algorand, it is conceptually simpler to stick to our simpler forms of payments
and keys having a single amount associated to them.
• Current Status. The Idealized Scheme does not directly provide information about the current
status of the system (i.e., about how many money units each public key has). This information
is deducible from the Magic Ledger.
In the ideal system, an active user continually stores and updates the latest status information,
or he would otherwise have to reconstruct it, either from scratch, or from the last time he
computed it. (In the next version of this paper, we shall augment Algorand so as to enable its
users to reconstruct the current status in an efficient manner.)
• Security and “Privacy”. Digital signatures guarantee that no one can forge a payment by
another user. In a payment ℘, the public keys and the amount are not hidden, but the sensitive
information I is. Indeed, only H(I) appears in ℘, and since H is an ideal hash function, H(I)
is a random 256-bit value, and thus there is no way to figure out what I was better than by
simply guessing it. Yet, to prove what I was (e.g., to prove the reason for the payment) the
payer may just reveal I. The correctness of the revealed I can be verified by computing H(I)
and comparing the resulting value with the last item of ℘. In fact, since H is collision resilient,
it is hard to find a second value I ′ such that H(I) = H(I ′ ).

2.3

Basic Notions and Notations

Keys, Users, and Owners Unless otherwise specified, each public key (“key” for short) is longterm and relative to a digital signature scheme with the uniqueness property. A public key i joins
the system when another public key j already in the system makes a payment to i.
For color, we personify keys. We refer to a key i as a “he”, say that i is honest, that i sends
and receives messages, etc. User is a synonym for key. When we want to distinguish a key from
the person to whom it belongs, we respectively use the term “digital key” and “owner”.
Permissionless and Permissioned Systems. A system is permissionless, if a digital key is free
to join at any time and an owner can own multiple digital keys; and its permissioned, otherwise.

11

Unique Representation Each object in Algorand has a unique representation. In particular,
each set {(x, y, z, . . .) : x ∈ X, y ∈ Y, z ∈ Z, . . .} is ordered in a pre-specified manner: e.g., first
lexicographically in x, then in y, etc.
Same-Speed Clocks There is no global clock: rather, each user has his own clock. User clocks
need not be synchronized in any way. We assume, however, that they all have the same speed.
For instance, when it is 12pm according to the clock of a user i, it may be 2:30pm according to
the clock of another user j, but when it will be 12:01 according to i’s clock, it will 2:31 according
to j’s clock. That is, “one minute is the same (sufficiently, essentially the same) for every user”.
Rounds Algorand is organized in logical units, r = 0, 1, . . ., called rounds.
We consistently use superscripts to indicate rounds. To indicate that a non-numerical quantity Q
(e.g., a string, a public key, a set, a digital signature, etc.) refers to a round r, we simply write Qr .
Only when Q is a genuine number (as opposed to a binary string interpretable as a number), do
we write Q(r) , so that the symbol r could not be interpreted as the exponent of Q.
At (the start of a) round r > 0, the set of all public keys is P K r , and the system status is
o
n

(r)
Sr =
i, ai , . . . : i ∈ P K r ,
(r)

where ai is the amount of money available to the public key i. Note that P K r is deducible from
S r , and that S r may also specify other components for each public key i.
For round 0, P K 0 is the set of initial public keys, and S 0 is the initial status. Both P K 0 and
0
S are assumed to be common knowledge in the system. For simplicity, at the start of round r, so
are P K 1 , . . . , P K r and S 1 , . . . , S r .
In a round r, the system status transitions from S r to S r+1 : symbolically,
Round r: S r −→ S r+1 .
Payments In Algorand, the users continually make payments (and disseminate them in the way
described in subsection 2.7). A payment ℘ of a user i ∈ P K r has the same format and semantics
as in the Ideal System. Namely,
℘ = SIGi (i, i′ , a, I, H(I)) .

Payment ℘ is individually valid at a round r (is a round-r payment, for short) if (1) its amount
′
(r)
a is less than or equal to ai , and (2) it does not appear in any official payset P AY r for r ′ < r.
(As explained below, the second condition means that ℘ has not already become effective.
(r)
A set of round-r payments of i is collectively valid if the sum of their amounts is at most ai .
Paysets A round-r payset P is a set of round-r payments such that, for each user i, the payments
of i in P (possibly none) are collectively valid. The set of all round-r paysets is PAY(r). A round-r
payset P is maximal if no superset of P is a round-r payset.
We actually suggest that a payment ℘ also specifies a round ρ, ℘ = SIGi (ρ, i, i′ , a, I, H(I)) ,
and cannot be valid at any round outside [ρ, ρ + k], for some fixed non-negative integer k.4
4

This simplifies checking whether ℘ has become “effective” (i.e., it simplifies determining whether some payset
P AY r contains ℘. When k = 0, if ℘ = SIGi (r, i, i′ , a, I, H(I)) , and ℘ ∈
/ P AY r , then i must re-submit ℘.

12

Official Paysets For every round r, Algorand publicly selects (in a manner described later on)
a single (possibly empty) payset, P AY r , the round’s official payset. (Essentially, P AY r represents
the round-r payments that have “actually” happened.)
As in the Ideal System (and Bitcoin), (1) the only way for a new user j to enter the system
is to be the recipient of a payment belonging to the official payset P AY r of a given round r; and
(2) P AY r determines the status of the next round, S r+1 , from that of the current round, S r .
Symbolically,
P AY r : S r −→ S r+1 .
Specifically,
1. the set of public keys of round r + 1, P K r+1 , consists of the union of P K r and the set of all
payee keys that appear, for the first time, in the payments of P AY r ; and
(r+1)

2. the amount of money ai
that a user i owns in round r + 1 is the sum of ai (r) —i.e., the
amount of money i owned in the previous round (0 if i 6∈ P K r )— and the sum of amounts
paid to i according to the payments of P AY r .
In sum, as in the Ideal System, each status S r+1 is deducible from the previous payment history:
P AY 0 , . . . , P AY r .

2.4

Blocks and Proven Blocks

In Algorand0 , the block B r corresponding to a round r specifies: r itself; the set of payments of
round r, P AY r ; a quantity Qr , to be explained, and the hash of the previous block, H(B r−1 ).
Thus, starting from some fixed block B 0 , we have a traditional blockchain:
B 1 = (1, P AY 1 , Q0 , H(B 0 )),

B 2 = (2, P AY 2 , Q1 , H(B 1 )),

B 3 = (3, P AY 3 , Q2 , H(B 2 )),

...

In Algorand, the authenticity of a block is actually vouched by a separate piece of information,
a “block certificate” CERT r , which turns B r into a proven block, B r . The Magic Ledger, therefore,
is implemented by the sequence of the proven blocks,
B 1, B 2, . . .
Discussion As we shall see, CERT r consists of a set of digital signatures for H(B r ), those of a
majority of the members of SV r , together with a proof that each of those members indeed belongs
to SV r . We could, of course, include the certificates CERT r in the blocks themselves, but find it
conceptually cleaner to keep it separate.)
In Bitcoin each block must satisfy a special property, that is, must “contain a solution of a
crypto puzzle”, which makes block generation computationally intensive and forks both inevitable
and not rare. By contrast, Algorand’s blockchain has two main advantages: it is generated with
minimal computation, and it will not fork with overwhelmingly high probability. Each block B i is
safely final as soon as it enters the blockchain.

13

2.5

Acceptable Failure Probability

To analyze the security of Algorand we specify the probability, F , with which we are willing to
accept that something goes wrong (e.g., that a verifier set SV r does not have an honest majority).
As in the case of the output length of the cryptographic hash function H, also F is a parameter.
But, as in that case, we find it useful to set F to a concrete value, so as to get a more intuitive
grasp of the fact that it is indeed possible, in Algorand, to enjoy simultaneously sufficient security
and sufficient efficiency. To emphasize that F is parameter that can be set as desired, in the first
and second embodiments we respectively set
F = 10−12

and

F = 10−18 .

Discussion Note that 10−12 is actually less than one in a trillion, and we believe that such a
choice of F is adequate in our application. Let us emphasize that 10−12 is not the probability
with which the Adversary can forge the payments of an honest user. All payments are digitally
signed, and thus, if the proper digital signatures are used, the probability of forging a payment is
far lower than 10−12 , and is, in fact, essentially 0. The bad event that we are willing to tolerate
with probability F is that Algorand’s blockchain forks. Notice that, with our setting of F and
one-minute long rounds, a fork is expected to occur in Algorand’s blockchain as infrequently as
(roughly) once in 1.9 million years. By contrast, in Bitcoin, a forks occurs quite often.
A more demanding person may set F to a lower value. To this end, in our second embodiment
we consider setting F to 10−18 . Note that, assuming that a block is generated every second, 1018
is the estimated number of seconds taken by the Universe so far: from the Big Bang to present
time. Thus, with F = 10−18 , if a block is generated in a second, one should expect for the age of
the Universe to see a fork.

2.6

The Adversarial Model

Algorand is designed to be secure in a very adversarial model. Let us explain.
Honest and Malicious Users A user is honest if he follows all his protocol instructions, and
is perfectly capable of sending and receiving messages. A user is malicious (i.e., Byzantine, in the
parlance of distributed computing) if he can deviate arbitrarily from his prescribed instructions.
The Adversary The Adversary is an efficient (technically polynomial-time) algorithm, personified for color, who can immediately make malicious any user he wants, at any time he wants (subject
only to an upperbound to the number of the users he can corrupt).
The Adversary totally controls and perfectly coordinates all malicious users. He takes all actions
on their behalf, including receiving and sending all their messages, and can let them deviate from
their prescribed instructions in arbitrary ways. Or he can simply isolate a corrupted user sending
and receiving messages. Let us clarify that no one else automatically learns that a user i is malicious,
although i’s maliciousness may transpire by the actions the Adversary has him take.
This powerful adversary however,
• Does not have unbounded computational power and cannot successfully forge the digital
signature of an honest user, except with negligible probability; and
14

• Cannot interfere in any way with the messages exchanges among honest users.
Furthermore, his ability to attack honest users is bounded by one of the following assumption.
Honesty Majority of Money We consider a continuum of Honest Majority of Money (HMM)
assumptions: namely, for each non-negative integer k and real h > 1/2,
HHMk > h: the honest users in every round r owned a fraction greater than h of all money in
the system at round r − k.
Discussion. Assuming that all malicious users perfectly coordinate their actions (as if controlled
by a single entity, the Adversary) is a rather pessimistic hypothesis. Perfect coordination among too
many individuals is difficult to achieve. Perhaps coordination only occurs within separate groups
of malicious players. But, since one cannot be sure about the level of coordination malicious users
may enjoy, we’d better be safe than sorry.
Assuming that the Adversary can secretly, dynamically, and immediately corrupt users is also
pessimistic. After all, realistically, taking full control of a user’s operations should take some time.
The assumption HM Mk > h implies, for instance, that, if a round (on average) is implemented
in one minute, then, the majority of the money at a given round will remain in honest hands for
at least two hours, if k = 120, and at least one week, if k = 10, 000.
Note that the HMM assumptions and the previous Honest Majority of Computing Power
assumptions are related in the sense that, since computing power can be bought with money,
if malicious users own most of the money, then they can obtain most of the computing power.

2.7

The Communication Model

We envisage message propagation —i.e., “peer-to-peer gossip”5 — to be the only means of
communication.
Temporary Assumption: Timely Delivery of Messages in the Entire Network. For
most part of this paper we assume that every propagated message reaches almost all honest users
in a timely fashion. We shall remove this assumption in Section 10, where we deal with network
partitions, either naturally occurring or adversarially induced. (As we shall see, we only assume
timely delivery of messages within each connected component of the network.)
One concrete way to capture timely delivery of propagated messages (in the entire network) is
the following:
For all reachability ρ > 95% and message size µ ∈ Z+ , there exists λρ,µ such that,
if a honest user propagates µ-byte message m at time t,
then m reaches, by time t + λρ,µ , at least a fraction ρ of the honest users.
5

Essentially, as in Bitcoin, when a user propagates a message m, every active user i receiving m for the first time,
randomly and independently selects a suitably small number of active users, his “neighbors”, to whom he forwards m,
possibly until he receives an acknowledgement from them. The propagation of m terminates when no user receives
m for the first time.

15

The above property, however, cannot support our Algorand protocol, without explicitly and separately envisaging a mechanism to obtain the latest blockchain —by another user/depository/etc.
In fact, to construct a new block B r not only should a proper set of verifiers timely receive round-r
messages, but also the messages of previous rounds, so as to know B r−1 and all other previous
blocks, which is necessary to determine whether the payments in B r are valid. The following
assumption instead suffices.
Message Propagation (MP) Assumption: For all ρ > 95% and µ ∈ Z+ , there exists λρ,µ
such that, for all times t and all µ-byte messages m propagated by an honest user before t − λρ,µ ,
m is received, by time t, by at least a fraction ρ of the honest users.
Protocol Algorand ′ actually instructs each of a small number of users (i.e., the verifiers of a
given step of a round in Algorand ′ , to propagate a separate message of a (small) prescribed size,
and we need to bound the time required to fulfill these instructions. We do so by enriching the MP
assumption as follows.
For all n, ρ > 95%, and µ ∈ Z+ , there exists λn,ρ,µ such that, for all times t and all µ-byte
messages m1 , . . . , mn , each propagated by an honest user before t − λn,ρ,µ , m1 , . . . , mn are received,
by time t, by at least a fraction ρ of the honest users.
Note
• The above assumption is deliberately simple, but also stronger than needed in our paper.6
• For simplicity, we assume ρ = 1, and thus drop mentioning ρ.
• We pessimistically assume that, provided he does not violate the MP assumption, the Adversary
totally controls the delivery of all messages. In particular, without being noticed by the honest
users, the Adversary he can arbitrarily decide which honest player receives which message when,
and arbitrarily accelerate the delivery of any message he wants.7

The BA Protocol BA⋆ in a Traditional Setting

3

As already emphasized, Byzantine agreement is a key ingredient of Algorand. Indeed, it is through
the use of such a BA protocol that Algorand is unaffected by forks. However, to be secure against our
powerful Adversary, Algorand must rely on a BA protocol that satisfies the new player-replaceability
constraint. In addition, for Algorand to be efficient, such a BA protocol must be very efficient.
BA protocols were first defined for an idealized communication model, synchronous complete
networks (SC networks). Such a model allows for a simpler design and analysis of BA protocols.
6

Given the honest percentage h and the acceptable failure probability F , Algorand computes an upperbound, N ,
to the maximum number of member of verifiers in a step. Thus, the MP assumption need only hold for n ≤ N .
In addition, as stated, the MP assumption holds no matter how many other messages may be propagated alongside
the mj ’s. As we shall see, however, in Algorand messages at are propagated in essentially non-overlapping time
intervals, during which either a single block is propagated, or at most N verifiers propagate a small (e.g., 200B)
message. Thus, we could restate the MP assumption in a weaker, but also more complex, way.
7
For instance, he can immediately learn the messages sent by honest players. Thus, a malicious user i′ , who is
asked to propagate a message simultaneously with a honest user i, can always choose his own message m′ based on
the message m actually propagated by i. This ability is related to rushing, in the parlance of distributed-computation
literature.

16

Accordingly, in this section, we introduce a new BA protocol, BA⋆ , for SC networks and ignoring
the issue of player replaceability altogether. The protocol BA⋆ is a contribution of separate value.
Indeed, it is the most efficient cryptographic BA protocol for SC networks known so far.
To use it within our Algorand protocol, we modify BA⋆ a bit, so as to account for our different
communication model and context, but make sure, in section X, to highlight how BA⋆ is used
within our actual protocol Algorand ′ .
We start by recalling the model in which BA⋆ operates and the notion of a Byzantine agreement.

3.1

Synchronous Complete Networks and Matching Adversaries

In a SC network, there is a common clock, ticking at each integral times r = 1, 2, . . .
At each even time click r, each player i instantaneously and simultaneously sends a single
message mri,j (possibly the empty message) to each player j, including himself. Each mri,j is received
at time click r + 1 by player j, together with the identity of the sender i.
Again, in a communication protocol, a player is honest if he follows all his prescribed
instructions, and malicious otherwise. All malicious players are totally controlled and perfectly
coordinated by the Adversary, who, in particular, immediately receives all messages addressed to
malicious players, and chooses the messages they send.
The Adversary can immediately make malicious any honest user he wants at any odd time click
he wants, subject only to a possible upperbound t to the number of malicious players. That is,
the Adversary “cannot interfere with the messages already sent by an honest user i”, which will be
delivered as usual.
The Adversary also has the additional ability to see instantaneously, at each even round, the
messages that the currently honest players send, and instantaneously use this information to choose
the messages the malicious players send at the same time tick.
Remarks
• Adversary Power. The above setting is very adversarial. Indeed, in the Byzantine agreement
literature, many settings are less adversarial. However, some more adversarial settings have
also been considered, where the Adversary, after seeing the messages sent by an honest player i
at a given time click r, has the ability to erase all these messages from the network, immediately
corrupt i, choose the message that the now malicious i sends at time click r, and have them
delivered as usual. The envisaged power of the Adversary matches that he has in our setting.
• Physical Abstraction. The envisaged communication model abstracts a more physical model,
in which each pair of players (i, j) is linked by a separate and private communication line li,j .
That is, no one else can inject, interfere with, or gain information about the messages sent over
li,j . The only way for the Adversary to have access to li,j is to corrupt either i or j.
• Privacy and Authentication. In SC networks message privacy and authentication are guaranteed
by assumption. By contrast, in our communication network, where messages are propagated
from peer to peer, authentication is guaranteed by digital signatures, and privacy is non-existent.
Thus, to adopt protocol BA⋆ to our setting, each message exchanged should be digitally signed
(further identifying the state at which it was sent). Fortunately, the BA protocols that we
consider using in Algorand do not require message privacy.
17

3.2

The Notion of a Byzantine Agreement

The notion of Byzantine agreement was introduced by Pease Shostak and Lamport [31] for the
binary case, that is, when every initial value consists of a bit. However, it was quickly extended
to arbitrary initial values. (See the surveys of Fischer [16] and Chor and Dwork [10].) By a BA
protocol, we mean an arbitrary-value one.
Definition 3.1. In a synchronous network, let P be a n-player protocol, whose player set is common
knowledge among the players, t a positive integer such that n ≥ 2t + 1. We say that P is an
arbitrary-value (respectively, binary) (n, t)-Byzantine agreement protocol with soundness σ ∈ (0, 1)
if, for every set of values V not containing the special symbol ⊥ (respectively, for V = {0, 1}), in an
execution in which at most t of the players are malicious and in which every player i starts with an
initial value vi ∈ V , every honest player j halts with probability 1, outputting a value outi ∈ V ∪{⊥}
so as to satisfy, with probability at least σ, the following two conditions:
1. Agreement: There exists out ∈ V ∪ {⊥} such that outi = out for all honest players i.
2. Consistency: if, for some value v ∈ V , vi = v for all honest players, then out = v.
We refer to out as P’s output, and to each outi as player i’s output.

3.3

The BA Notation #

In our BA protocols, a player is required to count how many players sent him a given message in
a given step. Accordingly, for each possible value v that might be sent,
#si (v)
(or just #i (v) when s is clear) is the number of players j from which i has received v in step s.
Recalling that a player i receives
one message from each player j, if the number of
P exactly
s
players is n, then, for all i and s, v #i (v) = n.

3.4

The Binary BA Protocol BBA⋆

In this section we present a new binary BA protocol, BBA⋆ , which relies on the honesty of more
than two thirds of the players and is very fast: no matter what the malicious players might do,
each execution of its main loop brings the players into agreement with probability 1/3.
Each player has his own public key of a digital signature scheme satisfying the unique-signature
property. Since this protocol is intended to be run on synchronous complete network, there is no
need for a player i to sign each of his messages.
Digital signatures are used to generate a sufficiently common random bit in Step 3. (In Algorand,
digital signatures are used to authenticate all other messages as well.)
The protocol requires a minimal set-up: a common random string r, independent of the players’
keys. (In Algorand, r is actually replaced by the quantity Qr .)
Protocol BBA⋆ is a 3-step loop, where the players repeatedly exchange Boolean values, and
different players may exit this loop at different times. A player i exits this loop by propagating,
at some step, either a special value 0∗ or a special value 1∗, thereby instructing all players to
“pretend” they respectively receive 0 and 1 from i in all future steps. (Alternatively said: assume
18

that the last message received by a player j from another player i was a bit b. Then, in any step
in which he does not receive any message from i, j acts as if i sent him the bit b.)
The protocol uses a counter γ, representing how many times its 3-step loop has been executed.
At the start of BBA⋆ , γ = 0. (One may think of γ as a global counter, but it is actually increased
by each individual player every time that the loop is executed.)
There are n ≥ 3t + 1, where t is the maximum possible number of malicious players. A binary
string x is identified with the integer whose binary representation (with possible leadings 0s) is x;
and lsb(x) denotes the least significant bit of x.
Protocol BBA⋆
(Communication) Step 1. [Coin-Fixed-To-0 Step] Each player i sends bi .
1.1 If #1i (0) ≥ 2t + 1, then i sets bi = 0, sends 0∗, outputs outi = 0, and HALTS.
1.2 If #1i (1) ≥ 2t + 1, then, then i sets bi = 1.
1.3 Else, i sets bi = 0.
(Communication) Step 2. [Coin-Fixed-To-1 Step] Each player i sends bi .
2.1 If #2i (1) ≥ 2t + 1, then i sets bi = 1, sends 1∗, outputs outi = 1, and HALTS.
2.2 If #2i (0) ≥ 2t + 1, then i set bi = 0.
2.3 Else, i sets bi = 1.
(Communication) Step 3. [Coin-Genuinely-Flipped Step] Each player i sends bi and SIGi (r, γ).
3.1 If #3i (0) ≥ 2t + 1, then i sets bi = 0.
3.2 If #3i (1) ≥ 2t + 1, then i sets bi = 1.
3.3 Else, letting Si = {j ∈ N who have sent i a proper message in this step 3 },
i sets bi = c , lsb(minj∈Si H(SIGi (r, γ))); increases γi by 1; and returns to Step 1.
Theorem 3.1. Whenever n ≥ 3t + 1, BBA⋆ is a binary (n, t)-BA protocol with soundness 1.
A proof of Theorem 3.1 is given in [26]. Its adaptation to our setting, and its player-replaceability
property are novel.
Historical Remark Probabilistic binary BA protocols were first proposed by Ben-Or in
asynchronous settings [7]. Protocol BBA⋆ is a novel adaptation, to our public-key setting, of the
binary BA protocol of Feldman and Micali [15]. Their protocol was the first to work in an expected
constant number of steps. It worked by having the players themselves implement a common coin,
a notion proposed by Rabin, who implemented it via an external trusted party [32].

19

3.5

Graded Consensus and the Protocol GC

Let us recall, for arbitrary values, a notion of consensus much weaker than Byzantine agreement.
Definition 3.2. Let P be a protocol in which the set of all players is common knowledge, and each
player i privately knows an arbitrary initial value vi′ .
We say that P is an (n, t)-graded consensus protocol if, in every execution with n players, at
most t of which are malicious, every honest player i halts outputting a value-grade pair (vi , gi ),
where gi ∈ {0, 1, 2}, so as to satisfy the following three conditions:
1. For all honest players i and j, |gi − gj | ≤ 1.
2. For all honest players i and j, gi , gj > 0 ⇒ vi = vj .
3. If v1′ = · · · = vn′ = v for some value v, then vi = v and gi = 2 for all honest players i.
Historical Note The notion of a graded consensus is simply derived from that of a graded
broadcast, put forward by Feldman and Micali in [15], by strengthening the notion of a crusader
agreement, as introduced by Dolev [12], and refined by Turpin and Coan [33].8
In [15], the authors also provided a 3-step (n, t)-graded broadcasting protocol, gradecast, for
n ≥ 3t + 1. A more complex (n, t)-graded-broadcasting protocol for n > 2t + 1 has later been found
by Katz and Koo [19].
The following two-step protocol GC consists of the last two steps of gradecast, expressed in our
notation. To emphasize this fact, and to match the steps of protocol Algorand ′ of section 4.1, we
respectively name 2 and 3 the steps of GC.
Protocol GC
Step 2. Each player i sends vi′ to all players.
Step 3. Each player i sends to all players the string x if and only if #2i (x) ≥ 2t + 1.
Output Determination. Each player i outputs the pair (vi , gi ) computed as follows:
• If, for some x, #3i (x) ≥ 2t + 1, then vi = x and gi = 2.
• If, for some x, #3i (x) ≥ t + 1, then vi = x and gi = 1.
• Else, vi = ⊥ and gi = 0.
Theorem 3.2. If n ≥ 3t + 1, then GC is a (n, t)-graded broadcast protocol.
The proof immediately follows from that of the protocol gradecast in [15], and is thus omitted.9
8
In essence, in a graded-broadcasting protocol, (a) the input of every player is the identity of a distinguished
player, the sender, who has an arbitrary value v as an additional private input, and (b) the outputs must satisfy the
same properties 1 and 2 of graded consensus, plus the following property 3′ : if the sender is honest, then vi = v and
gi = 2 for all honest player i.
9
Indeed, in their protocol, in step 1, the sender sends his own private value v to all players, and each player i lets
vi′ consist of the value he has actually received from the sender in step 1.

20

3.6

The Protocol BA⋆

We now describe the arbitrary-value BA protocol BA⋆ via the binary BA protocol BBA⋆ and the
graded-consensus protocol GC. Below, the initial value of each player i is vi′ .
Protocol BA⋆
Steps 1 and 2. Each player i executes GC, on input vi′ , so as to compute a pair (vi , gi ).
Step 3, . . . Each player i executes BBA⋆ —with initial input 0, if gi = 2, and 1 otherwise— so
as to compute the bit outi .
Output Determination. Each player i outputs vi , if outi = 0, and ⊥ otherwise.
Theorem 3.3. Whenever n ≥ 3t + 1, BA⋆ is a (n, t)-BA protocol with soundness 1.
Proof. We first prove Consistency, and then Agreement.
Proof of Consistency. Assume that, for some value v ∈ V , vi′ = v. Then, by property 3 of
graded consensus, after the execution of GC, all honest players output (v, 2). Accordingly, 0 is
the initial bit of all honest players in the end of the execution of BBA⋆ . Thus, by the Agreement
property of binary Byzantine agreement, at the end of the execution of BA⋆ , outi = 0 for all honest
players. This implies that the output of each honest player i in BA⋆ is vi = v. ✷
Proof of Agreement. Since BBA⋆ is a binary BA protocol, either
(A) outi = 1 for all honest player i, or
(B) outi = 0 for all honest player i.
In case A, all honest players output ⊥ in BA⋆ , and thus Agreement holds. Consider now case B. In
this case, in the execution of BBA⋆ , the initial bit of at least one honest player i is 0. (Indeed, if
initial bit of all honest players were 1, then, by the Consistency property of BBA⋆ , we would have
outj = 1 for all honest j.) Accordingly, after the execution of GC, i outputs the pair (v, 2) for some
value v. Thus, by property 1 of graded consensus, gj > 0 for all honest players j. Accordingly, by
property 2 of graded consensus, vj = v for all honest players j. This implies that, at the end of
BA⋆ , every honest player j outputs v. Thus, Agreement holds also in case B. ✷
Since both Consistency and Agreement hold, BA⋆ is an arbitrary-value BA protocol.
Historical Note Turpin and Coan were the first to show that, for n ≥ 3t+1, any binary (n, t)-BA
protocol can be converted to an arbitrary-value (n, t)-BA protocol. The reduction arbitrary-value
Byzantine agreement to binary Byzantine agreement via graded consensus is more modular and
cleaner, and simplifies the analysis of our Algorand protocol Algorand ′ .
Generalizing BA⋆ for use in Algorand Algorand works even when all communication is via
gossiping. However, although presented in a traditional and familiar communication network, so as
to enable a better comparison with the prior art and an easier understanding, protocol BA⋆ works
also in gossiping networks. In fact, in our detailed embodiments of Algorand, we shall present it
directly for gossiping networks. We shall also point out that it satisfies the player replaceability
property that is crucial for Algorand to be secure in the envisaged very adversarial model.
21

Any BA player-replaceable protocol working in a gossiping communication network can be
securely employed within the inventive Algorand system. In particular, Micali and Vaikunthanatan
have extended BA⋆ to work very efficiently also with a simple majority of honest players. That
protocol too could be used in Algorand.

4

Two Embodiments of Algorand

As discussed, at a very high level, a round of Algorand ideally proceeds as follows. First, a randomly
selected user, the leader, proposes and circulates a new block. (This process includes initially
selecting a few potential leaders and then ensuring that, at least a good fraction of the time, a
single common leader emerges.) Second, a randomly selected committee of users is selected, and
reaches Byzantine agreement on the block proposed by the leader. (This process includes that
each step of the BA protocol is run by a separately selected committee.) The agreed upon block
is then digitally signed by a given threshold (TH ) of committee members. These digital signatures
are circulated so that everyone is assured of which is the new block. (This includes circulating the
credential of the signers, and authenticating just the hash of the new block, ensuring that everyone
is guaranteed to learn the block, once its hash is made clear.)
In the next two sections, we present two embodiments of Algorand, Algorand ′1 and Algorand ′2 ,
that work under a majority-of-honest-users assumption. In Section 8 we show how to adopts these
embodiments to work under a honest-majority-of-money assumption.
Algorand ′1 only envisages that > 2/3 of the committee members are honest. In addition, in
Algorand ′1 , the number of steps for reaching Byzantine agreement is capped at a suitably high
number, so that agreement is guaranteed to be reached with overwhelming probability within a
fixed number of steps (but potentially requiring longer time than the steps of Algorand ′2 ). In the
remote case in which agreement is not yet reached by the last step, the committee agrees on the
empty block, which is always valid.
Algorand ′2 envisages that the number of honest members in a committee is always greater than
or equal to a fixed threshold tH (which guarantees that, with overwhelming probability, at least
2/3 of the committee members are honest). In addition, Algorand ′2 allows Byzantine agreement to
be reached in an arbitrary number of steps (but potentially in a shorter time than Algorand ′1 ).
It is easy to derive many variants of these basic embodiments. In particular, it is easy, given
Algorand ′2 , to modify Algorand ′1 so as to enable to reach Byzantine agreement in an arbitrary
number of steps.
Both embodiments share the following common core, notations, notions, and parameters.

4.1

A Common Core

Objectives Ideally, for each round r, Algorand would satisfy the following properties:
1. Perfect Correctness. All honest users agree on the same block B r .
2. Completeness 1. With probability 1, the payset of B r , P AY r , is maximal.10
10
Because paysets are defined to contain valid payments, and honest users to make only valid payments, a maximal
P AY r contains the “currently outstanding” payments of all honest users.

22

Of course, guaranteeing perfect correctness alone is trivial: everyone always chooses the official
payset P AY r to be empty. But in this case, the system would have completeness 0. Unfortunately,
guaranteeing both perfect correctness and completeness 1 is not easy in the presence of malicious
users. Algorand thus adopts a more realistic objective. Informally, letting h denote the percentage
of users who are honest, h > 2/3, the goal of Algorand is
Guaranteeing, with overwhelming probability, perfect correctness and completeness close to h.
Privileging correctness over completeness seems a reasonable choice: payments not processed in
one round can be processed in the next, but one should avoid forks, if possible.
Led Byzantine Agreement Perfect Correctness could be guaranteed as follows. At the start
of round r, each user i constructs his own candidate block Bir , and then all users reach Byzantine
agreement on one candidate block. As per our introduction, the BA protocol employed requires
a 2/3 honest majority and is player replaceable. Each of its step can be executed by a small and
randomly selected set of verifiers, who do not share any inner variables.
Unfortunately, this approach has no completeness guarantees. This is so, because the candidate
blocks of the honest users are most likely totally different from each other. Thus, the ultimately
agreed upon block might always be one with a non-maximal payset. In fact, it may always be the
empty block, Bε , that is, the block whose payset is empty. well be the default, empty one.
Algorand ′ avoids this completeness problem as follows. First, a leader for round r, ℓr , is selected.
Then, ℓr propagates his own candidate block, Bℓrr . Finally, the users reach agreement on the block
they actually receive from ℓr . Because, whenever ℓr is honest, Perfect Correctness and Completeness
1 both hold, Algorand ′ ensures that ℓr is honest with probability close to h. (When the leader is
malicious, we do not care whether the agreed upon block is one with an empty payset. After all, a
malicious leader ℓr might always maliciously choose Bℓrr to be the empty block, and then honestly
propagate it, thus forcing the honest users to agree on the empty block.)
Leader Selection In Algorand’s, the rth block is of the form B r = (r, P AY r , Qr , H(B r−1 ).
As already mentioned in the introduction, the quantity Qr−1 is carefully constructed so as to be
essentially non-manipulatable by our very powerful Adversary. (Later on in this section, we shall
provide some intuition about why this is the case.) At the start of a round r, all users know the
blockchain so far, B 0 , . . . , B r−1 , from which they deduce the set of users of every prior round: that
is, P K 1 , . . . , P K r−1 . A potential leader of round r is a user i such that

.H SIGi r, 1, Qr−1 ≤ p .

Let us explain. Note that, since the quantity Qr−1 is part of block
B r−1 , and the underlying

string uniquely
signature scheme satisfies the uniqueness property, SIGi r, 1, Qr−1 is a binary

associated to i and r. Thus, since H is a random oracle, H SIGi r, 1, Qr−1 is a random256-bit
long string uniquely associated to i and r. The symbol “.” in front of H SIGi r, 1, Qr−1 is the

decimal (in our case, binary) point, so that ri , .H SIGi r, 1, Qr−1 is the binary expansion of a
random 256-bit number between 0 and 1 uniquely associated to i and r. Thus the probability that
ri is less than or equal to p is essentially p. (Our potential-leader selection mechanism has been
inspired by the micro-payment scheme of Micali and Rivest [28].)
The probability p is chosen so that, with overwhelming (i.e., 1 − F ) probability, at least one
potential verifier is honest. (If fact, p is chosen to be the smallest such probability.)
23

Note that, since i is the only one capable of computing his own signatures, he alone can
determine whether he is a potential verifier of round 1. However, by revealing his own credential,
σir , SIGi r, 1, Qr−1 , i can prove to anyone to be a potential verifier of round r.
The leader ℓr is defined to be the potential leader whose hashed credential is smaller that the
r,s
hashed credential of all other potential leader j: that is, H(σℓr,s
r ) ≤ H(σj ).
Note that, since a malicious ℓr may not reveal his credential, the correct leader of round r may
never be known, and that, barring improbable ties, ℓr is indeed the only leader of round r.
Let us finally bring up a last but important detail: a user i can be a potential leader (and thus
the leader) of a round r only if he belonged to the system for at least k rounds. This guarantees
the non-manipulatability of Qr and all future Q-quantities. In fact, one of the potential leaders
will actually determine Qr .
Verifier Selection Each step s > 1 of round r is executed by a small set of verifiers, SV r,s .
Again, each verifier i ∈ SV r,s is randomly selected among the users already in the system k rounds
before r, and again via the special quantity Qr−1 . Specifically, i ∈ P K r−k is a verifier in SV r,s , if

.H SIGi r, s, Qr−1 ≤ p′ .
r,s ,but, if this is the case, he could prove it by
Once more, only i knows whether he belongs to SV

r,s
exhibiting his credential σi , H(SIGi r, s, Qr−1 ). A verifier i ∈ SV r,s sends a message, mr,s
i , in
step s of round r, and this message includes his credential σir,s , so as to enable the verifiers f the
nest step to recognize that mr,s
i is a legitimate step-s message.
The probability p′ is chosen so as to ensure that, in SV r,s , letting #good be the number of
honest users and #bad the number of malicious users, with overwhelming probability the following
two conditions hold.
For embodiment Algorand ′1 :
(1) #good > 2 · #bad and
(2) #good + 4 · #bad < 2n, where n is the expected cardinality of SV r,s .

For embodiment Algorand ′2 :
(1) #good > tH and
(2) #good + 2#bad < 2tH , where tH is a specified threshold.
These conditions imply that, with sufficiently high probability, (a) in the last step of the BA
protocol, there will be at least given number of honest players to digitally sign the new block B r ,
(b) only one block per round may have the necessary number of signatures, and (c) the used BA
protocol has (at each step) the required 2/3 honest majority.
Clarifying Block Generation If the round-r leader ℓr is honest, then the corresponding block
is of the form


B r = r, P AY r , SIGℓr Qr−1 , H B r−1
,
where the payset P AY r is maximal. (recall that all paysets are, by definition, collectively valid.)
Else (i.e., if ℓr is malicious), B r has one of the following two possible forms:



and B r = Bεr , r, ∅, Qr−1 , H B r−1
.
B r = r, P AY r , SIGi Qr−1 , H B r−1
24

In the first form, P AY r is a (non-necessarily maximal) payset and it may be P AY r = ∅; and i is
a potential leader of round r. (However, i may not be the leader ℓr . This may indeed happen if if
ℓr keeps secret his credential and does not reveal himself.)
The second form arises when, in the round-r execution of the BA protocol, all honest players
output the default value, which is the empty block Bεr in our application. (By definition, the possible
outputs of a BA protocol include a default value, generically denoted by ⊥. See section
 3.2.)r−1 
r−1
r
,H B
Note that, although the paysets are empty in both cases, B = r, ∅, SIGi Q
and Bεr are syntactically different blocks and arise in two different situations: respectively, “all
went smoothly enough in the execution of the BA protocol”, and “something went wrong in the
BA protocol, and the default value was output”.
Let us now intuitively describe how the generation of block B r proceeds in round r of Algorand ′ .
In the first step, each eligible player, that is, each player i ∈ P K r−k , checks whether he is a potential
leader. If this is the case, then i is asked, using of all the payments he has seen so far, and the
current blockchain, B 0 , . . . , B r−1 , to secretly prepare a maximal
payment
set, P AYir , and secretly


assembles his candidate block, B r = r, P AYir , SIGi Qr−1 , H B r−1 . That,is, not only does he
include in Bir , as its second component the just prepared payset, but also, as its third component,
his own signature of Qr−1 , the third component of the last block, B r−1 . Finally, he propagate his
r
round-r-step-1 message, mr,1
i , which includes (a) his candidate block Bi , (b) his proper signature
of his candidate block (i.e., his signature of the hash of Bir , and (c) his own credential σir,1 , proving
that he is indeed a potential verifier of round r.
(Note that, until an honest i produces his message mr,1
i , the Adversary has no clue that i is a
potential verifier. Should he wish to corrupt honest potential leaders, the Adversary might as well
corrupt random honest players. However, once he sees mr,1
i , since it contains i’s credential, the
Adversary knows and could corrupt i, but cannot prevent mr,1
i , which is virally propagated, from
reaching all users in the system.)
In the second step, each selected verifier j ∈ SV r,2 tries to identify the leader of the round.
, contained in the proper step-1 message mr,1
Specifically, j takes the step-1 credentials, σir,1
, . . . , σir,1
i
n
1




r,1
he has received; hashes all of them, that is, computes H σir,1
;
finds
the
credential,
,
.
.
.
,
H
σ
in
1

σℓr,1
, whose hash is lexicographically minimum; and considers ℓrj to be the leader of round r.
j

Recall that each considered credential is a digital signature of Qr−1 , that SIGi r, 1, Qr−1 is
uniquely determined by i and Qr−1 , that H is random oracle, and thus that each H(SIGi r, 1, Qr−1
is a random 256-bit long string unique to each potential leader i of round r.
From this we can conclude that, if the 256-bit string Qr−1 were itself randomly and independently
selected, than so would be the hashed credentials of all potential leaders of round r. In fact, all
potential leaders are well defined, and so are their credentials (whether actually computed or
not). Further, the set of potential leaders of round r is a random subset of the users of round
r − k, and an honest potential leader i always properly constructs and propagates his message mri ,
which contains i’s credential. Thus, since the percentage of honest users is h, no matter what the
malicious potential leaders might do (e.g., reveal or conceal their own credentials), the minimum
hashed potential-leader credential belongs to a honest user, who is necessarily identified by everyone
to be the leader ℓr of the round r. Accordingly, if the 256-bit string Qr−1 were itself randomly and
independently selected, with probability exactly h (a) the leader ℓr is honest and (b) ℓj = ℓr for all
honest step-2 verifiers j.
In reality, the hashed credential are, yes, randomly selected, but depend on Qr−1 , which is

25

not randomly and independently selected. We shall prove in our analysis, however, that Qr−1 is
sufficiently non-manipulatable to guarantee that the leader of a round is honest with probability
h′ sufficiently close to h: namely, h′ > h2 (1 + h − h2 ). For instance, if h = 80%, then h′ > .7424.
Having identified the leader of the round (which they correctly do when the leader ℓr is honest),
the task of the step-2 verifiers is to start executing the BA using as initial values what they believe
to be the block of the leader. Actually, in order to minimize the amount of communication required,
a verifier j ∈ SV r,2 does not use, as his input value vj′ to the Byzantine protocol, the block Bj that
he has actually received from ℓj (the user j believes to be the leader), but the the leader, but the
hash of that block, that is, vj′ = H(Bi ). Thus, upon termination of the BA protocol, the verifiers
of the last step do not compute the desired round-r block B r , but compute (authenticate and
propagate) H(B r ). Accordingly, since H(B r ) is digitally signed by sufficiently many verifiers of the
last step of the BA protocol, the users in the system will realize that H(B r ) is the hash of the new
block. However, they must also retrieve (or wait for, since the execution is quite asynchronous) the
block B r itself, which the protocol ensures that is indeed available, no matter what the Adversary
might do.
Asynchrony and Timing Algorand ′1 and Algorand ′2 have a significant degree of asynchrony.
This is so because the Adversary has large latitude in scheduling the delivery of the messages being
propagated. In addition, whether the total number of steps in a round is capped or not, there is
the variance contribute by the number of steps actually taken.
As soon as he learns the certificates of B 0 , . . . , B r−1 , a user i computes Qr−1 and starts working
on round r, checking whether he is a potential leader, or a verifier in some step s of round r.
Assuming that i must act at step s, in light of the discussed asynchrony, i relies on various
strategies to ensure that he has sufficient information before he acts.
For instance, he might wait to receive at least a given number of messages from the verifiers of
the previous step, or wait for a sufficient time to ensure that he receives the messages of sufficiently
many verifiers of the previous step.
The Seed Qr and the Look-Back Parameter k Recall that, ideally, the quantities Qr should
random and independent, although it will suffice for them to be sufficiently non-manipulatable by
the Adversary.

At a first glance, we could choose Qr−1 to coincide with H P AY r−1 , and thus avoid to
specify Qr−1 explicitly in B r−1 . An elementary analysis reveals, however, that malicious users may
take advantage of this selection mechanism.11 Some additional effort shows that myriads of other
11

We are at the start of round r − 1. Thus, Qr−2 = P AY r−2 is publicly known, and the Adversary privately
knows who are the potential leaders he controls. Assume that the Adversary controls 10% of the users, and
that, with very high probability,
a malicious user w is the potential leader of round r − 1. That is, assume that

H SIGw r − 2, 1, Qr−2 is so small that it is highly improbable an honest potential leader will actually be the
leader of round r − 1. (Recall that, since we choose potential leaders via a secret cryptographic sortition mechanism,
the Adversary does not know who the honest potential leaders are.) The Adversary, therefore, is in the enviable
position of choosing the payset P AY ′ he wants, and have it become the official payset of round r − 1. However,
he can do more. He can also ensure that, with high probability, (*) one of his malicious users will be the leader
also of round r, so that he can freely select what P AY r will be. (And so on. At least for a long while, that is,
as long as these high-probability events really occur.) To guarantee (*), the Adversary acts as follows. Let P AY ′
be the payset the Adversary prefers for round r − 1. Then, he computes H(P AY ′ ) and checks whether, for some
already malicious player z, SIGz (r, 1, H(P AY ′ )) is particularly small, that is, small enough that with very high
probability z will be the leader of round r. If this is the case, then he instructs w to choose his candidate block to be

26

alternatives, based on traditional block quantities are easily exploitable by the Adversary to ensure
that malicious leaders are very frequent. We instead specifically and inductively define our brand
new quantity Qr so as to be able to prove that it is non-manipulatable by the Adversary. Namely,
Qr , H(SIGℓr (Qr−1 ), r), if B r is not the empty block, and Qr , H(Qr−1 , r) otherwise.
The intuition of why this construction of Qr works is as follows. Assume for a moment that
Qr−1 is truly randomly and independently selected. Then, will so be Qr ? When ℓr is honest the
answer is (roughly speaking) yes. This is so because
H(SIGℓr (·), r) : {0, 1}256 −→ {0, 1}256
is a random function. When ℓr is malicious, however, Qr is no longer univocally defined from Qr−1
and ℓr . There are at least two separate values for Qr . One continues to be Qr , H(SIGℓr (Qr−1 ), r),
and the other is H(Qr−1 , r). Let us first argue that, while the second choice is somewhat arbitrary,
a second choice is absolutely mandatory. The reason for this is that a malicious ℓr can always cause
totally different candidate blocks to be received by the honest verifiers of the second step.12 Once
this is the case, it is easy to ensure that the block ultimately agreed upon via the BA protocol of
round r will be the default one, and thus will not contain anyone’s digital signature of Qr−1 . But
the system must continue, and for this, it needs a leader for round r. If this leader is automatically
and openly selected, then the Adversary will trivially corrupt him. If it is selected by the previous
Qr−1 via the same process, than ℓr will again be the leader in round r+1. We specifically propose to
use the same secret cryptographic sortition mechanism, but applied to a new Q-quantity: namely,
H(Qr−1 , r). By having this quantity to be the output of H guarantees that the output is random,
and by including r as the second input of H, while all other uses of H have one or 3+ inputs,
“guarantees” that such a Qr is independently selected. Again, our specific choice of alternative Qr
does not matter, what matter is that ℓr has two choice for Qr , and thus he can double his chances
to have another malicious user as the next leader.
The options for Qr may even be more numerous for the Adversary who controls a malicious ℓr .
For instance, let x, y, and z be three malicious potential leaders of round r such that



H σxr,1 < H σyr,1 < H σzr,1




and H σzr,1 is particulary small. That is, so small that there is a good chance that H σzr,1 is
smaller of the hashed credential of every honest potential leader. Then, by asking x to hide his
credential, the Adversary has a good chance of having y becomethe leader of round r − 1. This
implies that he has another option for Qr : namely, SIGy Qr−1 . Similarly, the Adversary may
ask both x and y of withholding their credentials, so as to
 have z become the leader of round r − 1
and gaining another option for Qr : namely, SIGz Qr−1 .
Of course, however, each of these and other options has a non-zero chance to fail, because the
Adversary cannot predict the hash of the digital signatures of the honest potential users.
Bir−1 = (r − 1, P AY ′ , H(B r−2 ). Else, he has two other malicious users x and y to keep on generating a new payment
℘′ , from one to the other, until, for some malicious user z (or even for some fixed user z) H (SIGz (P AY ′ ∪ {℘})) is
particularly small too. This experiment will stop quite quickly. And when it does the Adversary asks w to propose
the candidate block Bir−1 = (r − 1, P AY ′ ∪ {℘}, H(B r−2 ).
12
For instance, to keep it simple (but extreme), “when the time of the second step is about to expire”, ℓr could
directly email a different candidate block Bi to each user i. This way, whoever the step-2 verifiers might be, they
will have received totally different blocks.

27

A careful, Markov-chain-like analysis shows that, no matter what options the Adversary chooses
to make at round r − 1, as long as he cannot inject new users in the system, he cannot decrease the
probability of an honest user to be the leader of round r + 40 much below h. This is the reason for
which we demand that the potential leaders of round r are users already existing in round r − k.
It is a way to ensure that, at round r − k, the Adversary cannot alter by much the probability that
an honest user become the leader of round r. In fact, no matter what users he may add to the
system in rounds r − k through r, they are ineligible to become potential leaders (and a fortiori the
leader) of round r. Thus the look-back parameter k ultimately is a security parameter. (Although,
as we shall see in section 7, it can also be a kind of “convenience parameter” as well.)
Ephemeral Keys Although the execution of our protocol cannot generate a fork, except with
negligible probability, the Adversary could generate a fork, at the rth block, after the legitimate
block r has been generated.
Roughly, once B r has been generated, the Adversary has learned who the verifiers of each step
of round r are. Thus, he could therefore corrupt all of them and oblige them to certify a new block
fr . Since this fake block might be propagated only after the legitimate one, users that have been
B
fr would be syntactically correct and we
paying attention would not be fooled.13 Nonetheless, B
want to prevent from being manufactured.
We do so by means of a new rule. Essentially, the members of the verifier set SV r,s of a step s
of round r use ephemeral public keys pkir,s to digitally sign their messages. These keys are singleuse-only and their corresponding secret keys skir,s are destroyed once used. This way, if a verifier is
corrupted later on, the Adversary cannot force him to sign anything else he did not originally sign.
Naturally, we must ensure that it is impossible for the Adversary to compute a new key g
pr,s
i
and convince an honest user that it is the right ephemeral key of verifier i ∈ SV r,s to use in step s.

4.2

Common Summary of Notations, Notions, and Parameters

Notations
• r ≥ 0: the current round number.
• s ≥ 1: the current step number in round r.
• B r : the block generated in round r.
• P K r : the set of public keys by the end of round r − 1 and at the beginning of round r.
• S r : the system status by the end of round r − 1 and at the beginning of round r.14
• P AY r : the payset contained in B r .
• ℓr : round-r leader. ℓr chooses the payset P AY r of round r (and determines the next Qr ).
• Qr : the seed of round r, a quantity (i.e., binary string) that is generated at the end of round r
and is used to choose verifiers for round r + 1. Qr is independent of the paysets in the blocks
and cannot be manipulated by ℓr .
13
Consider corrupting the news anchor of a major TV network, and producing and broadcasting today a newsreel
showing secretary Clinton winning the last presidential election. Most of us would recognize it as a hoax. But
someone getting out of a coma might be fooled.
14
In a system that is not synchronous, the notion of “the end of round r − 1” and “the beginning of round r”
need to be carefully defined. Mathematically, P K r and S r are computed from the initial status S 0 and the blocks
B 1 , . . . , B r−1 .

28

• SV r,s : the set of verifiers chosen for step s of round r.
• SV r : the set of verifiers chosen for round r, SV r = ∪s≥1 SV r,s .
• M SV r,s and HSV r,s : respectively, the set of malicious verifiers and the set of honest verifiers
in SV r,s . M SV r,s ∪ HSV r,s = SV r,s and M SV r,s ∩ HSV r,s = ∅.
• n1 ∈ Z+ and n ∈ Z+ : respectively, the expected numbers of potential leaders in each SV r,1 ,
and the expected numbers of verifiers in each SV r,s , for s > 1.
Notice that n1 << n, since we need at least one honest honest member in SV r,1 , but at least
a majority of honest members in each SV r,s for s > 1.
• h ∈ (0, 1): a constant greater than 2/3. h is the honesty ratio in the system. That is, the
fraction of honest users or honest money, depending on the assumption used, in each P K r is
at least h.
• H: a cryptographic hash function, modelled as a random oracle.
• ⊥: A special string of the same length as the output of H.
• F ∈ (0, 1): the parameter specifying the allowed error probability. A probability ≤ F is
considered “negligible”, and a probability ≥ 1 − F is considered “overwhelming”.
• ph ∈ (0, 1): the probability that the leader of a round r, ℓr , is honest. Ideally ph = h. With
the existence of the Adversary, the value of ph will be determined in the analysis.
• k ∈ Z+ : the look-back parameter. That is, round r − k is where the verifiers for round r are
chosen from —namely, SV r ⊆ P K r−k .15
• p1 ∈ (0, 1): for the first step of round r, a user in round r − k is chosen to be in SV r,1 with
1
.
probability p1 , |P Knr−k
|
• p ∈ (0, 1): for each step s > 1 of round r, a user in round r − k is chosen to be in SV r,s with
probability p , |P Knr−k | .
• CERT r : the certificate for B r . It is a set of tH signatures of H(B r ) from proper verifiers in
round r.
• B r , (B r , CERT r ) is a proven block.
A user i knows B r if he possesses (and successfully verifies) both parts of the proven block.
Note that the CERT r seen by different users may be different.
• τir : the (local) time at which a user i knows B r . In the Algorand protocol each user has his
own clock. Different users’ clocks need not be synchronized, but must have the same speed.
Only for the purpose of the analysis, we consider a reference clock and measure the players’
related times with respect to it.
r,s
• αr,s
i and βi : respectively the (local) time a user i starts and ends his execution of Step s of
round r.

• Λ and λ: essentially, the upper-bounds to, respectively, the time needed to execute Step 1 and
the time needed for any other step of the Algorand protocol.
Parameter Λ upper-bounds the time to propagate a single 1MB block. (In our notation,
Λ = λρ,1M B . Recalling our notation, that we set ρ = 1 for simplicity, and that blocks are
chosen to be at most 1MB-long, we have Λ = λ1,1,1M B .)
15

Strictly speaking, “r − k” should be “max{0, r − k}”.

29

Parameter λ upperbounds the time to propagate one small message per verifier in a Step s > 1.
(Using, as in Bitcoin, elliptic curve signatures with 32B keys, a verifier message is 200B long.
Thus, in our notation, λ = λn,ρ,200B .)
We assume that Λ = O(λ).
Notions
• Verifier selection.
For each round r and step s > 1, SV r,s , {i ∈ P K r−k : .H(SIGi (r, s, Qr−1 )) ≤ p}. Each
user i ∈ P K r−k privately computes his signature using his long-term key and decides whether
i ∈ SV r,s or not. If i ∈ SV r,s , then SIGi (r, s, Qr−1 ) is i’s (r, s)-credential, compactly denoted
by σir,s .
For the first step of round r, SV r,1 and σir,1 are similarly defined, with p replaced by p1 . The
verifiers in SV r,1 are potential leaders.
• Leader selection.
User i ∈ SV r,1 is the leader of round r, denoted by ℓr , if H(σir,1 ) ≤ H(σjr,1 ) for all potential
leaders j ∈ SV r,1 . Whenever the hashes of two players’ credentials are compared, in the unlikely
event of ties, the protocol always breaks ties lexicographically according to the (long-term public
keys of the) potential leaders.
By definition, the hash value of player ℓr ’s credential is also the smallest among all users in
P K r−k . Note that a potential leader cannot privately decide whether he is the leader or not,
without seeing the other potential leaders’ credentials.
Since the hash values are uniform at random, when SV r,1 is non-empty, ℓr always exists and is
honest with probability at least h. The parameter n1 is large enough so as to ensure that each
SV r,1 is non-empty with overwhelming probability.
• Block structure.
A non-empty block is of the form B r = (r, P AY r , SIGℓr (Qr−1 ), H(B r−1 )), and an empty block
is of the form Bǫr = (r, ∅, Qr−1 , H(B r−1 )).
Note that a non-empty block may still contain an empty payset P AY r , if no payment occurs in
this round or if the leader is malicious. However, a non-empty block implies that the identity of
r−1 ) have all been timely revealed. The protocol guarantees
ℓr , his credential σℓr,1
r and SIGℓr (Q
that, if the leader is honest, then the block will be non-empty with overwhelming probability.
• Seed Qr .
If B r is non-empty, then Qr , H(SIGℓr (Qr−1 ), r), otherwise Qr , H(Qr−1 , r).
Parameters
• Relationships among various parameters.
— The verifiers and potential leaders of round r are selected from the users in P K r−k ,
where k is chosen so that the Adversary cannot predict Qr−1 back at round r − k − 1
with probability better than F : otherwise, he will be able to introduce malicious users
for round r − k, all of which will be potential leaders/verifiers in round r, succeeding in
30

having a malicious leader or a malicious majority in SV r,s for some steps s desired by
him.
— For Step 1 of each round r, n1 is chosen so that with overwhelming probability, SV r,1 6= ∅.
• Example choices of important parameters.
— The outputs of H are 256-bit long.
— h = 80%, n1 = 35.
— Λ = 1 minute and λ = 10 seconds.
• Initialization of the protocol.
The protocol starts at time 0 with r = 0. Since there does not exist “B −1 ” or “CERT −1 ”,
syntactically B −1 is a public parameter with its third component specifying Q−1 , and all users
know B −1 at time 0.

Algorand ′1

5

In this section, we construct a version of Algorand ′ working under the following assumption.
Honest Majority of Users Assumption: More than 2/3 of the users in each P K r are honest.
In Section 8, we show how to replace the above assumption with the desired Honest Majority of
Money assumption.

5.1

Additional Notations and Parameters

Notations
• m ∈ Z+ : the maximum number of steps in the binary BA protocol, a multiple of 3.
• Lr ≤ m/3: a random variable representing the number of Bernoulli trials needed to see a 1,
when each trial is 1 with probability p2h and there are at most m/3 trials. If all trials fail then
Lr , m/3. Lr will be used to upper-bound the time needed to generate block B r .
2n
3 + 1:
CERT r : the

• tH =

the number of signatures needed in the ending conditions of the protocol.

•

certificate for B r . It is a set of tH signatures of H(B r ) from proper verifiers in

round r.
Parameters
• Relationships among various parameters.
— For each step s > 1 of round r, n is chosen so that, with overwhelming probability,
|HSV r,s | > 2|M SV r,s | and |HSV r,s | + 4|M SV r,s | < 2n.
The closer to 1 the value of h is, the smaller n needs to be. In particular, we use (variants
of) Chernoff bounds to ensure the desired conditions hold with overwhelming probability.
— m is chosen such that Lr < m/3 with overwhelming probability.
• Example choices of important parameters.
— F = 10−12 .
— n ≈ 1500, k = 40 and m = 180.
31

5.2

Implementing Ephemeral Keys in Algorand ′1

As already mentioned, we wish that a verifier i ∈ SV r,s digitally signs his message mr,s
i of step
r,s
s in round r, relative to an ephemeral public key pki , using an ephemeral secrete key skir,s that
he promptly destroys after using. We thus need an efficient method to ensure that every user can
verify that pkir,s is indeed the key to use to verify i’s signature of mr,s
i . We do so by a (to the best
of our knowledge) new use of identity-based signature schemes.
At a high level, in such a scheme, a central authority A generates a public master key, P M K,
and a corresponding secret master key, SM K. Given the identity, U , of a player U , A computes,
via SM K, a secret signature key skU relative to the public key U , and privately gives skU to
U . (Indeed, in an identity-based digital signature scheme, the public key of a user U is U itself!)
This way, if A destroys SM K after computing the secret keys of the users he wants to enable to
produce digital signatures, and does not keep any computed secret key, then U is the only one who
can digitally sign messages relative to the public key U . Thus, anyone who knows “U ’s name”,
automatically knows U ’s public key, and thus can verify U ’s signatures (possibly using also the
public master key P M K).
In our application, the authority A is user i, and the set of all possible users U coincides with
the round-step pair (r, s) in —say— S = {i} × {r ′ , . . . , r ′ + 106 } × {1, . . . , m + 3}, where r ′ is a given
round, and m + 3 the upperbound to the number of steps that may occur within a round. This
(mr,s
way, pkir,s , (i, r, s), so that everyone seeing i’s signature SIGr,s
i ) can, with overwhelming
pk r,s
i

probability, immediately verify it for the first million rounds r following r ′ .
In other words, i first generates P M K and SM K. Then, he publicizes that P M K is i’s master
public key for any round r ∈ [r ′ , r ′ + 106 ], and uses SM K to privately produce and store the secret
key skir,s for each triple (i, r, s) ∈ S. This done, he destroys SM K. If he determines that he is not
part of SV r,s , then i may leave skir,s alone (as the protocol does not require that he aunthenticates
any message in Step s of round r). Else, i first uses skir,s to digitally sign his message mr,s
i , and
then destroys skir,s .
Note that i can publicize his first public master key when he first enters the system. That is,
the same payment ℘ that brings i into the system (at a round r ′ or at a round close to r ′ ), may also
specify, at i’s request, that i’s public master key for any round r ∈ [r ′ , r ′ + 106 ] is P M K —e.g., by
including a pair of the form (P M K, [r ′ , r ′ + 106 ]).
Also note that, since m + 3 is the maximum number of steps in a round, assuming that a round
takes a minute, the stash of ephemeral keys so produced will last i for almost two years. At the same
time, these ephemeral secret keys will not take i too long to produce. Using an elliptic-curve based
system with 32B keys, each secret key is computed in a few microseconds. Thus, if m + 3 = 180,
then all 180M secret keys can be computed in less than one hour.
When the current round is getting close to r ′ + 106 , to handle the next million rounds, i
generates a new (P M K ′ , SM K ′ ) pair, and informs what his next stash of ephemeral keys is by
—for example— having SIGi (P M K ′ , [r ′ + 106 + 1, r ′ + 2 · 106 + 1]) enter a new block, either as a
separate “transaction” or as some additional information that is part of a payment. By so doing,
i informs everyone that he/she should use P M K ′ to verify i’s ephemeral signatures in the next
million rounds. And so on.
(Note that, following this basic approach, other ways for implementing ephemeral keys without
using identity-based signatures are certainly possible. For instance, via Merkle trees.16 )
16

In this method, i generates a public-secret key pair (pkir,s , skir,s ) for each round-step pair (r, s) in —say—

32

Other ways for implementing ephemeral keys are certainly possible —e.g., via Merkle trees.

5.3

Matching the Steps of Algorand ′1 with those of BA⋆

As we said, a round in Algorand ′1 has at most m + 3 steps.
Step 1. In this step, each potential leader i computes and propagates his candidate block Bir ,
together with his own credential, σir,1 .
Recall that this credential explicitly identifies i. This is so, because σir,1 , SIGi (r, 1, Qr−1 ).
Potential verifier i also propagates, as part of his message, his proper digital signature of H(Bir ).
Not dealing with a payment or a credential, this signature of i is relative to his ephemeral public
key pkir,1 : that is, he propagates sigpkr,1 (H(Bir )).
i

Given our conventions, rather than propagating Bir and sigpkr,1 (H(Bir )), he could have
i
propagated SIGpkr,1 (H(Bir )). However, in our analysis we need to have explicit access to
i
sigpkr,1 (H(Bir )).
i

Steps 2. In this step, each verifier i sets ℓri to be the potential leader whose hashed credential
is the smallest, and Bir to be the block proposed by ℓri . Since, for the sake of efficiency, we
wish to agree on H(B r ), rather than directly on B r , i propagates the message he would have
propagated in the first step of BA⋆ with initial value vi′ = H(Bir ). That is, he propagates vi′ ,
after ephemerally signing it, of course. (Namely, after signing it relative to the right ephemeral
public key, which in this case is pkir,2 .) Of course too, i also transmits his own credential.
Since the first step of BA⋆ consists of the first step of the graded consensus protocol GC, Step
2 of Algorand ′ corresponds to the first step of GC.
Steps 3. In this step, each verifier i ∈ SV r,2 executes the second step of BA⋆ . That is, he sends the
same message he would have sent in the second step of GC. Again, i’s message is ephemerally
signed and accompanied by i’s credential. (From now on, we shall omit saying that a verifier
ephemerally signs his message and also propagates his credential.)
Step 4. In this step, every verifier i ∈ SV r,4 computes the output of GC, (vi , gi ), and ephemerally
signs and sends the same message he would have sent in the third step of BA⋆ , that is, in the
first step of BBA⋆ , with initial bit 0 if gi = 2, and 1 otherwise.
Step s = 5, . . . , m + 2. Such a step, if ever reached, corresponds to step s − 1 of BA⋆ , and thus to
step s − 3 of BBA⋆ .
Since our propagation model is sufficiently asynchronous, we must account for the possibility
that, in the middle of such a step s, a verifier i ∈ SV r,s is reached by information proving him
that block B r has already been chosen. In this case, i stops his own execution of round r of
Algorand ′ , and starts executing his round-(r + 1) instructions.
{r ′ , . . . , r ′ + 106 } × {1, . . . , m + 3}. Then he orders these public keys in a canonical way, stores the jth public
key in the jth leaf of a Merkle tree, and computes the root value Ri , which he publicizes. When he wants to sign
a message relative to key pkir,s , i not only provides the actual signature, but also the authenticating path for pkir,s
relative to Ri . Notice that this authenticating path also proves that pkir,s is stored in the jth leaf. The rest of the
details can be easily filled.

33

Accordingly, the instructions of a verifier i ∈ SV r,s , in addition to the instructions corresponding
to Step s − 3 of BBA⋆ , include checking whether the execution of BBA⋆ has halted in a prior
Step s′ . Since BBA⋆ can only halt is a Coin-Fixed-to-0 Step or in a Coin-Fixed-to-1 step, the
instructions distinguish whether
A (Ending Condition 0): s′ − 2 ≡ 0 mod 3, or
B (Ending Condition 1): s′ − 2 ≡ 1 mod 3.
In fact, in case A, the block B r is non-empty, and thus additional instructions are necessary to
ensure that i properly reconstructs B r , together with its proper certificate CERT r . In case B,
the block B r is empty, and thus i is instructed to set B r = Bεr = (r, ∅, H(Qr−1 , r), H(B r−1 )),
and to compute CERT r .
If, during his execution of step s, i does not see any evidence that the block B r has already
been generated, then he sends the same message he would have sent in step s − 3 of BBA⋆ .
Step m + 3. If, during step m + 3, i ∈ SV r,m+3 sees that the block B r was already generated in
a prior step s′ , then he proceeds just as explained above.
Else, rather then sending the same message he would have sent in step m of BBA⋆ , i is
instructed, based on the information in his possession, to compute B r and its corresponding
certificate CERT r .
Recall, in fact, that we upperbound by m + 3 the total number of steps of a round.

5.4

The Actual Protocol

Recall that, in each step s of a round r, a verifier i ∈ SV r,s uses his long-term
 public-secret key pair
r,s
r−1
r−1
in case s = 1. Verifier i
to produce his credential, σi , SIGi (r, s, Q ), as well as SIGi Q
uses his ephemeral secret key skir,s to sign his (r, s)-message mr,s
.
For
simplicity,
when r and s are
i
clear, we write esigi (x) rather than sigpkir,s (x) to denote i’s proper ephemeral signature of a value
x in step s of round r, and write ESIGi (x) instead of SIGpkir,s (x) to denote (i, x, esigi (x)).
Step 1: Block Proposal
Instructions for every user i ∈ P K r−k : User i starts his own Step 1 of round r as soon as he
knows B r−1 .
• User i computes Qr−1 from the third component of B r−1 and checks whether i ∈ SV r,1 or
not.
• If i ∈
/ SV r,1 , then i stops his own execution of Step 1 right away.
• If i ∈ SV r,1 , that is, if i is a potential leader, then he collects the round-r payments that have
been propagated to him so far and computes a maximal payset P AYir from them. Next, he
computes his “candidate block” Bir = (r, P AYir , SIGi (Qr−1 ), H(B r−1 )). Finally, he computes
r,1
r,1
r
r
the message mr,1
i = (Bi , esigi (H(Bi )), σi ), destroys his ephemeral secret key ski , and then
propagates mr,1
i .

34

Remark. In practice, to shorten the global execution of Step 1, it is important that the (r, 1)messages are selectively propagated. That is, for every user i in the system, for the first (r, 1)message that he ever receives and successfully verifies,17 player i propagates it as usual. For all the
other (r, 1)-messages that player i receives and successfully verifies, he propagates it only if the hash
value of the credential it contains is the smallest among the hash values of the credentials contained
in all (r, 1)-messages he has received and successfully verified so far. Furthermore, as suggested
by Georgios Vlachos, it is useful that each potential leader i also propagates his credential σir,1
separately: those small messages travel faster than blocks, ensure timely propagation of the mr,1
j ’s
where the contained credentials have small hash values, while make those with large hash values
disappear quickly.
Step 2: The First Step of the Graded Consensus Protocol GC
Instructions for every user i ∈ P K r−k : User i starts his own Step 2 of round r as soon as he
knows B r−1 .
• User i computes Qr−1 from the third component of B r−1 and checks whether i ∈ SV r,2 or
not.
• If i ∈
/ SV r,2 then i stops his own execution of Step 2 right away.
• If i ∈ SV r,2 , then after waiting an amount of time t2 , λ + Λ, i acts as follows.
1. He finds the user ℓ such that H(σℓr,1 ) ≤ H(σjr,1 ) for all credentials σjr,1 that are part of
the successfully verified (r, 1)-messages he has received so far.a
r,1 b
r
r
2. If he has received from ℓ a valid message mr,1
ℓ = (Bℓ , esigℓ (H(Bℓ )), σℓ ), then i sets
vi′ , H(Bℓr ); otherwise i sets vi′ , ⊥.

3. i computes the message mr,2
, (ESIGi (vi′ ), σir,2 ),c destroys his ephemeral secret key
i
r,2
r,2
ski , and then propagates mi .
a

Essentially, user i privately decides that the leader of round r is user ℓ.
Again, player ℓ’s signatures and the hashes are all successfully verified, and P AYℓr in Bℓr is a valid payset for
round r —although i does not check whether P AYℓr is maximal for ℓ or not.
c
The message mr,2
signals that player i considers vi′ to be the hash of the next block, or considers the next
i
block to be empty.
b

17

That is, all the signatures are correct and both the block and its hash are valid —although i does not check
whether the included payset is maximal for its proposer or not.

35

Step 3: The Second Step of GC
Instructions for every user i ∈ P K r−k : User i starts his own Step 3 of round r as soon as he
knows B r−1 .
• User i computes Qr−1 from the third component of B r−1 and checks whether i ∈ SV r,3 or
not.
• If i ∈
/ SV r,3 , then i stops his own execution of Step 3 right away.
• If i ∈ SV r,3 , then after waiting an amount of time t3 , t2 + 2λ = 3λ + Λ, i acts as follows.
1. If there exists a value v ′ 6= ⊥ such that, among all the valid messages mr,2
j he has received,
r,2
′
more than 2/3 of them are of the form (ESIGj (v ), σj ), without any contradiction,a
r,3
r,3
′
then he computes the message mr,3
i , (ESIGi (v ), σi ). Otherwise, he computes mi ,
r,3
(ESIGi (⊥), σi ).
2. i destroys his ephemeral secret key skir,3 , and then propagates mr,3
i .
a

That is, he has not received two valid messages containing ESIGj (v ′ ) and a different ESIGj (v ′′ ) respectively,
from a player j. Here and from here on, except in the Ending Conditions defined later, whenever an honest player
wants messages of a given form, messages contradicting each other are never counted or considered valid.

36

Step 4: Output of GC and The First Step of BBA⋆
Instructions for every user i ∈ P K r−k : User i starts his own Step 4 of round r as soon as he
knows B r−1 .
• User i computes Qr−1 from the third component of B r−1 and checks whether i ∈ SV r,4 or
not.
• If i ∈
/ SV r,4 , then i his stops his own execution of Step 4 right away.
• If i ∈ SV r,4 , then after waiting an amount of time t4 , t3 + 2λ = 5λ + Λ, i acts as follows.
1. He computes vi and gi , the output of GC, as follows.
(a) If there exists a value v ′ 6= ⊥ such that, among all the valid messages mr,3
j he has
r,3
received, more than 2/3 of them are of the form (ESIGj (v ′ ), σj ), then he sets
vi , v ′ and gi , 2.
(b) Otherwise, if there exists a value v ′ 6= ⊥ such that, among all the valid messages
r,3
′
mr,3
j he has received, more than 1/3 of them are of the form (ESIGj (v ), σj ), then
he sets vi , v ′ and gi , 1.a
(c) Else, he sets vi , H(Bǫr ) and gi , 0.
2. He computes bi , the input of BBA⋆ , as follows:
bi , 0 if gi = 2, and bi , 1 otherwise.
r,4
3. He computes the message mr,4
i , (ESIGi (bi ), ESIGi (vi ), σi ), destroys his ephemeral
secret key skir,4 , and then propagates mr,4
i .
a

It can be proved that the v ′ in case (b), if exists, must be unique.

37

Step s, 5 ≤ s ≤ m + 2, s − 2 ≡ 0 mod 3: A Coin-Fixed-To-0 Step of BBA⋆
Instructions for every user i ∈ P K r−k : User i starts his own Step s of round r as soon as he
knows B r−1 .
• User i computes Qr−1 from the third component of B r−1 and checks whether i ∈ SV r,s .
• If i ∈
/ SV r,s , then i stops his own execution of Step s right away.
• If i ∈ SV r,s then he acts as follows.
– He waits until an amount of time ts , ts−1 + 2λ = (2s − 3)λ + Λ has passed.
– Ending Condition 0: If, during such waiting and at any point of time, there exists a
string v 6= ⊥ and a step s′ such that
(a) 5 ≤ s′ ≤ s, s′ − 2 ≡ 0 mod 3 —that is, Step s′ is a Coin-Fixed-To-0 step,
(b) i has received at least tH =

2n
3

′

−1
+ 1 valid messages mr,s
= (ESIGj (0),
j

′

ESIGj (v), σjr,s −1 ),a and
r,1
r
r
r
(c) i has received a valid message mr,1
j = (Bj , esigj (H(Bj )), σj ) with v = H(Bj ),
then, i stops his own execution of Step s (and in fact of round r) right away without
propagating anything; sets B r = Bjr ; and sets his own CERT r to be the set of messages
′

mjr,s −1 of sub-step (b).b
– Ending Condition 1: If, during such waiting and at any point of time, there exists a
step s′ such that
(a’) 6 ≤ s′ ≤ s, s′ − 2 ≡ 1 mod 3 —that is, Step s′ is a Coin-Fixed-To-1 step, and
′

(b’) i has received at least tH valid messages mjr,s −1 = (ESIGj (1), ESIGj (vj ),
′

σjr,s −1 ),c
then, i stops his own execution of Step s (and in fact of round r) right away without
propagating anything; sets B r = Bǫr ; and sets his own CERT r to be the set of messages
′
mjr,s −1 of sub-step (b’).
– Otherwise, at the end of the wait, user i does the following.
He sets vi to be the majority vote of the vj ’s in the second components of all the valid
mjr,s−1 ’s he has received.
He computes bi as follows.
If more than 2/3 of all the valid mjr,s−1 ’s he has received are of the form
(ESIGj (0), ESIGj (vj ), σjr,s−1 ), then he sets bi , 0.
Else, if more than 2/3 of all the valid mjr,s−1 ’s he has received are of the form
(ESIGj (1), ESIGj (vj ), σjr,s−1 ), then he sets bi , 1.
Else, he sets bi , 0.
r,s
He computes the message mr,s
i , (ESIGi (bi ), ESIGi (vi ), σi ), destroys his ephemeral
r,s
r,s
secret key ski , and then propagates mi .
a
Such a message from player j is counted even if player i has also received a message from j signing for 1.
Similar things for Ending Condition 1. As shown in the analysis, this is done to ensure that all honest users know
B r within time λ from each other.
b
User i now knows B r and his own round r finishes. He still helps propagating messages as a generic user, but
does not initiate any propagation as a (r, s)-verifier. In particular, he has helped propagating all messages in his
CERT r , which is enough for our protocol. Note that he should also set bi , 0 for the binary BA protocol, but bi
is not needed in this case anyway. Similar things for all 38
future instructions.
c
In this case, it does not matter what the vj ’s are.

Step s, 6 ≤ s ≤ m + 2, s − 2 ≡ 1 mod 3: A Coin-Fixed-To-1 Step of BBA⋆
Instructions for every user i ∈ P K r−k : User i starts his own Step s of round r as soon as he
knows B r−1 .
• User i computes Qr−1 from the third component of B r−1 and checks whether i ∈ SV r,s or
not.
• If i ∈
/ SV r,s , then i stops his own execution of Step s right away.
• If i ∈ SV r,s then he does the follows.
– He waits until an amount of time ts , (2s − 3)λ + Λ has passed.
– Ending Condition 0: The same instructions as Coin-Fixed-To-0 steps.
– Ending Condition 1: The same instructions as Coin-Fixed-To-0 steps.
– Otherwise, at the end of the wait, user i does the following.
He sets vi to be the majority vote of the vj ’s in the second components of all the valid
mjr,s−1 ’s he has received.
He computes bi as follows.
If more than 2/3 of all the valid mjr,s−1 ’s he has received are of the form
(ESIGj (0), ESIGj (vj ), σjr,s−1 ), then he sets bi , 0.
Else, if more than 2/3 of all the valid mjr,s−1 ’s he has received are of the form
(ESIGj (1), ESIGj (vj ), σjr,s−1 ), then he sets bi , 1.
Else, he sets bi , 1.
r,s
He computes the message mr,s
i , (ESIGi (bi ), ESIGi (vi ), σi ), destroys his ephemeral
r,s
r,s
secret key ski , and then propagates mi .

39

Step s, 7 ≤ s ≤ m + 2, s − 2 ≡ 2 mod 3: A Coin-Genuinely-Flipped Step of BBA⋆
Instructions for every user i ∈ P K r−k : User i starts his own Step s of round r as soon as he
knows B r−1 .
• User i computes Qr−1 from the third component of B r−1 and checks whether i ∈ SV r,s or
not.
• If i ∈
/ SV r,s , then i stops his own execution of Step s right away.
• If i ∈ SV r,s then he does the follows.
– He waits until an amount of time ts , (2s − 3)λ + Λ has passed.
– Ending Condition 0: The same instructions as Coin-Fixed-To-0 steps.
– Ending Condition 1: The same instructions as Coin-Fixed-To-0 steps.
– Otherwise, at the end of the wait, user i does the following.
He sets vi to be the majority vote of the vj ’s in the second components of all the valid
mjr,s−1 ’s he has received.
He computes bi as follows.
If more than 2/3 of all the valid mjr,s−1 ’s he has received are of the form
(ESIGj (0), ESIGj (vj ), σjr,s−1 ), then he sets bi , 0.
Else, if more than 2/3 of all the valid mjr,s−1 ’s he has received are of the form
(ESIGj (1), ESIGj (vj ), σjr,s−1 ), then he sets bi , 1.
Else, let SVir,s−1 be the set of (r, s − 1)-verifiers from whom he has received a valid
message mjr,s−1 . He sets bi , lsb(minj∈SV r,s−1 H(σjr,s−1 )).
i

r,s
He computes the message mr,s
i , (ESIGi (bi ), ESIGi (vi ), σi ), destroys his ephemeral
r,s
r,s
secret key ski , and then propagates mi .

40

Step m + 3: The Last Step of BBA⋆

a

Instructions for every user i ∈ P K r−k : User i starts his own Step m + 3 of round r as soon as he
knows B r−1 .
• User i computes Qr−1 from the third component of B r−1 and checks whether i ∈ SV r,m+3 or
not.
• If i ∈
/ SV r,m+3 , then i stops his own execution of Step m + 3 right away.
• If i ∈ SV r,m+3 then he does the follows.
– He waits until an amount of time tm+3 , tm+2 + 2λ = (2m + 3)λ + Λ has passed.
– Ending Condition 0: The same instructions as Coin-Fixed-To-0 steps.
– Ending Condition 1: The same instructions as Coin-Fixed-To-0 steps.
– Otherwise, at the end of the wait, user i does the following.
He sets outi , 1 and B r , Bǫr .
He computes the message mr,m+3
= (ESIGi (outi ), ESIGi (H(B r )), σir,m+3 ), destroys his
i
to certify B r .b
ephemeral secret key skir,m+3 , and then propagates mr,m+3
i
With overwhelming probability BBA⋆ has ended before this step, and we specify this step for completeness.
A certificate from Step m + 3 does not have to include ESIGi (outi ). We include it for uniformity only: the
certificates now have a uniform format no matter in which step they are generated.
a

b

41

Reconstruction of the Round-r Block by Non-Verifiers
Instructions for every user i in the system: User i starts his own round r as soon as he knows
B r−1 , and waits for block information as follows.
– If, during such waiting and at any point of time, there exists a string v and a step s′ such
that
(a) 5 ≤ s′ ≤ m + 3 with s′ − 2 ≡ 0 mod 3,
′

′

(b) i has received at least tH valid messages mjr,s −1 = (ESIGj (0), ESIGj (v), σjr,s −1 ), and
r,1
r
r
r
(c) i has received a valid message mr,1
j = (Bj , esigj (H(Bj )), σj ) with v = H(Bj ),

then, i stops his own execution of round r right away; sets B r = Bjr ; and sets his own CERT r
′

to be the set of messages mjr,s −1 of sub-step (b).
– If, during such waiting and at any point of time, there exists a step s′ such that
(a’) 6 ≤ s′ ≤ m + 3 with s′ − 2 ≡ 1 mod 3, and
′

′

(b’) i has received at least tH valid messages mjr,s −1 = (ESIGj (1), ESIGj (vj ), σjr,s −1 ),
then, i stops his own execution of round r right away; sets B r = Bǫr ; and sets his own CERT r
′
to be the set of messages mjr,s −1 of sub-step (b’).
– If, during such waiting and at any point of time, i has received at least tH valid messages
mr,m+3
= (ESIGj (1), ESIGj (H(Bǫr )), σjr,m+3 ), then i stops his own execution of round r
j
right away, sets B r = Bǫr , and sets his own CERT r to be the set of messages mr,m+3
for 1
j
r
and H(Bǫ ).

5.5

Analysis of Algorand ′1

We introduce the following notations for each round r ≥ 0, used in the analysis.
• Let T r be the time when the first honest user knows B r−1 .
• Let I r+1 be the interval [T r+1 , T r+1 + λ].
Note that T 0 = 0 by the initialization of the protocol. For each s ≥ 1 and i ∈ SV r,s , recall that
r,s
αr,s
i and βi are respectively the starting time and the ending time of player i’s step s. Moreover,
recall that ts = (2s − 3)λ + Λ for each 2 ≤ s ≤ m + 3. In addition, let I 0 , {0} and t1 , 0.
Finally, recall that Lr ≤ m/3 is a random variable representing the number of Bernoulli trials
needed to see a 1, when each trial is 1 with probability p2h and there are at most m/3 trials. If all
trials fail then Lr , m/3.
In the analysis we ignore computation time, as it is in fact negligible relative to the time needed
to propagate messages. In any case, by using slightly larger λ and Λ, the computation time can
be incorporated into the analysis directly. Most of the statements below hold “with overwhelming
probability,” and we may not repeatedly emphasize this fact in the analysis.

42

5.6

Main Theorem

Theorem 5.1. The following properties hold with overwhelming probability for each round r ≥ 0:
1. All honest users agree on the same block B r .
2. When the leader ℓr is honest, the block B r is generated by ℓr , B r contains a maximal payset
r+1 ≤ T r + 8λ + Λ and all honest users know B r in the time
received by ℓr by time αr,1
ℓr , T
interval I r+1 .
3. When the leader ℓr is malicious, T r+1 ≤ T r + (6Lr + 10)λ + Λ and all honest users know B r
in the time interval I r+1 .
4. ph = h2 (1 + h − h2 ) for Lr , and the leader ℓr is honest with probability at least ph .
Before proving our main theorem, let us make two remarks.
Remarks.
• Block-Generation and True Latency. The time to generate block B r is defined to be T r+1 − T r .
That is, it is defined to be the difference between the first time some honest user learns B r and
the first time some honest user learns B r−1 . When the round-r leader is honest, Property 2 our
main theorem guarantees that the exact time to generate B r is 8λ + Λ time, no matter what
the precise value of h > 2/3 may be. When the leader is malicious, Property 3 implies that the
expected time to generate B r is upperbounded by ( p12h + 10)λ + Λ, again no matter the precise
value of h.18 However, the expected time to generate B r depends on the precise value of h.
Indeed, by Property 4, ph = h2 (1 + h − h2 ) and the leader is honest with probability at least
ph , thus
E[T r+1 − T r ] ≤ h2 (1 + h − h2 ) · (8λ + Λ) + (1 − h2 (1 + h − h2 ))((

12
+ 10)λ + Λ).
h2 (1 + h − h2 )

For instance, if h = 80%, then E[T r+1 − T r ] ≤ 12.7λ + Λ.
• λ vs. Λ. Note that the size of the messages sent by the verifiers in a step Algorand ′ is dominated
by the length of the digital signature keys, which can remain fixed, even when the number of
users is enormous. Also note that, in any step s > 1, the same expected number n of verifiers
can be used whether the number of users is 100K, 100M, or 100M. This is so because n solely
depends on h and F . In sum, therefore, barring a sudden need to increase secret key length,
the value of λ should remain the same no matter how large the number of users may be in the
foreseeable future.
By contrast, for any transaction rate, the number of transactions grows with the number of
users. Therefore, to process all new transactions in a timely fashion, the size of a block should
also grow with the number of users, causing Λ to grow too. Thus, in the long run, we should have
λ << Λ. Accordingly, it is proper to have a larger coefficient for λ, and actually a coefficient
of 1 for Λ.
Proof of Theorem 5.1. We prove Properties 1–3 by induction: assuming they hold for round r − 1
(without loss of generality, they automatically hold for “round -1” when r = 0), we prove them for
round r.
18

Indeed, E[T r+1 − T r ] ≤ (6E[Lr ] + 10)λ + Λ = (6 ·

2
ph

+ 10)λ + Λ = ( p12h + 10)λ + Λ.

43

Since B r−1 is uniquely defined by the inductive hypothesis, the set SV r,s is uniquely defined
for each step s of round r. By the choice of n1 , SV r,1 6= ∅ with overwhelming probability. We now
state the following two lemmas, proved in Sections 5.7 and 5.8. Throughout the induction and in
the proofs of the two lemmas, the analysis for round 0 is almost the same as the inductive step,
and we will highlight the differences when they occur.
Lemma 5.2. [Completeness Lemma] Assuming Properties 1–3 hold for round r−1, when the leader
ℓr is honest, with overwhelming probability,
• All honest users agree on the same block B r , which is generated by ℓr and contains a maximal
r
payset received by ℓr by time αr,1
ℓr ∈ I ; and
• T r+1 ≤ T r + 8λ + Λ and all honest users know B r in the time interval I r+1 .
Lemma 5.3. [Soundness Lemma] Assuming Properties 1–3 hold for round r − 1, when the leader
ℓr is malicious, with overwhelming probability, all honest users agree on the same block B r , T r+1 ≤
T r + (6Lr + 10)λ + Λ and all honest users know B r in the time interval I r+1 .
Properties 1–3 hold by applying Lemmas 5.2 and 5.3 to r = 0 and to the inductive step. Finally,
we restate Property 4 as the following lemma, proved in Section 5.9.
Lemma 5.4. Given Properties 1–3 for each round before r, ph = h2 (1 + h − h2 ) for Lr , and the
leader ℓr is honest with probability at least ph .
Combining the above three lemmas together, Theorem 5.1 holds.



The lemma below states several important properties about round r given the inductive
hypothesis, and will be used in the proofs of the above three lemmas.
Lemma 5.5. Assume Properties 1–3 hold for round r − 1. For each step s ≥ 1 of round r and
each honest verifier i ∈ HSV r,s , we have that
r
(a) αr,s
i ∈I ;
(b) if player i has waited an amount of time ts , then βir,s ∈ [T r + ts , T r + λ + ts ] for r > 0 and
βir,s = ts for r = 0; and

(c) if player i has waited an amount of time ts , then by time βir,s , he has received all messages
′
sent by all honest verifiers j ∈ HSV r,s for all steps s′ < s.
Moreover, for each step s ≥ 3, we have that
(d) there do not exist two different players i, i′ ∈ SV r,s and two different values v, v ′ of the same
length, such that both players have waited an amount of time ts , more than 2/3 of all the
valid messages mjr,s−1 player i receives have signed for v, and more than 2/3 of all the valid
messages mjr,s−1 player i′ receives have signed for v ′ .
Proof. Property (a) follows directly from the inductive hypothesis, as player i knows B r−1 in the
time interval I r and starts his own step s right away. Property (b) follows directly from (a): since
r,s
player i has waited an amount of time ts before acting, βir,s = αr,s
i + ts . Note that αi = 0 for
r = 0.
We now prove Property (c). If s = 2, then by Property (b), for all verifiers j ∈ HSV r,1 we have
r,1
r
r
βir,s = αr,s
i + ts ≥ T + ts = T + λ + Λ ≥ βj + Λ.

44

Since each verifier j ∈ HSV r,1 sends his message at time βjr,1 and the message reaches all honest
users in at most Λ time, by time βir,s player i has received the messages sent by all verifiers in
HSV r,1 as desired.
′
If s > 2, then ts = ts−1 + 2λ. By Property (b), for all steps s′ < s and all verifiers j ∈ HSV r,s ,
′

r,s
r
r
r
r
+ λ.
βir,s = αr,s
i + ts ≥ T + ts = T + ts−1 + 2λ ≥ T + ts′ + 2λ = T + λ + ts′ + λ ≥ βj
′

Since each verifier j ∈ HSV r,s sends his message at time βjr,s and the message reaches all honest
users in at most λ time, by time βir,s player i has received all messages sent by all honest verifiers
′
in HSV r,s for all s′ < s. Thus Property (c) holds.
Finally, we prove Property (d). Note that the verifiers j ∈ SV r,s−1 sign at most two things in
Step s − 1 using their ephemeral secret keys: a value vj of the same length as the output of the
hash function, and also a bit bj ∈ {0, 1} if s − 1 ≥ 4. That is why in the statement of the lemma
we require that v and v ′ have the same length: many verifiers may have signed both a hash value
v and a bit b, thus both pass the 2/3 threshold.
Assume for the sake of contradiction that there exist the desired verifiers i, i′ and values v, v ′ .
Note that some malicious verifiers in M SV r,s−1 may have signed both v and v ′ , but each honest
verifier in HSV r,s−1 has signed at most one of them. By Property (c), both i and i′ have received
all messages sent by all honest verifiers in HSV r,s−1 .
Let HSV r,s−1 (v) be the set of honest (r, s − 1)-verifiers who have signed v, M SVir,s−1 the set
of malicious (r, s − 1)-verifiers from whom i has received a valid message, and M SVir,s−1 (v) the
subset of M SVir,s−1 from whom i has received a valid message signing v. By the requirements for
i and v, we have
|HSV r,s−1 (v)| + |M SVir,s−1 (v)|
2
(1)
> .
ratio ,
r,s−1
r,s−1
3
|
|HSV
| + |M SVi
′

We first show

|M SVir,s−1 (v)| ≤ |HSV r,s−1 (v)|.

(2)

Assuming otherwise, by the relationships among the parameters, with overwhelming probability
|HSV r,s−1 | > 2|M SV r,s−1 | ≥ 2|M SVir,s−1 |, thus
ratio <

|HSV r,s−1 (v)| + |M SVir,s−1 (v)|
3|M SVir,s−1 |

<

2|M SVir,s−1 (v)|
3|M SVir,s−1 |

2
≤ ,
3

contradicting Inequality 1.
Next, by Inequality 1 we have
2|HSV r,s−1 | + 2|M SVir,s−1 | < 3|HSV r,s−1 (v)| + 3|M SVir,s−1 (v)|
≤ 3|HSV r,s−1 (v)| + 2|M SVir,s−1 | + |M SVir,s−1 (v)|.
Combining with Inequality 2,
2|HSV r,s−1 | < 3|HSV r,s−1 (v)| + |M SVir,s−1 (v)| ≤ 4|HSV r,s−1 (v)|,
which implies
|HSV r,s−1 (v)| >
45

1
|HSV r,s−1 |.
2

Similarly, by the requirements for i′ and v ′ , we have
1
|HSV r,s−1 (v ′ )| > |HSV r,s−1 |.
2
Since an honest verifier j ∈ HSV r,s−1 destroys his ephemeral secret key skjr,s−1 before propagating
his message, the Adversary cannot forge j’s signature for a value that j did not sign, after
learning that j is a verifier. Thus, the two inequalities above imply |HSV r,s−1 | ≥ |HSV r,s−1 (v)| +
|HSV r,s−1 (v ′ )| > |HSV r,s−1 |, a contradiction. Accordingly, the desired i, i′ , v, v ′ do not exist, and
Property (d) holds.


5.7

The Completeness Lemma

Lemma 5.2. [Completeness Lemma, restated] Assuming Properties 1–3 hold for round r − 1, when
the leader ℓr is honest, with overwhelming probability,
• All honest users agree on the same block B r , which is generated by ℓr and contains a maximal
r
payset received by ℓr by time αr,1
ℓr ∈ I ; and
• T r+1 ≤ T r + 8λ + Λ and all honest users know B r in the time interval I r+1 .
Proof. By the inductive hypothesis and Lemma 5.5, for each step s and verifier i ∈ HSV r,s ,
r
αr,s
i ∈ I . Below we analyze the protocol step by step.
Step 1. By definition, every honest verifier i ∈ HSV r,1 propagates the desired message mr,1
i at
r,1
r,1
r,1
r,1
r
r
r
r
r−1
r−1
time βi = αi , where mi = (Bi , esigi (H(Bi )), σi ), Bi = (r, P AYi , SIGi (Q ), H(B )),
and P AYir is a maximal payset among all payments that i has seen by time αr,1
i .
Step 2. Arbitrarily fix an honest verifier i ∈ HSV r,2 . By Lemma 5.5, when player i is done
r,1 , including
waiting at time βir,2 = αr,2
i + t2 , he has received all messages sent by verifiers in HSV
r,1
mℓr . By the definition of ℓr , there does not exist another player in P K r−k whose credential’s hash
r,1
r
value is smaller than H(σℓr,1
r ). Of course, the Adversary can corrupt ℓ after seeing that H(σℓr )
is very small, but by that time player ℓr has destroyed his ephemeral key and the message mr,1
ℓr
r,2
r
has been propagated. Thus verifier i sets his own leader to be player ℓ . Accordingly, at time βi ,
r,2
′
′
r
verifier i propagates mr,2
i = (ESIGi (vi ), σi ), where vi = H(Bℓr ). When r = 0, the only difference
is that βir,2 = t2 rather than being in a range. Similar things can be said for future steps and we
will not emphasize them again.
Step 3. Arbitrarily fix an honest verifier i ∈ HSV r,3 . By Lemma 5.5, when player i is done
r,2 .
waiting at time βir,3 = αr,3
i + t3 , he has received all messages sent by verifiers in HSV
By the relationships among the parameters, with overwhelming probability |HSV r,2 | >
2|M SV r,2 |. Moreover, no honest verifier would sign contradicting messages, and the Adversary
cannot forge a signature of an honest verifier after the latter has destroyed his corresponding
ephemeral secret key. Thus more than 2/3 of all the valid (r, 2)-messages i has received are from
r,2
r
honest verifiers and of the form mr,2
j = (ESIGj (H(Bℓr )), σj ), with no contradiction.
r,3
′
′
r
Accordingly, at time βir,3 player i propagates mr,3
i = (ESIGi (v ), σi ), where v = H(Bℓr ).

46

Step 4. Arbitrarily fix an honest verifier i ∈ HSV r,4 . By Lemma 5.5, player i has received all
messages sent by verifiers in HSV r,3 when he is done waiting at time βir,4 = αr,4
i + t4 . Similar to
Step 3, more than 2/3 of all the valid (r, 3)-messages i has received are from honest verifiers and
r,3
r
of the form mr,3
j = (ESIGj (H(Bℓr )), σj ).
Accordingly, player i sets vi = H(Bℓrr ), gi = 2 and bi = 0. At time βir,4 = αr,4
i + t4 he propagates
r,4
r,4
r
mi = (ESIGi (0), ESIGi (H(Bℓr )), σi ).
Step 5. Arbitrarily fix an honest verifier i ∈ HSV r,5 . By Lemma 5.5, player i would have
received all messages sent by the verifiers in HSV r,4 if he has waited till time αr,5
i + t5 . Note that
|HSV r,4 | ≥ tH .19 Also note that all verifiers in HSV r,4 have signed for H(Bℓrr ).
As |M SV r,4 | < tH , there does not exist any v ′ 6= H(Bℓrr ) that could have been signed by tH
verifiers in SV r,4 (who would necessarily be malicious), so player i does not stop before he has
received tH valid messages mr,4
= (ESIGj (0), ESIGj (H(Bℓrr )), σjr,4 ). Let T be the time when
j
the latter event happens. Some of those messages may be from malicious players, but because
|M SV r,4 | < tH , at least one of them is from an honest verifier in HSV r,4 and is sent after time
T r + t4 . Accordingly, T ≥ T r + t4 > T r + λ + Λ ≥ βℓr,1
r + Λ, and by time T player i has also received
r,1
the message mℓr . By the construction of the protocol, player i stops at time βir,5 = T without
propagating anything; sets B r = Bℓrr ; and sets his own CERT r to be the set of (r, 4)-messages for
0 and H(Bℓrr ) that he has received.
Step s > 5. Similarly, for any step s > 5 and any verifier i ∈ HSV r,s , player i would have
received all messages sent by the verifiers in HSV r,4 if he has waited till time αr,s
i + ts . By the
r
r
same analysis, player i stops without propagating anything, setting B = Bℓr (and setting his own
CERT r properly). Of course, the malicious verifiers may not stop and may propagate arbitrary
messages, but because |M SV r,s | < tH , by induction no other v ′ could be signed by tH verifiers
in any step 4 ≤ s′ < s, thus the honest verifiers only stop because they have received tH valid
(r, 4)-messages for 0 and H(Bℓrr ).
Reconstruction of the Round-r Block. The analysis of Step 5 applies to a generic honest
user i almost without any change. Indeed, player i starts his own round r in the interval I r and
will only stop at a time T when he has received tH valid (r, 4)-messages for H(Bℓrr ). Again because
at least one of those messages are from honest verifiers and are sent after time T r + t4 , player i has
r
r
r
also received mr,1
ℓr by time T . Thus he sets B = Bℓr with the proper CERT .
It only remains to show that all honest users finish their round r within the time interval I r+1 .
By the analysis of Step 5, every honest verifier i ∈ HSV r,5 knows B r on or before αr,5
i + t5 ≤
T r + λ + t5 = T r + 8λ + Λ. Since T r+1 is the time when the first honest user ir knows B r , we have
T r+1 ≤ T r + 8λ + Λ
as desired. Moreover, when player ir knows B r , he has already helped propagating the messages in
his CERT r . Note that all those messages will be received by all honest users within time λ, even if
19

Strictly speaking, this happens with very high probability but not necessarily overwhelming. However, this
probability slightly effects the running time of the protocol, but does not affect its correctness. When h = 80%, then
|HSV r,4 | ≥ tH with probability 1 − 10−8 . If this event does not occur, then the protocol will continue for another
3 steps. As the probability that this does not occur in two steps is negligible, the protocol will finish at Step 8. In
expectation, then, the number of steps needed is almost 5.

47

player ir were the first player to propagate them. Moreover, following the analysis above we have
r,1
r+1 + λ. Accordingly,
T r+1 ≥ T r + t4 ≥ βℓr,1
r + Λ, thus all honest users have received mℓr by time T
r
r+1
r+1
r+1
all honest users know B in the time interval I
= [T
,T
+ λ].
Finally, for r = 0 we actually have T 1 ≤ t4 + λ = 6λ + Λ. Combining everything together,
Lemma 5.2 holds.


5.8

The Soundness Lemma

Lemma 5.3. [Soundness Lemma, restated] Assuming Properties 1–3 hold for round r − 1, when
the leader ℓr is malicious, with overwhelming probability, all honest users agree on the same block
B r , T r+1 ≤ T r + (6Lr + 10)λ + Λ and all honest users know B r in the time interval I r+1 .
Proof. We consider the two parts of the protocol, GC and BBA⋆ , separately.
GC. By the inductive hypothesis and by Lemma 5.5, for any step s ∈ {2, 3, 4} and any honest
verifier i ∈ HSV r,s , when player i acts at time βir,s = αr,s
i + ts , he has received all messages sent
′
by all the honest verifiers in steps s < s. We distinguish two possible cases for step 4.
Case 1. No verifier i ∈ HSV r,4 sets gi = 2.
In this case, by definition bi = 1 for all verifiers i ∈ HSV r,4 . That is, they start with an
agreement on 1 in the binary BA protocol. They may not have an agreement on their vi ’s,
but this does not matter as we will see in the binary BA.
Case 2. There exists a verifier î ∈ HSV r,4 such that gî = 2.
In this case, we show that
(1) gi ≥ 1 for all i ∈ HSV r,4 ,
(2) there exists a value v ′ such that vi = v ′ for all i ∈ HSV r,4 , and
r,1 such that v ′ = H(B r ).
(3) there exists a valid message mr,1
ℓ
ℓ from some verifier ℓ ∈ SV
Indeed, since player î is honest and sets gî = 2, more than 2/3 of all the valid messages mr,3
j
he has received are for the same value v ′ 6= ⊥, and he has set vî = v ′ .
By Property (d) in Lemma 5.5, for any other honest (r, 4)-verifier i, it cannot be that more
′
′′
′
than 2/3 of all the valid messages mr,3
j that i has received are for the same value v 6= v .
′
Accordingly, if i sets gi = 2, it must be that i has seen > 2/3 majority for v as well and set
vi = v ′ , as desired.

Now consider an arbitrary verifier i ∈ HSV r,4 with gi < 2. Similar to the analysis of Property
(d) in Lemma 5.5, because player î has seen > 2/3 majority for v ′ , more than 12 |HSV r,3 | honest
(r, 3)-verifiers have signed v ′ . Because i has received all messages by honest (r, 3)-verifiers by
1
r,3 | messages from them
time βir,4 = αr,4
i + t4 , he has in particular received more than 2 |HSV
′
r,3
r,3
for v . Because |HSV | > 2|M SV |, i has seen > 1/3 majority for v ′ . Accordingly, player
i sets gi = 1, and Property (1) holds.
Does player i necessarily set vi = v ′ ? Assume there exists a different value v ′′ 6= ⊥ such that
player i has also seen > 1/3 majority for v ′′ . Some of those messages may be from malicious
verifiers, but at least one of them is from some honest verifier j ∈ HSV r,3 : indeed, because
|HSV r,3 | > 2|M SV r,3 | and i has received all messages from HSV r,3 , the set of malicious
verifiers from whom i has received a valid (r, 3)-message counts for < 1/3 of all the valid
messages he has received.

48

By definition, player j must have seen > 2/3 majority for v ′′ among all the valid (r, 2)-messages
he has received. However, we already have that some other honest (r, 3)-verifiers have seen
> 2/3 majority for v ′ (because they signed v ′ ). By Property (d) of Lemma 5.5, this cannot
happen and such a value v ′′ does not exist. Thus player i must have set vi = v ′ as desired,
and Property (2) holds.
Finally, given that some honest (r, 3)-verifiers have seen > 2/3 majority for v ′ , some (actually,
more than half of) honest (r, 2)-verifiers have signed for v ′ and propagated their messages.
By the construction of the protocol, those honest (r, 2)-verifiers must have received a valid
r,1 with v ′ = H(B r ), thus Property (3) holds.
message mr,1
ℓ
ℓ from some player ℓ ∈ SV
BBA⋆ . We again distinguish two cases.
Case 1. All verifiers i ∈ HSV r,4 have bi = 1.
This happens following Case 1 of GC. As |M SV r,4 | < tH , in this case no verifier in SV r,5
could collect or generate tH valid (r, 4)-messages for bit 0. Thus, no honest verifier in HSV r,5
would stop because he knows a non-empty block B r .
Moreover, although there are at least tH valid (r, 4)-messages for bit 1, s′ = 5 does not satisfy
s′ − 2 ≡ 1 mod 3, thus no honest verifier in HSV r,5 would stop because he knows B r = Bǫr .
Instead, every verifier i ∈ HSV r,5 acts at time βir,5 = αr,5
i + t5 , by when he has received all
messages sent by HSV r,4 following Lemma 5.5. Thus player i has seen > 2/3 majority for 1
and sets bi = 1.
In Step 6 which is a Coin-Fixed-To-1 step, although s′ = 5 satisfies s′ − 2 ≡ 0 mod 3, there
do not exist tH valid (r, 4)-messages for bit 0, thus no verifier in HSV r,6 would stop because
he knows a non-empty block B r . However, with s′ = 6, s′ − 2 ≡ 1 mod 3 and there do exist
|HSV r,5 | ≥ tH valid (r, 5)-messages for bit 1 from HSV r,5 .
For every verifier i ∈ HSV r,6 , following Lemma 5.5, on or before time αr,6
i + t6 player i
r,5
has received all messages from HSV , thus i stops without propagating anything and sets
r,5
B r = Bǫr . His CERT r is the set of tH valid (r, 5)-messages mr,5
j = (ESIGj (1), ESIGj (vj ), σj )
received by him when he stops.
Next, let player i be either an honest verifier in a step s > 6 or a generic honest user (i.e.,
non-verifier). Similar to the proof of Lemma 5.2, player i sets B r = Bǫr and sets his own
r,5
CERT r to be the set of tH valid (r, 5)-messages mr,5
j = (ESIGj (1), ESIGj (vj ), σj ) he has
received.
Finally, similar to Lemma 5.2,
T r+1 ≤

min

i∈HSV r,6

r
r
αr,6
i + t6 ≤ T + λ + t6 = T + 10λ + Λ,

and all honest users know B r in the time interval I r+1 , because the first honest user i who
knows B r has helped propagating the (r, 5)-messages in his CERT r .
Case 2. There exists a verifier î ∈ HSV r,4 with bî = 0.
This happens following Case 2 of GC and is the more complex case. By the analysis of GC,
r,4 . Note
r
in this case there exists a valid message mr,1
ℓ such that vi = H(Bℓ ) for all i ∈ HSV
that the verifiers in HSV r,4 may not have an agreement on their bi ’s.
For any step s ∈ {5, . . . , m + 3} and verifier i ∈ HSV r,s , by Lemma 5.5 player i would have
received all messages sent by all honest verifiers in HSV r,4 ∪ · · · ∪ HSV r,s−1 if he has waited
for time ts .
49

We now consider the following event E: there exists a step s∗ ≥ 5 such that, for the first
∗
time in the binary BA, some player i∗ ∈ SV r,s (whether malicious or honest) should stop
without propagating anything. We use “should stop” to emphasize the fact that, if player i∗
is malicious, then he may pretend that he should not stop according to the protocol and
propagate messages of the Adversary’s choice.
Moreover, by the construction of the protocol, either
′ −1
= (ESIGj (0), ESIGj (v),
(E.a) i∗ is able to collect or generate at least tH valid messages mr,s
j
′

σjr,s −1 ) for the same v and s′ , with 5 ≤ s′ ≤ s∗ and s′ − 2 ≡ 0 mod 3; or
′

−1
(E.b) i∗ is able to collect or generate at least tH valid messages mr,s
= (ESIGj (1), ESIGj (vj ),
j
′

σjr,s −1 ) for the same s′ , with 6 ≤ s′ ≤ s∗ and s′ − 2 ≡ 1 mod 3.
Because the honest (r, s′ − 1)-messages are received by all honest (r, s′ )-verifiers before they
are done waiting in Step s′ , and because the Adversary receives everything no later than the
honest users, without loss of generality we have s′ = s∗ and player i∗ is malicious. Note that
we did not require the value v in E.a to be the hash of a valid block: as it will become clear
in the analysis, v = H(Bℓr ) in this sub-event.
Below we first analyze Case 2 following event E, and then show that the value of s∗ is essentially
distributed accordingly to Lr (thus event E happens before Step m + 3 with overwhelming
probability given the relationships for parameters). To begin with, for any step 5 ≤ s < s∗ ,
every honest verifier i ∈ HSV r,s has waited time ts and set vi to be the majority vote of the
valid (r, s−1)-messages he has received. Since player i has received all honest (r, s−1)-messages
following Lemma 5.5, since all honest verifiers in HSV r,4 have signed H(Bℓr ) following Case
2 of GC, and since |HSV r,s−1 | > 2|M SV r,s−1 | for each s, by induction we have that player i
has set
vi = H(Bℓr ).
∗

The same holds for every honest verifier i ∈ HSV r,s who does not stop without propagating
anything. Now we consider Step s∗ and distinguish four subcases.
∗

Case 2.1.a. Event E.a happens and there exists an honest verifier i′ ∈ HSV r,s who should
also stop without propagating anything.
In this case, we have s∗ − 2 ≡ 0 mod 3 and Step s∗ is a Coin-Fixed-To-0 step. By
definition, player i′ has received at least tH valid (r, s∗ − 1)-messages of the form
∗
∗
(ESIGj (0), ESIGj (v), σjr,s −1 ). Since all verifiers in HSV r,s −1 have signed H(Bℓr ) and
∗
|M SV r,s −1 | < tH , we have v = H(Bℓr ).
∗
Since at least tH − |M SV r,s −1 | ≥ 1 of the (r, s∗ − 1)-messages received by i′ for 0 and v
∗
are sent by verifiers in HSV r,s −1 after time T r + ts∗ −1 ≥ T r + t4 ≥ T r + λ + Λ ≥ βℓr,1 + Λ,
∗
player i′ has received mr,1
ℓ by the time he receives those (r, s − 1)-messages. Thus player
′
r
r
i stops without propagating anything; sets B = Bℓ ; and sets his own CERT r to be the
set of valid (r, s∗ − 1)-messages for 0 and v that he has received.
∗

Next, we show that, any other verifier i ∈ HSV r,s has either stopped with B r = Bℓr , or
has set bi = 0 and propagated (ESIGi (0), ESIGi (H(Bℓr )), σir,s ). Indeed, because Step s∗
is the first time some verifier should stop without propagating anything, there does not
exist a step s′ < s∗ with s′ − 2 ≡ 1 mod 3 such that tH (r, s′ − 1)-verifiers have signed 1.
∗
Accordingly, no verifier in HSV r,s stops with B r = Bǫr .
50

Moreover, as all honest verifiers in steps {4, 5, . . . , s∗ − 1} have signed H(Bℓr ), there does
not exist a step s′ ≤ s∗ with s′ − 2 ≡ 0 mod 3 such that tH (r, s′ − 1)-verifiers have signed
′
∗
some v ′′ 6= H(Bℓr ) —indeed, |M SV r,s −1 | < tH . Accordingly, no verifier in HSV r,s stops
∗
with B r 6= Bǫr and B r 6= Bℓr . That is, if a player i ∈ HSV r,s has stopped without
propagating anything, he must have set B r = Bℓr .
∗
If a∗ player ∗i ∈ HSV r,s has waited time ts∗ and propagated a message at time
∗
βir,s = αr,s
+ ts∗ , he has received all messages from HSV r,s −1 , including at least
i
∗
tH − |M SV r,s −1 | of them for 0 and v. If i has seen > 2/3 majority for 1, then he
∗
has seen more than 2(tH − |M SV r,s −1 |) valid (r, s∗ − 1)-messages for 1, with more
∗
than 2tH − 3|M SV r,s −1 | of them from honest (r, s∗ − 1)-verifiers. However, this implies
∗
∗
∗
∗
|HSV r,s −1 | ≥ tH −|M SV r,s −1 |+2tH −3|M SV r,s −1 | > 2n−4|M SV r,s −1 |, contradicting
the fact that
∗
∗
|HSV r,s −1 | + 4|M SV r,s −1 | < 2n,
which comes from the relationships for the parameters. Accordingly, i does not see > 2/3
majority for 1, and he sets bi = 0 because Step s∗ is a Coin-Fixed-To-0 step. As we have
seen, vi = H(Bℓr ). Thus i propagates (ESIGi (0), ESIGi (H(Bℓr )), σir,s ) as we wanted to
show.
For Step s∗ + 1, since∗ player i′ has helped propagating the messages in his CERT r
∗
on or before time αr,s
+ ts∗ , all honest verifiers in HSV r,s +1 have received at least
i′
tH valid (r, s∗ − 1)-messages for bit 0 and value H(Bℓr ) on or before they are done
∗
waiting. Furthermore, verifiers in HSV r,s +1 will not stop before receiving those (r, s∗ −1)messages, because there do not exist any other tH valid (r, s′ − 1)-messages for bit 1 with
s′ − 2 ≡ 1 mod 3 and 6 ≤ s′ ≤ s∗ + 1, by the definition of Step s∗ . In particular, Step
∗
s∗ + 1 itself is a Coin-Fixed-To-1 step, but no honest verifier in HSV r,s has propagated
∗
a message for 1, and |M SV r,s | < tH .
∗
Thus all honest verifiers in HSV r,s +1 stop without propagating anything and set B r =
∗
20
Bℓr : as before, they have received mr,1
ℓ before they receive the desired (r, s −1)-messages.
The same can be said for all honest verifiers in future steps and all honest users in general.
In particular, they all know B r = Bℓr within the time interval I r+1 and
∗

T r+1 ≤ αr,s
+ ts ∗ ≤ T r + λ + ts ∗ .
i′
∗

Case 2.1.b. Event E.b happens and there exists an honest verifier i′ ∈ HSV r,s who should
also stop without propagating anything.
In this case we have s∗ −2 ≡ 1 mod 3 and Step s∗ is a Coin-Fixed-To-1 step. The analysis
is similar to Case 2.1.a and many details have been omitted.
20
If ℓ is malicious, he might send out mr,1
late, hoping that some honest users/verifiers have not received mr,1
yet
ℓ
ℓ
when they receive the desired certificate for it. However, since verifier î ∈ HSV r,4 has set bî = 0 and vî = H(Bℓr ), as
before we have that more than half of honest verifiers i ∈ HSV r,3 have set vi = H(Bℓr ). This further implies more
than half of honest verifiers i ∈ HSV r,2 have set vi = H(Bℓr ), and those (r, 2)-verifiers have all received mr,1
ℓ . As the
Adversary cannot distinguish a verifier from a non-verifier, he cannot target the propagation of mr,1
to (r, 2)-verifiers
ℓ
without having the non-verifiers seeing it. In fact, with high probability, more than half (or a good constant fraction)
of all honest users have seen mr,1
after waiting for t2 from the beginning of their own round r. From here on, the
ℓ
time λ′ needed for mr,1
to reach the remaining honest users is much smaller than Λ, and for simplicity we do not
ℓ
write it out in the analysis. If 4λ ≥ λ′ then the analysis goes through without any change: by the end of Step 4, all
′
honest users would have received mr,1
ℓ . If the size of the block becomes enormous and 4λ < λ , then in Steps 3 and 4,
′
the protocol could ask each verifier to wait for λ /2 rather than 2λ, and the analysis continues to hold.

51

As before, player i′ must have received at least tH valid (r, s∗ − 1)-messages of the form
∗
(ESIGj (1), ESIGj (vj ), σjr,s −1 ). Again by the definition of s∗ , there does not exist a step
5 ≤ s′ < s∗ with s′ − 2 ≡ 0 mod 3, where at least tH (r, s′ − 1)-verifiers have signed 0 and
the same v. Thus player i′ stops without propagating anything; sets B r = Bǫr ; and sets
his own CERT r to be the set of valid (r, s∗ − 1)-messages for bit 1 that he has received.
∗

Moreover, any other verifier i ∈ HSV r,s has either stopped with B r = Bǫr , or has set bi =
∗
1 and propagated (ESIGi (1), ESIGi (vi ), σir,s ). Since player i′ has helped propagating
∗
the (r, s∗ − 1)-messages in his CERT r by time αr,s
+ ts∗ , again all honest verifiers in
i′
∗
r,s
+1
HSV
stop without propagating anything and set B r = Bǫr . Similarly, all honest
users know B r = Bǫr within the time interval I r+1 and
∗

T r+1 ≤ αr,s
+ ts ∗ ≤ T r + λ + ts ∗ .
i′
∗

Case 2.2.a. Event E.a happens and there does not exist an honest verifier i′ ∈ HSV r,s who
should also stop without propagating anything.
In this case, note that player i∗ could have a valid CERTir∗ consisting of the tH desired
(r, s∗ − 1)-messages the Adversary is able to collect or generate. However, the malicious
verifiers may not help propagating those messages, so we cannot conclude that the honest
∗
users will receive them in time λ. In fact, |M SV r,s −1 | of those messages may be from
malicious (r, s∗ − 1)-verifiers, who did not propagate their messages at all and only send
them to the malicious verifiers in step s∗ .
Similar to Case 2.1.a, here we have s∗ − 2 ≡ 0 mod 3, Step s∗ is a Coin-Fixed-To-0 step,
and the (r, s∗ − 1)-messages in CERTir∗ are for bit 0 and v = H(Bℓr ). Indeed, all honest
(r, s∗ −1)-verifiers sign v, thus the Adversary cannot generate tH valid (r, s∗ −1)-messages
for a different v ′ .
Moreover, all honest (r, s∗ )-verifiers have waited time ts∗ and do not see > 2/3 majority
∗
∗
for bit 1, again because |HSV r,s −1 | + 4|M SV r,s −1 | < 2n. Thus every honest verifier
∗
∗
=
i ∈ HSV r,s sets bi = 0, vi = H(Bℓr ) by the majority vote, and propagates mr,s
i
r,s∗
r,s∗
r
∗
(ESIGi (0), ESIGi (H(Bℓ )), σi ) at time αi + ts .
Now consider the honest verifiers in Step s∗ + 1 (which is a Coin-Fixed-To-1 step). If the
Adversary actually sends the messages in CERTir∗ to some of them and causes them to
stop, then similar to Case 2.1.a, all honest users know B r = Bℓr within the time interval
I r+1 and
T r+1 ≤ T r + λ + ts∗ +1 .
Otherwise, all honest verifiers in Step s∗ +1 have received all the (r, s∗ )-messages for 0 and
∗
H(Bℓr ) from HSV r,s after waiting time ts∗ +1 , which leads to > 2/3 majority, because
∗
∗
∗
|HSV r,s | > 2|M SV r,s |. Thus all the verifiers in HSV r,s +1 propagate their messages for
∗
0 and H(Bℓr ) accordingly. Note that the verifiers in HSV r,s +1 do not stop with B r = Bℓr ,
because Step s∗ + 1 is not a Coin-Fixed-To-0 step.
Now consider the honest verifiers in Step s∗ + 2 (which is a Coin-Genuinely-Flipped step).
If the Adversary sends the messages in CERTir∗ to some of them and causes them to stop,
then again all honest users know B r = Bℓr within the time interval I r+1 and
T r+1 ≤ T r + λ + ts∗ +2 .
52

Otherwise, all honest verifiers in Step s∗ + 2 have received all the (r, s∗ + 1)-messages for
∗
0 and H(Bℓr ) from HSV r,s +1 after waiting time ts∗ +2 , which leads to > 2/3 majority.
Thus all of them propagate their messages for 0 and H(Bℓr ) accordingly: that is they do
not “flip a coin” in this case. Again, note that they do not stop without propagating,
because Step s∗ + 2 is not a Coin-Fixed-To-0 step.
Finally, for the honest verifiers in Step s∗ + 3 (which is another Coin-Fixed-To-0 step), all
∗
of them would have received at least tH valid messages for 0 and H(Bℓr ) from HSV s +2 ,
if they really wait time ts∗ +3 . Thus, whether or not the Adversary sends the messages
∗
in CERTir∗ to any of them, all verifiers in HSV r,s +3 stop with B r = Bℓr , without
propagating anything. Depending on how the Adversary acts, some of them may have
their own CERT r consisting of those (r, s∗ − 1)-messages in CERTir∗ , and the others have
their own CERT r consisting of those (r, s∗ + 2)-messages. In any case, all honest users
know B r = Bℓr within the time interval I r+1 and
T r+1 ≤ T r + λ + ts∗ +3 .
∗

Case 2.2.b. Event E.b happens and there does not exist an honest verifier i′ ∈ HSV r,s who
should also stop without propagating anything.
The analysis in this case is similar to those in Case 2.1.b and Case 2.2.a, thus many details
have been omitted. In particular, CERTir∗ consists of the tH desired (r, s∗ − 1)-messages
for bit 1 that the Adversary is able to collect or generate, s∗ − 2 ≡ 1 mod 3, Step s∗ is a
Coin-Fixed-To-1 step, and no honest (r, s∗ )-verifier could have seen > 2/3 majority for 0.
∗

= (ESIGi (1), ESIGi (vi ),
Thus, every verifier i ∈ HSV r,s sets bi = 1 and propagates mr,s
i
r,s∗
r,s∗
∗
σi ) at time αi + ts . Similar to Case 2.2.a, in at most 3 more steps (i.e., the protocol
reaches Step s∗ +3, which is another Coin-Fixed-To-1 step), all honest users know B r = Bǫr
within the time interval I r+1 . Moreover, T r+1 may be ≤ T r +λ+ts∗+1 , or ≤ T r +λ+ts∗+2 ,
or ≤ T r + λ + ts∗ +3 , depending on when is the first time an honest verifier is able to stop
without propagating.
∗

Combining the four sub-cases, we have that all honest users know B r within the time interval
I r+1 , with
T r+1 ≤ T r + λ + ts∗ in Cases 2.1.a and 2.1.b, and
T r+1 ≤ T r + λ + ts∗ +3 in Cases 2.2.a and 2.2.b.
It remains to upper-bound s∗ and thus T r+1 for Case 2, and we do so by considering how
many times the Coin-Genuinely-Flipped steps are actually executed in the protocol: that is,
some honest verifiers actually have flipped a coin.
In particular, arbitrarily fix a Coin-Genuinely-Flipped step s′ (i.e., 7 ≤ s′ ≤ m + 2 and
′
s′ − 2 ≡ 2 mod 3), and let ℓ′ , arg minj∈SV r,s′ −1 H(σjr,s −1 ). For now let us assume s′ < s∗ ,
because otherwise no honest verifier actually flips a coin in Step s′ , according to previous
discussions.
′

By the definition of SV r,s −1 , the hash value of the credential of ℓ′ is also the smallest among
all users in P K r−k . Since the hash function is a random oracle, ideally player ℓ′ is honest with
probability at least h. As we will show later, even if the Adversary tries his best to predict the
output of the random oracle and tilt the probability, player ℓ′ is still honest with probability

53

at least ph = h2 (1 + h − h2 ). Below we consider the case when that indeed happens: that is,
′
ℓ′ ∈ HSV r,s −1 .
′
′
Note that every honest verifier i ∈ HSV r,s has received all messages from HSV r,s −1 by
′
time αr,s
+ ts′ . If player i needs to flip a coin (i.e., he has not seen > 2/3 majority for
i
′ −1
the same bit b ∈ {0, 1}), then he sets bi = lsb(H(σℓr,s
)). If there exists another honest
′
′
′
r,s
who has seen > 2/3 majority for a bit b ∈ {0, 1}, then by Property
verifier i ∈ HSV
′
(d) of Lemma 5.5, no honest verifier in HSV r,s would have seen > 2/3 majority for a bit
′
′
−1
b′ 6= b. Since lsb(H(σℓr,s
)) = b with probability 1/2, all honest verifiers in HSV r,s reach
′
an agreement on b with probability 1/2. Of course, if such a verifier i′ does not exist, then all
′ −1
′
honest verifiers in HSV r,s agree on the bit lsb(H(σℓr,s
)) with probability 1.
′
′

′

Combining the probability for ℓ′ ∈ HSV r,s −1 , we have that the honest verifiers in HSV r,s
2
2)
reach an agreement on a bit b ∈ {0, 1} with probability at least p2h = h (1+h−h
. Moreover,
2
′
r,s
have their vi ’s set
by induction on the majority vote as before, all honest verifiers in HSV
′
r+1
r
is
to be H(Bℓ ). Thus, once an agreement on b is reached in Step s , T
either ≤ T r + λ + ts′ +1 or ≤ T r + λ + ts′ +2 ,
depending on whether b = 0 or b = 1, following the analysis of Cases 2.1.a and 2.1.b. In
particular, no further Coin-Genuinely-Flipped step will be executed: that is, the verifiers in
such steps still check that they are the verifiers and thus wait, but they will all stop without
propagating anything. Accordingly, before Step s∗ , the number of times the Coin-GenuinelyFlipped steps are executed is distributed according to the random variable Lr . Letting Step s′
be the last Coin-Genuinely-Flipped step according to Lr , by the construction of the protocol
we have
s′ = 4 + 3Lr .
When should the Adversary make Step s∗ happen if he wants to delay T r+1 as much as
possible? We can even assume that the Adversary knows the realization of Lr in advance. If
s∗ > s′ then it is useless, because the honest verifiers have already reached an agreement in
Step s′ . To be sure, in this case s∗ would be s′ + 1 or s′ + 2, again depending on whether b = 0
or b = 1. However, this is actually Cases 2.1.a and 2.1.b, and the resulting T r+1 is exactly the
same as in that case. More precisely,
T r+1 ≤ T r + λ + ts∗ ≤ T r + λ + ts′ +2 .
If s∗ < s′ − 3 —that is, s∗ is before the second-last Coin-Genuinely-Flipped step— then by
the analysis of Cases 2.2.a and 2.2.b,
T r+1 ≤ T r + λ + ts∗ +3 < T r + λ + ts′ .
That is, the Adversary is actually making the agreement on B r happen faster.
If s∗ = s′ − 2 or s′ − 1 —that is, the Coin-Fixed-To-0 step or the Coin-Fixed-To-1 step
immediately before Step s′ — then by the analysis of the four sub-cases, the honest verifiers in
Step s′ do not get to flip coins anymore, because they have either stopped without propagating,
or have seen > 2/3 majority for the same bit b. Therefore we have
T r+1 ≤ T r + λ + ts∗ +3 ≤ T r + λ + ts′ +2 .
54

In sum, no matter what s∗ is, we have
T r+1 ≤ T r + λ + ts′ +2 = T r + λ + t3Lr +6
= T r + λ + (2(3Lr + 6) − 3)λ + Λ
= T r + (6Lr + 10)λ + Λ,
as we wanted to show. The worst case is when s∗ = s′ − 1 and Case 2.2.b happens.
Combining Cases 1 and 2 of the binary BA protocol, Lemma 5.3 holds.

5.9



Security of the Seed Qr and Probability of An Honest Leader

It remains to prove Lemma 5.4. Recall that the verifiers in round r are taken from P K r−k and
are chosen according to the quantity Qr−1 . The reason for introducing the look-back parameter k
is to make sure that, back at round r − k, when the Adversary is able to add new malicious users
to P K r−k , he cannot predict the quantity Qr−1 except with negligible probability. Note that the
hash function is a random oracle and Qr−1 is one of its inputs when selecting verifiers for round r.
Thus, no matter how malicious users are added to P K r−k , from the Adversary’s point of view each
one of them is still selected to be a verifier in a step of round r with the required probability p (or
p1 for Step 1). More precisely, we have the following lemma.
Lemma 5.6. With k = O(log1/2 F ), for each round r, with overwhelming probability the Adversary
did not query Qr−1 to the random oracle back at round r − k.
Proof. We proceed by induction. Assume that for each round γ < r, the Adversary did not query
Qγ−1 to the random oracle back at round γ − k.21 Consider the following mental game played by
the Adversary at round r − k, trying to predict Qr−1 .
In Step 1 of each round γ = r − k, . . . , r − 1, given a specific Qγ−1 not queried to the random
oracle, by ordering the players i ∈ P K γ−k according to the hash values H(SIGi (γ, 1, Qγ−1 ))
increasingly, we obtain a random permutation over P K γ−k . By definition, the leader ℓγ is the
first user in the permutation and is honest with probability h. Moreover, when P K γ−k is large
enough, for any integer x ≥ 1, the probability that the first x users in the permutation are all
malicious but the (x + 1)st is honest is (1 − h)x h.
If ℓγ is honest, then Qγ = H(SIGℓγ (Qγ−1 ), γ). As the Adversary cannot forge the signature
of ℓγ , Qγ is distributed uniformly at random from the Adversary’s point of view and, except
with exponentially small probability,22 was not queried to H at round r − k. Since each
Qγ+1 , Qγ+2 , . . . , Qr−1 respectively is the output of H with Qγ , Qγ+1 , . . . , Qr−2 as one of the inputs,
they all look random to the Adversary and the Adversary could not have queried Qr−1 to H at
round r − k.
Accordingly, the only case where the Adversary can predict Qr−1 with good probability at round
r−k is when all the leaders ℓr−k , . . . , ℓr−1 are malicious. Again consider a round γ ∈ {r−k . . . , r−1}
and the random permutation over P K γ−k induced by the corresponding hash values. If for some
x ≥ 2, the first x − 1 users in the permutation are all malicious and the x-th is honest, then the
Adversary has x possible choices for Qγ : either of the form H(SIGi (Qγ−1 , γ)), where i is one of
21

As k is a small integer, without loss of generality one can assume that the first k rounds of the protocol are run
under a safe environment and the inductive hypothesis holds for those rounds.
22
That is, exponential in the length of the output of H. Note that this probability is way smaller than F .

55

the first x − 1 malicious users, by making player i the actually leader of round γ; or H(Qγ−1 , γ), by
forcing B γ = Bǫγ . Otherwise, the leader of round γ will be the first honest user in the permutation
and Qr−1 becomes unpredictable to the Adversary.
Which of the above x options of Qγ should the Adversary pursue? To help the Adversary
answer this question, in the mental game we actually make him more powerful than he actually
is, as follows. First of all, in reality, the Adversary cannot compute the hash of a honest user’s
signature, thus cannot decide, for each Qγ , the number x(Qγ ) of malicious users at the beginning
of the random permutation in round γ + 1 induced by Qγ . In the mental game, we give him the
numbers x(Qγ ) for free. Second of all, in reality, having the first x users in the permutation all
being malicious does not necessarily mean they can all be made into the leader, because the hash
values of their signatures must also be less than p1 . We have ignored this constraint in the mental
game, giving the Adversary even more advantages.
It is easy to see that in the mental game, the optimal option for the Adversary, denoted by Q̂γ ,
is the one that produces the longest sequence of malicious users at the beginning of the random
permutation in round γ + 1. Indeed, given a specific Qγ , the protocol does not depend on Qγ−1
anymore and the Adversary can solely focus on the new permutation in round γ + 1, which has the
same distribution for the number of malicious users at the beginning. Accordingly, in each round
γ, the above mentioned Q̂γ gives him the largest number of options for Qγ+1 and thus maximizes
the probability that the consecutive leaders are all malicious.
Therefore, in the mental game the Adversary is following a Markov Chain from round r − k
to round r − 1, with the state space being {0} ∪ {x : x ≥ 2}. State 0 represents the fact that the
first user in the random permutation in the current round γ is honest, thus the Adversary fails the
game for predicting Qr−1 ; and each state x ≥ 2 represents the fact that the first x − 1 users in the
permutation are malicious and the x-th is honest, thus the Adversary has x options for Qγ . The
transition probabilities P (x, y) are as follows.
• P (0, 0) = 1 and P (0, y) = 0 for any y ≥ 2. That is, the Adversary fails the game once the first
user in the permutation becomes honest.
• P (x, 0) = hx for any x ≥ 2. That is, with probability hx , all the x random permutations have
their first users being honest, thus the Adversary fails the game in the next round.
• For any x ≥ 2 and y ≥ 2, P (x, y) is the probability that, among the x random permutations
induced by the x options of Qγ , the longest sequence of malicious users at the beginning of
some of them is y − 1, thus the Adversary has y options for Qγ+1 in the next round. That is,
!x
!x
y−2
y−1
X
X
i
i
(1 − h) h
= (1 − (1 − h)y )x − (1 − (1 − h)y−1 )x .
(1 − h) h
−
P (x, y) =
i=0

i=0

Note that state 0 is the unique absorbing state in the transition matrix P , and every other state
x has a positive probability of going to 0. We are interested in upper-bounding the number k of
rounds needed for the Markov Chain to converge to 0 with overwhelming probability: that is, no
matter which state the chain starts at, with overwhelming probability the Adversary loses the game
and fails to predict Qr−1 at round r − k.
Consider the transition matrix P (2) , P ·P after two rounds. It is easy to see that P (2) (0, 0) = 1
and P (2) (0, x) = 0 for any x ≥ 2. For any x ≥ 2 and y ≥ 2, as P (0, y) = 0, we have
X
X
P (2) (x, y) = P (x, 0)P (0, y) +
P (x, z)P (z, y) =
P (x, z)P (z, y).
z≥2

z≥2

56

Letting h̄ , 1 − h, we have
and
P (2) (x, y) =

P (x, y) = (1 − h̄y )x − (1 − h̄y−1 )x
X

[(1 − h̄z )x − (1 − h̄z−1 )x ][(1 − h̄y )z − (1 − h̄y−1 )z ].

z≥2

(2)

(x,y)
as h goes to 1 —that is, h̄ goes to 0. Note that the highest
Below we compute the limit of PP (x,y)
y−1
order of h̄ in P (x, y) is h̄ , with coefficient x. Accordingly,

P (2) (x, y)
P (2) (x, y)
P (2) (x, y)
= lim
= lim
h→1 P (x, y)
h̄→0 P (x, y)
h̄→0 xh̄y−1 + O(h̄y )
P
z−1 + O(h̄z )][z h̄y−1 + O(h̄y )]
2xh̄y + O(h̄y+1 )
z≥2 [xh̄
= lim
=
lim
xh̄y−1 + O(h̄y )
h̄→0
h̄→0 xh̄y−1 + O(h̄y )
2xh̄y
= lim 2h̄ = 0.
= lim
h̄→0
h̄→0 xh̄y−1
lim

When h is sufficiently close to 1,23 we have
1
P (2) (x, y)
≤
P (x, y)
2
for any x ≥ 2 and y ≥ 2. By induction, for any k > 2, P (k) , P k is such that
• P (k) (0, 0) = 1, P (k) (0, x) = 0 for any x ≥ 2, and
• for any x ≥ 2 and y ≥ 2,
P (k) (x, y) = P (k−1) (x, 0)P (0, y) +

X

P (k−1) (x, z)P (z, y) =

z≥2

≤

X P (x, z)
z≥2

2k−2

· P (z, y) =

P (2) (x, y)
2k−2

≤

P (x, y)
.
2k−1

X

P (k−1) (x, z)P (z, y)

z≥2

As P (x, y) ≤ 1, after 1 − log2 F rounds, the transition probability into any state y ≥ 2 is negligible,
starting with any state x ≥ 2. Although there are many such states y, it is easy to see that
1
1
P (x, y)
(1 − h̄y )x − (1 − h̄y−1 )x
h̄y−1 − h̄y
= =
= lim
.
=
lim
y→+∞ P (x, y + 1)
y→+∞ (1 − h̄y+1 )x − (1 − h̄y )x
y→+∞ h̄y − h̄y+1
1−h
h̄
lim

1
>2
Therefore each row x of the transition matrix P decreases as a geometric sequence with rate 1−h
(k)
when y is large enough, P
and the same holds for P . Accordingly, when k is large enough but still
on the order of log1/2 F , y≥2 P (k) (x, y) < F for any x ≥ 2. That is, with overwhelming probability
the Adversary loses the game and fails to predict Qr−1 at round r − k. For h ∈ (2/3, 1], a more
complex analysis shows that there exists a constant C slightly larger than 1/2, such that it suffices
to take k = O(logC F ). Thus Lemma 5.6 holds.


Lemma 5.4. (restated) Given Properties 1–3 for each round before r, ph = h2 (1 + h − h2 ) for Lr ,
and the leader ℓr is honest with probability at least ph .
23

For example, h = 80% as suggested by the specific choices of parameters.

57

Proof. Following Lemma 5.6, the Adversary cannot predict Qr−1 back at round r − k except with
negligible probability. Note that this does not mean the probability of an honest leader is h for
each round. Indeed, given Qr−1 , depending on how many malicious users are at the beginning of
the random permutation of P K r−k , the Adversary may have more than one options for Qr and
thus can increase the probability of a malicious leader in round r + 1 —again we are giving him
some unrealistic advantages as in Lemma 5.6, so as to simplify the analysis.
However, for each Qr−1 that was not queried to H by the Adversary back at round r − k, for
any x ≥ 1, with probability (1 − h)x−1 h the first honest user occurs at position x in the resulting
random permutation of P K r−k . When x = 1, the probability of an honest leader in round r + 1 is
indeed h; while when x = 2, the Adversary has two options for Qr and the resulting probability is
h2 . Only by considering these two cases, we have that the probability of an honest leader in round
r + 1 is at least h · h + (1 − h)h · h2 = h2 (1 + h − h2 ) as desired.
Note that the above probability only considers the randomness in the protocol from round r − k
to round r. When all the randomness from round 0 to round r is taken into consideration, Qr−1 is
even less predictable to the Adversary and the probability of an honest leader in round r + 1 is at
least h2 (1 + h − h2 ). Replacing r + 1 with r and shifts everything back by one round, the leader ℓr
is honest with probability at least h2 (1 + h − h2 ), as desired.
Similarly, in each Coin-Genuinely-Flipped step s, the “leader” of that step —that is the verifier
in SV r,s whose credential has the smallest hash value, is honest with probability at least h2 (1 +
h − h2 ). Thus ph = h2 (1 + h − h2 ) for Lr and Lemma 5.4 holds.


Algorand ′2

6

In this section, we construct a version of Algorand ′ working under the following assumption.
Honest Majority of Users Assumption: More than 2/3 of the users in each P K r are honest.
In Section 8, we show how to replace the above assumption with the desired Honest Majority of
Money assumption.

6.1

Additional Notations and Parameters for Algorand ′2

Notations
• µ ∈ Z+ : a pragmatic upper-bound to the number of steps that, with overwhelming probability,
will actually taken in one round. (As we shall see, parameter µ controls how many ephemeral
keys a user prepares in advance for each round.)
• Lr : a random variable representing the number of Bernoulli trials needed to see a 1, when each
trial is 1 with probability p2h . Lr will be used to upper-bound the time needed to generate
block B r .
• tH : a lower-bound for the number of honest verifiers in a step s > 1 of round r, such that with
overwhelming probability (given n and p), there are > tH honest verifiers in SV r,s .
Parameters
• Relationships among various parameters.
— For each step s > 1 of round r, n is chosen so that, with overwhelming probability,
58

|HSV r,s | > tH and |HSV r,s | + 2|M SV r,s | < 2tH .
Note that the two inequalities above together imply |HSV r,s | > 2|M SV r,s |: that is, there
is a 2/3 honest majority among selected verifiers.
The closer to 1 the value of h is, the smaller n needs to be. In particular, we use (variants
of) Chernoff bounds to ensure the desired conditions hold with overwhelming probability.
• Example choices of important parameters.
— F = 10−18 .
— n ≈ 4000, tH ≈ 0.69n, k = 70.

6.2

Implementing Ephemeral Keys in Algorand ′2

Recall that a verifier i ∈ SV r,s digitally signs his message mr,s
of step s in round r, relative to
i
r,s
an ephemeral public key pki , using an ephemeral secrete key skir,s that he promptly destroys
after using. When the number of possible steps that a round may take is capped by a given
integer µ, we have already seen how to practically handle ephemeral keys. For example, as we
have explained in Algorand ′1 (where µ = m + 3), to handle all his possible ephemeral keys, from
a round r ′ to a round r ′ + 106 , i generates a pair (P M K, SM K), where P M K public master
key of an identity based signature scheme, and SM K its corresponding secret master key. User i
publicizes P M K and uses SM K to generate the secret key of each possible ephemeral public key
(and destroys SM K after having done so). The set of i’s ephemeral public keys for the relevant
rounds is S = {i} × {r ′ , . . . , r ′ + 106 } × {1, . . . , µ}. (As discussed, as the round r ′ + 106 approaches,
i “refreshes” his pair (P M K, SM K).)
In practice, if µ is large enough, a round of Algorand ′2 will not take more than µ steps. In
principle, however, there is the remote possibility that, for some round r the number of steps
actually taken will exceed µ. When this happens, i would be unable to sign his message mr,s
i for
any step s > µ, because he has prepared in advance only µ secret keys for round r. Moreover, he
could not prepare and publicize a new stash of ephemeral keys, as discussed before. In fact, to do
so, he would need to insert a new public master key P M K ′ in a new block. But, should round r
take more and more steps, no new blocks would be generated.
However, solutions exist. For instance, i may use the last ephemeral key of round r, pkir,µ ,
as follows. He generates another stash of key-pairs for round r —e.g., by (1) generating another
master key pair (P M K, SM K); (2) using this pair to generate another, say, 106 ephemeral keys,
r,µ+1

r,µ+106

sk i
, . . . , sk i
, corresponding to steps µ + 1, ..., µ + 106 of round r; (3) using skir,µ to digitally
sign P M K (and any (r, µ)-message if i ∈ SV r,µ ), relative to pkir,µ ; and (4) erasing SM K and skir,µ .
Should i become a verifier in a step µ + s with s ∈ {1, . . . , 106 }, then i digitally signs his (r, µ + s)r,µ+s
= (i, r, µ + s). Of course, to verify this signature
message mr,µ+s
relative to his new key pk i
i
of i, others need to be certain that this public key corresponds to i’s new public master key P M K.
Thus, in addition to this signature, i transmits his digital signature of P M K relative to pkir,µ .
Of course, this approach can be repeated, as many times as necessary, should round r continue
for more and more steps! The last ephemeral secret key is used to authenticate a new master public
key, and thus another stash of ephemeral keys for round r. And so on.

59

6.3

The Actual Protocol Algorand ′2

Recall again that, in each step s of a round r, a verifier i ∈ SV r,s uses his long-term
 public-secret
r,s
r−1
r−1
in case s = 1.
key pair to produce his credential, σi , SIGi (r, s, Q ), as well as SIGi Q
Verifier i uses his ephemeral key pair, (pkir,s , skir,s ), to sign any other message m that may be
required. For simplicity, we write esigi (m), rather than sigpkir,s (m), to denote i’s proper ephemeral
signature of m in this step, and write ESIGi (m) instead of SIGpkir,s (m) , (i, m, esigi (m)).
Step 1: Block Proposal
Instructions for every user i ∈ P K r−k : User i starts his own Step 1 of round r as soon as he has
CERT r−1 , which allows i to unambiguously compute H(B r−1 ) and Qr−1 .
• User i uses Qr−1 to check whether i ∈ SV r,1 or not. If i ∈
/ SV r,1 , he does nothing for Step 1.
• If i ∈ SV r,1 , that is, if i is a potential leader, then he does the following.
(a) If i has seen B 0 , . . . , B r−1 himself (any B j = Bǫj can be easily derived from its hash value
in CERT j and is thus assumed “seen”), then he collects the round-r payments that have
been propagated to him so far and computes a maximal payset P AYir from them.
(b) If i hasn’t seen all B 0 , . . . , B r−1 yet, then he sets P AYir = ∅.
(c) Next, i computes his “candidate block” Bir = (r, P AYir , SIGi (Qr−1 ), H(B r−1 )).
r,1
r
r
(c) Finally, i computes the message mr,1
i = (Bi , esigi (H(Bi )), σi ), destroys his ephemeral
r,1
r,1
secret key ski , and then propagates two messages, mi and (SIGi (Qr−1 ), σir,1 ),
separately but simultaneously.a
a

When i is the leader, SIGi (Qr−1 ) allows others to compute Qr = H(SIGi (Qr−1 ), r).

60

Selective Propagation
To shorten the global execution of Step 1 and the whole round, it is important that the (r, 1)messages are selectively propagated. That is, for every user j in the system,
• For the first (r, 1)-message that he ever receives and successfully verifies,a whether it contains
a block or is just a credential and a signature of Qr−1 , player j propagates it as usual.
• For all the other (r, 1)-messages that player j receives and successfully verifies, he propagates
it only if the hash value of the credential it contains is the smallest among the hash values
of the credentials contained in all (r, 1)-messages he has received and successfully verified so
far.
• However, if j receives two different messages of the form mr,1
from the same player i,b he
i
discards the second one no matter what the hash value of i’s credential is.
Note that, under selective propagation it is useful that each potential leader i propagates his
c those small messages travel faster than blocks, ensure
credential σir,1 separately from mr,1
i :
timely propagation of the mr,1
i ’s where the contained credentials have small hash values, while
make those with large hash values disappear quickly.
That is, all the signatures are correct and, if it is of the form mr,1
i , both the block and its hash are valid
—although j does not check whether the included payset is maximal for i or not.
b
Which means i is malicious.
c
We thank Georgios Vlachos for suggesting this.
a

61

Step 2: The First Step of the Graded Consensus Protocol GC
Instructions for every user i ∈ P K r−k : User i starts his own Step 2 of round r as soon as he has
CERT r−1 .
• User i waits a maximum amount of time t2 , λ + Λ. While waiting, i acts as follows.
1. After waiting for time 2λ, he finds the user ℓ such that H(σℓr,1 ) ≤ H(σjr,1 ) for all
credentials σjr,1 that are part of the successfully verified (r, 1)-messages he has received
so far.a
2. If he has received a block B r−1 , which matches the hash value H(B r−1 )
contained in CERT r−1 ,b and if he has received from ℓ a valid message mr,1
=
ℓ
r,1 c
r
r
′
r
(Bℓ , esigℓ (H(Bℓ )), σℓ ), then i stops waiting and sets vi , (H(Bℓ ), ℓ).
3. Otherwise, when time t2 runs out, i sets vi′ , ⊥.
4. When the value of vi′ has been set, i computes Qr−1 from CERT r−1 and checks whether
i ∈ SV r,2 or not.
r,2 d
′
5. If i ∈ SV r,2 , i computes the message mr,2
i , (ESIGi (vi ), σi ), destroys his ephemeral
secret key skir,2 , and then propagates mr,2
i . Otherwise, i stops without propagating
anything.
a

Essentially, user i privately decides that the leader of round r is user ℓ.
Of course, if CERT r−1 indicates that B r−1 = Bǫr−1 , then i has already “received” B r−1 the moment he has
CERT r−1 .
c
Again, player ℓ’s signatures and the hashes are all successfully verified, and P AYℓr in Bℓr is a valid payset for
round r —although i does not check whether P AYℓr is maximal for ℓ or not. If Bℓr contains an empty payset, then
there is actually no need for i to see B r−1 before verifying whether Bℓr is valid or not.
d
The message mr,2
signals that player i considers the first component of vi′ to be the hash of the next block, or
i
considers the next block to be empty.
b

62

Step 3: The Second Step of GC
Instructions for every user i ∈ P K r−k : User i starts his own Step 3 of round r as soon as he has
CERT r−1 .
• User i waits a maximum amount of time t3 , t2 + 2λ = 3λ + Λ. While waiting, i acts as
follows.
1. If there exists a value v such that he has received at least tH valid messages mr,2
j of
r,2
a
the form (ESIGj (v), σj ), without any contradiction, then he stops waiting and sets
v ′ = v.
2. Otherwise, when time t3 runs out, he sets v ′ = ⊥.
3. When the value of v ′ has been set, i computes Qr−1 from CERT r−1 and checks whether
i ∈ SV r,3 or not.
, (ESIGi (v ′ ), σir,3 ), destroys his
4. If i ∈ SV r,3 , then i computes the message mr,3
i
ephemeral secret key skir,3 , and then propagates mr,3
i . Otherwise, i stops without
propagating anything.
a

That is, he has not received two valid messages containing ESIGj (v) and a different ESIGj (v̂) respectively,
from a player j. Here and from here on, except in the Ending Conditions defined later, whenever an honest player
wants messages of a given form, messages contradicting each other are never counted or considered valid.

63

Step 4: Output of GC and The First Step of BBA⋆
Instructions for every user i ∈ P K r−k : User i starts his own Step 4 of round r as soon as he
finishes his own Step 3.
• User i waits a maximum amount of time 2λ.a While waiting, i acts as follows.
1. He computes vi and gi , the output of GC, as follows.
(a) If there exists a value v ′ 6= ⊥ such that he has received at least tH valid messages
r,3
′
′
mr,3
j = (ESIGj (v ), σj ), then he stops waiting and sets vi , v and gi , 2.
r,3
(b) If he has received at least tH valid messages mr,3
j = (ESIGj (⊥), σj ), then he stops
waiting and sets vi , ⊥ and gi , 0.b

(c) Otherwise, when time 2λ runs out, if there exists a value v ′ 6= ⊥ such that he has
r,3
′
′
received at least ⌈ t2H ⌉ valid messages mr,j
j = (ESIGj (v ), σj ), then he sets vi , v
and gi , 1.c
(d) Else, when time 2λ runs out, he sets vi , ⊥ and gi , 0.
2. When the values vi and gi have been set, i computes bi , the input of BBA⋆ , as follows:
bi , 0 if gi = 2, and bi , 1 otherwise.
3. i computes Qr−1 from CERT r−1 and checks whether i ∈ SV r,4 or not.
r,4
4. If i ∈ SV r,4 , he computes the message mr,4
i , (ESIGi (bi ), ESIGi (vi ), σi ), destroys his
ephemeral secret key skir,4 , and propagates mr,4
i . Otherwise, i stops without propagating
anything.
a

Thus, the maximum total amount of time since i starts his Step 1 of round r could be t4 , t3 + 2λ = 5λ + Λ.
Whether Step (b) is in the protocol or not does not affect its correctness. However, the presence of Step (b)
allows Step 4 to end in less than 2λ time if sufficiently many Step-3 verifiers have “signed ⊥.”
c
It can be proved that the v ′ in this case, if exists, must be unique.
b

64

Step s, 5 ≤ s ≤ m + 2, s − 2 ≡ 0 mod 3: A Coin-Fixed-To-0 Step of BBA⋆
Instructions for every user i ∈ P K r−k : User i starts his own Step s of round r as soon as he
finishes his own Step s − 1.
• User i waits a maximum amount of time 2λ.a While waiting, i acts as follows.
– Ending Condition 0: If at any point there exists a string v 6= ⊥ and a step s′ such that
(a) 5 ≤ s′ ≤ s, s′ − 2 ≡ 0 mod 3 —that is, Step s′ is a Coin-Fixed-To-0 step,
′

′

(b) i has received at least tH valid messages mjr,s −1 = (ESIGj (0), ESIGj (v), σjr,s −1 ),b
and
(c) i has received a valid message (SIGj (Qr−1 ), σjr,1 ) with j being the second
component of v,
then, i stops waiting and ends his own execution of Step s (and in fact of round r)
right away without propagating anything as a (r, s)-verifier; sets H(B r ) to be the first
′
component of v; and sets his own CERT r to be the set of messages mjr,s −1 of step (b)
together with (SIGj (Qr−1 ), σjr,1 ).c
– Ending Condition 1: If at any point there exists a step s′ such that
(a’) 6 ≤ s′ ≤ s, s′ − 2 ≡ 1 mod 3 —that is, Step s′ is a Coin-Fixed-To-1 step, and
′

(b’) i has received at least tH valid messages mjr,s −1 = (ESIGj (1), ESIGj (vj ),
′

σjr,s −1 ),d
then, i stops waiting and ends his own execution of Step s (and in fact of round r) right
away without propagating anything as a (r, s)-verifier; sets B r = Bǫr ; and sets his own
′
CERT r to be the set of messages mjr,s −1 of sub-step (b’).
– If at any point he has received at least tH valid mjr,s−1 ’s of the form
(ESIGj (1), ESIGj (vj ), σjr,s−1 ), then he stops waiting and sets bi , 1.
– If at any point he has received at least tH valid mjr,s−1 ’s of the form
(ESIGj (0), ESIGj (vj ), σjr,s−1 ), but they do not agree on the same v, then he stops
waiting and sets bi , 0.
– Otherwise, when time 2λ runs out, i sets bi , 0.
– When the value bi has been set, i computes Qr−1 from CERT r−1 and checks whether
i ∈ SV r,s .
r,s
– If i ∈ SV r,s , i computes the message mr,s
i , (ESIGi (bi ), ESIGi (vi ), σi ) with vi being
the value he has computed in Step 4, destroys his ephemeral secret key skir,s , and then
propagates mr,s
i . Otherwise, i stops without propagating anything.
a

Thus, the maximum total amount of time since i starts his Step 1 of round r could be ts , ts−1 + 2λ =
(2s − 3)λ + Λ.
b
Such a message from player j is counted even if player i has also received a message from j signing for 1.
Similar things for Ending Condition 1. As shown in the analysis, this is to ensure that all honest users know
CERT r within time λ from each other.
c
User i now knows H(B r ) and his own round r finishes. He just needs to wait until the actually block B r is
propagated to him, which may take some additional time. He still helps propagating messages as a generic user,
but does not initiate any propagation as a (r, s)-verifier. In particular, he has helped propagating all messages in
his CERT r , which is enough for our protocol. Note that he should also set bi , 0 for the binary BA protocol, but
bi is not needed in this case anyway. Similar things for all future instructions.
d
In this case, it does not matter what the vj ’s are.

65

Step s, 6 ≤ s ≤ m + 2, s − 2 ≡ 1 mod 3: A Coin-Fixed-To-1 Step of BBA⋆
Instructions for every user i ∈ P K r−k : User i starts his own Step s of round r as soon as he
finishes his own Step s − 1.
• User i waits a maximum amount of time 2λ. While waiting, i acts as follows.
– Ending Condition 0: The same instructions as in a Coin-Fixed-To-0 step.
– Ending Condition 1: The same instructions as in a Coin-Fixed-To-0 step.
– If at any point he has received at least tH valid mjr,s−1 ’s of the form
(ESIGj (0), ESIGj (vj ), σjr,s−1 ), then he stops waiting and sets bi , 0.a
– Otherwise, when time 2λ runs out, i sets bi , 1.
– When the value bi has been set, i computes Qr−1 from CERT r−1 and checks whether
i ∈ SV r,s .
r,s
– If i ∈ SV r,s , i computes the message mr,s
i , (ESIGi (bi ), ESIGi (vi ), σi ) with vi being
the value he has computed in Step 4, destroys his ephemeral secret key skir,s , and then
propagates mr,s
i . Otherwise, i stops without propagating anything.
a

Note that receiving tH valid (r, s − 1)-messages signing for 1 would mean Ending Condition 1.

Step s, 7 ≤ s ≤ m + 2, s − 2 ≡ 2 mod 3: A Coin-Genuinely-Flipped Step of BBA⋆
Instructions for every user i ∈ P K r−k : User i starts his own Step s of round r as soon as he
finishes his own step s − 1.
• User i waits a maximum amount of time 2λ. While waiting, i acts as follows.
– Ending Condition 0: The same instructions as in a Coin-Fixed-To-0 step.
– Ending Condition 1: The same instructions as in a Coin-Fixed-To-0 step.
– If at any point he has received at least tH valid mjr,s−1 ’s of the form
(ESIGj (0), ESIGj (vj ), σjr,s−1 ), then he stops waiting and sets bi , 0.
– If at any point he has received at least tH valid mjr,s−1 ’s of the form
(ESIGj (1), ESIGj (vj ), σjr,s−1 ), then he stops waiting and sets bi , 1.
– Otherwise, when time 2λ runs out, letting SVir,s−1 be the set of (r, s − 1)-verifiers from
whom he has received a valid message mjr,s−1 , i sets bi , lsb(minj∈SV r,s−1 H(σjr,s−1 )).
i

– When the value bi has been set, i computes
i ∈ SV r,s .

Qr−1

from

CERT r−1

and checks whether

r,s
– If i ∈ SV r,s , i computes the message mr,s
i , (ESIGi (bi ), ESIGi (vi ), σi ) with vi being
the value he has computed in Step 4, destroys his ephemeral secret key skir,s , and then
propagates mr,s
i . Otherwise, i stops without propagating anything.

Remark. In principle, as considered in subsection 6.2, the protocol may take arbitrarily many
steps in some round. Should this happens, as discussed, a user i ∈ SV r,s with s > µ has exhausted
66

his stash of pre-generated ephemeral keys and has to authenticate his (r, s)-message mr,s
by a
i
“cascade” of ephemeral keys. Thus i’s message becomes a bit longer and transmitting these longer
messages will take a bit more time. Accordingly, after so many steps of a given round, the value of
the parameter λ will automatically increase slightly. (But it reverts to the original λ once a new
block is produced and a new round starts.)
Reconstruction of the Round-r Block by Non-Verifiers
Instructions for every user i in the system: User i starts his own round r as soon as he has
CERT r−1 .
• i follows the instructions of each step of the protocol, participates the propagation of all
messages, but does not initiate any propagation in a step if he is not a verifier in it.
• i ends his own round r by entering either Ending Condition 0 or Ending Condition 1 in some
step, with the corresponding CERT r .
• From there on, he starts his round r + 1 while waiting to receive the actual block B r (unless
he has already received it), whose hash H(B r ) has been pinned down by CERT r . Again, if
CERT r indicates that B r = Bǫr , the i knows B r the moment he has CERT r .

6.4

Analysis of Algorand ′2

The analysis of Algorand ′2 is easily derived from that of Algorand ′1 . Essentially, in Algorand ′2 , with
overwhelming probability, (a) all honest users agree on the same block B r ; the leader of a new
block is honest with probability at least ph = h2 (1 + h − h2 ).

7

Handling Offline Honest users

As we said, a honest user follows all his prescribed instructions, which include that of being online
and running the protocol. This is not a major burden in Algorand, since the computation and
bandwidth required from a honest user are quite modest. Yet, let us point out that Algorand can
be easily modified so as to work in two models, in which honest users are allowed to be offline in
great numbers.
Before discussing these two models, let us point out that, if the percentage of honest players
were 95%, Algorand could still be run setting all parameters assuming instead that h = 80%.
Accordingly, Algorand would continue to work properly even if at most half of the honest players
chose to go offline (indeed, a major case of“absenteeism”). In fact, at any point in time, at least
80% of the players online would be honest.
From Continual Participation to Lazy Honesty As we saw, Algorand ′1 and Algorand ′2 choose
the look-back parameter k. Let us now show that choosing k properly large enables one to remove
the Continual Participation requirement. This requirement ensures a crucial property: namely,
that the underlying BA protocol BBA⋆ has a proper honest majority. Let us now explain how lazy
honesty provides an alternative and attractive way to satisfy this property.

67

Recall that a user i is lazy-but-honest if (1) he follows all his prescribed instructions, when
he is asked to participate to the protocol, and (2) he is asked to participate to the protocol only
very rarely —e.g., once a week— with suitable advance notice, and potentially receiving significant
rewards when he participates.
To allow Algorand to work with such players, it just suffices to “choose the verifiers of the
current round among the users already in the system in a much earlier round.” Indeed, recall that
the verifiers for a round r are chosen from users in round r − k, and the selections are made based
on the quantity Qr−1 . Note that a week consists of roughly 10,000 minutes, and assume that a
round takes roughly (e.g., on average) 5 minutes, so a week has roughly 2,000 rounds. Assume
that, at some point of time, a user i wishes to plan his time and know whether he is going to be
a verifier in the coming week. The protocol now chooses the verifiers for a round r from users in
round r − k − 2, 000, and the selections are based on Qr−2,001 . At round r, player i already knows
the values Qr−2,000 , . . . , Qr−1 , since they are actually part of the blockchain. Then, for each M
between 1 and 2,000, i is a verifier in a step s of round r + M if and only if

.H SIGi r + M, s, Qr+M −2,001 ≤ p .
Thus, to check whether he is going to be called
 to act as a verifier in the next 2,000 rounds, i must
compute σiM,s = SIGi r + M, s, Qr+M −2,001 for M = 1 to 2, 000 and for each step s, and check
whether .H(σiM,s ) ≤ p for some of them. If computing a digital signature takes a millisecond, then
this entire operation will take him about 1 minute of computation. If he is not selected as a verifier
in any of these rounds, then he can go off-line with an “honest conscience”. Had he continuously
participated, he would have essentially taken 0 steps in the next 2,000 rounds anyway! If, instead,
he is selected to be a verifier in one of these rounds, then he readies himself (e.g., by obtaining all
the information necessary) to act as an honest verifier at the proper round.
By so acting, a lazy-but-honest potential verifier i only misses participating to the propagation
of messages. But message propagation is typically robust. Moreover, the payers and the payees of
recently propagated payments are expected to be online to watch what happens to their payments,
and thus they will participate to message propagation, if they are honest.

8

Protocol Algorand ′ with Honest Majority of Money

We now, finally, show how to replace the Honest Majority of Users assumption with the much more
meaningful Honest Majority of Money assumption. The basic idea is (in a proof-of-stake flavor)
“to select a user i ∈ P K r−k to belong to SV r,s with a weight (i.e., decision power) proportional to
the amount of money owned by i.”24
By our HMM assumption, we can choose whether that amount should be owned at round r − k
or at (the start of) round r. Assuming that we do not mind continual participation, we opt for
the latter choice. (To remove continual participation, we would have opted for the former choice.
Better said, for the amount of money owned at round r − k − 2, 000.)
There are many ways to implement this idea. The simplest way would be to have each key hold
(r)
at most 1 unit of money and then select at random n users i from P K r−k such that ai = 1.
24

We should say P K r−k−2,000 so as to replace continual participation. For simplicity, since one may wish to require
continual participation anyway, we use P K r−k as before, so as to carry one less parameter.

68

The Next Simplest Implementation
The next simplest implementation may be to demand that each public key owns a maximum amount
of money M , for some fixed M . The value M is small enough compared with the total amount of
money in the system, such that the probability a key belongs to the verifier set of more than one
(r)
step in —say— k rounds is negligible. Then, a key i ∈ P K r−k , owning an amount of money ai
in round r, is chosen to belong to SV r,s if
.H SIGi r, s, Qr−1
And all proceeds as before.



(r)

≤ p·

ai
.
M

A More Complex Implementation
The last implementation “forced a rich participant in the system to own many keys”.
An alternative implementation, described below, generalizes the notion of status and consider
each user i to consist of K + 1 copies (i, v), each of which is independently selected to be a verifier,
r,s
r,s
and will own his own ephemeral key (pki,v
, ski,v
) in a step s of a round r. The value K depends
(r)

on the amount of money ai owned by i in round r.
Let us now see how such a system works in greater detail.
(r)

Number of Copies Let n be the targeted expected cardinality of each verifier set, and let ai
be the amount of money owned by a user i at round r. Let Ar be the total amount of money owned
by the users in P K r−k at round r, that is,
X
(r)
Ar =
ai .
i∈P K r−k

If i is an user in P K r−k , then i’s copies are (i, 1), . . . , (i, K + 1), where
%
$
(r)
n · ai
.
K=
Ar
(r)

Example. Let n = 1, 000, Ar = 109 , and ai = 3.7 millions. Then,

 3
10 · (3.7 · 106 )
= ⌊3.7⌋ = 3 .
K=
109
Verifiers and Credentials Let i be a user in P K r−k with K + 1 copies.
For each v = 1, . . . , K, copy (i, v) belongs to SV r,s automatically. That is, i’s credential is
r,s
r,s
σi,v , SIGi ((i, v), r, s, Qr−1 ), but the corresponding condition becomes .H(σi,v
) ≤ 1, which is
always true.
For copy (i, K + 1), for each Step s of round r, i checks whether
.H SIGi (i, K + 1), r, s, Qr−1
69



(r)

≤ ai

n
−K .
Ar

If so, copy (i, K + 1) belongs to SV r,s . To prove it, i propagates the credential

r,1
σi,K+1
= SIGi (i, K + 1), r, s, Qr−1 .
(r)

Example. As in the previous example, let n = 1K, ai = 3.7M , Ar = 1B, and i has 4
copies: (i, 1), . . . , (i, 4). Then, the first 3 copies belong to SV r,s automatically. For the 4th one,
conceptually, Algorand ′ independently rolls a biased coin, whose probability of Heads is 0.7. Copy
(i, 4) is selected if and only if the coin toss is Heads.
(Of course, this biased coin flip is implemented by hashing, signing, and comparing —as we
have done all along in this paper— so as to enable i to prove his result.)

Business as Usual Having explained how verifiers are selected and how their credentials are
computed at each step of a round r, the execution of a round is similar to that already explained.

9

Handling Forks

Having reduced the probability of forks to 10−12 or 10−18 , it is practically unnecessary to handle
them in the remote chance that they occur. Algorand, however, can also employ various fork
resolution procedures, with or without proof of work.
One possible way of instructing the users to resolve forks is as follows:
• Follow the longest chain if a user sees multiple chains.
• If there are more than one longest chains, follow the one with a non-empty block at the end. If
all of them have empty blocks at the end, consider their second-last blocks.
• If there are more than one longest chains with non-empty blocks at the end, say the chains are
of length r, follow the one whose leader of block r has the smallest credential. If there are ties,
follow the one whose block r itself has the smallest hash value. If there are still ties, follow the
one whose block r is ordered the first lexicographically.

10

Handling Network Partitions

As said, we assume the propagation times of messages among all users in the network are upperbounded by λ and Λ. This is not a strong assumption, as today’s Internet is fast and robust, and
the actual values of these parameters are quite reasonable. Here, let us point out that Algorand ′2
continues to work even if the Internet occasionally got partitioned into two parts. The case when
the Internet is partitioned into more than two parts is similar.

10.1

Physical Partitions

First of all, the partition may be caused by physical reasons. For example, a huge earthquake may
end up completely breaking down the connection between Europe and America. In this case, the
malicious users are also partitioned and there is no communication between the two parts. Thus
70

there will be two Adversaries, one for part 1 and the other for part 2. Each Adversary still tries to
break the protocol in its own part.
Assume the partition happens in the middle of round r. Then each user is still selected as a
verifier based on P K r−k , with the same probability as before. Let HSVir,s and M SVir,s respectively
be the set of honest and malicious verifiers in a step s in part i ∈ {1, 2}. We have
|HSV1r,s | + |M SV1r,s | + |HSV2r,s | + |M SV2r,s | = |HSV r,s | + |M SV r,s |.
Note that |HSV r,s | + |M SV r,s | < |HSV r,s | + 2|M SV r,s | < 2tH with overwhelming probability.
If some part i has |HSVir,s | + |M SVir,s | ≥ tH with non-negligible probability, e.g., 1%, then the
r,s
r,s
probability that |HSV3−i
| + |M SV3−i
| ≥ tH is very low, e.g., 10−16 when F = 10−18 . In this case,
we may as well treat the smaller part as going offline, because there will not be enough verifiers in
this part to generate tH signatures to certify a block.
Let us consider the larger part, say part 1 without loss of generality. Although |HSV r,s | <
tH with negligible probability in each step s, when the network is partitioned, |HSV1r,s | may be
less than tH with some non-negligible probability. In this case the Adversary may, with some
other non-negligible probability, force the binary BA protocol into a fork in round r, with a nonempty block B r and the empty block Bǫr both having tH valid signatures.25 For example, in a
Coin-Fixed-To-0 step s, all verifiers in HSV1r,s signed for bit 0 and H(B r ), and propagated their
messages. All verifiers in M SV1r,s also signed 0 and H(B r ), but withheld their messages. Because
|HSV1r,s | + |M SV1r,s | ≥ tH , the system has enough signatures to certify B r . However, since the
malicious verifiers withheld their signatures, the users enter step s + 1, which is a Coin-Fixed-To1 step. Because |HSV1r,s | < tH due to the partition, the verifiers in HSV1r,s+1 did not see tH
signatures for bit 0 and they all signed for bit 1. All verifiers in M SV1r,s+1 did the same. Because
|HSV1r,s+1 | + |M SV1r,s+1 | ≥ tH , the system has enough signatures to certify Bǫr . The Adversary
then creates a fork by releasing the signatures of M SV1r,s for 0 and H(B r ).
Accordingly, there will be two Qr ’s, defined by the corresponding blocks of round r. However,
the fork will not continue and only one of the two branches may grow in round r + 1.
Additional Instructions for Algorand ′2 . When seeing a non-empty block B r and the empty
block Bǫr , follow the non-empty one (and the Qr defined by it).
Indeed, by instructing the users to go with the non-empty block in the protocol, if a large
amount of honest users in P K r+1−k realize there is a fork at the beginning of round r + 1, then the
empty block will not have enough followers and will not grow. Assume the Adversary manages to
partition the honest users so that some honest users see B r (and perhaps Bǫr ), and some only see
Bǫr . Because the Adversary cannot tell which one of them will be a verifier following B r and which
will be a verifier following Bǫr , the honest users are randomly partitioned and each one of them still
becomes a verifier (either with respect to B r or with respect to Bǫr ) in a step s > 1 with probability
p. For the malicious users, each one of them may have two chances to become a verifier, one with
B r and the other with Bǫr , each with probability p independently.
r+1,s
Let HSV1;B
be the set of honest verifiers in step s of round r+1 following B r . Other notations
r

r+1,s
r+1,s
r+1,s
such as HSV1;B
and M SV1;B
are similarly defined. By Chernoff bound, it is easy
r , M SV1;B r
r
ǫ
ǫ
25

Having a fork with two non-empty blocks is not possible with or without partitions, except with negligible
probability.

71

to see that with overwhelming probability,
r+1,s
r+1,s
r+1,s
r+1,s
|HSV1;B
r | + |HSV1;B r | + |M SV1;B r | + |M SV1;B r | < 2tH .
ǫ
ǫ

Accordingly, the two branches cannot both have tH proper signatures certifying a block for round
r + 1 in the same step s. Moreover, since the selection probabilities for two steps s and s′ are the
same and the selections are independent, also with overwhelming probability
′

′

r+1,s
r+1,s
r+1,s
r+1,s
| < 2tH ,
| + |M SV1;B
|HSV1;B
r
r | + |M SV1;B r | + |HSV1;B r
ǫ
ǫ

for any two steps s and s′ . When F = 10−18 , by the union bound, as long as the Adversary cannot
partition the honest users for a long time (say 104 steps, which is more than 55 hours with λ = 10
seconds26 ), with high probability (say 1 − 10−10 ) at most one branch will have tH proper signatures
to certify a block in round r + 1.
Finally, if the physical partition has created two parts with roughly the same size, then the
probability that |HSVir,s | + |M SVir,s | ≥ tH is small for each part i. Following a similar analysis,
even if the Adversary manages to create a fork with some non-negligible probability in each part
for round r, at most one of the four branches may grow in round r + 1.

10.2

Adversarial Partition

Second of all, the partition may be caused by the Adversary, so that the messages propagated
by the honest users in one part will not reach the honest users in the other part directly, but
the Adversary is able to forward messages between the two parts. Still, once a message from one
part reaches an honest user in the other part, it will be propagated in the latter as usual. If the
Adversary is willing to spend a lot of money, it is conceivable that he may be able to hack the
Internet and partition it like this for a while.
The analysis is similar to that for the larger part in the physical partition above (the smaller
part can be considered as having population 0): the Adversary may be able to create a fork and
each honest user only sees one of the branches, but at most one branch may grow.

10.3

Network Partitions in Sum

Although network partitions can happen and a fork in one round may occur under partitions, there
is no lingering ambiguity: a fork is very short-lived, and in fact lasts for at most a single round. In
all parts of the partition except for at most one, the users cannot generate a new block and thus
(a) realize there is a partition in the network and (b) never rely on blocks that will “vanish”.

Acknowledgements
We would like to first acknowledge Sergey Gorbunov, coauthor of the cited Democoin system.
Most sincere thanks go to Maurice Herlihy, for many enlightening discussions, for pointing
out that pipelining will improve Algorand’s throughput performance, and for greatly improving the
26
Note that a user finishes a step s without waiting for 2λ time only if he has seen at least tH signatures for the
same message. When there are not enough signatures, each step will last for 2λ time.

72

exposition of an earlier version of this paper. Many thanks to Sergio Rajsbaum, for his comments on
an earlier version of this paper. Many thanks to Vinod Vaikuntanathan, for several deep discussions
and insights. Many thanks to Yossi Gilad, Rotem Hamo, Georgios Vlachos, and Nickolai Zeldovich
for starting to test these ideas, and for many helpful comments and discussions.
Silvio Micali would like to personally thank Ron Rivest for innumerable discussions and guidance
in cryptographic research over more than 3 decades, for coauthoring the cited micropayment system
that has inspired one of the verifier selection mechanisms of Algorand.
We hope to bring this technology to the next level. Meanwhile the travel and companionship
are great fun, for which we are very grateful.

References

[1] Bitcoin Computation Waste, http://gizmodo.com/the-worlds-most-powerful-computer-network-is-being-was-50
2013.
[2] Bitcoinwiki. Proof of Stake. http://www.blockchaintechnologies.com/blockchain-applications
As of 5 June 2016.
[3] Coindesk.com.
Bitcoin:
A
Peer-to-Peer
Electronic
Cash
System
http://www.coindesk.com/ibm-reveals-proof-concept-blockchain-powered-internet-things/
As of June 2016.
[4] Ethereum. Ethereum. https://github.com/ethereum/. As of 12 June 2016.
[5] HowStuffWorks.com.
How
much
actual
money
is
there
in
the
world?,
https://money.howstuffworks.com/how-much-money-is-in-the-world.htm. As of 5
June 2016.
[6] en.wikipedia.org/wiki/Sortition.
[7] M. Ben-Or. Another advantage of free choice: Completely asynchronous agreement protocols.
Proc. 2nd Annual Symposium on Principles of Distributed Computing, ACM, New York, 1983,
pp. 27-30.
[8] M. Castro and B. Liskov. Practical Byzantine Fault Tolerance, Proceedings of the Third
Symposium on Operating Systems Design and Implementation. New Orleans, Louisiana, USA,
1999, pp. 173–186.

[9] D. L. Chaum, Random Sample Elections, https://www.scribd.com/mobile/document/236881043/Random-Sa
[10] B. Chor and C. Dwork. Randomization in Byzantine agreement, in Randomness and
Computation. S. Micali, ed., JAI Press, Greenwich, CT, 1989, pp. 433-498.
[11] C. Decker and R. Wattenhofer. Information Propagation in the Bitcoin Network. 13-th IEEE
Conference on Peer-to-Peer Computing, 2013.
[12] D. Dolev. The Byzantine Generals Strike Again. J. Algorithms, 3, (1982), pp. 14-30.
[13] D. Dolev and H.R. Strong. Authenticated algorithms for Byzantine agreement. SIAM Journal
on Computing 12 (4), 656-666.
73

[14] C. Dwork and M. Naor. Pricing via Processing, Or, Combatting Junk Mail. Advances in
Cryptology, CRYPTO’92: Lecture Notes in Computer Science No. 740. Springer: 139–147.
[15] P. Feldman and S. Micali. An Optimal Probabilistic Algorithm for Synchronous Byzantine
Agreement. (Preliminary version in STOC 88.) SIAM J. on Computing, 1997.
[16] M. Fischer. The consensus problem in unreliable distributed systems (a brief survey). Proc.
International Conference on Foundations of Computation, 1983.
[17] S. Goldwasser, S. Micali, and R. Rivest. A Digital Signature Scheme Secure Against Adaptive
Chosen-Message Attack. SIAM Journal of Computing, 17, No. 2, April 1988, pp. 281-308
[18] S. Gorbunov and S. Micali. Democoin: A Publicly Verifiable and Jointly Serviced
Cryptocurrency. https://eprint.iacr.org/2015/521, May 30, 2015.
[19] J. Katz and C-Y Koo. On Expected Constant-Round Protocols for Byzantine Agreement.
https://www.cs.umd.edu/~jkatz/papers/BA.pdf.
[20] A. Kiayias, A. Russel, B. David, and R. Oliynycov.. Ouroburos:
A provably
secure proof-of-stake protocol. Cryptology ePrint Archive, Report 2016/889, 2016.
http://eprint.iacr.org/2016/889.
[21] S. King and S. Nadal. PPCoin: Peer-to-Peer Crypto-Currency with Proof-of-Stake, 2012.
[22] D. Lazar and Y. Gilad. Personal Communication.
[23] N. Lynch. Distributed Algorithms. Morgan Kaufmann Publishers, 1996.
[24] S. Micali. Algorand: The Efficient Public Ledger. https://arxiv.org/abs/1607.01341.
[25] S. Micali. Fast And Furious Byzantine Agreement. Innovation in Theoretical Computer Science
2017. Berkeley, CA, January 2017. Single-page abstract.

[26] S. Micali. Byzantine Agreement, Made Trivial. https://people.csail.mit.edu/silvio/SelectedScientifi
[27] S. Micali, M. Rabin and S. Vadhan. Verifiable Random Functions. 40th Foundations of
Computer Science (FOCS), New York, Oct 1999.
[28] S. Micali and R. L. Rivest. Micropayments Revisited. Lecture Notes in Computer Science, Vol.
2271, pp 149-163, Springer Verlag, 2002.
[29] S.
Nakamoto.
Bitcoin:
A
Peer-to-Peer
http://www.bitcoin.org/bitcoin.pdf, May 2009.

Electronic

Cash

System.

[30] R. Pass and E. Shi. The Sleepy Model of Consensus. Cryptology ePrint Archive, Feb 2017,
Report 2017/918.
[31] M. Pease, R. Shostak, and L. Lamport. Reaching agreement in the presence of faults. J. Assoc.
Comput. Mach., 27 (1980), pp. 228-234.
[32] M. Rabin. Randomized Byzantine generals. 24th Foundations of Computer Science (FOCS),
IEEE Computer Society Press, Los Alamitos, CA, 1983, pp. 403-409.
74

[33] R. Turpin and B. Coan. Extending binary Byzantine agreement to multivalued Byzantine
agreement. Inform. Process. Lett., 18 (1984), pp. 73-76.

75

