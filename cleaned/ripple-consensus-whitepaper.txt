ripple labs inc, the ripple protocol consensus algorithm david schwartz david@ripple.com noah youngs nyoungs@nyu.edu arthur britto arthur@ripple.com abstract while several consensus algorithms exist for the byzantine generals problem, specifically pertains distributed payment systems, many suffer from high latency induced the requirement that all nodes within the network communicate synchronously. this work, present novel consensus algorithm that circumvents this requirement utilizing collectively-trusted subnetworks within the larger network. show that the "trust" required these subnetworks fact minimal and can further reduced with principled choice the member nodes. addition, show that minimal connectivity required maintain agreement throughout the whole network. the result low-latency consensus algorithm which still maintains robustness the face byzantine failures. present this algorithm its embodiment the ripple protocol. introduction contents introduction definitions, formalization and previous work interest and research distributed consensus systems has increased markedly recent years, with central focus being distributed payment networks. such networks allow for fast, low-cost transactions which are not controlled centralized source. while the economic benefits and drawbacks such system are worthy much research and themselves, this work focuses some the technical challenges that all distributed payment systems must face. while these problems are varied, group them into three main categories: correctness, agreement, and utility. correctness, mean that necessary for distributed system able discern the difference between correct and fraudulent transaction. traditional fiduciary settings, this done through trust between institutions and cryptographic signatures that guarantee transaction indeed coming from the institution that claims coming from. distributed systems, however, there such trust, the identity any and all members the network may not even known. therefore, alternative methods for correctness must ripple protocol components formalization existing consensus algorithms formal consensus goals ripple consensus algorithm definition correctness agreement utility convergence heuristics and procedures simulation code discussion acknowledgments references utilized. agreement refers the problem maintaining single global truth the face decentralized accounting system. while similar the correctness problem, the difference lies the fact that while malicious user the network may unable create fraudulent transaction (defying correctness), may able create multiple correct transactions that are somehow unaware each other, and thus combine create fraudulent act. for example, malicious user may make two simultaneous purchases, with only enough funds their account cover each purchase individually, but not both together. thus each transaction itself correct, but executed simultaneously such way that the distributed network whole unaware both, clear problem arises, commonly referred the "double-spend problem" []. thus the agreement problem can summarized the requirement that only one set globally recognized transactions exist the network. utility slightly more abstract problem, which define generally the "usefulness" distributed payment system, but which practice most often simplifies the latency the system. distributed system that both correct and agreement but which requires one year process transaction, for example, obviously inviable payment system. additional aspects utility may include the level computing power required participate the correctness and agreement processes the technical proficiency required end user avoid being defrauded the network. many these issues have been explored long before the advent modern distributed computer systems, via problem known the "byzantine generals problem" []. this problem, group generals each control portion army and must coordinate attack sending messengers each other. because the generals are unfamiliar and hostile territory, messengers may fail reach their destination (just nodes distributed network may fail, send corrupted data instead the intended message). additional aspect the problem that some the generals may traitors, either individually, conspiring together, and messages may arrive which are intended create false plan that doomed failure for the loyal generals (just malicious members distributed system may attempt convince the system accept fraudulent transactions, multiple versions the same truthful transaction that would result double-spend). thus distributed payment system must robust both the face standard failures, and so-called "byzantine" failures, which may coordinated and originate from multiple sources the network. this work, analyze one particular implementation distributed payment system: the ripple protocol. focus the algorithms utilized achieve the above goals correctness, agreement, and utility, and show that all are met (within necessary and predetermined tolerance thresholds, which are well-understood). addition, provide code that simulates the consensus process with parameterizable network size, number malicious users, and message-sending latencies. definitions, formalization and previous work begin defining the components the ripple protocol. order prove correctness, agreement, and utility properties, first formalize those properties into axioms. these properties, when grouped together, form the notion consensus: the state which nodes the network reach correct agreement. then highlight some previous results relating consensus algorithms, and finally state the goals consensus for the ripple protocol within our formalization framework. ripple protocol components begin our description the ripple network defining the following terms: server: server any entity running the ripple server software (as opposed the ripple client software which only lets user send and receive funds), which participates the consensus process. ledger: the ledger record the amount currency each user's account and represents the "ground truth" the network. the ledger repeatedly updated with transactions that successfully pass through the consensus process. last-closed ledger: the last-closed ledger the most recent ledger that has been ratified the consensus process and thus represents the current state the network. open ledger: the open ledger the current operating status node (each node maintains its own open ledger). transactions initiated end users given server are applied the open ledger that server, but transactions are not considered final until they have passed through the consensus process, which point the open ledger becomes the last-closed ledger. previous work has included extensions cases where all participants the network are not known ahead time, where the messages are sent asynchronously (there bound the amount time individual node will take reach decision), and where there delineation between the notion strong and weak consensus. one pertinent result previous work consensus algorithms that fischer, lynch, and patterson, [], which proves that the asynchronous case, non-termination always possibility for consensus algorithm, even with just one faulty process. this introduces the necessity for time-based heuristics, ensure convergence (or least repeated iterations non-convergence). shall describe these heuristics for the ripple protocol section the strength consensus algorithm usually measured terms the fraction faulty processes can tolerate. provable that solution the byzantine generals problem (which already assumes synchronicity, and known participants) can tolerate more than byzantine faults, the network acting maliciously []. this solution does not, however, require verifiable authenticity the messages delivered between nodes (digital signatures). guarantee the unforgeability messages possible, algorithms exist with much higher fault tolerance the synchronous case. several algorithms with greater complexity have been proposed for byzantine consensus the asynchronous case. fab paxos will tolerate byzantine failures network nodes, amounting tolerance nodes the network colluding maliciously. attiya, doyev, and gill introduce phase algorithm for the asynchronous case, which can tolerate failures, the network. lastly, alchieri al., present bft-cup, which achieves byzantine consensus the asynchronous case even with unknown participants, with the maximal bound tolerance failures, but with additional restrictions the connectivity the underlying network. unique node list (unl): each server, maintains unique node list, which set other servers that queries when determining consensus. only the votes the other members the unl are considered when determining consensus (as opposed every node the network). thus the unl represents subset the network which when taken collectively, "trusted" not collude attempt defraud the network. note that this definition "trust" does not require that each individual member the unl trusted (see section .). proposer: any server can broadcast transactions included the consensus process, and every server attempts include every valid transaction when new consensus round starts. during the consensus process, however, only proposals from servers the unl server are considered formalization use the term nonfaulty refer nodes the network that behave honestly and without error. conversely, faulty node one which experiences errors which may honest (due data corruption, implementation errors, etc.), malicious (byzantine errors). reduce the notion validating transaction simple binary decision problem: each node must decide from the information has been given the value attiya, dolev, and gill, [], define consensus according the following three axioms: (c): every nonfaulty node makes decision finite time (c): all nonfaulty nodes reach the same decision value (c): and are both possible values for all nonfaulty nodes. (this removes the trivial solution which all nodes decide regardless the information they have been presented). formal consensus goals our goal this work show that the consensus algorithm utilized the ripple protocol will achieve consensus each ledger-close (even consensus the trivial consensus all transactions being rejected), and that the trivial consensus will only reached with known probability, even the face byzantine failures. existing consensus algorithms there has been much research done algorithms that achieve consensus the face byzantine errors. this since each node the network only votes proposals from trusted set nodes (the other nodes its unl), and since each node may have differing unls, also show that only one consensus will reached amongst all nodes, regardless unl membership. this goal also referred preventing "fork" the network: situation which two disjoint sets nodes each reach consensus independently, and two different last-closed ledgers are observed nodes each node-set. lastly will show that the ripple protocol can achieve these goals the face failures, which not the strongest result the literature, but will also show that the ripple protocol possesses several other desirable features that greatly enhance its utility. transaction. all transactions that meet this requirement are applied the ledger, and that ledger closed, becoming the new last-closed ledger. correctness order achieve correctness, given maximal amount byzantine failures, must shown that impossible for fraudulent transaction confirmed during consensus, unless the number faulty nodes exceeds that tolerance. the proof the correctness the rpca then follows directly: since transaction only approved the unl server agrees with it, long the unl honest, fraudulent transactions will approved. thus for unl nodes the network, the consensus protocol will maintain correctness long as: ripple consensus algorithm the ripple protocol consensus algorithm (rpca), applied every few seconds all nodes, order maintain the correctness and agreement the network. once consensus reached, the current ledger considered "closed" and becomes the last-closed ledger. assuming that the consensus algorithm successful, and that there fork the network, the last-closed ledger maintained all nodes the network will identical. max(|unli |unl |)i, this upper bound assumes clique-like structure unls, i.e. nodes form sets whose unls contain other nodes those sets. this upper bound guarantees that two cliques can reach consensus conflicting transactions, since becomes impossible reach the threshold required for consensus. tighter bound possible when indirect edges between unls are taken into account well. for example, the structure the network not clique-like, fork becomes much more difficult achieve, due the greater entanglement the unls all nodes. interesting note that assumptions are made about the nature the intersecting nodes. the intersection two unls may include faulty nodes, but long the size the intersection larger than the bound required guarantee agreement, and the total number faulty nodes less than the bound required satisfy strong correctness, then both correctness and agreement will achieved. that say, agreement dependent solely the size the intersection nodes, not the size the intersection nonfaulty nodes. agreement satisfy the agreement requirement, must shown that all nonfaulty nodes reach consensus the same set transactions, regardless their unls. since the unls for each server can different, agreement not inherently guaranteed the correctness proof. for example, there are restrictions the membership the unl, and the size the unl not larger than ntotal where ntotal the number nodes the entire network, then fork possible. this illustrated simple example (depicted figure imagine two cliques within the unl graph, each larger than ntotal cliques, mean set nodes where each node's unl the selfsame set nodes. because these two cliques not share any members, possible for each achieve correct consensus independently each other, violating agreement. the connectivity the two cliques surpasses ntotal then fork longer possible, disagreement between the cliques would prevent consensus from being reached the agreement threshold that required. utility while many components utility are subjective, one that indeed provable convergence: that the consensus process will terminate finite time. upper bound the connectivity required figure probability nefarious cartel being able thwart consensus function the size the unl, for different values the probability that any member the unl will decide collude with others. here, lower values indicate higher probability consensus success. since the consensus algorithm itself deterministic, and has preset number rounds, before consensus terminated, and the current set transactions are declared approved not-approved (even this point transactions have more than the required agreement, and the consensus only the trivial consensus), the limiting factor for the termination the algorithm the communication latency between nodes. order bound this quantity, the response-time nodes monitored, and nodes who's latency grows larger than preset bound are removed from all unls. while this guarantees that consensus will terminate with upper bound tb, important note that the bounds described for correctness and agreement above must met the final unl, after all nodes that will convergence define convergence the point which the rpca reaches consensus with strong correctness the ledger, and that ledger then becomes the last-closed ledger. note that while technically weak correctness still represents convergence the algorithm, only convergence the trivial case, proposition violated, and transactions will ever confirmed. from the results above, know that strong correctness always achievable the face byzantine failures, and that only one consensus will achieved the entire network long the unl-connectedness condition met (equation all that remains show that when both these conditions are met, consensus reached finite time. dropped have been dropped. the conditions hold for the initial unls for all nodes, but then some nodes are dropped from the network due latency, the correctness and agreement guarantees not automatically hold but must satisfied the new set unls. validation", which they not process vote transactions, but declare that are still participating the consensus process, opposed different consensus process disconnected subnetwork. heuristics and procedures while would possible apply the rpca just one round consensus, utility can gained through multiple rounds, each with increasing minimum-required percentage agreement, before the final round with requirement. these rounds allow for detection latent nodes the case that few such nodes are creating bottleneck the transaction rate the network. these nodes will able initially keep during the lower-requirement rounds but fall behind and identified the threshold increases. the case one round consensus, may the case that few transactions pass the threshold, that even slow nodes can keep up, lowering the transaction rate the entire network. mentioned above, latency bound heuristic enforced all nodes the ripple network guarantee that the consensus algorithm will converge. addition, there are few other heuristics and procedures that provide utility the rpca. there mandatory second window for all nodes propose their initial candidate sets each round consensus. while this does introduce lower bound seconds each consensus round, also guarantees that all nodes with reasonable latency will have the ability participate the consensus process. the votes are recorded the ledger for each round consensus, nodes can flagged and removed from the network for some common, easily-identifiable malicious behaviors. these include nodes that vote "no" every transaction, and nodes that consistently propose transactions which are not validated consensus. simulation code the provided simulation code demonstrates round rpca, with parameterizable features (the number nodes the network, the number malicious nodes, latency messages, etc.). the simulator begins perfect disagreement (half the nodes the network initially propose "yes", while the other half propose "no"), then proceeds with the consensus process, showing each stage the number yes/no votes the network nodes adjust their proposals based upon the proposals their unl members. once the threshold reached, consensus achieved. encourage the reader experiment with different values the constants defined the beginning "sim.cpp", order become familiar with the consensus process under different conditions. curated default unl provided all users, which chosen minimize described section while users can and should select their own unls, this default list nodes guarantees that even naive users will participate consensus process that achieves correctness and agreement with extremely high probability. network split detection algorithm also employed avoid fork the network. while the consensus algorithm certifies that the transactions the last-closed ledger are correct, does not prohibit the possibility more than one lastclosed ledger existing different subsections the network with poor connectivity. try and identify such split has occurred, each node monitors the size the active members its unl. this size suddenly drops below preset threshold, possible that split has occurred. order prevent false positive the case where large section unl has temporary latency, nodes are allowed publish "partial discussion have described the rpca, which satisfies the conditions correctness, agreement, and utility which have outlined above. the result that the ripple protocol able process secure and reliable transactions matter seconds: the length time required for one round consensus complete. these transactions are provably secure the bounds outlined section which, while not the strongest available the literature for asynchronous byzantine consensus, allow for rapid convergence and flexibility network membership. when taken together, these qualities allow the ripple network function fast and low-cost global payment network with well-understood security and reliability properties. while have shown that the ripple protocol provably secure long the bounds described equations and are met, worth noting that these are maximal bounds, and practice the network may secure under significantly less stringent conditions. also important recognize, however, that satisfying these bounds not inherent the rpca itself, but rather requires management the unls all users. the default unl provided all users already sufficient, but should user make changes the unl, must done with knowledge the above bounds. addition, some monitoring the global network structure required order ensure that the bound equation met, and that agreement will always satisfied. believe the rpca represents significant step forward for distributed payment systems, the lowlatency allows for many types financial transactions previously made difficult even impossible with other, higher latency consensus methods. acknowledgments ripple labs would like acknowledge all the people involved the development the ripple protocol consensus algorithm. specifically, arthur britto, for his work transaction sets, jed mccaleb, for the original ripple protocol consensus concept, and david schwartz, for his work the "failure agree agreement defer" aspect consensus. ripple labs would also like acknowledge noah youngs for his efforts preparing and reviewing this paper. references nakamoto, satoshi. "bitcoin: peer-to-peer electronic cash system." consulted (): lamport, leslie, robert shostak, and marshall pease. "the byzantine generals problem." acm transactions programming languages and systems (toplas) (): attiya, c., dolev, and gill. "asynchronous byzantine agreement." proc. rd. annual acm symposium principles distributed computing. fischer, michael j., nancy lynch, and michael paterson. "impossibility distributed consensus with one faulty process." journal the acm (jacm) (): martin, j-p., and lorenzo alvisi. "fast byzantine consensus." dependable and secure computing, ieee transactions (): alchieri, eduardo ap, al. "byzantine consensus with unknown participants." principles distributed systems. springer berlin heidelberg,