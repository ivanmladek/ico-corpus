zerocoin: anonymous distributed e-cash from bitcoin ian miers, christina garman, matthew green, aviel rubin the johns hopkins university department computer science, baltimore, usa {imiers, cgarman, mgreen, rubin}@cs.jhu.edu abstract--bitcoin the first e-cash system see widespread adoption. while bitcoin offers the potential for new types financial interaction, has significant limitations regarding privacy. specifically, because the bitcoin transaction log completely public, users' privacy protected only through the use pseudonyms. this paper propose zerocoin, cryptographic extension bitcoin that augments the protocol allow for fully anonymous currency transactions. our system uses standard cryptographic assumptions and does not introduce new trusted parties otherwise change the security model bitcoin. detail zerocoin's cryptographic construction, its integration into bitcoin, and examine its performance both terms computation and impact the bitcoin protocol. ntroduction digital currencies have long academic pedigree. yet, however, system from the academic literature has seen widespread use. bitcoin, the other hand, viable digital currency with market capitalization valued more than million and between and million usd transactions day []. unlike many proposed digital currencies, bitcoin fully decentralized and requires central bank authority. instead, its security depends distributed architecture and two assumptions: that majority its nodes are honest and that substantive proof-ofwork can deter sybil attacks. consequence, bitcoin requires neither legal mechanisms detect and punish double spending nor trusted parties chosen, monitored, policed. this decentralized design likely responsible for bitcoin's success, but comes price: all transactions are public and conducted between cryptographically binding pseudonyms. while relatively few academic works have considered the privacy implications bitcoin's design the preliminary results are not encouraging. one example, researchers were able trace the spending bitcoins that were allegedly stolen although tracking stolen coins may seem harmless, note that similar techniques could also applied trace sensitive transactions, thus violating users' privacy. moreover, there reason believe that sophisticated results from other domains (e.g., efforts deanonymize social network data using network topology []) will soon applied the bitcoin transaction graph. since all bitcoin transactions are public, anonymous transactions are necessary avoid tracking third parties even not wish provide the absolute anonymity typically associated with e-cash schemes. top such transactions, one could build mechanisms partially explicitly identify participants authorized parties (e.g., law enforcement). however, limit this information authorized parties, must first anonymize the underlying public transactions. the bitcoin community generally acknowledges the privacy weaknesses the currency. unfortunately, the available mitigations are quite limited. the most common recommendation employ laundry service which exchanges different users' bitcoins. several these are commercial operation today these services, however, have severe limitations: operators can steal funds, track coins, simply out business, taking users' funds with them. perhaps recognition these risks, many services offer short laundering periods, which lead minimal transaction volumes and hence limited anonymity. our contribution. this paper describe zerocoin, distributed e-cash system that uses cryptographic techniques break the link between individual bitcoin transactions without adding trusted parties. this, first define the abstract functionality and security requirements new primitive that call decentralized e-cash scheme. next propose concrete instantiation and prove secure under standard cryptographic assumptions. finally, describe the specific extensions required integrate our protocol into the bitcoin system and evaluate the performance prototype implementation derived from the original opensource bitcoind client. are not the first propose e-cash techniques for solving bitcoin's privacy problems. however, common problem with many e-cash protocols that they rely fundamentally trusted currency issuer "bank," who creates electronic "coins" using blind signature scheme. one solution (attempted unsuccessfully with bitcoin []) simply appoint such party. alternatively, one can distribute the responsibility among quorum nodes using threshold cryptography. unfortunately, both these solutions introduce points failure and seem inconsistent with the bitcoin network model, which consists many untrusted nodes that routinely enter and exit the network. moreover, the problem choosing long-term trusted parties, especially the legal and regulatory grey area bitcoin operates in, seems like major impediment adoption. zerocoin eliminates block block ... block block (a) block block ... block block (b) bitcoin zerocoin mint zerocoin spend figure two example block chains. chain (a) illustrates normal bitcoin transaction history, with each transaction linked preceding transaction. chain (b) illustrates zerocoin chain. the linkage between mint and spend (dotted line) cannot determined from the block chain data. the need for such coin issuers allowing individual bitcoin clients generate their own coins provided that they have sufficient classical bitcoins so. intuition behind our construction. understand the intuition behind zerocoin, consider the following "pencil and paper" protocol example. imagine that all users share access physical bulletin board. mint zerocoin fixed denomination user alice first generates random coin serial number then commits using secure digital commitment scheme. the resulting commitment coin, denoted which can only opened random number reveal the serial number alice pins the public bulletin board, along with physical currency. all users will accept provided correctly structured and carries the correct sum currency. redeem her coin alice first scans the bulletin board obtain the set valid commitments that have thus far been posted all users the system. she next produces non-interactive zero-knowledge proof for the following two statements: she knows and she knows hidden value such that the commitment opens full view the others, alice, using disguise hide her identity, posts "spend" transaction containing (s, p). the remaining users verify the proof and check that has not previously appeared any other spend transaction. these conditions are met, the users allow course, the real protocol alice will emulate this using anonymity network such tor []. alice collect from any location the bulletin board; otherwise they reject her transaction and prevent her from collecting the currency. this simple protocol achieves some important aims. first, alice's minted coin cannot linked her retrieved funds: order link the coin the the serial number used her withdrawal, one must either know directly know which coin alice proved knowledge of, neither which are revealed the proof. thus, even the original dollar bill recognizably tainted (e.g., was used controversial transaction), cannot linked alice's new dollar bill. the same time, the commitment and zero-knowledge proof are secure, then alice cannot double-spend any coin without re-using the serial number and thus being detected the network participants. course, the above protocol not workable: bulletin boards are poor place store money and critical information. currency might stolen serial numbers removed allow double spends. more importantly, conduct this protocol over network, alice requires distributed digital backing currency. the first and most basic contribution our work recognize that bitcoin answers all these concerns, providing with backing currency, bulletin board, and conditional currency redemption mechanism. indeed, the core the bitcoin protocol the decentralized calculation one could easily imagine solution based existing payment networks, e.g., visa paypal. however, this would introduce the need for trusted parties exchanges. block chain which acts trusted, append-only bulletin board that can both store information and process financial transactions. alice can add her commitments and escrow funds placing them the block chain while being assured that strict protocol conditions (and not her colleagues' scruples) determine when her committed funds may accessed. course, even when integrated with the bitcoin block chain, the protocol above has another practical challenge. specifically, difficult efficiently prove that commitment the set the naive solution prove the disjunction unfortunately such "or proofs" have size o(n which renders them impractical for all but small values our second contribution solve this problem, producing new construction with proofs that not grow linearly increases. rather than specifying expensive proof, employ "public" one-way accumulator reduce the size this proof. one-way accumulators first proposed benaloh and mare [], allow parties combine many elements into constant-sized data structure, while efficiently proving that one specific value contained within the set. our construction, the bitcoin network computes accumulator over the commitments along with the appropriate membership witnesses for each item the set. the spender need only prove knowledge one such witness. practice, this can reduce the cost the spender's proof o(log even constant size. our application requires specific properties from the accumulator. with trusted parties, the accumulator and its associated witnesses must publicly computable and verifiable (though are willing relax this requirement include single, trusted setup phase which parameters are generated). moreover, the accumulator must bind even the computing party the values the set. lastly, the accumulator must support efficient non-interactive witnessindistinguishable zero-knowledge proof set membership. fortunately such accumulators exist. our concrete proposal section use construction based the strong rsa accumulator camenisch and lysyanskaya [], which turn based accumulator baric and pfitzmann and benaloh and mare []. outline this work. the rest this paper proceeds follows. section provide brief technical overview the bitcoin protocol. section iii formally define the notion decentralized e-cash and provide correctness and security requirements for such system. section give concrete realization our scheme based standard cryptographic hardness assumptions including the discrete logarithm problem and strong rsa. finally, sections vi, and vii, describe how integrate our e-cash construction into the bitcoin protocol, discuss the security and anonymity provided, and detail experimental results showing that our solution practical. ii. overview itcoin this section provide short overview the bitcoin protocol. for more detailed explanation, refer the reader the original specification nakamoto the summary barber al. []. the bitcoin network. bitcoin peer-to-peer network nodes that distribute and record transactions, and clients used interact with the network. the heart bitcoin the block chain, which serves append-only bulletin board maintained distributed fashion the bitcoin peers. the block chain consists series blocks connected hash chain. every bitcoin block memorializes set transactions that are collected from the bitcoin broadcast network. bitcoin peers compete determine which node will generate the next canonical block. this competition requires each node solve proof work based identifying specific sha- preimages, specifically block such that sha(sha(b)) ||{, }-` the value selected periodic network vote ensure that average block created every minutes. when peer generates valid solution, process known mining, broadcasts the new block all nodes the system. the block valid (i.e., all transactions validate and valid proof work links the block the chain thus far), then the new block accepted the head the block chain. the process then repeats. bitcoin provides two separate incentives peers that mine new blocks. first, successfully mining new block (which requires non-trivial computational investment) entitles the creator reward, currently set btc. second, nodes who mine blocks are entitled collect transaction fees from every transaction they include. the fee paid given transaction determined its author (though miners may exclude transactions with insufficient fees prioritize high fee transactions). bitcoin transactions. bitcoin transaction consists set outputs and inputs. each output described the tuple (a, where the amount, denominated satoshi (one bitcoin satoshi), and specification who authorized spend that output. this specification, denoted scriptpubkey, given bitcoin script, stack-based nonturing-complete language similar forth. transaction inputs for efficiency reasons, this chain actually constructed using hash tree, but use the simpler description for this overview. each block includes counter value that may incremented until the hash satisfies these requirements. the bitcoin specification holds that this reward should reduced every few years, eventually being eliminated altogether. input: previous tx: bdfaaaab... index: scriptsig: dcdcdfeacdceeaf... output: value: scriptpubkey: op_dup op_hash afffdebfdddcafbc op_equalverify op_checksig figure example bitcoin transaction. the output script specifies that the redeeming party provide public key that hashes the given value and that the transaction signed with the corresponding private key. are simply reference previous transaction output, well second script, scriptsig, with code and data that when combined with scriptpubkey evaluates true. coinbase transactions, which start off every block and pay its creator, not include transaction input. send bitcoins bob, alice embeds the hash bob's ecdsa public key the amount and some script instructions scriptpubkey one output transaction whose referenced inputs total least bitcoins (see figure since any excess input paid transaction fee the node who includes block, alice typically adds second output paying the surplus change back herself. once the transaction broadcasted the network and included block, the bitcoins belong bob. however, bob should only consider the coins his once least five subsequent blocks reference this block. bob can spend these coins transaction referencing input and including scriptsig signature the claiming transaction under and the public key anonymity. anonymity was not one the design goals bitcoin bitcoin provides only pseudonymity through the use bitcoin identities (public keys their hashes), which bitcoin user can generate unlimited number. indeed, many bitcoin clients routinely generate new identities effort preserve the user's privacy. regardless bitcoin design goals, bitcoin's user base seems willing through considerable effort maintain their anonymity including risking their money and paying transaction fees. one illustration this the existence laundries that (for fee) will mix together different users' funds the hopes that shuffling makes them difficult trace because such systems require the users trust the laundry both (a) not record how the mixing done this reference consists transaction hash identifier well index into the transaction's output list. character hash that contains the double sha- hash the key and some checksum data. individual recipients are free disregard this advice. however, this could make them vulnerable double-spending attacks described karame al. []. and (b) give the users back the money they put the pot, use these systems involves fair amount risk. iii. ecentralized e-c ash our approach anonymizing the bitcoin network uses form cryptographic e-cash. since our construction does not require central coin issuer, refer decentralized e-cash scheme. this section define the algorithms that make decentralized e-cash scheme and describe the correctness and security properties required such system. notation. let represent adjustable security parameter, let poly(*) represent some polynomial function, and let n(*) represent negligible function. use indicate the set allowable coin values. definition (decentralized e-cash scheme): decentralized e-cash scheme consists tuple possibly randomized algorithms (setup, mint, spend, verify). setup( params. input security parameter, output set global public parameters params and description the set mint(params) (c, skc). input parameters params, output coin well trapdoor skc. spend(params, skc, (p, s). given params, coin its trapdoor skc, some transaction string and arbitrary set coins output coin spend transaction consisting proof and serial number otherwise output verify(params, given params, proof serial number transaction information and set coins output and (p, valid. otherwise output note that the setup routine may executed trusted party. since this setup occurs only once and does not produce any corresponding secret values, believe that this relaxation acceptable for real-world applications. some concrete instantiations may use different assumptions. each coin generated using randomized minting algorithm. the serial number unique value released during the spending coin and designed prevent any user from spending the same coin twice. will now formalize the correctness and security properties decentralized e-cash scheme. each call the spend algorithm can include arbitrary string which intended store transaction-specific information (e.g., the identity transaction recipient). correctness. every decentralized e-cash scheme must satisfy the following correctness requirement. let params setup(l and (c, skc) mint(params). let any valid set coins, where |c| select random generators such that hgi hhi and subgroup z*q output params (n, h). mint(params) (c, skc). select and compute mod such that prime ]}. set skc (s, and output (c, skc). spend(params, skc, (p, s). output compute accumulate((n, u), and genwitness((n, u), c). output (p, where comprises the following signature knowledge: zksok[r]{(c, accverify((n, u), verify(params, given proof serial number and set coins first compute see appendix for more precise description. see appendix for the construction the zksok. accumulate((n, u), c). next verify that the aforementioned signature knowledge using the known public values. the proof verifies successfully, output otherwise output our protocol assumes trusted setup process for generating the parameters. stress that the accumulator trapdoor (p, not used subsequent the setup procedure and can therefore destroyed immediately after the parameters are generated. alternatively, implementers can use the technique sander for generating so-called rsa ufos for accumulator parameters without trapdoor []. security analysis now consider the security our construction. theorem the zero-knowledge signature knowledge computationally zero-knowledge the random oracle model, then (setup, mint, spend, verify) satisfies the anonymity property. provide proof sketch for theorem appendix intuitively, the security our construction stems from the fact that the coin commitment perfectly-hiding commitment and the signature proof least computationally zeroknowledge. these two facts ensure that the adversary has most negligible advantage guessing which coin was spent. theorem the signature proof sound the random oracle model, the strong rsa problem hard, and the discrete logarithm problem hard then (setup, mint, spend, verify) satisfies the balance property. proof theorem included appendix briefly, this proof relies the binding properties the coin commitment, well the soundness and unforgeability the zksok and collision-resistance the accumulator. show that adversary who wins the balance game with non-negligible advantage can used either find collision the commitment scheme (allowing solve the discrete logarithm problem) find collision the accumulator (which leads solution for strong rsa). ntegrating with itcoin while the construction the previous section gives overview our approach, have yet describe how our techniques integrate with bitcoin. this section address the specific challenges that come when combine decentralized e-cash scheme with the bitcoin protocol. the general overview our approach straightforward. mint zerocoin denomination alice runs mint(params) (c, skc) and stores skc securely. she then embeds the output bitcoin transaction that spends fees classical bitcoins. once mint transaction has been accepted into the block chain, included the our implementation all bitcoins have single fixed value. however, can support multiple values running distinct zerocoin instantiations simultaneously, all sharing the same set public parameters. global accumulator and the currency cannot accessed except through zerocoin spend, i.e., essentially placed into escrow. spend with bob, alice first constructs partial transaction ptx that references unclaimed mint transaction input and includes bob's public key output. she then traverses all valid mint transactions the block chain, assembles the set minted coins and runs spend(params, skc, hash(ptx), (p, s). finally, she completes the transaction embedding (p, the scriptsig the input ptx. the output this transaction could also further zerocoin mint transaction feature that may useful transfer value between multiple zerocoin instances (i.e., different denomination) running the same block chain. when this transaction appears the network, nodes check that verify(params, hash(ptx), and check that does not appear any previous transaction. these condition hold and the referenced mint transaction not claimed input into different transaction, the network accepts the spend valid and allows alice redeem bitcoins. computing the accumulator. naive implementation the construction section requires that the verifier recompute the accumulator with each call verify(. .). practice, the cost can substantially reduced. first, recall that the accumulator our construction can computed incrementally, hence nodes can add new coins the accumulation when they arrive. exploit this, require any node mining new block add the zerocoins that block the previous block's accumulator and store the resulting new accumulator value the coinbase transaction the start the new block. call this accumulator checkpoint. peer nodes validate this computation before accepting the new block into the blockchain. provided that this verification occurs routinely when blocks are added the chain, some clients may choose trust the accumulator older (confirmed) blocks rather than re-compute from scratch. with this optimization, alice need longer compute the accumulator and the full witness for instead she can merely reference the current block's accumulator checkpoint and compute the witness starting from the checkpoint preceding her mint (instead starting since computing the witness equivalent accumulating {c}. script functionality have been disabled the bitcoin production network due security concerns. hence, the existing script language cannot used for sophisticated calculations such verifying zero-knowledge proofs. fortunately for our purposes, the bitcoin designers chose reserve several script operations for future expansion. extend bitcoin adding new instruction: zerocoin mint. minting zerocoin constructs transaction with output whose scriptpubkey contains this instruction and coin nodes who receive this transaction should validate that well-formed coin. spend zerocoin, alice constructs new transaction that claims input some zerocoin mint transaction and has scriptsig field containing (p, and reference the block containing the accumulator used verifier extracts the accumulator from the referenced block and, using it, validates the spend described earlier. finally, note that transactions must signed prevent attacker from simply changing who the transaction payed to. normal bitcoin transactions include ecdsa signature the key specified the scriptpubkey the referenced input. however, for spend transaction arbitrary zerocoin, there ecdsa public key. instead, use the zksok sign the transaction hash that normally would signed using ecdsa. statekeeping and side effects. validating zerocoin changes bitcoin's semantics: currently, bitcoin's persistent state defined solely terms transactions and blocks transactions. furthermore, access this state done via explicit reference hash. zerocoin, the other hand, because its strong anonymity requirement, deals with existentials: the coin the set thus-far-minted coins and its serial number not yet the set spent serial numbers. enable these type qualifiers, introduce side effects into bitcoin transaction handling. processing mint transaction causes coin accumulated side effect. processing spend transaction causes the coin serial number added list spent serial numbers held the client. for coin serial numbers, have little choice but keep full list them per client and incur the (small) overhead storing that list and the larger engineering overhead handling all possible ways transaction can enter client. the accumulator state maintained within the accumulator checkpoints, which the client verifies for each received block. new transaction types. bitcoin transactions use flexible scripting language determine the validity each transaction. unfortunately, bitcoin script (by design) not turingcomplete. moreover, large segments the already-limited proof optimizations. for reasonable parameter sizes, the proofs produced spend(. exceed bitcoin's transaction size limits. although can simply increase this limit, doing has two drawbacks: drastically increases the storage requirements for bitcoin since current transactions the coinbase transaction format already allows for the inclusion arbitrary data, this requires fundamental changes the bitcoin protocol. practice, this modification simply requires include the transaction digest the hash computation the challenge for the fiat-shamir proofs. see appendix for details. are between and and may increase memory pressure clients that store transactions memory. our prototype implementation store our proofs separate, well-known location simple server). full implementation could use distributed hash table non block-chain backed storage bitcoin. while recommend storing proofs the block chain, these alternatives not increase the storage required for the block chain. suggestions for optimizing proof verification the complexity the proofs will also lead longer verification times than expected with standard bitcoin transaction. this magnified the fact that bitcoin transaction verified once when included block and again every node when that block accepted into the block chain. although the former cost can accounted for charging transaction fees, would obviously ideal for these costs low possible. one approach distribute the cost verification over the entire network and not make each node verify the entire proof. because the zksok use utilizes cut-and-choose techniques, essentially consists repeated iterations the same proof (reducing the probability forgery roughly can simply have nodes randomly select which iterations the proofs they verify. distributing this process across the network, should achieve approximately the same security with less duplication effort. this optimization involves time-space tradeoff, since the existing proof verified computing series (at minimum) bit values and hashing the result. naive implementation would require send fully computed greatly increasing the size the proof since the client will only compute some them but needs all them verify the hash. can avoid this issue replacing the standard hash with merkel tree where the leaves are the hashed values and the root the challenge hash used the proof. can then send the bit bit intermediate nodes instead the bit values, allowing the verifier compute only subset the values and yet still validate the proof against the challenge without drastically increasing the proof size. limited anonymity and forward security serious concern the bitcoin community the loss wallets due poor endpoint security. traditional bitcoin, this results the theft coins []. however, the zerocoin setting may also allow attacker deanonymize zerocoin transactions using the stored skc. the the reference bitcoind client stores transactions stl vectors, which require contiguous segments memory. such, storing zerocoin proofs the transaction might cause memory issues far faster than expected. furthermore, this solution allows for the intriguing possibility that proofs allowed vanish after they have been sufficiently verified the network and entombed the block chain. however, not clear how this interacts with bitcoin theory practice. obvious solution securely delete skc immediately after coin spent. unfortunately, this provides protection skc stolen some earlier point. one solution generate the spend transaction immediately (or shortly after) the coin minted, possibly using earlier checkpoint for calculating this greatly reduces the user's anonymity decreasing the number coins and leaking some information about when the coin was minted. however, attacker who compromises the wallet can link any zerocoins their mint transactions. code changes for our implementation, chose modify bitcoind, the original open-source bitcoin c++ client. this required several modifications. first, added instructions the bitcoin script for minting and spending zerocoins. next, added transaction types and code for handling these new instructions, well maintaining the list spent serial numbers and the accumulator. used the charm cryptographic framework implement the cryptographic constructions python, and used boost's python utilities call that code from within bitcoind. this introduces some performance overhead, but allowed rapidly prototype and leave room for implementing future constructions well. incremental deployment described above, zerocoin requires changes the bitcoin protocol that must happen globally: while transactions containing the new instructions will validated updated servers, they will fail validation older nodes, potentially causing the network split when block produced that validates for some, but not all, nodes. although this not the first time bitcoin has faced this problem, and there precedent for flag day type upgrade strategy [], not clear how willing the bitcoin community repeat it. such, consider the possibility incremental deployment. one way accomplish this embed the above protocol comments standard bitcoin scripts. for non zerocoin aware nodes, this data effectively inert, and can use bitcoin's signature support specify that such comment embedded zerocoins are valid only signed some subset the zerocoin processing nodes. such zerocoin aware nodes can parse the comments and charge transaction fees for validation according the proofs embedded the comments, thus providing incentive for more nodes provide such services. since this only changes the validation mechanism for zerocoin, the anonymity property holds does the balance property more than zerocoin nodes are malicious. some care must taken when electing these nodes prevent sybil attack. thankfully, require that such node also produce blocks the bitcoin block chain, have decent deterrent. furthermore, because any malfeasance these nodes readily detectable (since they signed invalid zerocoin transaction), third parties can audit these nodes and potentially hold funds escrow deter fraud. vi. eal orld ecurity and parameter hoice anonymity zerocoin definition states that given two zerocoin mints and one spend, one cannot much better than guess which minted coin was spent. put differently, attacker learns more from our scheme than they would from observing the mints and spends some ideal scheme. however, even ideal scheme imposes limitations. for example, consider case where coins are minted, then all coins are subsequently spent. another coin minted after this point, the size the anonymity set for the next spend not since clear all observers that the previous coins have been used. also stress that many anonymity systems privacy may compromised attacker who mints large fraction the active coins. hence, lower bound the anonymity provided the number coins minted honest parties between coin's mint and its spend. upper bound the total set minted coins. also note that zerocoin reveals the number minted and spent coins all users the system, which provides potential source information attackers. this contrast many previous e-cash schemes which reveal this information primarily merchants and the bank. however, believe this may advantage rather than loss, since the bank generally considered adversarial party most e-cash security models. the public model zerocoin actually removes information asymmetry allowing users determine when such conditions might pose problem. lastly, zerocoin does not hide the denominations used transaction. practice, this problem can avoided simply fixing one small set coin denominations and exchanging coins until one has those denominations, simply using zerocoin anonymize bitcoins. parameters generally, cryptographers specify security terms single, adjustable security parameter indeed, have used this notation throughout the previous sections. reality, however, there are three distinct security choices for zerocoin which affect either the system's anonymity, its resilience counterfeiting, both. these are: the size the schnorr group used the coin commitments. the size the rsa modulus used the accumulator. lzkp the security the zero-knowledge proofs. commitments. because pedersen commitments are information theoretically hiding for any schnorr group whose order large enough fit the committed values, the size the group used does not affect the long term anonymity zerocoin. the security the commitment scheme does, however, affect counterfeiting: attacker who can break the binding property the commitment scheme can mint zerocoin that opens least two different serial numbers, resulting double spend. result, the schnorr group must large enough that such attack cannot feasibly mounted the lifetime coin. the other hand, the size the signature knowledge used coin spends increases linearly with the size the schnorr group. one solution minimize the group size announcing fresh parameters for the commitment scheme periodically and forcing old zerocoins expire unless exchanged for new zerocoins minted under the fresh parameters. since all coins being spent the network time are spent with the current parameters and all previous coins can converted fresh ones, this does not decrease the anonymity the system. does, however, require users convert old zerocoins fresh ones before the old parameters expire. for our prototype implementation, chose use bit parameters the assumption that commitment parameters could regenerated periodically. explore the possibility extensions zerocoin that might enable smaller groups section ix. accumulator rsa key. because generating new accumulator requires either new trusted setup phase generating new rsa ufo [], cannot re-key very frequently. result, the accumulator long lived, and thus truly need long term security. therefore currently propose rsa key least bits. note that this does not greatly affect the size the coins themselves, and, because the proof accumulator membership efficient, this does not have large adverse effect the overall coin spend proof size. moreover, although re-keying the accumulator expensive, need not reduce the anonymity the system since the new parameters can used re-accumulate the existing coin set and hence anonymize spends over that whole history. zero-knowledge proof security lzkp this parameter affects the anonymity and security the zero-knowledge proof. also greatly affects the size the spend proof. thankfully, since each proof independent, applies per proof and therefore per spend. such, dishonest party would have expend roughly lzkp effort forge single coin could link single coin mint spend with probability roughly lzkp such pick lzkp bits. vii. erformance validate our results, conducted several experiments using the modified bitcoind implementation described section ran our experiments with three different note that this conversion need not involve full spend the coins. the user may simply reveal the trapdoor for the old coin, since the new zerocoin will still unlinkable when properly spent. performance zerocoin algorithms zerocoin spend proof size mint spend verify proof size (bytes) time (sec) modulus size (bits) (a) times for single zerocoin operation measured seconds. these operations not include the time required compute the accumulator. accumulation time zerocoin block verification performance transactions per minute time (sec) (b) zerocoin proof sizes measured bytes function rsa modulus size. modulus size (bits) number elements accumulated (c) time required accumulate elements. note, this cost amortized when computing the global accumulator. percentage zerocoins (d) transaction verifications per minute function the percentage zerocoin transactions the network (where half are mints and half are spends). note, since plot the reciprocal transaction time, this graph appears logarithmic even though zerocoin scales linearly. figure zerocoin performance function parameter size. parameter sizes, where each corresponds length the rsa modulus bits, bits, and bits. conducted two types experiments: microbenchmarks that measure the performance our cryptographic constructions and tests our whole modified bitcoin client measuring the time verify zerocoin carrying blocks. the former gives reasonable estimate the cost minting single zerocoin, spending it, and verifying the resulting transaction. the latter gives estimate zerocoin's impact the existing bitcoin network and the computational cost that will born each node that verifies zerocoin transactions. all our experiments were conducted intel xeon (.ghz quad-core processor with hyperthreading) with ram, running -bit ubuntu server with linux kernel ... these sizes can viewed roughly corresponding discrete logarithm/factorization security level and respectively. note that the choice determines the size the parameter select |q| roughly twice the estimated security level. microbenchmarks evaluate the performance our mint, spend, and verify algorithms isolation, conducted series microbenchmarks using the charm (python) implementation. our goal these experiments was provide direct estimate the performance our cryptographic primitives. experimental setup. one challenge conducting our microbenchmarks the accumulation coins for the witness spend(. for the global accumulator both spend(. and verify(. .). this problematic for two reasons. first, not know how large will practice. second, our implementation accumulations are incremental. address these issues chose break our microbenchmarks into two separate experiments. the first experiment simply computes the accumulator for number possible sizes ranging from elements. the second experiment measures the runtime the spend(. and verify(. routines with precomputed accumulator and witness (a, o). conducted our experiments single thread the processor, using all three parameter sizes. all experiments were performed times, and the results given represent the average these times. figure shows the measured times for computing the coin operations, figure shows the resulting proof sizes for each security parameter, and figure shows the resulting times for computing the accumulator. stress that accumulation our system incremental, typically over most the transactions block (which takes worst eight seconds), and hence the cost computing the global accumulator therefore amortized. the only time one might accumulate coins one time would when generating the witness for very old zerocoin. block verification how zerocoin affects network transaction processing determines its practicality and scalability. like all transactions, zerocoin spends must verified first the miner make sure not including invalid transactions block and then again the network make sure not including invalid block the block chain. both cases, this entails checking that verify(. for each zerocoin transaction and computing the accumulator checkpoint. need know the impact this for two reasons. first, the bitcoin protocol specifies that new block should created average once every minutes. verification takes longer than minutes for blocks with reasonable number zerocoins, then the network cannot function. second, while the cost generating these blocks and verifying their transactions can offset transaction fees and coin mining, the cost verifying blocks prior appending them the block chain only offset for mining nodes (who can view part the cost mining new block). this leaves anyone else verifying the block chain with uncompensated computational cost. experimental setup. measure the effect zerocoin block verification time, measure how long takes our modified bitcoind client verify externally loaded test blocks containing and transactions where percent the transactions are zerocoin transactions (half which are mints and half are spends). repeat this experiment for all three security parameters. our test data consists two blocks. the first contains zerocoin mints that must exist for any spends occur. the second block our actual test vector. contains, random order, zerocoin spends the coins the previous block, zerocoin mints, and standard bitcoin sendtoaddress transactions. measure how long the processblock call the bitcoind client takes verify the second block containing the mix zerocoin and classical bitcoin this rate maintained periodic network vote that adjusts the difficulty the bitcoin proof work. for blocks with unreasonable numbers zerocoin transaction can simply extend bitcoind's existing anti-dos mechanisms reject the block and blacklist its origin. transactions. for accuracy, repeat these measurements times and average the results. the results are presented figure discussion our results show that zerocoin scales beyond current bitcoin transaction volumes. though require significant computational effort, verification does not fundamentally threaten the operation the network: even with block containing zerocoin transactions roughly double the average size bitcoin block currently verification takes less than five minutes. this under the unreasonable assumption that all bitcoin transactions are supplanted zerocoin transactions. fact, can scale well beyond bitcoin's current average between and transactions per block zerocoin transactions are not the majority transactions the network. if, the graph suggests, assume that verification scales linearly, then can support transaction mix out transactions per minute transactions per block) and mixture out transactions per minute per block). one remaining question what point start running risk coin serial number collisions causing erroneous double spends. even for our smallest serial numbers bits the collision probability small, and for the bit serial numbers used with the bit accumulator, our collision probability worst equal the odds collision normal bitcoin transaction which uses sha- hashes. stress several caveats about the above data. first, our prototype system does not exploit any parallelism either for verifying multiple zerocoin transactions validating individual proof. since the only serial dependency for either these tasks the (fast) duplicate serial number check, this offers the opportunity for substantial improvement. second, the above data not accurate estimate the financial cost zerocoin for the network: (a) overestimate mining node's extra effort when verifying proposed blocks since practice many transactions received block will already have been received and validated the node attempts construct its own contribution the block chain; (b) execution time poor metric the context bitcoin, since miners are concerned with actual monetary operating cost; (c) since mining typically performed using gpus and lesser extent fpgas and asics, which are far more efficient computing hash collisions, the cpu cost measured here likely insignificant. finally, our experiment neglects the load node both from processing incoming transactions and from solving the proof work. again, contend that most nodes will probably use gpus for mining, and such the latter not issue. the former, however, remains unknown. practice believe zerocoin will used anonymize bitcoins that will then spent actual transactions, resulting far lower transaction volumes. the very least seems unlikely disproportionately affect zerocoin performance. viii. revious ork ron and shamir examined the general structure the bitcoin network graph after its nearly -fold expansion. finally, have been made privately aware two other early-stage efforts examine bitcoin anonymity. e-cash and bitcoin electronic cash has long been research topic for cryptographers. many cryptographic e-cash systems focus user privacy and typically assume the existence semitrusted coin issuer bank. e-cash schemes largely break down into online schemes where users have contact with bank registry and offline schemes where spending can occur even without network connection. chaum introduced the first online cryptographic e-cash system based rsa signatures, later extending this work the offline setting de-anonymizing users who double-spent. many subsequent works improved upon these techniques while maintaining the requirement trusted bank: for example, making coins divisible and reducing wallet size []. one exception the rule above comes from sander and ta-shma who presciently developed alternative model that reminiscent our proposal: the central bank replaced with hash chain and signatures with accumulators. unfortunately the accumulator was not practical, central party was still required, and real-world system existed compute the chain. bitcoin's primary goal, the other hand, not anonymity. has its roots non-academic proposal wei dai for distributed currency based solving computational problems []. dai's original proposal anyone could create currency, but all transactions had broadcast all clients. second variant limited currency generation and transaction broadcast set servers, which effectively the approach bitcoin takes. this marked distinction from most, not all, other e-cash systems since there need select one more trusted parties. there general assumption that majority the bitcoin nodes are honest, but anyone can join node the bitcoin network, and anyone can get the entire transaction graph. overview bitcoin and some its shortcomings was presented barber et. al. []. anonymity numerous works have shown that "pseudonymized" graphs can re-identified even under passive analysis. narayanan and shmatikov showed that real world social networks can passively de-anonymized. similarly, backstrom al. constructed targeted attacks against anonymized social networks test for relationships between vertices. previously, narayanan and shmatikov de-anonymized users the netflix prize data set correlating data from imdb []. bitcoin itself came into existence and now beginning receive scrutiny from privacy researchers. deanonymization techniques were applied effectively bitcoin even its relatively small size reid and harrigan []. ix. onclusion and uture ork zerocoin distributed e-cash scheme that provides strong user anonymity and coin security under the assumption that there distributed, online, append-only transaction store. use bitcoin provide such store and the backing currency for our scheme. after providing general definitions, proposed concrete realization based rsa accumulators and non-interactive zero-knowledge signatures knowledge. finally, integrated our construction into bitcoin and measured its performance. our work leaves several open problems. first, although our scheme workable, the need for double-discrete logarithm proof leads large proof sizes and verification times. would prefer scheme with both smaller proofs and greater speed. this particularly important when comes reducing the cost third-party verification zerocoin transactions. there are several promising constructions the cryptographic literature, e.g., bilinear accumulators, mercurial commitments while were not able find analogue our scheme using alternative components, possible that further research will lead other solutions. ideally such improvement could produce drop-in replacement for our existing implementation. second, zerocoin currently derives both its anonymity and security against counterfeiting from strong cryptographic assumptions the cost substantially increased computational complexity and size. discussed section vi-b, anonymity relatively cheap, and this cost principally driven the anti-counterfeiting requirement, manifesting itself through the size the coins and the proofs used. bitcoin, counterfeiting coin not computationally prohibitive, merely computationally costly, requiring the user obtain control least the network. this provides possible alternative our standard cryptographic assumptions: rather than the strong assumption that computing discrete logs infeasible, might construct our scheme the weak assumption that there financial incentive break our construction the cost computing discrete log exceeds the value the resulting counterfeit coins. for example, require spends prove that fresh and random bases were used the commitments for the corresponding mint transaction (e.g., selecting the bases for the commitment from the hash the coin serial number and proving that the serial number fresh), then appears that attacker can only forge single zerocoin per discrete log computation. provided the cost computing such discrete log greater than the value zerocoin, forging coin not profitable. how small this allows make the coins open question. there relatively little work comparing the asymptotic difficulty solving multiple distinct discrete logs fixed group, and not clear how theory translates into practice. leave these questions, along with the security the above proposed construction, issues for future work. finally, believe that further research could lead different tradeoffs between security, accountability, and anonymity. common objection bitcoin that can facilitate money laundering circumventing legally binding financial reporting requirements. propose that additional protocol modifications (e.g., the use anonymous credentials []) might allow users maintain their anonymity while demonstrating compliance with reporting requirements. acknowledgements. thank stephen checkoway, george danezis, and the anonymous reviewers for their helpful comments. the research this paper was supported part the office naval research under contract n--, and darpa and the air force research laboratory (afrl) under contract fa---. eferences ron and shamir, "quantitative analysis the full bitcoin transaction graph," cryptology eprint archive, report http://eprint.iacr.org/. barber, boyen, shi, and uzun, "bitter better how make bitcoin better currency," financial cryptography vol. lncs, pp. reid and harrigan, "an analysis anonymity the bitcoin system," privacy, security, risk and trust (passat), ieee third internatiojn conference social computing (socialcom). ieee, pp. lee, risky currency? alleged bitcoin heist raises questions," available http://arstechnica.com/, june narayanan and shmatikov, "de-anonymizing social networks," security and privacy, ieee symposium on. ieee, pp. "bitcoin fog company," http://www.bitcoinfog.com/. "the bitcoin laundry," http://www.bitcoinlaundry.com/. "blind bitcoin," information https://en.bitcoin.it/wiki/blind bitcoin transfers. camenisch and lysyanskaya, "dynamic accumulators and application efficient revocation anonymous credentials," crypto pp. nguyen, "accumulators from bilinear pairings and applications," topics cryptology ct-rsa vol. lncs, pp. camenisch, kohlweiss, and soriente, "an accumulator based bilinear maps and efficient revocation for anonymous credentials," pkc vol. lncs, pp. nakamoto, "bitcoin: peer-to-peer electronic cash system, [online]. available: http://www.bitcoin.org/ bitcoin.pdf karame, androulaki, and capkun, "two bitcoins the price one? double-spending attacks fast payments bitcoin," cryptology eprint archive, report http://eprint.iacr.org/. european central bank, "virtual currency schemes," available http://www.ecb.europa.eu/pub/pdf/other/ virtualcurrencyschemesen.pdf, october c.-p. schnorr, "efficient signature generation for smart cards," journal cryptology, vol. no. pp. cramer, damgard, and schoenmakers, "proofs partial knowledge and simplified design witness hiding protocols," crypto vol. lncs, pp. camenisch and michels, "proving zero-knowledge that number the product two safe primes," eurocrypt vol. lncs, pp. camenisch, "group signature schemes and payment systems based the discrete logarithm problem," ph.d. dissertation, eth zurich, brands, "rapid demonstration linear relations connected boolean operators," eurocrypt vol. lncs, pp. fiat and shamir, "how prove yourself: practical solutions identification and signature problems," crypto vol. lncs, pp. chase and lysyanskaya, "on signatures knowledge," crypto', vol. lncs, pp. camenisch and stadler, "efficient group signature schemes for large groups," crypto vol. lncs, pp. [online]. available: https://www.torproject.org/ benaloh and mare, "one-way accumulators: decentralized alternative digital signatures," eurocrypt vol. lncs, pp. baric and pfitzmann, "collision-free accumulators and fail-stop signature schemes without trees," eurocrypt vol. lncs, pp. note that both ssh and the internet key exchange protocol used ipv use fixed diffie-hellman parameters. sander, "efficient accumulators without trapdoor extended abstract," information and communication security, vol. lncs, pp. akinyele, garman, miers, pagano, rushanan, green, and rubin, "charm: framework for rapidly prototyping cryptosystems," appear, journal cryptographic engineering, [online]. available: http://dx.doi.org/./s--- [online]. available: https://en.bitcoin.it/wiki/bip [online]. available: transactions-per-block http://blockchain.info/charts/n- chaum, "blind signatures for untraceable payments," crypto plenum press, pp. chaum, fiat, and naor, "untraceable electronic cash," crypto vol. lncs, pp. okamoto and ohta, "universal electronic cash," crypto vol. lncs, pp. okamoto, "an efficient divisible electronic cash scheme," crypt vol. lncs, pp. camenisch, hohenberger, and lysyanskaya, "compact e-cash," eurocrypt vol. lncs, pp. sander and ta-shma, "auditable, anonymous electronic cash (extended abstract)," crypto vol. lncs, pp. dai. b-money proposal. [online]. available: http: //www.weidai.com/bmoney.txt backstrom, dwork, and kleinberg, "wherefore art thou rx?: anonymized social networks, hidden patterns, and structural steganography," proceedings the international conference world wide web, ser. www new york, ny, usa: acm, pp. narayanan and shmatikov, "robust de-anonymization large sparse datasets," ieee symposium security and privacy. ieee, pp. chase, healy, lysyanskaya, malkin, and reyzin, "mercurial commitments with applications zero-knowledge sets," eurocrypt vol. pp. camenisch and lysyanskaya, "an efficient system for non-transferable anonymous credentials with optional anonymity revocation," eurocrypt vol. lcns, pp. ----, "dynamic accumulators and application efficient revocation anonymous credentials," crypto extended abstract. [online]. available: http://cs.brown.edu/ ~anna/papers/camlys.pdf pointcheval and stern, "provably secure blind signature schemes," asiacrypt vol. lncs, pp. ppendix ecurity roofs proof sketch theorem proof sketch. consider the following simulation. first, the simulation generates params setup(l and two primes that are uniformly sampled from the set prime numbers the range takes these values input and outputs set and transaction string using "where and can chosen with arbitrary polynomial dependence the security parameter, long ((m (l) (l) (l) /l). conclude with the remaining lemmas. lemma a.: under the vent acc (l). strong rsa assumption, proof sketch. the basic idea this proof that who induces vent acc with non-negligible probability can used find witness the presence non-member given accumulator. given this value, apply the technique ss] solve the strong rsa problem. for the complete details refer the reader ss] and simply outline the remaining details the simulation. let adversary that induces vent acc with nonnegligible probability the simulation above. use construct strong rsa solver that succeeds with non-negligible probability. input strong rsa instance (n, u), selects (p, setup and sets params (n, h). generates the previous simulation and runs induce vent acc produces valid output and (by extraction from now extracts from using the technique described ss] and uses the resulting value compute solution the strong rsa instance. lemma a.: under the discrete logarithm assumption, vent orge (l). proof sketch. leave proof for the full version this paper, but similar those used earlier schemes, e.g., []. let adversary that induces vent orge with non-negligible probability the simulation above. input discrete logarithm instance, run the main simulation except that not use the trapdoor information answer oracle queries. instead select random serial numbers and simulate the zksok responses programming the random oracle. when outputs forgery repeated serial number but different string than used any previous proof, rewind extract the pair (sj rj* and solve for the discrete logarithm the main simulation. ppendix ero nowledge roof onstruction the signature knowledge zksok[r]{(c, accverify((n, u), composed two proofs that committed value accumulated and that commitment the former proof detailed ss. and appendix a]. the latter double discrete log signature knowledge that, although related previous work ss..], new (at least us). proof its security can found the full version this paper. constructed follows: given let two security parameters and cryptographic hash function. generate random numbers and compute, for hvi the signature knowledge the message (c, where: h(mky kakbkgkhkxkt ktl and c[i] then else wbri verify the signature sufficient compute: h(mky kakbkgkhkxkt- kt-l with c[i] then t-i hsi else t-i hsi and check whether simulating and extracting. our proofs appendix assume the existence efficient simulator and extractor for the signature knowledge. these may constructed using wellunderstood results the random oracle model, e.g., provide further details the full version this work.