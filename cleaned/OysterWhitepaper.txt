oyster whitepaper rev. september bruno block bruno@oyster.ws oyster.ws introduction mechanics the tangle initial file storage the tangle burying pearls with broker nodes treasure hunting for oyster pearls web node and broker node collaboration web node web node interaction content consumption entitlement oyster pearl token functionality file verification and retrieval distributed reputation system conclusion oyster.ws/discuss page the oyster protocol enables websites silently generate traffic revenue visitors perform proof work for decentralized storage ledger. introduction despite the exponential growth the internet, mechanisms for monetizing web content have remained stagnant. advertisements intrude privacy, distract from the intended content, and break design continuity websites. due general disregard and negative sentiment towards online advertisements, blockers have become mainstream. they have become mainstream that content publishers are pushing back blocking and limiting viewers from content blockers are detected. publishers are losing either large amount money from blockers, large amount viewers from block retaliation mechanisms. therefore the entire advertising scene gradually morphed into ineffective, inefficient and intrusive ordeal without foresight and wholistic solution deployment. parallel, there currently storage service that both convenient and private. you choose convenience, then you are opting for standard cloud storage company which precludes privacy and anonymity. closed source software means you can never truly take what they say for granted. you choose privacy, then you will seldom find accessible and straight forward web interface with simple 'upload' button. the oyster protocol true two-birds-one-stone proposition. the protocol introduces radically different approach getting content publishers and content consumers reach equilibrium and cooperation. consequence, anyone with web browser can store and retrieve files decentralized, anonymous, secure, and reliable manner. the following list all the parties that make the oyster ecosystem: storage user user that spends oyster pearls upload file responsibilities pay the correct amount oyster pearls two broker nodes. despite automation, has final discretion choosing which two broker nodes use. encrypt and split file locally browser, then send parts chosen broker nodes. verify the integrity the data map installed broker nodes. share broker node contracts via the distributed reputation system. securely store the oyster handle retrieve the file from the tangle later time. reward their file securely, reliably, and anonymously stored. website owner organization individual that runs website responsibilities provide content/goods/services web nodes. add the oyster protocol script their website html. reward get paid oyster pearls that have been discovered web nodes. oyster.ws/discuss page web node web browser that visiting web site responsibilities search through treasure maps via proof work discover embedded oyster pearls. submit discovered treasure broker node for claiming behalf website owner. perform proof work for broker nodes get web node identities and new treasure maps. perform proof work for web nodes get web node identities and old treasure maps. send web node identities and old treasure maps web nodes that have performed the adequate proof work. share broker node contracts via the distributed reputation system. reward granted access content/goods/services from the corresponding website owner. pass proof work burden other web nodes where applicable. broker node network device with access the tangle and blockchain responsibilities maintain connectivity the tangle via mutual neighboring nodes. provide web nodes and storage users with access the tangle. perform proof work for new file uploads where applicable. submit the storage user's pearls buried state the blockchain contract. unlock discovered treasure for which the proof work has been correctly performed. maintain positive balance eth unlock discovered treasure. build reputation score the distributed reputation system. broker peer-to-peer connection initiations between web nodes. send new treasure maps web nodes that perform proof work. reward earn oyster pearls collecting leftovers from newly buried treasure. earn oyster pearls collecting fees from newly discovered treasure. pass proof work burden web nodes where applicable. iota tangle distributed ledger known directed acyclic graph responsibilities retain data for which the proof work has been performed. geographically distribute redundant copies data. load balance storage burden, such with swarm intelligence. reward network experiences increased resistance against attack vectors. faster average confirmation time for transactions. ethereum blockchain distributed ledger with smart contract capabilities responsibilities provide smart contract framework that produces the properties inherent oyster pearls (as tokens). reward blockchain miners receive fees paid eth from the broker nodes. oyster.ws/discuss page mechanics the tangle the iota tangle directed acyclic graph, which means blockless distributed ledger. live visualization the iota tangle can seen here. each submitted transaction must perform proof work for two prior transactions, therefore confirming them. these two transactions are contextually referenced the branch and trunk. see here for more details concerning broadcasting transaction the tangle. each transaction has payload capacity which used retain the data that uploaded the storage user. transactions are propagated throughout mesh-net nodes that have mutually peered with each other, whilst each node retains redundant copy the transactions. this leads great redundancy data copies, therefore heavily mitigating the risk data-loss whilst not relying centralized hosting provider. tangle nodes are designed that they automatically delete old data once they reach saturation their physical storage limits (it called automatic snapshots and not yet live the tangle). this means that, eventually, transaction data deleted from the node. therefore web nodes perform proof work re-attach the transaction data the tangle they search for embedded oyster pearls. this ensures that the data maintained across the topology the tangle nodes and never becomes irrevocably deleted. the iota tangle contains many innovations it's roadmap, specifically swarm intelligence. swarm intelligence relevant the oyster protocol because removes the bottleneck each tangle node being required maintain the entire ledger. similar transitioning from raid drive array setup raid setup. implementation swarm intelligence further strengthens the scalability merits the oyster protocol. network bandwidth the most scarce resource concerning reliably committing data across the tangle. tangle node inherently restricted it's network interface bandwidth. since the oyster protocol aims commit data more reliably the tangle, bandwidth access the tangle rewarded with share the processed oyster pearls. tangle nodes that adhere the oyster protocol specifications are called broker nodes. broker nodes act bridge from the tangle web nodes and storage users. data stored the tangle parts within the transaction payload. sha hash the referenced basis for storing and retrieving data the tangle. when sha hash has been selected represent data, converted into it's trinary form represent the recipient address the transaction. retrieve the data from the tangle the hash again converted into it's trinary form produce the recipient address, and then all the transactions under the address are recovered. the transaction with the oldest issuance timestamp contains the payload data that represents the selected hash. initial file storage the tangle when storage user wants upload file via the oyster protocol, the file split into parts and encrypted locally the browser. this isolation ensures the impossibility malicious actor retrieving the data since can only accessed with the corresponding encryption key, which known the oyster handle. the first characters the oyster handle represents the name the file. this usually copied from the filename that was uploaded the browser, but can also customized the storage user for their own references. the primordial hash character long sha hash random input that generated from within the storage user's browser with much entropy possible. oyster.ws/discuss page the last characters the handle the cryptographic salt that differentiates the primordial hash from the overall encryption key. the salt used further protect the data case the primordial hash found because future weakness hash function rainbow table attack the genesis hash. therefore the entire character long handle the entire encryption key used encrypt and decrypt the split parts the data. the oyster protocol also supports adding passphrase the encryption scheme. the primordial hash initiates sequence sha hashes that represents split parts the data. the data first split parts, then each part individually encrypted with the entire handle the key. each part sequentially represented hash iteration (genesis, etc.), and eventually submitted tangle transaction each two broker nodes. the distributed reputation system amongst web nodes and storage users tracks the best performing broker nodes, therefore automatically selecting the most appropriate two broker nodes behalf the storage user. the selection exactly two broker nodes stipulated the oyster protocol induce competitive race between the two for which broker node can install the most pearls into the data map. the better performing broker node receives less pearls for the specific session, yet gains more reputation and hence pearl revenue the future. oyster.ws/discuss page the value the genesis hash submitted both broker nodes the storage user. one broker node designated commit the data map working downwards from the genesis hash (alpha node), whilst the other (beta node) designated commit the data map upwards from the hash represents the last iteration the sequence). the correct amount oyster pearls are sent the alpha-designated broker node. the alpha node sent the full pearl amount and the ethereum address the beta node. the alpha node sends half the pearls the beta node when receives them along with cryptographically signed statement that reveals it's identity. any defections either node will reported via the distributed reputation system, which would exponentially degrade their reputation web nodes and storage users across the oyster network. the amount pearls which the storage user pays half the amount that gets eventually embedded the data map. broker nodes are allowed keep any leftover pearls after the data map has been correctly installed. default, the selected broker nodes are responsible for performing the proof work attach each data part the tangle. the tangle address used send the transaction the trinary form the corresponding hash iteration (genesis, etc.) the sequence. however, broker nodes are able delegate the proof work tasks web nodes there sufficient demand for peer-to-peer connection brokerage and new genesis hashes. understand how the increase overall proof work being performed across the tangle lowers transaction confirmation times and increases the general security the network, more information can found here. burying pearls with broker nodes oyster pearls are designed embedded within the data map that defines the structure and contents the uploaded file. instead storage users embedding the pearls into the data map themselves, broker nodes have been allocated this task for several reasons: broker nodes have access eth balances, and therefore can pay the gas fees needed move all the pearls into the correct designations. every worth user data requires transaction the ethereum blockchain. would impractically complicated for the storage user have perform large amount complex blockchain transactions, which includes invoking custom smart contract functions. when this complexity passed onto broker nodes, the storage user need only send the pearls once the alpha-designated broker node via typical ethereum wallet. having broker nodes embed the pearls the data map heavily mitigates the red herring attack vector. red herring attack when malicious storage user pretends embed pearls into the data map but does not actually embed them. they were upload garbage data without any pearls it, would waste the time web nodes that are searching for treasure (that doesn't exist). eventually the web nodes would realize that the data map not within the bounds the oyster protocol specification, but then the energy spent the web nodes expected greater than the energy put the malicious attacker. therefore this would cause the attack successful and potentially profitable. however, because web nodes rely broker nodes receive genesis hashes (which define the entire data map), red herring attacks are heavily mitigated. this because broker node began give out genesis hashes that represented invalid data map (that doesn't have the correct amount pearls the correct places) would easy for web nodes report the broker node and therefore ruin it's reputation and future traffic. whilst broker nodes have consistent identities that have oyster.ws/discuss page associated reputation scores, storage users and web nodes are much more dynamic. not only already difficult establish consistent cryptographic identities for web nodes and storage users, but the oyster protocol defines that web nodes need reset their identities every amount treasure hunts. storage users not have discernible identity except session basis negotiate with broker nodes. once storage user submits pearls for payments, approximately half are embedded the data map and the other half are collected compensation the two broker nodes. the two broker nodes installing the data map can likened candle that burns both ends. the candle wax represents the data map and the two flames each represent broker node. broker node has the right retain any leftover pearls remaining after the data map has been completely installed (or the candle completely burns out). the default economic pressures would indicate that advantageous for broker node install the data map (burn one side the candle) very slowly not all. the alpha node burns the candle units per second, and the beta node burns the candle units per second, they will still eventually meet some stage but the beta node will have lot more leftover pearls, which entitled keep. the logical extension this economic situation that both nodes would not burn the candle all, both trying keep the most pearls for themselves. the distributed reputation system inverses the economic incentives. broker nodes are assigned cryptographic identities which initially debut with score zero, the lowest possible. web nodes and storage users seek perform transactions with the broker nodes that have the highest available reputation scores (whilst also factoring latency and other selection restrictions). the average candle burning speed node increases linearly, it's reputation score increases exponentially. this causes broker nodes race burning more the candle themselves, despite there being less pearl revenue the short term. broker node that intends burn the candle quickly possible will earn less the short term whilst earning exponentially more the long term. therefore the economic incentive for broker node defect has been nullified. when broker node embeds oyster pearls into data map, special bury function the oyster contract invoked. sector data map represents hashes since the chosen hash (genesis n,, n,, n,, etc). therefore sector holds user data. each sector must have least one embedded treasure pearls inside, whilst possible that sometimes sector will contain two due non-perfect calibration between both broker nodes. the location the pearls within the sectors randomly chosen both broker nodes. therefore the amount pearls per sector defines how long the file should retained the tangle. prl will ensure maintained the tangle for year. therefore the oyster contract locks the pearls for the duration the intended storage time. during this time, web nodes perform proof work find the embedded pearls. pearls must already buried state before they can claimed web node. pearls are also claimed separate time zones named epochs. the oyster protocol defines epoch being year long duration. this means that there sector the data map that contains treasure prl years storage time), then there are available epochs: year year year and year the oyster contract allows exactly prl claimed per epoch. web nodes claim pearls behalf the website owner that invoked them. oyster.ws/discuss page treasure hunting for oyster pearls web nodes search through sectors data maps find embedded oyster pearls. data map defined single sha hash known the genesis hash. web nodes get genesis hashes from broker nodes and other web nodes. genesis hashes don't come for free, web node must perform specific proof work tasks that are defined the counterparty node. the proof work task defined quoting two unconfirmed transactions from the tangle, one that the designated branch and the other that the designated trunk. once the proof work has been completed, the web node responds the counterparty node with the identity the transaction just submitted. the counterparty node then checks the tangle verify that the quoted transaction matches the previously specified branch and trunk identities, and also that the transaction references the data that was meant have proof work performed it. once the counterparty node verifies the proof work was performed, the genesis hash sent exchange. search for treasure, web nodes select random sector the data map that derived from the newly earned genesis hash. the web node then checks see proof work was performed another web node within the current epoch referencing the tangle. the proof work was performed, then the web node abandons the sector and tries again another sector. this because even the web node were find the treasure that sector, highly likely that another web node already claimed the pearls for the epoch the oyster contract. proof work was not performed during the current epoch, then the web node scrolls through each consecutive hash that sector. for example: sector was chosen, the web node scrolls through hashes n,, n,,, which represents data the uploaded file. over time, new web node strategies can deployed which not conform this behavior, such bluffing web nodes. web node bluffs when performs proof work sector that does not expect contain claimable treasure the near future. this way, other non-bluffing web nodes are prevented from accessing it, which causes the sector become exclusively available the bluffing web node. therefore the bluffing web node hopes keep the sector exclusively for themselves until the next epoch becomes available. the game theory mechanics concerning web node interactions can become much more complex and advanced more sophisticated strategies for effectively finding treasure are produced and refined, therefore producing prisoner's dilemma. for each hash that encountered, the web node first performs the proof work the tangle for the corresponding transaction, which utilizes the gpu the device (using webgl). thereafter, the web node retrieves the payload the corresponding transaction and calculates the sha hash the current sha hash. the web node then attempts unlock the payload using the sha hash the decryption key. unlocks, then this means treasure that contains pearls. does not unlock, then the sha hash the current sha calculated, therefore scrolling through the next link the sequence known the hashchain. the web node reaches the upper limit the hashchain size defined the oyster protocol, moves the next sha hash the data map and repeats the process. the oyster protocol defines that treasure must exist least once per sector. treasure was found entire sector, then the data map declared invalid and participants the distributed reputation system are warned. this would lead the degrading the reputation oyster.ws/discuss page the broker node that initially introduced the genesis hash for that invalid data map. could take days for web node scroll through single sha hashchain, and therefore many months for entire sector. this prevents web nodes from consuming large amounts data sudden spikes, the data consumption would spread out over those months the oyster protocol also very simple for visitors disable, should they not consent spend their computational resources exchange. such case, blocking flag would installed the html localstorage area the disabled web node. the visitor's device would then not perform any proof work treasure hunting tasks, but javascript flag would enabled the website owner's site mark the abstention. therefore website owner can opt easily block sending out content anyone who doesn't consent work for them find treasure. because web nodes use the html localstorage directive retain data, they retain the same identity and work queue whilst being invoked different website owners. once treasure hunting session has been initiated, the web node permanently associates the ethereum address the invoking website owner the claimant. for example: person browsing four their favorite websites their laptop, two which have the oyster protocol enabled. when the oyster enabled website visited, the visitor's laptop will become web node and attribute any active treasure hunts the website owner website therefore, any discovered pearls would claimed the oyster contract under the ethereum address website thereafter the person visits the oyster protocol enabled website the laptop still operates web node and retains the same cryptographic oyster.ws/discuss page identity, collection genesis hashes, identities other web nodes and broker nodes, well any pending data maps that working on. any new treasure hunts are initiated under the jurisdiction website then any discovered pearls are attributed the website owner website oyster pearl token functionality because the oyster network fully decentralized system, requires trustless mechanism manage it's referenced value token; the oyster pearl. the oyster pearl erccompliant token the ethereum blockchain that contains custom designed properties that enable the functionality the oyster protocol. custom function specific the pearl token the bury function. burying ethereum address blocks pearls from being withdrawn whilst still permitting deposits. deposits buried address are still enabled allow storage users potentially extend the lifespan their data prevent intentional data expiration. broker nodes invoke the bury function the oyster contract when initially uploading file the tangle. the pearls that are embedded the data map the broker node are withheld the oyster contract and are therefore unspendable. web nodes seek treasure they will encounter private seed keys ethereum addresses that have had the bury function invoked them, therefore locking the pearls from being withdrawn all once. therefore anyone who retrieves the private seed key, web node not, will not able withdraw any pearls via the typical transfer function that invoked all erccompliant tokens. web node must ask broker node invoke the claim function behalf the website owner's ethereum address. the claim function can only invoked ethereum address that buried state. the oyster contract calculates the epochs for the specified sector, and allocates only epoch's worth pearls the claimant. two more epochs worth pearls are unclaimed within sector, then the claimant rewarded all them. the oyster contract doesn't need factor the metrics sectors, because each embedded ethereum address already represents exactly one sector each. the broker node invokes the claim function with the ethereum address the claimant website owner which invoked the web node that discovered the treasure. the claim function also defines fee address variable. when the broker node invokes the claim function, submits it's own ethereum address the fee variable. therefore the oyster contract automatically assigns the due fee that the broker node has earned for unlocking the treasure. therefore the fees which broker nodes receive are unanimously agreed upon and auditable. once the claim function executed, any claimable pearls are directly sent the ethereum address the website owner, whilst agreed upon percentage reserved for the broker node brokerage fee. therefore the oyster pearl the essential medium exchange that bridges the economic motivations website owners, web nodes, broker nodes, and storage users. file verification and retrieval upload file via the oyster protocol, the storage user's client selects two broker nodes commit the data the tangle. the data processed from the beginning and end the file, one broker node performing each, similar candle that burns both ends. some stage the broker nodes will have met somewhere near the middle the data map. however, the unlikely scenario that one the broker nodes was defecting not performing the proof work (and keeping the oyster pearls for themselves), the non-defecting broker node will have oyster.ws/discuss page completed the entire data map. the storage user's client would have noted the defection and cryptographically reported the defecting node via the distributed reputation system. once the file has been fully committed the tangle, the client begins downloading the entire data map order verify it's integrity. the client uses broker nodes other than the first two (that performed the upload) access the tangle and download the data map. this verification stage technically skippable, but recommended that the very unlikely scenario that two broker nodes conspired against the storage user both individually defected, the storage user's client would able cryptographically report the offenses via the distributed reputation system. honest broker nodes would then elect perform the task that the dishonest broker nodes didn't do, whilst not seeking any pearl payments from the oyster user. honest broker nodes seek perform this act data rectification because they would get large boost their cryptographic reputation, which would turn boost their prospects for increased future revenue. whilst the verification process guards against dishonest broker nodes, also guarantees that there flaw the data map due programming error execution bug. the download sequence that used for both upload verifications and candid data retrievals defined such: the client retrieves the primordial hash from the oyster handle and submits input the sha function produce the genesis hash. the client calculates the trinary data the selected hash the sha hashchain (genesis hash for first iteration). the client retrieves the payload data the tangle transaction that correlates with the trinary data from the previous step. the retrieval performed via broker node that selected according the distributed reputation system (which used web nodes and storage users). verification process occurring, the broker nodes used access the tangle cannot the same broker nodes that performed the initial upload. once the payload data retrieved, the client attempts unlock with the entire oyster handle the encryption key. the oyster protocol also allows for passphrase used the encryption scheme, yet caution advised due the risk the storage user forgetting the passphrase. either the oyster handle the optional passphrase are lost, then the file permanently lost. the payload data unlocks, then part the data sequence that makes the uploaded file. does not unlock, then reference the sha hashchain that contains the embedded treasure. the client progresses through the data map checks that least one sha hashchain reference exists per sector (,, sha hashes), else declares the data map invalid and performs the appropriate procedure with the distributed reputation system. once the payload data single hash has been retrieved, stored the storage user's persistent storage device and freed from the corresponding memory usage allocation. the client calculates the next iteration the sha hashchain, submitting the current sha hash into the sha function. the resultant hash the next iteration the hashchain. (e.g. the hash comes after the genesis hash). the process repeats itself until the entire file has been retrieved from the tangle. oyster.ws/discuss page the individual file parts are glued back together, and the entire contents are compared the embedded checksum guarantee data integrity. the storage user able access their files through any client, even from tangle nodes that are not broker nodes. the only two things that are needed retrieve that data are the oyster handle and generic access the iota tangle. distributed reputation system broker nodes are needed storage users bury pearls, and web nodes claim them. both instances, valuable pearls are sent the broker node for processing. therefore monitoring system used storage users and web nodes keep the broker nodes check. this system known the distributed reputation system and operates similar manner ebay. broker nodes are like ebay sellers and web nodes/storage users are like ebay buyers. web nodes/storage users will only conduct transactions with the highest reputation broker nodes that they can find. the broker node selection algorithm considers other criteria such network latency, traffic constraints, and protocol prohibitions (e.g. storage users cannot use the same broker node for both the upload and verification processes). despite these separate criteria, relatively small range the highest reputation broker nodes will receive the vast majority the traffic, and hence pearl revenue. therefore critical for broker nodes honest order for them become profitable. all reputation scores debut zero. there are negative reputation scores, else malicious broker node could remove it's negative reputation generating brand new cryptographic identity that debuts score zero. the flawed strategy switching reputations perform scams comparable rogue ebay seller that keeps generating new accounts. little attention will given these new accounts that have zero reputation. instead, the honest sellers with high reputation will get the vast majority the business. from score zero, honest broker nodes make slow and gradual progress granting web nodes and storage users with access the tangle. genuine access the tangle verifiable and fault tolerant, referencing more reputable broker nodes confirm that the real tangle being accessed. when honest broker node gathers enough initial reputation begins receive requests from web nodes/storage users for performing value based transactions (burying and claiming pearls). they will initially assigned the beta node since beta nodes handle less pearl value. the value based transactions are performed correctly, then the broker node's reputation will begin increase exponentially. turn, this would cause more web nodes/storage users request for value based transactions. dishonest broker nodes will seldom reach the exponential reputation boost ramp. each broker node's identity based off generated pgp key, which must kept secret. the pgp key where leaked would quickly degrade the node's reputation (and future revenue prospects) because malicious actors would quickly use for short term gain. broker node's ability safeguard their pgp keys precedes and confirms their ability safeguard the treasure coordinates data map and the private seed keys treasure. broker nodes and web nodes/storage users agree perform value based transaction after negotiating two terms: minimal state the tangle and minimal state the blockchain. the minimal state ledger defines the minimum scope transactions that should exist after the contract successfully executed and before the contractual deadline. storage user's client defines all the branch and trunk transactions for each sha hash the data map the minimum scope what the tangle should contain. response the broker node sets the minimum scope the blockchain contain transfer pearls address that controls. oyster.ws/discuss page the proposed contract conforms with the oyster protocol and the environmental context both parties, then both parties digitally sign the contract with their pgp signatures. broker nodes always install data maps pairs whilst racing each other embed the most pearls. the contract, each node assigned branch/trunk designation the storage user's client. once the data map installation complete the observing web nodes can estimate the performance each broker node comparing the trunk/branch designations that were defined the contract with the actual trunks and branches that were referenced the tangle. therefore there unanimous agreement amongst participants the distributed reputation system for who performed the best. the broker node that performed the majority proof work receives reputation score promotion, whilst the broker node that performed the minority proof work either gets reputation change demotion (depending the degree performance). therefore broker node's long term interest (concerning revenue generation) perform the proof work quickly possible. this economic pressure ensures fast and efficient experience for the storage user upload file. broker nodes are able offset the proof work burden web nodes that want purchase genesis hashes web node identities. therefore broker node with strong reputation can typically install the data map faster because has more exchange sequences occurring with more web nodes, therefore offsetting more the branch/trunk proof work designations them. zero near-zero amount branch/trunk designations from the signed contract match with the tangle after the contract deadline, then this will considered defection and the broker node's reputation will severely demoted. when web node needs unlock discovered treasure, defines the contract the minimal state the blockchain. the minimal state defines that the pearls from the treasure address should claimed the oyster contract for the website owner's ethereum address. minimal state the tangle defined for this contract. the broker node agrees with the terms, digitally signs the agreement with it's pgp keys. only once the web node receives the signed copy the contract will send the private seed key the treasure the broker node. the minimal blockchain state has not been fulfilled before the contractual deadline, then the web node notifies other distributed reputation system participants the failure quoting the signed contract. therefore the mesh-net web nodes gradually build consensus that the broker node did not perform the task was meant to, therefore demoting it's reputation and future income prospects. conclusion the oyster protocol designed solve revenue generation, anonymous and accessible storage, and decentralized application development and deployment. the same way that the ethereum blockchain provides straightforward framework for token creation, the oyster protocol provides straightforward framework for accessing decentralized mesh network. web nodes are everyday computers, smartphones, cars, fridges anything with modern web browser. they communicate with each other directly, only needing occasional connection brokerage from broker nodes. they automatically choose neighbors that have lower latencies over time, leading overall optimized node topology. extensions can built javascript, popular and easy use language, therefore developers can gain access world-spanning mesh-net. this creates the perfect breeding ground for decentralized applications become easily built and access capable, latency optimized mesh net. the oyster protocol unlocks the dormant revenue potential millions websites, the storage dilemmas individuals and corporations, and the mesh-net platform that developers need. oyster.ws/discuss page