aidos kuneen blockless and anonymous cryptocurrency for the post-quantum era aidos developer aidos foundation january, version (draft) abstract this white paper introduce new cryptocurrency, aidos kuneen. aidos kuneen has been developed deliver fast, anonymous, blockless, decentralized and scalable solution for post-quantum era transfers with zero fees. aidos kuneen employs mechanism known imesh, within imesh all transactions are directly referenced one another order form directed acyclic graph (dag) structure. the inclusion 'spectre' allows full-nodes determine which transactions are legitimate within the dag structure and reject those that are not. addition, spectre provides resilience against any attackers who may happen gain control the network's computational power. ensure continued security the post-quantum era, aidos kuneen utilises the hash-based signature 'xmss'. xmss provides for both small signature and small public key size which turn reduces network load. order provide anonymity within the network, aidos kuneen employs akshuffle. akshuffle incorporates the postquantum, zero-knowledge proof 'zkboo (zkb++)', this allows for truly anonymous transfers throughout the entire network. allow aidos kuneen service the expected future growth the 'iot' sector introduce innovative new cooperative proof work mechanism known copow. copow allows number senders within the network cooperatively perform the necessary proof work order confirm transactions the network, thus reducing the physical processing requirements any one sender. finally, provide simulation the number leaves imesh and further determine the minimum number reference transactions required order converge the dag and deliver fast confirmation times, whilst still having minimal effect the transaction size. copyright aidos developer and aidos foundation. event shall the authors copyright holders held liable for any claim, damages other liability, whether action contract, tort otherwise, arising from, out of, connection with this document, the use other dealings with this document. this work licensed under creative commons attribution international license. http://creativecommons.org/licenses/by/./ contents introduction related works signature scheme wots+ xmss imesh spectre akconsensus proof work co-operative proof work akshuffle network leaves within imesh future plans conclusion appendix results simulation number leaves eaves appendix results simulation growth ndescendant list figures generation the wots+ public key signing with the wots+ private key wots+ verification key generation the auth path for xmss imesh example the voting procedure within simplified dag structure. statements and finalisation transactions cuckoo graph example how akshuffle operates aidos kuneen network topology leaves within imesh transaction per minute, transaction per minute, tps tps tps transaction per minute tps tps tps introduction back the founding transactions that came before it, these founding transactions are open the public. such, anyone free track the flow btc from address address. bitcoin, the once obscure cryptocurrency introduced satoshi nakamoto has now begun draw much wider attention from both the general public and governments alike. within the bitcoin network, transactions are written into 'blocks', these blocks are then cryptographically validated powerful computers known 'miners' using proof work (pow) system. once block has been validated then appended the end continually growing chain blocks aptly named 'the block-chain'. miners are subsequently rewarded for successfully validating block means the transaction fees paid senders who transact the bitcoin network. order address these issues, introduce new cryptocurrency, aidos kuneen. the aidos kuneen network, known imesh, based directed acyclic graph (dag) technology. imesh, transactions are directly referred other transactions and such there are blocks, and extension, block-chain. the confirmation transaction determined the number other transactions which vote for the transaction. imesh, are able achieve the benefits scalability while completely removing the requirement for miners, which subsequently removes the need for the associated transaction fees that were currently, blocks are added the blockchain rate once required order incentivise mining. approximately one every minutes. the transactions contained within the blocks consist both input and output adios kuneen has been specifically designed provide: increased scalability addresses, with the inputs themselves being the outputs imesh, one performs relatively simple pow comprevious transactions this provides auditable history putations confirm the transaction. after the transof all past bitcoin transactions within the network. order action broadcast the network, the transaction prove ownership, transactions are signed the address stored into imesh immediately. hence, there need owner with elliptic curve digital signature algorithm wait for one's own transaction stored. addi(ecdsa). tionally there limitation the size number transactions that can stored time. the more however, recent years number problems have been imesh grows, the greater the number transactions identified with the bitcoin implementation, including: that become involved. this means that the confirma* limited scalability tion time any single transaction will reduce the within the core bitcoin code, the maximum block size network matures. restricted and blocks are unable store transactions zero fees once this limit exceeded. this turn leads scalas one longer required pay any transaction fees ability problem when many transactions are broadcast (owing the fact that there are miners), one free simultaneously with many them being unable transact with any amount, matter how small withincluded the current block. out requiring any special knowledge techniques. high transaction fees post-quantum resistance aidos kuneen have specifically chosen hashbased signature which provides strong post-quantum security. there have been number different signature architectures developed provide resistance future quantum based computer hardware, including ring-lwe, lattice and hash-based methods. however, the majority these are not practical for our purposes due their large key and signature sizes. for example, the key sizes ring-lwe and lattice based signatures weigh number kilobytes. this means that were employ one these methods for example, would forced use long alphanumeric address strings which are not conducive usage the non-technical, general public. for cryptocurrency that intended for widespread daily use this completely unsuitable. senders are required pay transaction fee order incentivise the miners include their transaction block. bitcoin usage continues grow and the price bitcoin increases, the relative value the fee will also increase. longer makes sense send small transactions via the bitcoin network the fee could easily exceed the value the bitcoin being transacted. this forces senders use complicated schemes send small value transactions (e.g. micropayment channels). poor resistance against quantum computers the development quantum computers still its infancy. however, experiments have already been carried out which quantum computational operations were executed small number quantum bits. furthermore, google has reported its intent commercialize quantum technologies within the next five years []. the same time, according shor's algorithm [], all algorithms based the discrete logarithm problem (including ecdsa used bitcoin), can easily solved with sufficiently powerful quantum computer. such, focus our attention the family hash-based signature methods instead. some hash based functions such 'sphincs', provide with the ability reuse the same public key multiple times, which step the right direction. however, sphincs also suffers from the same large public key size (around kilobyte) the other methods, again making unsuitable for our application. limited anonymity the auditable nature bitcoin means that order spend bitcoin, the spending transaction must refer eventually, the 'extended merkle signature scheme' (xmss) was identified being the ideal balance human usability and small key size. xmss allows repeatedly utilise the same public key large number times times more). however, unlike sphincs, xmss has lightweight public key only bytes and signature key size approximately kilobytes. utilising xmss also benefit from bit post-quantum security []. lieve that least the short medium term, binary based systems will continue remain the dominant form for consumer grade hardware. iota's confirmation process, outlined iota's white paper, counts only the number referring transactions (descendant transactions), notice that the total number leaves the dag increases (as will occur naturally), the percentage these leaves which descendant transactions refer will decrease. this means that attackers could potentially grow their malicious transactions faster than the network. combat this introduce confirmation process based spectre presented []. spectre one does not only count the number descendant transactions, but one also counts the number other transactions which subsequently vote for the transaction. hence, even the leaves diverge, difficult for attacker grow the confirmations their malicious transactions. strong anonymity order achieve anonymity, utilize the post quantum, zero-knowledge, non interactive (zkni) proof 'zkboo' presented []. zkboo allows one transact freely across imesh, without the need reveal one's address either the receiver the wider network. related works within the spectre voting process, still require faster dag convergence for rapid confirmations. the white paper presented the iota team does not specifically clarify the convergence behaviour the dag, rather the white paper simply states that 'one expects that the l(t) (total number leaves) remains stable'. such, section additionally simulate the behavior leaves within imesh order ensure that the dag converges. monero, bytecoin and zcoin achieve anonymity, both monero and bytecoin use 'ring signature' methods discussed cryptonote []. ring signature methods rely signature which utilises novel trapdoor function (e.g. public key encryption), unfortunately though, this feature not found any the available hash-based signature methods. zcoin utilises zero-knowledge, non interactive proof called 'zksnarks', however, zk-snarks not quantum secure, owing the fact that uses pairing-based cryptography. signature scheme previously mentioned, aidos kuneen employs xmss described the rfc draft ietf its signature algorithm. xmss itself based the earlier work the winternitz one time signature (wots+). wots+ hash based signature scheme designed for single use only, xmss builds upon this work and delivers mechanism which makes possible sign multiple messages with single key. coinjoin another potential option for providing anonymity, would use 'coinjoin' one its variants (e.g. 'coinshuffle'). however, coinjoin requires the presence active participants the same time one intends send coins. this requirement could prove handicap the early stages adoption when the aidos kuneen userbase still small. wots+ iota iota dag based, fee-less, iot focussed cryptocurrency. iota unique that makes use ternary based signatures rather than standard binary. this due the fact that ternary based systems are theoretically more computationally efficient than binary based systems. aidos kuneen have chosen utilise traditional binary based signatures order fully utilize existing cpu features (such simd instructions and dedicated sha extensions). this decision was made because believe that current generation digital processors are already sufficiently fast and efficient enough meet our requirements, with some iot oriented figure generation the wots+ public key processors already containing dedicated circuits for sha- based hash processing, e.g. arm processors. also be- figure demonstrates how public key generated. order generate public key, one initially generates http://monero.org/ series character strings consisting byte https://bytecoin.org/ https://zcoin.io/ bit) random binary data which becomes the private key post-quantum zcash (https://github.com/zcash/zcash/issues/) priv then, each priv hashed with the https://en.bitcoin.it/wiki/coinjoin sha- algorithm for total passes. while hashhttps://iota.org/ https://static.docs.arm.com/ddi/f/ddi.pdf ing, each priv xored with value from prf (pseudo random function). this xor operation employed re- xmss duce the signature size while maintaining the same security figure demonstrates how the public key for xmss genlevel. the output these operations becomes the public erated. key pub which also character string consisting byte binary data. figure signing with the wots+ private key figure illustrates how the message signed. when signing, one calculates bit hash (msg) the original message, and corresponding bit checksum from figure key generation (msg). next, series bit, character binary strings are produced from the (msg) and the checksum. each the priv values are then hashed for short, xmss builds tree known 'merkle tree', times and xored with the same values used for pub gather all public keys into one single key. this then allows produce the signature sig one public key reused many times. the checksum used prevent attacks from malicious messages. for example, there were checksum and attacker were create message whose hash were i.e. then the signature would equal the private key and thus the private key would exposed. initially, one must generate wots+ private keys privi and the corresponding wots+ public keys pubi the height merkle tree). then, number 'ltrees' are generated. ith ltree generated from pubi one receives the root hash the ith ltree hashing wots+ public keys (i.e. (pubi |pubi |pubi )). the root hash ith ltree becomes the ith leaf the merkle tree. this operation then repeated times fill all remaining leaves the merkle tree. finally, the root hash the merkle tree calculated hashing together the leaves the merkle tree (i.e. roots the ltrees). this root hash becomes the xmss public key. when signing, one simply selects one the unused private keys and its corresponding public key. next, one calculates the wots+ signature. the xmss signature the wots+ signature with 'auth path'. the auth path additional piece binary data used calculate the root hash the merkle tree (i.e. the xmss public key). figure wots+ verification figure illustrates how the signature verified. order verify signature, verifier first calculates using the same procedure for signing explained above. next, each sig hashed times and xored with same values were used produce pub the output which yields pubj this then checked confirm that equals the signer's public key pub table illustrates, there are height levels for the merkle tree within aidos kuneen. users who desire change addresses for each payment who transact less than times with the same address are able use height=, reducing the impact generating public keys. heavy users such corporate entities merchants, who transact more than times with one public key, would use either height= height=. note: have chosen not use xmss detailed []. although xmss means not need generate all the public keys simultaneously, the signature size much larger than that xmss, weighing around kilobytes. figure the auth path for xmss with reference figure desire select private key for signing. verifier can calculate node from the signer's signature. however, order determine node the verifier will first need determine node this means that the auth path must include node the same manner, order determine node #'s root hash (i.e. the xmss public key), the signer also requires nodes and included within the auth path. thus, order perform the verification, the verifier must posses the wots+ signature and the node values along the auth path (i.e. the values nodes and #). this will allow the verifier calculate the root hash the merkle tree and determine the root hash equal the xmss public key. imesh spectre when sender sends transaction, includes some the transactions previously sent others. figure illustrates the dag structure these transactions which refer imesh. when sending, the sender selects some the leaves imesh (i.e. transactions which are not currently referred any other transactions) and determines whether not the parent transactions these leaves are valid. after determining the parent transactions are valid the leaves are included the senders transaction. note that: signers must record which private keys are used. order accomplish this use the logarithmic merkle tree traversal scheme presented provide efficient traversal with minimal storage cost. the public key consists bytes (the root hash the merkle tree and the seed the prf). there only one prf seed, all pseudo random values can generated from single prf. include the seed part the signature such that the public key size becomes bytes. the signature key size approximately kilobytes. the sha- hash provides strong preimage resistance (i.e. attacker unable guess the input from the output the hash), thus difficult guess the private key from the public key, even when using quantum based hardware. additionally, note that are able reuse the same public key number times (the height the merkle tree) increased (although this requires more time generate the public keys during the initial stage). figure imesh unlike block-chain based networks such bitcoin, where table merkle tree height, estimated time for key gener- block refers only the preceding block, single transaction dag refers many other transactions within ation per cpu core, and intended users xmss the dag. with block-chain technology, the chain grows height #keys key generation user linear sequence (i.e. one block time), whereas within dag the interlinked nature the transactions allow few seconds one time and grow simultaneously all directions, thus leading supenormal users rior scalability compared block-chain based systems. few minutes companies minutes big companies however, this interlinked nature not without its draw backs when comes conflicting transactions. for example, assume alice's address holds total coins. she sends coins bob transaction and then without thinking she sends coins cathy another transaction alice has inadvertently attempted spend the same coins twice (this known 'double spend') and result these two transactions are now direct conflict. block-chain based system, once one the conflicting transactions has been written into block, the other will never stored, (i.e. receives least one confirmation before then will rendered invalid). the other hand when there are conflicting transactions (highlighted red figure) within imesh, difficult determine which valid. solve this problem, aidos kuneen adopts the voting mechanism presented 'spectre' []. this system guarantees majority amplification, these transactions add votes that reinforce previous decisions. transactions which not have both transactions and parents vote for which ever has the majority voters (transaction -). this rule allows amplification the votes parents transaction (transaction -). this necessary counter 'pre-mining attack' scheme, i.e. the attacker builds blocks and withholds them from the network. due the fact that honest transactions tend have greater number ancestor transactions, honest transaction should receive more votes means rules and note: spectre resilient against attackers with the network's total computational power, and not the traditional demonstrated []. additionally, imesh receivers must also wait for their transaction confirmed sufficient number other transactions (much like waiting for number 'confirms' bitcoin) prior spending. reference provides guidance how long receivers should wait before trusting new transaction. for comparison, let's assume that will wait for confirmations before accepting payment the bitcoin network. let's also assume that attacker has managed gain control the total hash power the bitcoin network. the possibility success such attack .%[]. similarly, imesh with the spectre voting scheme employed, once transaction (tx has received approximately referrals the probability fraudulent (intentionally conflicting) transaction (tx being accepted legitimate place has reduced .%. the imesh network grows and the frequency transactions increases, the waiting time required for transaction verified legitimate the network will decrease (i.e. the larger the network grows the faster becomes). conversely, when the network small, the waiting times are very long, the network hash power also likely quite small and this opportunity that attacker may attempt exploit. order prevent this potential attack vector, introduce mechanism known 'akconsensus' (as discussed section .), confirm transactions between trusted full-nodes while imesh still its infancy. figure example the voting procedure within simplified dag structure. spectre, one counts the number voters for each the conflicting transactions. figure shows the voting procedure. can see, transactions and are conflict. transaction and transactions vote for transaction they only see their past, and not similarly, transaction and transactions vote for transaction transaction votes according the majority the votes from the other transactions (except for transactions and all transactions from vote for transaction they see more voters than voters. result, the total number voters greater than voters, therefore accepted the legitimate transaction and rejected. the rules regarding the spectre voting procedure are summarised follows: the voting scheme, senders have incentive refer transactions which only have transaction the paras many transactions they can due the confirmation ent can only vote for transaction (transactions speed the sender's transaction being directly related and the number referring transactions. sender were honest transactions gain votes over transactions that refer only small number transactions, the receiver have been secretly withheld dishonest parties, could potentially reject the payment would take sighonest nodes continue add new transactions that nificant amount time for the transaction validated and for the receiver receive the coins. subsequently vote for the honest transaction. transactions which have both and parent must also noted that there are many leaves within (transaction vote for which ever one has the ma- imesh, the possibility which any one leaf referred jority voters. new transaction would reduce. combat this need carefully consider how many transactions should referred any one single transaction. will explore this issue greater detail within section akconsensus mentioned the previous section, must assume that during imesh's infancy period attacker with access sufficient resources could realistically command the majority the total network hash power. for this reason that are therefore unable fully trust the spectre consensus mechanism during the early stages network growth. thus must introduce 'akconsensus', temporary system which utilises federated byzantine agreement (fba) based the 'the ripple protocol consensus algorithm' along with semi-trusted model detailed [], order validate transactions until such time the spectre consensus mechanism can take over. within the ripple protoco,l the fba process used order confirm the validity all transactions. similar process, referred 'akconsensus' has been adopted for aidos kuneen, however, should noted that the implementation this process within aidos kuneen differs significantly from that ripple. with akconsensus place, group trusted nodes periodically review randomly selected transaction from within imesh. this group trusted nodes reaches agreement the validity this transaction, the transaction becomes known 'statement', and now serves act milestone within the network. figure statements and finalisation transactions figure illustrates how statements act milestones for other transactions. full-nodes regard statements "absolute truth" and any conflicting transactions are discarded locally each full node. subsequent transactions that are referred statement become known finalised transactions. the numbered transactions figure show how transactions are finalised the statements that reference them, the process consensus follows: e.g. the transactions designated with are finalised each full-node defines the addresses trusted nodes statement within their trusted list. one the full-nodes selects transaction for review the rules employed akconsensus order determine and broadcasts the trusted nodes within their the validity conflicting transactions are follows: trusted list. this transaction now referred 'candidate statement'. the transaction which finalised the youngest statement deemed valid, and all others are considered invalid. each trusted node initialises each trusted node reviews the legitimacy the candidate statement based its local history. conflicting transactions are finalised the same statement, the transaction which possesses the older time stamp deemed valid. trusted node deems the candidate statement legitimate, then broadcasts 'yes' vote the fullnodes which referenced. the candidate statement deemed fraudulent subsequently discarded. both transactions possess the same time stamp, the transaction which has the smaller hash deemed valid. full-node does not receive minimum 'yes' votes from the nodes its trusted list within akconsensus requires minimum agreement becertain period, the candidate statement discarded. tween trusted nodes order accept candidate state. each trusted node increases ment, and extension, more order reject step repeated invalid candidate statement. the final round requires minimum full-node's trusted nodes agreement order accept the the candidate statement being legitimate and elevate the status statement. while acknowledged that the introduction akconsensus does directly contradict aidos kuneen's ultimate vision completely decentralised cryptocurrency, akconsensus, for the reasons outlined previously, accepted "necessary evil" until such time the network has manote: order accepted statement, candidate tured the point where capable resisting attack statement must have valid transaction structure and must its own. additionally, aidos kuneen believes very strongly exist within imesh. providing completely fee-less product its user base, the presence akconsensus allows the realisation this vision from day one, with need resort alternative, 'incentivised' mechanisms for early network protection. proof work and with equal roots. this case, can compute the length the resulting cycle plus the sum when sending transaction, senders must first perform the path lengths the node where the two paths join. 'proof work' (pow), similar that which performed the diagram, the paths join node and the cycle length miners the bitcoin network. the mandatory perfor- computed mance pow prior sending transaction necessary order protect imesh from ddos attacks via spam transac- the cuckoo cycle has been chosen the pow function for tions and double spend attacks (as previously discussed). imesh, due the following reasons: addition, pow used distribute the computational work* anticipate significantly higher daily transaction load validating transactions between all participants volumes compared that bitcoin, this due the the network. this ensures that the network does not become fact that unlike bitcoin, the fee-less nature aidos constrained the limitations processing capabilities kuneen means the economic disincentive against frea handful 'masternodes', but instead remains completely quently sending small transactions removed. thus, free scale required. during the pow operation each aidos kuneen requires very fast verification method. transaction assigned length -bit integer fields unlike other typical pow algorithms such crypknown 'nonce'. the value this nonce set such that tonight scrypt which are typically quite resource the hash the block will contain leading run zeros and intensive, full-nodes are able verify the validity form series 'cuckoo graphs' with cycle length (as nonces much faster when utilising the cuckoo cycle. discussed more detail below). the leading run zeroes determines the time required for the pow operation and has unlike bitcoin, which pow performed only been chosen produce average pow time minthe blocks themselves, aidos kuneen pow must utes. performed for each individual transaction. there are significantly more individual transactions than there for pow operations, aidos kuneen implements the cuckoo are blocks, aidos kuneen therefore requires more cycle discussed []. the cuckoo cycle arises the power perform pow verification. thus, esseninsertion keys into 'cuckoo hashtable' which naturally tial that highly efficient means verification, such leads the cyclic formation random bipartite graphs. the cuckoo cycle employed. cuckoo hashtable consists two identical tables, each with unique hash function which maps key table order prevent attacker from being able proplocation (this provides two possible locations for each key). agate fraudulent transactions throughout the network, upon arrival new key, its table location first deterspecialist hardware such asics and fpgas should mined. both possible locations are currently occupied not provide any advantage. the pow time mainly existing keys, then one extracted and inserted into its dominated memory access speed, specialist proalternate location (potentially displacing yet another key). cessing hardware essentially rendered ineffective. this process subsequently repeated until either vacant location identified, predetermined number itera- the following cuckoo cycle parameters will used for tions reached. this process leads the formation cy- pow operations: cles what referred 'cuckoo graph'. the cuckoo cycle length (to minimize the size impact graph bipartite graph with node each location, and transactions). edge for every inserted key, connecting the two locations which the key can reside. number nodes (to provide memory usage around mb). easiness n/m (m: number edges) (to prevent optimizations edge trimming). co-operative proof work figure cuckoo graph cater specifically for iot devices (whose performance typically quite low), introduce novel co-operative proof work mechanism known copow. utilising copow, the network able group number unverified transactions together into single, larger transaction known 'batch'. this allows the senders the individual transactions within the batch effectively pool their computational power into validating the batch unit, rather than just their own individual transactions. copow effectively acts like decentralised version bitcoin mining pool and allows large numbers lower powered devices interact directly with the network they were single, much more powerful device. the first diagram figure illustrates the directed cuckoo graph nodes after edges and are added. order add the edge follow the paths and find the different roots and since the latter path shorter, reverse the path such that can add the new edge resulting the middle diagram. order add the edge now find the path from the shorter one, reverse the path and add the new edge resulting the right diagram. when adding the edge find the paths copow functions follows: bob that she really has key without ever actually having sender wishing participate copow broadcasts reveal the key itself. request network via full-node. aidos kuneen utilizes 'zkboo (zkb++)' presented others who wish participate are already perform- its zkni mechanism. zkboo requires only the use hash and aes encryption function which has been ing copow respond the request. shown quantum secure []. the sender joins the copow group the group not yet established process leader selection performed, the group already established then the new device receives the identity the existing leader. the sender sends his transaction the leader who then mixes with the transactions from all the other participants form batch. all senders commence pow the batch. the sender periodically sends the result their 'pow for proof' (which meets the requirement for the 'target for proof') the leader. the sender periodically receives the pow results from other parties via the leader. any the parties submit incorrect results they are ejected from the group. figure example how akshuffle operates with reference figure the operation akshuffle any the parties fail submit their results within described follows: set period time, the leader ejects that party and then any user who desires shuffle their tokens simply sends delivers restart command all remaining parties. them akshuffle address. the shuffle address the process continues until one the parties successoutput the encryption with key where fully solves for the 'final hash', after which pow the secret key and the public input. completed and the group disbanded. any point the user desires withdraw their shuffled toparties participating copow group must periodically kens they simply create transaction which sends the tosend some their pow results the leader prove that kens their normal address (i.e. their xmss public they are actively participating the group. this prevents key). the transaction contains the user's akshuffle address free-loading parties who join the group but not intend along with other user's akshuffle addresses actively contribute. the target for proof threshold set input addresses. this means such that the hash less complex than the final hash, this that nobody knows which address has actually been used for important ensure that devices with limited computational the withdrawal. order prove ownership the user comcapacity are able successfully meet the target for proof pletes the zkni proof proving they know such that within the required time period. the target for proof itself one the akshuffle addresses listed input equals can variable. for example, target for proof final tar- the transaction also includes the user's pubget could adopted for groups low capacity iot lic input order prevent the reuse the shufdevices, and the target for proof final target could fle address. also important point out that the user required withdraw the full amount that they originally adopted for normal desktop pcs. deposited, the system will not allow partial withdrawals for added anonymity, participants copow group have the user's balance reuse shuffle address strictly the option utilise the tor network for all communications forbidden order maintain anonymity. between themselves and the group. note: transactions used for akshuffle and transactions user for normal payments are completely different. akshuffle (zkboo) used only for shuffling one's tokens. akshuffle such, one cannot use akshuffle send tokens directly for increased anonymity employ akshuffle. within another user. this due the fact that the signature size akshuffle utilize zero-knowledge, non-interactive zkboo quite large, weighing around kilobytes (zkni) proof for anonymous transactions. utilising for inputs. zkni, one can prove that their value satisfies set functions without the need reveal their secret key. for example: alice has input and key for encryption function (x), and shares (x) with bob. bob wants know alice really has key but alice doesn't want reveal her secret key bob. employing zkni, alice can prove network command table basic packet commands description ping pong find_node resp_node req_transactions resp_transactions req_leaves resp_leaves invent figure aidos kuneen network topology illustrated figure the aidos kuneen network comprised series full-nodes who communicate fashion. clients can either connect directly these full-nodes their own full-node via api. clients are able send api requests order broadcast their transactions the network (this usually performed automatically the wallet application). between full-nodes, transactions are sent and received using efficient serialization (e.g. msgpack) order reduce packet sizes. ack_invent invent_copow ack_copow find_value store_value ping another node response ping request node info response node infers request transactions contents respond transactions contents request leaves' hashes respond leaves' hashes invent new transaction hash ack invent invent that node searching for copow group ack invent_copow reserved for future use. reserved for future use. order ensure anonymity between public full-nodes and clients utilise the tor network. this essential full- leaves within imesh nodes may otherwise receive sensitive information such their clients' addresses along with the clients' transac- mentioned previously section the speed confirmation depends heavily the number leaves, eaves tions. imesh. this due the fact that the number leaves important note that tor not employed for com- within imesh increases, the probability that new transacmunications between full-nodes. this due the fact that tion will refer any one leaf reduces. routing traffic via the tor network introduces unavoidable element delay into inter-nodal communications, and there are number scenarios which the number efficiency between full-nodes critical aspect the speed leaves could conceivably increase, illustrated figof the entire aidos kuneen network. additionally, there ure little need enforce anonymous communication between nodes, this due the fact that even the initial clientto-node connection were not secured with tor, the initial receiving node does not transmit any sensitive information about the client when relays the transaction the other nodes. unfortunately however, tor not quantum secure. though, tor does have the advantage being well established, trusted network with large number participants. believe that for the short term least, the strong anonymity provided the tor network excellent fit for aidos kuneen. will continue investigate other potential methods providing quantum-resistant anonymity they become available. table lists the basic packet commands for the aidos kuneen network. figure leaves within imesh the first scenario that attacker might seek slow down imesh intentionally referring non-leaf transactions. this would have the effect adding additional, unreferenced leaves the dag, thus decreasing the overall efficiency the entire network. order combat this situation could set help prevent attackers from increasing the number leaves https://msgpack.org/ indiscriminately. combine this with the fact that at. tps tacker can only add one new leaf per transaction, will find that (provided the attacker does not control more than algorithm simulation the number leaves within the total network hash power) honest transactions imesh input number directly referring transactions will rapidly reference the attacker's new leaves, thus inteinput tsi number iterations grating them into the dag and preventing the uncontrolled input rate incoming transactions growth unreferenced leaves. input pow time complete pow output: number leaves similar situation scenario one, attacker may seek spam the network broadcasting large number very time //current time low (or even zero value) transactions either himself pow_t //transactions which are undergoing pow //transactions imesh accomplice attempt create large number leaves while time better (nl eaves furthermore, when look the other values, notice that considerably worse than the other values. for example, tps, eaves when eaves when therefore, clear that should not use assume transactions enter into imesh same speed bitcoin. the time converge dag below seconds minutes) for all values except when tps. algorithm shows the algorithm used simulate the number leaves imesh. take pow minutes and should also mentioned that exhibits simple linsimulate with across the following ear behaviour and doubles with each increase the value rates input transactions from purely transaction size focused point view, transaction per minute (this models the early should seek minimise the value. days imesh when the user base small) also simulate how the number transactions, tps (transaction per second) ndescendant which refer directly and indirectly any one tps (this the peak transaction speed the transaction grow for each the cases mentioned previously. figures appendix illustrate these results. bitcoin network occurred may these figures, the x-axis shows the number transactions which enter into imesh (after imesh has become stable). the y-axis shows ndescendant (the number descendant transactions) for one random transaction. the graph would become diagonal (linear) line ndescendant were grow ideal rate. when transaction per minute, the graphs all are almost diagonal. but, increases, ndescendant reduces. for example, when tps, ndescendant does not increase diagonally even after transactions seconds hours average) when and after transactions seconds minutes average), ndescendant starts increase linearly. such, believe that the best course action allow remain variable. will adopted the initial setting, due the fact that even imesh were grow tps (which the maximum tps bitcoin), still allows imesh converge around #leaves=. additionally, previously discussed, setting will help prevent attackers from increasing the number leaves indiscriminately. imesh continues grow will review the value the variable order maintain optimal network performance. future plans the following plans are intended integrated into the aidos kuneen network the future: distribute transactions between nodes allow for increased scalability (i.e. single full-node does not hold all transactions within the network but instead queries other nodes the network required) implement kademlia based scheme for tor-like anonymity, post-quantum security and distributed peer discovery. implement more sophisticated zkni algorithm order reduce transaction sizes. conclusion this white paper have presented the new cryptocurrency aidos kuneen. aidos kuneen employs imesh, where all transactions are directly referred one another order form dag structure. prevent double spending utilize 'spectre' determine the legitimacy all transactions. employ the hash-based signature 'xmss' the signature scheme for post-quantum resistance. for anonymity introduce akshuffle which utilises the zero-knowledge proof 'zkboo (zkb++)' for postquantum security. cater for the future growth the iot sector introduce novel cooperative proof work mechanism called copow, which allows low powered devices combined their resources and perform pow group. finally, provided simulation the number leaves within imesh, and the expected behaviour the network the network grows. table aidos kuneen: technical specifications ticker adk total supply adk minimum unit adk pow algorithm cuckoo cycle anonymity akshuffle (post-quantum zero knowledge proof) and tor consensus algorithm spectre distributed ledger imesh (transaction dag) signature scheme xmss (post quantum hash based signature) usage finance, banking, digital commerce, iot micropayments references satoshi nakamoto, bitcoin: peer-to-peer electronic cash system, crypto forum research group, draft-irtf-cfrg-xmss-hash-based-signatures- xmss:extended hash-based signatures, serguei popov, the tangle, sheldon ross, introduction probability models. edition, sergio demian lerner, dagcoin: cryptocurrency without blocks, johannes buchmann, erik dahmen, andreas hulsing, xmss practical forward secure signature scheme based minimal security assumptions, irene giacomelli, jesper madsen, claudio orland, zkboo: faster zero-knowledge for boolean circuits, melissa chase, david derler, steven goldfeder, claudio orlandi, sebastian ramacher, christian rechberger, daniel slamanig, greg zaverucha, post-quantum zero-knowledge and signatures from symmetric-key primitives, yonatan sompolinsky, yoad lewenberg, and aviv zohar, spectre: serialization proof-of-work events: confirming transactions via recursive elections, peter shor, polynomial-time algorithms for prime factorization and discrete logarithms quantum computer, masoud mohseni, peter read, hartmut neven, commercialize early quantum technologies, pqcrypto, post-quantum cryptography for long-term security, initial recommendations long-term secure post-quantum systems, nicolas van saberhagen, cryptonote john tromp, cuckoo cycle: memory bound graph-theoretic proof-of-work, anton churyumov, byteball: decentralized system for storage and transfer value. michael szydlo, merkle tree traversal log space and time, pqcrypto, post-quantum cryptography for long-term security, david schwartz, noah youngs, arthur britto, the ripple protocol consensus algorithm, appendix results simulation number leaves nleaves figure transaction per minute, figure tps figure transaction per minute, figure tps figure tps appendix results simulation growth ndescendant figure transaction per minute figure tps figure tps figure tps