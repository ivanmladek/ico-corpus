contentos technical white paper contentos blockchain system that aims form the foundation for decentralized digital content ecosystem. provides mature security mechanism protect users' accounts, and flexible enough meet various operational needs. the economic rules incentivize users contribute valuable contents and participate activities the system. its consensus protocol combination dpos and bft achieve high throughput and fast confirmation transactions. contentos also provides gprc and restful api services, supports http, https access. smart contract also supported, which enables users develop their own dapps. make more user friendly, contentos provides plenty smart contract apis that supports on-chain data query, asset transfer, contents management and cross-contract invocation. smart contract template module also provided make easier develop and deploy smart contract. .consensus overview according cap theory: distributed system cannot have consistency, availability and partition tolerance the same. new consensus protocol called sabft invented achieve consistency and availability, maximize the system's throughput and minimize the confirmation time transactions. generates blocks the same manner dpos and adopts bft achieve fast block confirmation. it's self adaptive way that can adjust the frequency bft process based the load the blockchain and network traffic. terminology node: server running contentos daemon(cosd) block producer: node that generate blocks validator: node that participates bft consensus proposer: validator who broadcasts proposal proposal: block which all validators try reach consensus, once reached, it'll committed commit: commit block means mark the block the last irreversible block block generation sabft generates blocks the same manner dpos. each validator takes turn produce blocks row and block generated every second. fork possible, the longest chain considered the current main branch. fork switch another branch out grows the main branch, swichfork taken place.it finds the common ancestor the two branches, pop all blocks the main branch after the ancestor and apply blocks the longer branch why need bft instant transactions are required many scenarios, especially when involves asset transfer. bitcoin world, there guarantee finalize certain block because theoretically any node with enough resource can generate longer chain and cause fork switch. this direct violation safety the realm distributed system. hence adopt bft achieve fast consensus. once consensus reached certain block, can never reverted. performance sabft reaches consensus seconds lan. the bft process adopts -phasecommit(propose, prevote, precommit), the propose phase, validators wait synchronously for the proposer broadcast proposal, the rest two phases are completely asynchronous. better illustrate sabft's performance, experiment conducted with following limitations: test environment hardware parameter cpu cpu ram bandwidth gb/s limitations type parameter no. consensus nodes max bandwidth between two nodes kb/s block size no. blocks monitored the figure below shows the margin step blocks. the average the figure below shows the interval between two committed blocks. the average ms. the figure below shows the interval between block's generation time and its commit time. average, takes for block committed and this includes the block's generation time. how it's different sabft's block producing process and bft process are completely decoupled. i.e. validator can generate blocks despite the state the bft process. let's say the current block height and the bft process only committed the block with height validator can start generating the block without waiting for block committed. another significant difference that the bft process does't have reach consensus every block. the height difference two consecutive blocks that reached consensus called margin step. adjusted sabft automatically according the network condition and load the contentos chain. sabft can usually reach consensus every seconds, the margin step increases due heavier load, network traffic the presence byzantine nodes. behaviour propose: how choose proposer: new proposer chosen among all validators every bft voting round round-robin how pick proposal: proposer simply propose its head block commit: it's possible that block that about committed not the main branch, hence fork switch needed. self adaptation explained the case network jam, validators crash byzantine validators, block confirmation can delayed. the self adaptive mechanism makes sure that the system can quickly confirm the latest generated block later rounds. new proposer chosen among all validators every bft voting round round-robin. the proposer simply proposes the latest block knows, when it's confirmed, all the blocks before will confirmed too. the case network latency, other validators may not receive the proposed block its votes. validators always propose the latest block, bft consensus may not reached very long time. overcome this, block with smaller block number than the head block proposed consensus not reached several voting rounds. the bft process can considered state machine. the state consists height, round and step. step omitted here simplify the process. each height, one more rounds exist. round starts from each height and increases bft consensus not reached this round. indicates the current state height and round the following picture illustrates how sabft adjusts its bft process any the abnormal situations mentioned earlier occurs. block generated, meanwhile the bft process starts and the proposer proposed block soon t'(t<t'<t), consensus reached and block committed. block generated and it's proposed. however things get messy and consensus reached round before timeout. the state enters and block proposed. finally consensus reached block and block committed once. from things back normal and all blocks after block are committed within second. shown above the margin step height after that quickly drops worst case scenario according flp impossibility, asynchronous network, there's deterministic way achieve consensus with one faulty process. each round the bft process, there always exists critical failure like crash, network jam malicious nodes broadcast bad message which mess the vote process. theoretically there's situation where every single bft round ends with failure but the possibility decrease exponentially round grows. it's bit too paranoid worry about this. bottom line, there perfect way guarantee both safety and liveness. take safety our priority, the only thing need worried about that too many uncommitted blocks might eventually eat the memory resource. but can easily come with retention policy discard far out blocks, which out the scope this discussion. bad behaviour punishment technically abnormal behaviour can hold accountable long track enough information. here's some first thought: validators that are offline constantly absent from block producing bft voting should removed from validator set validators that has following behaviour should punished: generates conflicting blocks signs conflicting votes violates the pol voting rule constantly proposes invalid blocks parallel processing maximize the tps the system, parallel processing architecture introduced. data the system generalized combination property. property the minimum representation unit data. property considered independent each other and different properties can processed parallel. transaction can processed stages: decoding, reading, execution and writing. decoding stage generates evaluating function along with its dependent input and output properties. reading stage reads input properties from database. execution stage feeds evaluating function with input properties and gets values output properties. writing stage writes updated output properties database. can establish -stage parallel pipeline which database i/o occurs reading and writing stage only. when i/o blocks, decoding and execution can still make full use cpu resource. economic system the general representation asset contentos called cos, which can transferred among accounts. holding cos doesn't give users voting power. get more voting power, users can stake their cos and transfer cos vests, which cannot participate the monetary circulation process the system. user with more vests has more influence the system. the cos vests ratio always each time block generated, newly generated vests will partially put into the reward pool. the rest will assigned the block producer reward. the amount vest generated each block decided mathematic model, which can adjusted all the members the committee. block producers get the vests while dapp related users get the vests reward pool will given dapp developers. content creators get and commenters get .%. the reward content creator and commenter relies the following factors: reward pool:generating block cause inflation. the cos minted during this process will put into reward pool vote_power:a user's vote_power indicates how much the user's vote matters post's reward. user with higher vote_power upvotes post, the creator the post will get more reward. user's vote_power will decrease each time the user upvotes post and will increase time passes by. vote_power vest^k (credit_score^m) and are parameters, which are adjusted block producers. post_power how much vote_power post has accumulated total_vote_power:increase when user upvotes post, decrease when block generated. all posts and comments uploaded exactly days ago will rewarded. each post's reward is: post_power total_vote_power, where the total cos reward pool. the reward will added the total_vote_power, which will decrease about every time new block generated. transfer from cos vests called power and power down vice versa. power instant while power down takes about weeks complete. multiple power down inside account the same time not allow. resource consumption resource type network resource: broadcasting transaction consumes network resources, which calculated the size the transaction. cpu resource: when action smart contract invoked, cpu resource consumed. fee simplify the fee calculation network and cpu resource consumption, the above resource type converted stamina. user's stamina insufficient for network resource consumption the transaction he/she sent, the transaction will discarded without deducting stamina. the transaction invalid, stamina will deducted. stamina insufficient for the cpu resource consumption, the transaction will not executed. however the rest the user's stamina costed. how get stamina free stamina: each user has certain amount stamina that will regenerated daily. stake cos: user needs more stamina, he/she can stake cos get more vest. the more vest user has, the more extra stamina the user gets. specifically, the usage and regeneration stamina contentos calculated using exponential weighted moving average exponential weighted moving average: time ,the moving average: the potential moving average time the actual value time the weight. account system account name account name the unique identification account contentos. contains characters, each character has lower case letter digit number. contentos uses digital signature check authority. each user has pair pub/priv key. users must sign their messages with their private key and the receivers use public key verify the authenticities the messages. storage service contentos uses leveldb store data. the performance follows: initial dataset leveldb/key: int leveldb/key: string insert query update delete initial dataset leveldb/key: int leveldb/key: string insert query update delete initial dataset leveldb/key: int leveldb/key: string insert query update delete more details:db_benchmark high-performance, highly available database service implemented based leveldb and mem cache. provides transactional supports and fast roll back mechanism. smart contract and virtual machine the smart contracts contentos currently can only written c/c++ language. webassembly the virtual machine which these smart contracts run. supported actions smart contracts developed users will compiled into wasm byte codes which can deployed the blockchain. series apis are provided make the contract development eaiser. provides similar features erc standards. also the apis allows the contract developers post article, comment get statistics they care about. smart contracts can updated online that developer can hotfix bugs add new features. limitations the running time contract together with the cpu, ram, bandwidth resources can use limited maintain the stableness the system. security smart contracts are running sandbox called webassembly. the security model webassembly has two important goals: protect users from buggy malicious modules, and provide developers with useful primitives and mitigations for developing safe applications, within the constraints (). meanwhile, contentos will also conduct authority validation and resource check before and during the execution smart contract. smart contract api contentos provides plenty apis enable dapp developer write contracts with advanced features, which include but not limited to: any low-level operations like read/write from/to blockchian high-level operations like post articles comment cross-contracts interactions smart contract template make smart contract development and deployment much easier, new feature call smart contract template provided contentos. users can propose template, once adopted, other users with programming skills can also develop and develop their own contracts using the template. plugin plugin mechanism implemented contentos that users can develop their own plugin add new functionalities. currently, trxsqlservice statelogservice dailystatservice are provided for statistics purposes.