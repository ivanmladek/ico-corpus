grostl implementation guide krystian matusiewicz martin schlaffer and soren thomsen intel technology poland iaik, graz university technology dtu mathematics, technical university denmark march the current version can downloaded from http://www.groestl.info/groestl-implementation-guide.pdf abstract the grostl hash function finalist the sha- competition organized nist. this paper, describe number implementation techniques and tricks for grostl. they allow develop range efficient implementations for various platforms, from -bit microcontrollers modern desktop processors using -bit avx instructions. these results demonstrate the implementation flexibility the algorithm and hope will inspire further optimizations and ports other platforms. the information this paper will also useful for developers planning implement grostl efficiently the platform their choice. furthermore, believe also hardware implementations may benefit from the optimization techniques presented this paper. introduction the hash function grostl was designed candidate for the sha- competition [], organized the national institute standards and technology (nist). grostl was selected one five finalists the competition. grostl borrows components from the aes block cipher, which became united states federal government standard []. the aes known for its good performance wide variety platforms, which due large amount flexibility the choice implementation methods. recently, intel introduced instruction set extension for computing aes rounds [], which makes encryption using the aes cpus implementing this instruction set very efficient. although several underlying components grostl differ from the ones used the aes, grostl still enjoys many the same implementation benefits the aes. even the aes instruction set extension can used significantly speed grostl. this paper, describe various software implementation techniques for grostl suitable for platforms ranging from -bit microcontrollers processors with simd and aes instruction set extensions. all these implementations can downloaded from http://www.groestl.info/. description grostl the grostl hash function iterates underlying compression function variant the merkle-damgard construction where the size the state (or chaining value) passed from one iteration the next least twice large the final hash value. the final hash value computed from the last chaining value using output transformation. hence, grostl known wide pipe design. the compression function and the output transformation are based permutations using round transformations similar those the aes []. for the final round the competition, grostl was tweaked order increase its security margin. the initial submission called grostl-. the following, describe the components the (tweaked) grostl hash function more detail. the hash function grostl comes several variants with different output sizes. denote the number bits the output, and the variant returning bits denoted grostl-n. here, focus grostl- and grostl. variants returning less than bits differ from grostl- only the initial value and the final truncation produce the hash value. similarly, variants returning more than bits differ from grostl- the same two respects. the input message padded and split into blocks bits with for grostl, and for grostl-. the initial value the intermediate hash values and the permutations and are size bits well. (the exact definition the can found []). the message blocks are processed via the compression function (hi- which accepts two `-bit inputs and outputs `-bit value. after all message blocks have been processed, output transformation (ht applied which outputs the final n-bit hash value (hi- for bits. the output transformation after the last call the compression function, output transformation applied give the final hash value size (ht truncn (ht where truncn (x) discards all but the least significant bits the output transformation also shown figure figure the output transformation grostl. the permutation size bits and only the last bits are returned. the permutations two permutations and are defined for grostl. distinguish between the permutations grostl- and grostl- sometimes write where the size the permutations. each permutation, the four aes-like round transformations addroundconstant (ac), subbytes (sb), shiftbytes (sh), and mixbytes (mb) are applied the state the given order. the permutations differ only the constants used addroundconstant and shiftbytes, and their number rounds. grostl- has rounds and the -bit state permutation and viewed matrix bytes. one round one permutation grostl- shown figure for grostl-, rounds are used and the -bit state the two permutations and viewed matrix bytes. (a) grostl- (b) grostl- figure one round one permutation the grostl- and grostl- hash function. addroundconstant the addroundconstant (ac) transformation xors round-dependent constant one row the state. the constant and the row different for and additionally, round-independent constant xored every byte (we denote hexadecimal byte values two-character values sans serif font). the xor constants for round (where viewed hexadecimal digit and denotes the bit-wise complement are shown figure subbytes the subbytes (sb) transformation applies the aes s-box each byte the state. the definition this s-box can found []. shiftbytes shiftbytes (sh) cyclically rotates the bytes row the left s[r] positions with different values for and grostl- and grostl-. have the following rotation values: for grostl- for grostl- for grostl- for grostl- (a) (b) (c) (d) figure the xor constants added the addroundconstant transformation. s(x) figure subbytes substitutes each byte the state using the aes s-box. mixbytes mixbytes (mb) linear diffusion layer, which multiplies each column the state with constant, circulant matrix a-b*a where this matrix constants are elements the finite field defined the polynomial -bit value with binary representation then represented the following polynomial the finite field (x) the multiplication the field defined polynomial multiplication modulo the polynomial defining the field: (x) (y) mod (th section describes how the multiplications this field are carried out efficiently practice. (a) (b) (c) (d) figure the shift values used the shiftbytes transformation. figure the mixbytes transformation multiplies each column the state constant matrix introduction efficient implementation techniques this section give high-level overview common efficient implementation techniques for grostl. since grostl aes-based hash function, most implementation techniques developed for aes can applied grostl well. the main implementation techniques for grostl are the t-table implementation, bit slicing, and byte slicing. parallel byte slice implementation, either the intel aes-ni instruction the vperm technique can used compute the aes s-box. table list some benchmark results grostl current desktop processors. for details more processors refer ebash []. additionally, the byte slice implementation technique has also been used get efficient -bit implementations grostl. table shows some time-memory trade-offs for -bit avr implementations. t-table implementation daemen and rijmen have presented table-based approach for aes [], which efficiently computes the combined subbytes and mixcolumns transformation. the same approach can applied grostl. using this technique, least one table lookup needed for each s-box. the mixbytes transformation computed parallel for rows the state and can combined with the s-box lookup. this approach most efficient the column size matches the register size. this the case -bit platforms for aes and -bits platforms for grostl. since many current and future small-scale -bit processors also provide -bit instructions (mmx, neon), grostl can implemented very efficiently these platforms using the t-table approach. t-table implementations, the state grostl stored -bit registers column ordering (see figure the addroundconstant transformation can computed separately using -bit xors. the computation the subbytes, shiftbytes and mixbytes transformations are combined efficiently compute table grostl software performance current desktop processors sorted their speed cycles/byte (c/b). the byte slice implementations using aes-ni vperm outperform table-based implementations processors with -bit registers. hash function grostl- grostl-- grostl- processor intel core i-k amd phenom intel core duo intel core intel pentium intel core duo intel core i-k intel core duo amd phenom intel core intel pentium speed (c/b) (.) (.) (.) (.) technique aes-ni t-tables vperm (t-tables) vperm (t-tables) t-tables bit slicing aes-ni vperm (t-tables) t-tables vperm (t-tables) t-tables table speed three different grostl- -bit avr implementations cycles/byte atmega. grostl grostl- ram highspeed balanced lowmem one -bit column (e.g., column grostl follows: s(a s(a s(a s(a s(a s(a s(a s(a where the resulting -bit value the first column computation. the input bytes aij are extracted from the state according the shiftbytes transformation and the s-box s(x) applied these bytes prior the matrix multiplication mixbytes. expanding the matrix multiplication then gives: s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a s(a which simplifies where the tables (x) contain -bit lookups the s-box together with the multipliers mmx mmx mmx mmx mmx mmx mmx mmx mmx mmx mmx mmx mmx mmx mmx mmx figure for the t-table approach, the grostl- state stored column-wise -bit registers. mixbytes. for example, for the first table get: (x) s(x) s(x) s(x) s(x) s(x) s(x) s(x) s(x) extracting single byte from word can implemented using bit-shift and masking (logical and) instruction. then, the computation one column consists only table lookups, xor xor for mb, xor for ac), shift and and instructions. some platforms, single bytes aij can extracted from -bit column words cost. this case, can save (some of) the shift and and instructions. the same t-table approach can also used for efficient implementations -bit processors. this case, split the computation into upper part and lower part. need split the tables into one table storing the upper bits and one table storing the lower bits. due the cyclic structure the mixbytes transformation matrix, the tables can reused lookup also the lower bits since have t(i+) mod hence, get with byte slice implementation another option implement grostl byte-wise parallel computation columns. all round transformations except shiftbytes and addroundconstant apply exactly the same computation each column the grostl state independently. therefore, can use single instruction multiple data (simd) approach compute these identical operations more than one column the same time. call this byte slice implementation since the grostl state cut into column slices bytes. the state stored row ordering. using w-bit registers, columns can computed parallel (see figure this approach most efficient for small (-bit) and large register sizes (-bit and more). requirement for this approach efficient that all round transformations grostl can parallelised using only few w-bit simd instructions. addroundconstant and mixbytes can computed parallel simply using basic alu instructions. for shiftbytes need byte shuffling instruction some mask and rotate instructions. the most difficult round transformation parallelise the -bit table lookup subbytes. however, using the intel aes new instructions extension (aes-ni) the vector-permute xmm xmm xmm xmm xmm xmm xmm xmm figure for the simd implementation, the grostl- state stored row-wise xmm registers compute each column times parallel. (vperm) approach hamburg [], parallel aes s-box table lookups can performed efficiently. moreover, the fastest grostl implementation byte slice implementation using aes-ni. for further details, how the round transformations can implemented, refer section byte slice implementation, need use row-ordering the grostl state. however, the input bytes the message are mapped the grostl state column-ordering. the column-ordering benefit for t-table based implementations but drawback for byte slice implementations. reduce the state transformation costs, the internal state kept row-ordering throughout the whole computation. then, only need transform each input message block and the hash function output the end (the can stored already row-ordering). transforming the input message from column-ordering into row-ordering corresponds transposing the state matrix the input message block. many algorithms for transposing matrix are known and square matrix can transposed using only few instructions. bit slice implementation the fastest aes software implementations are bit slice implementations running cycles/byte intel core multiple blocks are encrypted parallel counter mode []. also the hash function whirlpool which shares some similarities grostl has been implemented efficiently using bit slicing techniques []. preliminary assembly implementations grostl- show speed cycles/byte intel core duo processor for the computation the hash single message []. additionally, bit slice implementations grostl- get even more efficient two more messages are hashed parallel []. implementing grostl round transformations this section list common techniques efficiently implement the individual grostl round transformations. the listed techniques can used various platforms using different word sizes, well hardware and software. most cases also special optimization techniques which combine round transformations may lead better results some platforms (also see sections and .). addroundconstant the addroundconstant transformation consists xors bytes the state with constants. most cases, these constants will stored using the same data structures and ordering conventions the state itself, which case the xors are simply carried out word word. one may exploit the fact that the constants used correspond complementation each byte, followed xor with the same constants those used note, however, that these constants are xored the bottom row instead the top row (as subbytes the subbytes transformation most simply implemented -bit table lookup. however, since the transformation corresponds inversion the finite field followed affine transformation, some scenarios more efficient implement via computation. the most efficient known way compute the aes s-box using the formulas canright []. originally developed for compact hardware implementations, canright's formulas can also used for the efficient computation the aes s-box software. the fastest known aes implementation uses these formulas compute the s-box bit slice mode []. second efficient method compute the aes s-box has been proposed hamburg []. this approach, the inverse the aes s-box computed using small log tables the finite field small log tables can efficiently implemented using byte shuffling instructions. using registers containing bytes, -to- bit table lookup can performed. for more details this implementation refer the original publication []. the third possibility compute subbytes using the intel aes new instructions extension (aes-ni) the instruction set []. this extension includes number instructions for computing aes rounds. the instruction aesenclast, example, computes the last round aes (without any key additions), which means computes the transformations subbytes and shiftrows. hence, this instruction available, can used compute parallel aes s-box lookups. reduce the number byte shuffling instructions, the computation shiftrows aesenclast can combined with the computation shiftbytes. shiftbytes the shiftbytes transformation simply moves bytes around within row. hence, this transformation can often computed implicitly simply changing the addressing bytes. implementation modern desktop processor might store rows the state -bit -bit word. this case, the shiftbytes transformation can implemented via simple byte shuffling instruction. mixbytes mixbytes consists multiplication each column the state constant matrix all multiplications and additions needed compute this transformation are done the finite field defined the polynomial hexadecimal notation). there are many ways compute mixbytes and depends the hardware and cpu features which variant most efficient. the following, explain the most important techniques. table-based implementation the most efficient way implement mixbytes using precomputed t-tables (also see section especially since this case, the table lookups for mixbytes can also combined with those the s-box. the t-table approach, the effect each state byte one column bytes) precomputed and stored table -bit entries. for each input byte one column, need separate table. then, e.g. the first column can computed follows: where the tables (x) contain -bit lookups the s-box together with the multipliers mixbytes. table precomputed follows: (x) s(x) s(x) s(x) s(x) s(x) s(x) s(x) s(x) using this method, one column mixbytes including one column subbytes can computed using only table-lookups and -bit xor operations. however, need more instructions for shiftbytes since byte values have extracted from -bit words. furthermore, the t-table approach not resistant against cache-timing and table lookups are still the bottleneck most current processors. using double-and-add mixbytes can also computed using repeated double-and-add operations. then, only need xor and efficiently multiply (see section ..). for example, the multiplication can then carried out performing using only double-and-add operations, get the following formulas compute each output byte given the input bytes single column: (ai+ ai+ ai+ ai+ ai+ ai+ ai+ ai+ ai+ ai+ ai+ ai+ ai+ where and all the indices are taken modulo simply implementing this formula would require multiplications and xors. however, the number xors can significantly reduced least (see section and section ..). the multiplication the finite field the doubling operation (where -bit value) can implemented using left shift one, followed conditional xor using the irreducible polynomial overflow occurs. when operating bytes, the msb usually discarded the shift. hence, first check whether the msb set and conditionally xor the constant after the shift. worth note that some cases the condition can also checked efficiently treating the byte signed value and comparing zero. two's complement representation used, the most significant bit only set the value negative. minimising the number xors taking look equation can observe that there are many terms the form ai+ repeatedly computing temporary results tree-based form, get optimised way computing mixbytes using the following set formulas: ai+ xi+ xi+ ai+ yi+ zi+ zi+ these formulas contain minimum number multiplications and only xor operations. furthermore, the computations are more independent, which allows better parallelism superscalar cpus. for example, computing independent from any other where and the same true for the remaining temporary and final values. computing the multiplication first sometimes (see section .), can more efficient first compute the multiplication and all input values ai+ ai+ ai+ ai+ ai+ ai+ ai+ ai+ ai+ ai+ ai+ ai+ ai+ this case, the previous optimization cannot applied. however, still possible minimize the number xor operations this case well. since many terms (ai the computation are added more than one result, can save xors computing temporary results again. for example, the term added and can save many xor operations computing such temporary results first. the reuse such temporary results has been optimized (see table these equations result multiplications and xor operations. table mixbytes computation with xors. "*" denotes those inputs (ai which are added get the results superscripts denote the order which the temporary results are computed corresponds the temporary results equation other possible optimisations another possibility reduce the computation costs mixbytes use different basis multipliers. instead calik used his implementation the basis []. this case, the hamming weight the multiplication constants reduces significantly. unfortunately, this basis does not result less than xors and needs multiplications well. platforms where many registers are available and multiplications are cheap, can advantage compute the results each multiplier separately []. this case, the results bi, multiplier can reused compute those for multiplier since bi, bi+ mod (see table for multipliers and (bi, temporary results are used further minimize the number xors. this approach results multiplications and xors. t-table implementations this section present some example implementations which use the t-table approach for grostl. this implementation technique most efficient -bit platforms. -bit platforms, the number necessary instructions double. the following listing, provide unoptimized code segment for the computation one round permutation grostl-: sb+sh+mb (column t[(a>> t[(a>> t[(a>>) t[(a>>) t[(a>>) t[(a>>) t[(a>>) t[(a>>) sb+sh+mb (column t[(a>> xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; t[(a>>) t[(a>>) t[(a>>) t[(a>>) t[(a>>) t[(a>>) t[(a>> sb+sh+mb (column t[(a>>) t[(a>>) t[(a>>) t[(a>>) t[(a>>) t[(a>>) t[(a>> t[(a>> sb+sh+mb (column t[(a>>) t[(a>>) t[(a>>) xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; t[(a>>) t[(a>>) t[(a>> t[(a>> t[(a>>) sb+sh+mb (column t[(a>>) t[(a>>) t[(a>>) t[(a>>) t[(a>> t[(a>> t[(a>>) t[(a>>) sb+sh+mb (column t[(a>>) t[(a>>) t[(a>>) t[(a>> t[(a>> xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; xff]; t[(a>>) t[(a>>) t[(a>>) sb+sh+mb (column t[(a>>) t[(a>>) t[(a>> xff]; xff]; xff]; xff]; xff]; xff]; t[(a>> t[(a>>) t[(a>>) t[(a>>) t[(a>>) sb+sh+mb (column t[(a>>) xff]; xff]; xff]; xff]; xff]; xff]; t[(a>> t[(a>> t[(a>>) t[(a>>) t[(a>>) t[(a>>) t[(a>>) xff]; xff]; xff]; xff]; xff]; xff]; xff]; number optimized implementations have been published for grostl. the most important ones are the implementations submitted nist the designers and the crypto library sphlib. []. although sphlib not fully optimized (e.g. the round constants are added byte-by-byte), has good performance many constrained (-bit) devices. the following, present optimized assembly implementations few example platforms which can serve reference for further t-table optimizations. -bit processors t-table implementation grostl -bit processors needs table lookups, xor, and most shift and and instructions per column computation (see section however, cpus, can reduce the alu instructions xor, mov and shift instructions per column follows. let rax contain column where the least significant bits correspond the top byte. now, the following two instructions each extract one byte out rax: movzbl edi, movzbl esi, put least sig. byte (row edi put second-least sig. byte (row esi after this, edi used index lookup table esi used index lookup table (since shiftbytes will move column the results are stored (or xored to, for subsequent bytes) the new columns and then, the register rax shifted bits the right. hence, next time carry out the above two instructions again, edi will contain the byte row and esi will contain the byte row note that work two columns the same time order maximize instruction level parallelism. intel desktop processors prior the sandy bridge architecture have one memory load and one store units and three arithmetic logic units (alus). this implies that the load instructions are dominant, and the maximal throughput cycle/byte for each round grostl. this results cycles/byte for grostl- and cycles/byte for grostl-. the results given table show that the speed grostl very close this bound the intel core duo processor. since amd opteron and intel sandy bridge processors have two memory load units, two parallel table lookups are possible within each cpu cycle. assuming that single bytes can extracted efficiently using one instruction, get cycles/byte for the loads and )// cycles/byte for the alu instructions. hence, the alu instructions are dominant and get lower bound cycles/byte for grostl- and cycles/byte for grostl-. however, these ideal results are difficult achieve practice and our implementations are not approaching the theoretical lower bounds yet (see table -bit processors since the number table lookups and xors double for the -bit t-table implementation, get lower bound cycles/byte for grostl- and cycles/byte for grostl- parallel table lookups are possible. however, many current and future -bit processors have -bit instruction set extensions such mmx for intel/amd processors and neon for arm processors []. using these extended instructions, can get speed close cycles/byte also -bit cpus. similar improvement can expected from new neon implementations. simd-based byte slicing implementations this section describe few concrete examples the byte slicing implementation grostl. chose present implementation intel- platform with ssse instruction set example popular, modern desktop-class cpu. show implementation taking advantage the aes-ni instruction set present intel core and sandy bridge processors. byte sliced implementation with aes-ni instructions currently the fastest grostl implementation intel platforms. also discuss the vperm implementation, alternative for processors not equipped with aes-ni instructions. this case, the subbytes transformation can still implemented efficiently using only generic ssse instructions. transposing the input message transforming the input message from column-ordering into row-ordering corresponds transposing the input message block. many algorithms for transposing matrix are known and square matrix can transposed using only few punpck instructions []. store the whole grostl- state and -bit registers, get rectangular matrix. hence, additional byte shuffling (pshufb) and move (mov) instructions are needed transpose the input message []. using aes-ni this section describe the details the fastest known grostl implementation using the intel aes-ni extension. together with intel avx instructions speed less than cycles/byte can reached. pxor xmm, [const] pxor xmm, [const] pxor xmm, [const] pxor xmm, [const] pxor xmm, [const] pxor xmm, [const] pxor xmm, [const] pxor xmm, [const] (with aes shiftrowsinv) pshufb xmm, [sigma] pshufb xmm, [sigma] pshufb xmm, [sigma] pshufb xmm, [sigma] pshufb xmm, [sigma] pshufb xmm, [sigma] pshufb xmm, [sigma] pshufb xmm, [sigma] (with aes shiftrows) pxor xmm, xmm aesenclast xmm, xmm aesenclast xmm, xmm aesenclast xmm, xmm aesenclast xmm, xmm aesenclast xmm, xmm aesenclast xmm, xmm aesenclast xmm, xmm aesenclast xmm, xmm (y_i a_{i+}) movdqa xmm, xmm"); movdqa xmm, xmm"); movdqa xmm, xmm"); movdqa xmm, xmm"); movdqa xmm, xmm"); movdqa xmm, xmm"); movdqa xmm, xmm"); movdqa xmm, xmm"); (t_i a_i a_{i+}) pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); (y_i a_{i+} t_i) pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); (y_i y_i t_{i+}) pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); movaps [tmp_y], xmm"); movaps [tmp_y], xmm"); (x_i t_i t_{i+}) movdqa xmm, xmm"); movdqa xmm, xmm"); movaps [tmp_t], xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, [tmp_t]"); (z_i x_i) movaps xmm, [all_b]"); mul(a, b); mul(a, b); mul(a, b); mul(a, b); mul(a, b); mul(a, b); mul(a, b); mul(a, b); (w_i z_i y_{i+}) pxor xmm, [tmp_y]"); pxor xmm, [tmp_y]"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); (v_i w_i) mul(a, b); mul(a, b); mul(a, b); mul(a, b); mul(a, b); mul(a, b); mul(a, b); mul(a, b); (b_i v_{i+} y_{i+}) pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); pxor xmm, xmm"); movaps xmm, [tmp_y]"); movaps xmm, [tmp_y]"); pxor xmm, xmm"); pxor xmm, xmm"); addroundconstant the addroundconstant transformation xors round-dependent row-wise constant the first row and the last row and round-independent constant each row since the grostl state stored row-ordering, these constants can added efficiently parallel each column the state. for example, the constants grostl- are added follows: movaps pxor pxor pxor pxor pxor pxor pxor pxor xmm, xmm, xmm, xmm, xmm, xmm, xmm, xmm, xmm, [xffffffffffffffff] [round_const_p] xmm xmm xmm xmm xmm xmm [round_const_q] subbytes subbytes usually the most difficult transformation implement efficiently byte slice implementation. already mentioned, for w-bit registers need efficient method compute parallel aes s-box lookups. this results only one (parallel) table lookup the case -bit implementations unfortunately, for larger register sizes, parallel table lookups are usually non-trivial. although grostl does not use the same mds matrix the aes, grostl can still take advantage the intel aes new instructions extension (aes-ni). since mixcolumns transformation applied the last round the aes, intel also provides aesenclast instruction. this instruction able compute aes s-boxes parallel with throughput one cycle and latency cycles. the byte shuffling the aesenclast instruction can combined with extra byte shuffling perform the shiftbytes transformation grostl (see section ..). shiftbytes since shiftbytes just moves bytes within one row grostl, this transformation can implemented using only byte shuffling instructions. aesenclast used compute the s-box lookups, need take the shiftrows transformation the last round aes into account. note that any shiftbytes rotation constants can used for and additional cost. the resulting instructions for the combined subbytes and shiftbytes transformation grostl- given below: pxor pshufb aesenclast pshufb aesenclast pshufb aesenclast pshufb aesenclast pshufb aesenclast pshufb aesenclast pshufb aesenclast pshufb aesenclast xmm, xmm, xmm, xmm, xmm, xmm, xmm, xmm, xmm, xmm, xmm, xmm, xmm, xmm, xmm, xmm, xmm, xmm [adcfbe] xmm [cfabed] xmm [ecdbfa] xmm [befadc] xmm [cfbead] xmm [beadcf] xmm [dbcfae] xmm [fadecb] xmm mixbytes the mixbytes transformation the most costly transformation byte sliced implementation grostl. need combine the rows the grostl state according the mixbytes matrix multiplication. for processors that can execute more than one simd instruction parallel, mixbytes computation with the minimum number instructions does not necessarily result the fastest implementation. for example, modern desktop cpus can compute three independent simd xors parallel. however, when the mixbytes computation contains many long chains dependencies, the alu parallelism cannot fully utilised. compute mixbytes using simd instructions, use the formulas section ... this variant contains the minimal possible number multiplications and xors, and the computations are also mostly independent. illustrate this approach details, consider the implementation mixbytes using equations intel- architecture with sse instructions. order closer reflect the constraints the assembler code, rewrite the last equation contain only one type operation each pass. this yields the following sequential formulas: ai+ ai+ ti+ ti+ yi+ vi+ yi+ the main challenge minimise the number register spills when performing the computation xmm registers and reorder instructions way ensuring maximal instruction throughput. the algorithm shown table achieves this with only four spills that are not critical path and therefore can masked other operations. start with registers xmm,. xmm and keep building xmm,. ,xmm. the byte-wise multiplication the content xmm{i} done the sequence five instructions pxor pcmpgtb paddb pand pxor xmm{j}, xmm{j}, xmm{i}, xmm{j}, xmm{i}, xmm{j} xmm{i} xmm{i} xmm{k} xmm{j} clear register comparing with sets xff bytes that correspond msb bits set byte-wise shift left one position pick only those that correspond msb bit set xmm{i} and xor reduction polynomial the result where necessary that requires extra register xmm{j} scratch space and xmm{k} containing the constant reduction value bb...b. get those extra registers, can temporarily spill xmm, xmm since they hold the values which will not used critical path the computation. when avx instructions are available (starting from intel sandy bridge) can use three-operand instructions reduce the number instructions required the multiplication four, but the advantage smaller than one instruction since sandy bridge cores recognize xoring clear register and not issue uops that case anyway. using vperm even aes-ni are available, can still implement grostl efficiently using simd instructions. just need different method parallelize the s-box lookups subbytes. one such method has been proposed hamburg and uses vector permute (vperm) instructions compute the inversion and affine transformation the aes s-box. the following, describe grostl implementation using the vperm idea. the resulting implementation needs least ssse instructions and thus, also runs the nist reference platform. the resulting speed comparable with the t-table implementation. table optimised computation mixbytes intel- machine with sse instructions. each row describes eight operations for left columns show the content two banks registers with updated values shown bold and the rightmost column describes the performed operation. mul(xmma,xmmb,xmmc) doubles the content xmma using xmmb scratch and assuming xmmc contains b..b. xmm xmm xmm xmm b..b b..b b..b b..b operation equation movdqa xmm{i xmm{(i mod pxor xmm{i}, xmm{(i mod pxor xmm{i xmm{(i mod pxor xmm{i xmm{(i mod spill memory this computation: pxor xmm{i}, xmm{(i mod spill xmm, xmm memory, xmm- xb...b mul(xmm{i}, xmm, xmm) pxor xmm{i}, xmm{(i )}, from memory mul(xmm{i}, xmm, xmm) reload back xmm, xmm pxor xmm{i xmm{(i mod ai+ ai+ ti+ ti+ yi+ vi+ yi+ the state stored row-ordering and hence, the input transformation the message block can performed described section the following, the computation subbytes and mixbytes are somewhat merged. therefore, swap the order addroundconstant and shiftbytes for easier description. addroundconstant the addroundconstant implementation can implemented exactly using the same instructions the aes-ni implementation. however, since the vperm implementation uses different basis, the constants need transformed this basis well. the resulting constants can precomputed and stored memory well. for the specific constants, refer the actual vperm implementation grostl. shiftbytes shiftbytes computed using single byte shuffle instructions for each row and for example, the used rotation constants for the pshufb instruction grostl- are given the following assembly code listing: pshufb pshufb pshufb pshufb pshufb pshufb pshufb pshufb xmm, xmm, xmm, xmm, xmm, xmm, xmm, xmm, [xfedcba] [xafedcb] [xcbafed] [xedcbaf] [xfedcba] [xfedcba] [xbafedc] [xdcbafe] subbytes the vperm implementation, the inverse the aes s-box computed using small log tables the finite field efficiently compute these log tables, the -bit pshufb instruction ssse used -to- bit lookup table. for more details, refer the original paper []. the first vperm implementation has been published calik which served reference for our optimized implementation. using the vperm implementation, aes s-boxes can computed parallel within less than cycles. additional advantage this implementation that can multiply the resulting outputs constants almost without additional cost. hence, the vperm implementation subbytes actually returns the values s(xi s(xi and s(xi for each the input bytes mixbytes since the multiplication and the input bytes mixbytes are already computed subbytes, the formulas resulting only xors section cannot used. however, can use the method section which minimizes the number xors once the multiplications have already been performed. note that this approach still more efficient since the multiplications are much more expensive computed using instructions each (see section ..) than the additional xors. conclusions this paper, have shown the details the currently best known grostl implementations. using aesni extensions and avx instructions, are able implement grostl- with close cycles/byte. furthermore, the design grostl also provides many possibilities for efficient implementation techniques. have presented the most important methods and hope that they will serve inspiration for further optimizations. especially the vperm implementation has some room for improvements, cpus well new platforms. for example, neon byte permute instructions can used speed-up grostl new arm platforms. references aoki, roland, sasaki, and schlaffer. byte slicing grostl optimized intel aes-ni and -bit implementations the sha- finalist grostl. lopez and samarati, editors, secrypt proceedings, pages scitepress, arm limited. neon, march available online: http://www.arm.com/products/processors/ technologies/neon.php. bernstein and lange. ebash: ecrypt benchmarking all submitted hashes, january available online: http://bench.cr.yp.to/ebash.html. calik. multi-stream and constant-time sha- implementations. nist hash function mailing list, december retrieved may from http://www.metu.edu.tr/~ccalik/software.html# sha. canright. very compact s-box for aes. rao and sunar, editors, ches, volume lncs, pages springer, daemen and rijmen. aes proposal: rijndael. nist aes algorithm submission, september available online: http://csrc.nist.gov/archive/aes/rijndael/rijndael-ammended.pdf. damgard. design principle for hash functions. brassard, editor, advances cryptology crypto proceedings, volume lecture notes computer science, pages springer, gauravaram, knudsen, matusiewicz, mendel, rechberger, schlaffer, and thomsen. grostl sha- candidate. submission nist (round available: http: //www.groestl.info (//). gueron and intel corp. intel advanced encryption standard (aes) instructions set, retrieved december from http://software.intel.com/en-us/articles/ intel-advanced-encryption-standard-aes-instructions-set/. hamburg. accelerating aes with vector permute instructions. clavier and gaj, editors, ches, volume lncs, pages springer, intel corporation. using mmx instructions transpose matrix, available online: ftp: //download.intel.com/ids/mmx/mmx_app_transpose_matrix.pdf. intel corporation. intel advanced encryption standard instructions (aes-ni), march available online: http://software.intel.com/en-us/articles/ intel-advanced-encryption-standard-instructions-aes-ni/. intel corporation. pentium processors with mmx technology, march available online: http: //edc.intel.com/platforms/previous/processors/pentium-mmx/. kasper and schwabe. faster and timing-attack resistant aes-gcm. clavier and gaj, editors, ches, volume lncs, pages springer, merkle. one way hash functions and des. brassard, editor, advances cryptology crypto proceedings, volume lecture notes computer science, pages springer, national institute standards and technology. fips pub advanced encryption standard. federal information processing standards publication u.s. department commerce, november available online: http://www.itl.nist.gov/fipspubs. national institute standards and technology. fips pub advanced encryption standard (aes). federal information processing standards publication u.s. department commerce, november national institute standards and technology. cryptographic hash project, available online http://www.nist.gov/hash-competition. pornin. sphlib (//). available: http://www.saphir.com/sphlib/files/sphlib-..zip scheibelhofer. bit-slice implementation the whirlpool hash function. abe, editor, ct-rsa, volume lncs, pages springer, tillich. personal communication, another mixbytes computation variant table the mixbytes computation separated for factors and denote the input bytes and bi, bi, bi, are the output bytes. "*" marks those inputs (ai which are added get the intermediate results bi,j superscripts denote the order which temporary values are computed. the results for factor are computed multiplying the results factor where bi, bi+ mod