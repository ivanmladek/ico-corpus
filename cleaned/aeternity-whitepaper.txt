aeternity blockchain the trustless, decentralized and purely functional oracle machine january zackary hess zack@aeternity.com yanislav malahov yani@aeternity.com iii abstract-- since the introduction ethereum there has been great interest decentralized trustless applications (smart contracts). consequently, many have tried implement applications with real world data top blockchain. believe that storing the application's state and code on-chain wrong for several reasons. present highly scalable blockchain architecture with consensus mechanism which also used check the oracle. this makes the oracle very efficient, because avoids layering one consensus mechanism top another. state channels are integrated increase privacy and scalability. tokens channels can transferred using purely functional smart contracts that can access oracle answers. not storing contract code state on-chain, are able make smart contracts easier analyze and faster process, with substantial loss facto functionality. applications like markets for synthetic assets and prediction markets can efficiently implemented global scale. several parts have proof-of-concept implementations erlang. development tools and application essentials such wallet, naming and identity system will also provided. applications iii-a blockchain essentials iii-a. identities iii-a. wallet iii-a. proof existence iii-b state channel applications iii-b. toll api iii-b. insured crowdfunding iii-b. cross-chain atomic swaps iii-b. stable value assets and portfolio replication iii-b. event contracts iii-b. prediction markets iii-b. market with batch trading single price implementation iv-a virtual machine and contract language iv-b adoption via web-integration iv-c open source modules iv-d usability and design discussion v-a limitations and tradeoffs v-a. on-chain state v-a. free option problem v-a. liquidity loss and state channel topologies v-b future work v-b. functional contract language v-b. multi-party channels ontents introduction i-a previous work aeternity blockchain ii-a tokens, accounts and blocks ii-a. access token, aeon ii-a. accounts ii-a. name system ii-a. block contents ii-b state channels ii-b. smart contracts ii-b. example ii-c consensus mechanism ii-c. oracles ii-d governance ii-e scalability ii-e. sharding trees ii-e. light clients ii-e. state channels and parallelism ii-e. transactions per second given memory requirement jack pettersson jack@aeternity.com ntroduction the intention this paper give overview the aeternity blockchain architecture and possible applications. more detailed papers will released the future, specifically for the consensus and governance mechanisms. however, should noted that our architecture holistic; all components tie together and synergize, modular way. the rest this paper broken into four parts. first, will introduce and discuss the fundamental theoretical ideas that inform our architecture. second, will discuss the included essential applications, other possible use cases and give intuitions for how use the platform developer. third, will present the current proof-of-concept implementation, written erlang. conclude with discussion, including possible future directions and comparisons other technologies. become independent and can thus processed parallel. additionally, this means that contracts never write shared state, greatly simplifying their testing and verification. believe that this design emphasizes that blockchains are about financial logic rather than data storage; there exist decentralized storage solutions that complement blockchains perfectly. second, applications such augur have attempted bring real-world data onto the blockchain decentralized way--in the process essentially building consensus mechanism inside smart contracts [], instead utilizing the consensus mechanism the underlying blockchain. this leads inefficiencies but doesn't increase security. the natural conclusion from this generalize the blockchain's consensus mechanism that can provide information not only the next internal state, but also the state the external world. could thus argued that the blockchain's consensus mechanism determines the result running what complexity theory dubs oracle machine: theoretical machine that more powerful than turing machine because has answers some questions that can't necessarily computed, such "who won football game x?" [need cit.] third, seems natural that the consensus mechanism could also used determine the parameters the system. this allows adapt changing external conditions, well adopting new research and recent developments the field. the rest this section introduces the aeternity blockchain greater detail, starting with brief overview accounts, tokens, names and the structure blocks. this followed explanation our approach state channels and smart contracts, and then discussion how the blockchain's consensus mechanism can used both create efficient oracle mechanism and govern the system. finally, discuss scalability from several different angles. previous work blockchains, first all bitcoin, have shown new way architect value exchange the internet []. this has been followed number promising advances: ethereum demonstrated way write turing-complete smart contracts secured blockchain architecture []; truthcoin created tools for making oracles blockchains [], while groupgnosis and augur showed how make them more efficient []; casey detrio showed how make markets blockchains []; namecoin showed how make the distributed equivalent domain name server []; factom showed how blockchain that stores hashes can used proof existence for any digital data []. these technologies show great promise when comes providing first-class financial and legal services anyone. far however, they have failed come together unified whole that actually fulfills the promise. specifically, all solutions far have been lacking least one the following respects: governance, scalability, scripting safety and cheap access real-world data [need cit.] aeternity aims improve the state the art all these respects. ii. ternity blockchain believe that the lack scalability, scripting safety and cheap access real-world data current "smart contract platforms" come down three core issues. first, the currently prevailing stateful design makes smart contracts written for the platform hard analyze and statefulness combined with sequential transaction ordering complicates scalability [need cit.] second, the high cost bringing realworld data into the system decentralized, trustless and reliable way complicates outright prevents the realization many promising applications [need cit.] third, the platforms are limited their abilities update themselves, order adapt new technological economical knowledge. believe that each these three problems have clear solution paths that should explored. first, recent research into state channel technology suggests that for many use cases, keeping state on-chain not necessary [need cit.] very often entirely possible store all information state channels, and only use the blockchain settle any economic results the information exchange, and fallback the case dispute. this suggests alternative approach blockchain architecture which turing-complete smart contracts exist state channels but not on-chain. this increases scalability since all transactions tokens, accounts and blocks despite being "stateless" from the contract developer's point view, the aeternity blockchain keeps track several predefined state components. will now explain these, well the content each block. for simplicity, this section assumes that every node keeps track the whole blockchain. possible optimizations are described section ii-e. a.) access token, aeon: use the blockchain not free, but requires that the user spends token called aeon. aeon are used payment for any resources one consumes the platform, well the basis for financial applications implemented the platform. the distribution aeon the genesis block will determined smart contract hosted ethereum. further aeon will created via mining. all system fees get paid with aeon, all smart contracts settle aeon. a.) accounts: each account has address and balance aeon and also nonce which increases with every transaction and the height its last update. each account the difficulty analyzing stateful contracts was very clearly demonstrated the re-entrance bug that brought down "the dao". this happened despite the code having been audited several ethereum's creators well the general community [need cit.] also has pay small fee for the amount time open. the costs creating and keeping accounts prevents spam and disincentivizes state-bloat. the reward for deleting accounts incentivizes the reclaiming space. a.) name system: many blockchain systems suffer from unreadable addresses for their users. the vein aaron swartz' work and namecoin, aeternity features name system that both decentralized and secure, while still supporting human-friendly names []. the blockchain's state includes mapping from unique human-friendly strings fixed-size byte arrays. these names can used point things such account addresses aeternity, hashes e.g. merkle trees. a.) block contents: each block contains the following components: macro gold fefbaadbfe gold oracle else end fig. simple contract encoding bet the price gold. the language used the forth-like chalang, which will presented section iv-a. fit that any transactions related channels can processed parallel, greatly improving transaction throughput. the blockchain only used settle the final outcome resolve conflicts that arise, roughly analogous the judicial system. however, because the blockchain's behavior will predictable, there gain disputing the intended result state channel; malicious actors are incentivized behave correctly and only settle the final state the blockchain. all taken together, this increases transaction speed and volume several orders magnitude, well privacy. b.) smart contracts: despite that the only state that can settled on-chain transfer aeon, aeternity still features turing-complete virtual machine that can run "smart contracts". contracts aeternity are strictly agreements that distribute funds according some rules, which stands stark contrast the entity-like contracts e.g. ethereum. two the more notable practical differences that default, only the involved parties know about given contract, and only parties that have open state channel can create valid contract. the parties agree contract, they sign and keep copies for future reference. only submitted the blockchain its outcome disputed, which case the code only ever stored part the submitted transaction, never any other state. this happens, the blockchain distributes the tokens according the contract and closes the channel. example, fig. shows very simple contract that encodes bet the price gold certain time. line the macro gold saves the identifier the oracle question, which will return true the price gold below $/g december st, the body the contract displayed lines first push the gold oracle's identifier the stack and call using oracle, which will leave the oracle's answer the top the stack. use this conditional branching: the oracle returns true, push and the stack, indicating that aeon should burned and aeon should the first participant the channel. otherwise, push and with the second indicating that the other participant receives all aeon the channel. finally push which taken the nonce this channel state. actual usage, the nonce would generated deployment. one important thing note that contracts aeternity don't maintain any state their own. any state maintained the transacting parties and submitted input execution. every contract essentially pure function that takes some the hash the previous block. merkle tree transactions. merkle tree accounts. merkle tree names. merkle tree open channels. merkle tree oracles which haven't answered their respective questions. merkle tree oracle answers. merkle tree merkle proofs. the current entropy the random number generator. the hash the previous block required maintain ordering the blockchain. the transaction tree contains all transactions that are included the current block. with the exception the consensus vote tree, all the trees are fully under consensus: tree changed from one block the next, this change has due transaction the new block's transaction tree, and merkle proof the update has included the block's proof tree. the purpose the three remaining trees will hopefully become clear the following sections. state channels one the most interesting developments the blockchain space lately that state channels. they operate the basic principle that most cases, only the people affected transaction need know about it. essence, the transacting parties instantiate some state blockchain, e.g. ethereum contract bitcoin multisig. they then simply send signed updates this state between each other. the key point that either one them could use these update the state the blockchain, but most cases, they don't. this allows for transactions conducted fast information can transmitted and processed the parties, instead them having wait until the transaction has been validated--and potentially finalized-- the blockchain's consensus mechanism. aeternity, the only state update that can settled the blockchain transfer aeon, and the only aeon that can transferred are the ones that the transacting parties already deposited into the channel. this makes all channels independent from each other, which has the immediate bene hashlock swap hash macro commitment adefac fig. commitment hashlock call state else state end call simple hashlock. fig. simplified example using the hashlock play multi-player game channels. macro commitment adefac commitment hashlock call else end defined the function state, and want trustlessly simultaneously update all the channels state when the game manager reveals the secret, causes all the channels update the same time. metered execution: contract execution metered way similar ethereum's "gas", but aeternity uses two different resources for its metering, one for time and one for space. both these are paid for using aeon the party that requests the execution. this could seen undesirable, because probably another party that causing the need for the blockchain resolve the dispute the first place. however, long all money the channel not used for betting, this can effectively nullified the contract code, since has the ability redistribute funds from one party the other. fact generally good practice avoid using all funds channel transact, because disincentivizes the losing party cooperate when closing the channel. b.) example: let's bring all these ideas down earth. practice, alice and bob want transact using state channel aeternity, they through the following procedure: fig. using the hashlock trustlessly send tokens through middleman. input and gives new channel state output the benefits using pure functions software development general, and the development financial applications particular, has been extensively documented academia and industry for decades [][need cit.] contract interaction and multi-step contracts: even though all contracts are stateless and execute independently each other, contract interaction and statefulness can still achieved through hashlocking [need cit.] simple hashlock shown fig. line define function called hashlock that expects the stack contain hash and secret swaps them line order hash the secret line before calling the equality operator hash(v) and line this returns true the secret preimage the hash. this function can used predicate the execution code branches different contracts the existence the same secret value. simple example usage, hashlocks make possible for users that don't share state channel trustlessly send each other aeon, long there path channels between them. for example, alice and bob have channel and bob and carol have channel, then alice and carol can transact through bob. they this creating two copies the contract shown fig. one for each channel. the commitment line the hash secret that alice chooses. line push the stack and call the hashlock function. which branch the that gets executed depends the return value hashlock. once these contracts have been signed all parties, alice reveals the secret, allowing bob and carol use claim their aeon. hashlocking can also used e.g. play multi-player games the channels, shown fig. everyone makes channel with the game manager, which publishes the same contract every channel. say are game state alice and bob sign transaction that specifies how much money each them depositing into the channel, and publish the blockchain. once the blockchain has opened the channel, they can both create new channel states, send them between each other and sign them. channel states can either new distribution the funds the channel contract that determines new distribution. each these channel states has increasing nonce and are signed both parties, dispute arises, the latest valid state can submitted the blockchain, which enforces it. the channel can closed two different ways: alice and bob decide that they have finished transacting and agree their final balances, they both sign transaction indicating this and submit the blockchain, which will close the channel and redistribute the money the channel accordingly. alice refuses sign closing transaction for any reason, bob can submit the last state that both them signed and request have the channel closed using this state. this starts countdown. alice believes that bob being dishonest, she has the opportunity publish state with should noted that since contracts can read answers from oracles and some environment parameters, they aren't completely pure functions. however, oracle answers never change once they've been provided and can argued due the computational richness the oracle machine, rather than being impurity. environment parameters are deemed "necessary evil" and will ideally compartmentalized appropriately high-level languages. higher nonce that both them have signed before the countdown finishes. she does so, the channel closes immediately. otherwise closes when the countdown has finished. running two consensus mechanisms top each other expensive running both separately. additionally, doesn't increase security, because the least secure one can still attacked and made produce "false" values. thus, propose conflate the two consensus mechanisms into one, essentially reusing the mechanism that use agree the state the system, also agree the state the outside world. the way that this works follows. any aeon-holder can launch oracle committing answering yes/noquestion. when doing so, they also need specify the timeframe during which the question can answered, which can start now some time the future. the user that launches the oracle required deposit aeon proportion the length the timeframe, which will returned the user supplies answer that gets accepted truth, otherwise burned. the blockchain generates unique identifier for the oracle that can used retrieve the answer once available. once the time comes for the question answered, the user who launched the oracle can supply answer for free. once the oracle launcher has supplied answer until certain amount time has passed, any other users can submit counter-claims depositing the same amount aeon. counter-claims have been submitted the end the timeframe, the answer supplied the user that launched the oracle accepted truth, and the deposit returned. any counter-claims are submitted, then the consensus mechanism for blocks will used answer the oracle. this more expensive, but since know can take least one the two safety deposits, can use it. consensus mechanism aeternity uses hybrid proof-of-work and proof-of-stake consensus mechanism. the block-order will determined via proof-of-work. certain system variables will determined via on-chain prediction market system, which allows the users participate and bring their knowledge. for the pow algorithm currently favor variant tromp's cuckoo cycle, one which memory bound, and also "indirectly useful proof-of-work", requires less electricity run, but instead has another limiting factor, the one memory latency availability. this also makes feasible mine with smart phone. tromp writes about his work: "[cuckoo cycle is] instantly verifiable memory bound pow that unique being dominated latency rather than computation. that sense, mining cuckoo cycle form asic mining where dram chips serve the application randomly reading and writing billions bits. when even phones charging overnight can mine without orders magnitude loss efficiency, not with mindset profitability but playing the lottery, the mining hardware landscape will see vast expansion, benefiting adoption well decentralization." preview: the consensus mechanism has somewhat nonstandard role aeternity. addition agreeing new blocks for the blockchain, also agrees both answers oracle questions and the values the system's parameters. particular, the consensus mechanism can change itself. however, should noted that this not entirely unproblematic. for example, simple proof-of-work mechanism was used, would rather cheap bribe the miners corrupt the oracle. therefore aeternity going use novel hybrid proof-of-stake proof-of-work algorithm, leveraging the benefits both. independently from this, pow going used issue new aeon tokens. sidenote: originally aeternity intended percent proof-of-stake blockchain. don't think anymore that decentralized percent pos system possible. c.) oracles: crucial feature for most contracts, whether encoded text code, the ability refer values from the environment, such the prices different goods whether certain event occurred not. smart contract system without this ability essentially closed system and arguably not very useful. this generally accepted fact and there are already several projects that attempt bring external data into the blockchain decentralized way []. however, decide whether supplied fact true not, these essentially require the implementation new consensus mechanism top the consensus mechanism. governance governance blockchain-based systems has been big problem the past. whenever system upgrade needs done, this requires hard fork, which usually leads big discussions among all value holders. even simple things, like correcting arbitrarily set variable the source code, have seen with the block size debate bitcoin, seem very hard system where the users' incentives are not aligned with the decision makers, and where there clear upgrade path. have also seen more complicated governance decisions, like fixing single smart contract bug "the dao", which required quick intervention system developers. the primary problem these systems easily identifiable--the decision-making process for protocol upgrade change not well defined and lacks transparency. aeternity's governance system part the consensus. uses prediction markets function efficiently and transparently possible. moreover, the consensus mechanism defined number variables that determine how the system functions and that are being slightly updated each new block. from how much costs make transactions ask oracle, modifications fundamental parameter values like the block time. having prediction markets about the variables that define the protocol, the users can learn how efficiently improve the protocol. having predictions markets about potential hard forks, can help the community come consensus about which version the code use. each user chooses for itself which metric seeks optimize, but simple default strategy would maximize the value its holdings. change. define the following variables for the following calculations: block\_size bytes blocks\_till\_finality time\_till\_finality seconds transaction size bytes scalability transactions per second e.) sharding trees: the architecture that has been presented thus far highly scalable. possible run the blockchain even when each user only keeps track the part the blockchain state that they care about and ignores everyone else's data. least one copy the state needed for new users certain about the substate that they care about, but can shard this data across arbitrarily many nodes that each node's load arbitrarily small. merkle trees are used prove that substate part the state []. easy imagine scenario where certain nodes specialize keeping track the trees and get paid for inserts and look-ups. e.) light clients: light clients don't download the entire blocks. first the user gives their client hash the history the fork they prefer, technique also known weak subjectivity []. then the client knows only download forks that include block with that hash. the client only downloads the headers the blocks. the headers are much smaller than full blocks; very few transactions are processed. for simplicity, made mention the block headers when discussing the block structure section ii-a., but they contain the following: the hash the previous block. the root hash all the state trees. e.) state channels and parallelism: state channels have immense throughput and most transactions inside them are never executed even recorded the blockchain. additionally, the channels don't write any shared state on-chain, all transactions that actually get recorded the blockchain can processed parallel. given that most consumer hardware sold today has least four processing cores, this has the immediate effect that transaction throughput multiplied roughly factor furthermore, the fact that there will never any complex concurrent interaction suggests that sharding this blockchain architecture should relatively easy. since blockchain sharding still fairly experimental, have deliberately chosen not pursue any sharding techniques the initial design aeternity. however, this changes the future, aeternity should one the easiest blockchains shard. e.) transactions per second given memory requirement: the variables that define the protocol are all constantly being updated the consensus. from their initial default values, can calculate the initial default rate transactions per second. bytes megabyte per block blocks per day seconds per block seconds per day bytes per transaction ca. transactions per second (fast enough sign every human within years) operate node, need keep copy all the blocks since finality, and need able record times more information, case there attack. estimating that finality days, then there would blocks till finality. the memory requirement one megabyte megabytes gigabytes. when there isn't attack happening, one would only need about gigabytes store the blocks. iii. pplications the stateless nature the aeternity smart contracts makes easy build the following applications aeternity's blockchain. especially suitable for high-volume usecases. blockchain essentials blockchain essentials are necessary primitives like aeon, wallets, names and related concepts. they modularize reusable components which can used application foundations and can improved on. a.) identities: each account will have associated unique number. users can register unique names, and link names the merkle-root data structure. the data structure can contain one's unique well other information about one's account. aim use schema.org's json format represent things like persons companies []. a.) wallet: wallet piece software that used interact with aeternity. wallet manages private keys for the aeon and creates and signs transactions. one can use the wallet send channel transactions, and use apps the channel network. a.) proof existence: one transaction type allows for the publishing the hash any data. system participants can use the headers prove that the data existed that point time. note that this draft and will likely state channel applications smart contracts state channels are perfect for microservices the web that require high transaction throughput. b.) toll api: most apis existing today are publicly available for anyone call, else they are secured username-password-scheme unique access tokens. payment channels allow for new kind api, where one pays for every call the api, possibly every http-request. paying access api solves ddos problems, and makes easier build high-quality apis that are always available. api responses that require payment are fundamental for the creation yet impossible types businesses and can play important role the emergence the decentralized economy. they create incentives for information owners make otherwise private data publicly available. b.) insured crowdfunding: can implement insured crowdfunding using dominant assurance contracts [need cit.] these are smart contracts that are used raise money for public good, like new bridge, school market. dominant assurance contracts differ from traditional assurance contracts like kickstarter, that they make dominant strategy participate. the good not funded, all participants get their aeon back plus interest, they are insured against reducing their liquidity without receiving the good. using oracle, can ensure that the provider the good service only gets paid the good service actually provided. b.) cross-chain atomic swaps: cross chain atomic swaps allow for trustless exchange aeon for bitcoins [], []. these can implemented using hashlock, that locks the transactions both blockchains under the same value. b.) stable value assets and portfolio replication: can use smart contracts program synthetic assets that stay nearly the same price real world asset. for example, could make asset that stays the same price gold. synthetic derivatives are created equal and opposite pairs. for one user have asset that moves with gold, different user will have have asset that move inversely gold. for example, alice could make contract with bob that alice owns gram gold. out the money the contract, one gram gold worth aeon will alice, and the leftover money goes bob. the contract has expiration date when the price gold will measured, and the funds distributed alice and bob accordingly. b.) event contracts: event contracts pay when event happens and don't pay when event does not happen, per the oracle's telling. apart from being interesting themselves, these can used several different applications: insurances: can use event contracts implement insurances. for example, expensive music event tickets can become worthless the weather goes bad. however, the concert-goer receives money the oracle decides that rained the day the event, the investment can protected that one can afford find emotionallyadequate alternative. slightly more seriously, farmers are often interested the total number inches rain season. can insure them against their crops wilting from dryness. whistleblowing: event contracts can also used incentivize revealing sensitive information. for example, could bet the event "information indicating that company has used illegal pesticides was released before january th, any person with access such information would incentivized first bet that the event will happen and then release it. b.) prediction markets: prediction market works letting users bet whether future event will happen. from the price the bets can predict the future likelihood [], [], []. they are the most accurate way measure the future given price [need cit.] once the event has happened, the market settled using the oracle. noted section ii-d, can for example use prediction markets predict which updates the software will beneficial, and which will harmful. can also use them estimate how much candidates election will actually able accomplish, lies and baseless promises can detected more easily. fig. multidimensional prediction market. multidimensional prediction markets: multidimentional prediction markets allow predict the correlation between possible future events. for example, one could predict that alice elected leader, the price potatoes will down, and that bob wins, the price will up. one could learn that google uses plan for the next months, that will probably earn more money, and that uses plan will probably earn less. or, fig. can see that alice would elected president, there high likelihood the price potatoes being rather low. b.) market with batch trading single price: there are two approaches available attackers that want rob aeon from market. they can take advantage the market being split time, they can take advantage being split space. the market split space, then the attacker does arbitrage. simultaneously makes trades both markets once that his risk cancels out and earns iv. mplementation profit. the market split time, then the attacker frontruns the market. reads the transactions coming into the market and creates buy and sell orders immediately before and after. most key concepts already have proof-of-concept implementations erlang. this includes the blockchain itself, the contract language and vm, the oracle and governance mechanisms, well old version the consensus mechanism. have used erlang/otp because makes easy write code that can respond many requests parallel and does not crash. the servers with the highest uptime the world are based erlang. has been used for industrial applications for years, proving itself reliable and stable product. virtual machine and contract language the virtual machine stack-based and similar forth and bitcoin' scripting language, although comparison the latter, rather rich. the supports functions instead gotos, making its semantics relatively simple analyze. list the vm's opcodes can found our github additionally, there exists higher-level forth-like language called chalang, which compiles bytecode for the vm. supports macros and variable names, but keeps the stack-based execution model []. examples chalang code can also found our github fig. the black line the demand curve, the red line the supply curve. the sells red are the same size the buys red. the vertical line the price the market maker selected. everyone willing buy higher price traded that price, everyone willing sell lower price traded that price. adoption via web-integration the web the most popular application platform. will provide easy-to-use web-development tools, such jslibraries and json-apis for the core features the aeternity blockchain. combine markets space, everyone should use the same market maker. combine markets time, need have trading done batches, single price. the market maker needs commit each person what price decided, and anyone can find contradictory commitments from the market maker, then all his customers should able drain all his channels. the market maker commits fair price, then will match the same volume buyers and sellers together, fig. shows. otherwise, will end situation similar fig. thus taking large risk. open source modules order easily re-used for private blockchain consortium and other use-cases, the software will written mit-licensed modules, such consensus module, that can adapted specific needs. usability and design frictionless human interaction will big focus our development efforts. more specifically, will make sure that who controls the identity, keys and transactions clearly established. also, offering easy access via web-gateways will central focus future development. users participating prediction markets via tinder-like (swipe left/right) mobile interface, and simple web-wallets that can easily integrated website through iframe will the new norm. iscussion have provided explanation how architect fundamentally more efficient value transfer system. the described system fact global oracle machine that can used provide decision making services global scale. particular, all the applications proposed section iii can built easily and efficiently top aeternity. https://github.com/aeternity/chalang/blob/ master/opcodes.md https://github.com/aeternity/chalang/tree/ master/examples fig. the black much bigger than the red. the market maker selling many more shares than buying, thus taking lot risk. however, our approach has both fundamental limitations and avenues for improvement. these are discussed here. the secret hashlock has been revealed, the transaction doesn't through. goes offline afterwards, the only possible "negative" effect that the transmitter not able claim its aeon. limitations and tradeoffs while believe that the tradeoffs made our architecture are reasonable given the resulting performance increase other areas, aeternity not catch-all solution for decentralized applications. should rather viewed synergistic complement existing technologies. there are several caveats that one need aware of. a.) on-chain state: despite having many advantages, aeternity's lack programmable state makes unfit for applications that require custom state under consensus. for example, this includes daos they are usually conceived, custom name systems and subcurrencies which are not tied the value underlying asset. a.) free option problem: alice and bob have channel and alice signs contract, she essentially gives bob free option when she sends him: bob can choose sign and return (i.e. activate) the contract any time the future. often this not what intended. avoid this problem, channel contracts aren't immediately activated with the full amount. they are divided time space. both participants would sign for the contract small intervals that neither user ever offers large free option the other. for example, the parties want bet aeon, then they might sign steps that each increase the bet aeon. this would require about messages pass, each direction, which cheap enough since the contract never submitted the blockchain. another example, one wanted make financial asset that would last for days, one might sign steps one hour each. this would require about messages pass, each direction. a.) liquidity loss and state channel topologies: when composing channels using hashlocks demonstrated section ii-b., any middlemen have lock least twice many aeon will transmitted through them. for example, alice and carol want transact through bob, bob will act carol when interacting with alice, and viceversa. since this expensive for bob, would most likely earn fee compensation. alice and carol expect conduct many trades between each other, they can avoid this creating new channel and trustlessly moving the active contracts the new channel using hashlock. still, since keeping extra channel open impacts one's liquidity negatively, going through middlemen expected desirable many cases, especially cases where the parties don't expect trade lot the future. thus, channel topology where certain rich users make money from trustlessly transmitting transactions between other users expected emerge. should noted that this does not constitute single point failure, since not trust these transaction transmitters with anything. transmitter goes offline before future work there are several possible ways improve the current architecture. b.) functional contract language: reasonable future direction would experiment with high-level languages that adhere more closely the functional paradigm. keeping track implicit stack generally error-prone and arguably not suitable for high-level, developer-facing language. this should rather easy given that programs are already pure functions (modulo some environment variables), and would greatly simplify both development and formal verification contracts. this done, could also make sense revise the tightly coupled with the new language, make the compilation less error-prone and less dependent trust the developers. ideally, the translation from surface language code would simply direct transcription peer-reviewed research, though pragmatic concessions will likely have made. b.) multi-party channels: currently, all channels aeternity are limited two parties. while multi-party channels can facto achieved through hashlocking, this can expensive. hence, plan investigate the possibility adding support for n-party channels, with m-of-n settlement mechanism. lossary blockchain distributed, tamper-proof database with metered access. the database defined growing list hash-linked blocks and can have any rules for appending them. aeon aeon represents unit account and access right the aeternity blockchain. transferable. transaction message from user the blockchain. this how users can use their currency access the blockchain. state channel relationship between two users recorded the blockchain. enables users send aeon back and forth, and create trustless smart contracts between them that are enforced and settled the blockchain. hash hash takes input binary any size. gives fixed sized output. the same input always hashes the same output. given output, one cannot calculate the input. hashlocking this how connect pairs channels make smart contracts that involve more than people. secret referenced it's hash. when the secret revealed, can update multiple channels the same time. governance well-defined process making decisions for the future protocol(s) the blockchain. oracle mechanism that tells the blockchain facts about the world live in. using oracles users can predict the outcome events, external the blockchain system. value-holder user who owns aeon, financial derivative the system. validator validator user who participates the consensus mechanism. the case aeternity, every value-holder can participate. acknowledgments thanks vlad, matt, paul, dirk, martin, alistair, devon and ben for proof-reading. thanks these and lots other people for insightful discussions. eferences nakamoto, "bitcoin: peer-to-peer electronic cash system," [online]. available: https bitcoin.org/bitcoin.pdf. buterin, "ethereum: next-generation smart contract and decentralized application platform," [online]. available: https github com ethereum/wiki/wiki/white-paper. sztorc, "market empiricism," [online]. available: http://bitcoinhivemind.com/papers/_ purpose.pdf. liston and koppelmann, visit the oracle," [online]. available: https blog gnosis.pm. detrio, "smart markets for smart contracts," [online]. available: http://cdetr.io/smartmarkets/. namecoin wiki, [online]. available: https //wiki.namecoin.org/index.php?title= welcome. snow, deery, lu, al., "factom: business processes secured immutable audit trails the blockchain," [online]. available: http bravenewcoin.com/assets/whitepapers/ factom-whitepaper.pdf. peterson and krug, "augur: decentralized, open-source platform for prediction markets," [online]. available: http bravenewcoin com assets whitepapers augur decentralized open source platform for-prediction-markets.pdf. swartz, "squaring the triangle: secure, decentralized, human-readable names," [online]. available: http www aaronsw com weblog squarezooko. hvitved, survey formal languages for contracts," formal languages and analysis contract-oriented software, pp. [online]. available: http www diku hjemmesider ansatte hvitved publications/hvitvedflacosb.pdf. merkle, "protocols for public key cryptosystems," ieee symposium security and privacy, buterin, "proof stake: how learned love weak subjectivity," [online]. available: https blog ethereum org proof stake learned love weak subjectivity/. "schema.org schemas," [online]. available: http://schema.org/docs/schemas.html. "atomic-cross-chain-trading," [online]. available: https bitcoin wiki atomic%c_cross-chain%c_trading. "interledger," [online]. available: https:// interledger.org/. arrow, forsythe, gorham, al., "the promise prediction markets," science, [online]. available: http://mason.gmu.edu/ ~rhanson/promisepredmkt.pdf. hess, "chalang," [online]. available: https://github.com/aeternity/chalang.