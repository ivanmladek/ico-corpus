lto.network blockchain for decentralized workflows www.lto.network abstract digitalization and automation business processes offer great benefits terms productivity and cost reduction. organizations struggle tap into these benefits for interorganizational processes, partly due lack trust. bitcoin has proven how blockchain can use distribution and cryptography provide system that does not rely trust. lto builds upon this foundation with decentralized workflow engine employed for ad-hoc collaboration. information shared between parties using per-process private event chains and hashed public blockchain. this hybrid approach allows organizations meet any data protection regulations and prevents scalability issues that are typically associated with blockchain projects. ntroduction the digital revolution has resulted many changes that make our lives more efficient[]. this wave progress has taken place primarily consumer-facing and internal business processes. when comes inter-organizational processes have acknowledge that the changes are less drastic. faxing has largely been replaced e-mail, and the typewriter replaced word processor, but beyond these superficial changes, execution the underlying processes have hardly changed. the first reason that automation has been absent the reluctance corporations rely external systems operated counterparty[], the distribution information plays important role the outcome relationship[]. where there natural power imbalance, one party may take control, forcing all others use its centrally managed system. see this when dealing with the government and some extent with corporations. situation where single party can claim control, automation simply doesn't happen[]. achieve automation for inter-organizational processes, for over two decades people have experimented with decentralized workflows[]. these studies and experiments, high level trust and fair play assumed, focusing primarily solving technological challenges. reality, this false assumption lack trust prevents successful pilots from making production. second reason for the absence automation the correlation between efficiency and corruption[]. traditionally large corporations and government bodies require large number people execute process. fair amount bureaucracy required coordinate such processes. this increases the costs bribery, reducing the incentive automate. increasing efficiency negates this effect. this paper shows how both problems may solved using blockchain, providing solution where all parties can equal footing. ontents part live contracts live smart contracts ricardian contracts enforcement user interface finite state machine deterministic finite state machine extended finite state machine communicating finite state machines contract automaton alternative modeling methodologies petri nets bpmn demo scenario states actions actors assets data-objects immutability forms documents custom types identities inviting identities updating identity process adaptive workflows comments deviation scenario update event chain cryptographic signatures hash chain distribution private chain genesis consensus mechanism chance conflict branch validation cascading rules unanchored events merging branches forks actions manual actions system actions sub-processes projection data operators passive testing privacy linked data gdpr zero-knowledge proofs common patterns chain interaction explicit synchronization part ii. global blockchain centralized decentralized anchoring consensus algorithm leasing raffle factor forge probability fair pos generator signature protocol transaction types anchoring authentication and authorization certificates chain trust smart accounts summary blocks key block size growth without aggregation segregated witness aggregation difference pruning summary block size total size history nodes network vulnerability importance inflation nothing stake lpos centralization denial service attack sha- vulnerability part iii. platform architecture micro architecture application layers and services layer application layer web server workflow engine private public chain layer anchor service container orchestration chain layer eventchain service event enqueue service event dispatch service part live contracts business process modeling common strategy for any medium large organization[]. creating visual representation workflow process allows analyzed, improved, and automated (figure unlike procedures that are written natural language written programming language, these models can understood both humans and computers. draft document review document declined accepted party signs party signs fig. bpmn diagram can used visualize workflows. for inter-organizational cooperation, modeling not done merely improve communication. the parties involved must specify the process serve binding agreement[]; the lto platform this called live contract. the lto platform creates hoc private blockchain for each live contract. such blockchain not intended immutable ledger but ensures all parties have up-to-date countersigned history events and shared states. ive mart ontracts live contracts have similar goal smart contracts implemented ethereum[]. both define and solidify logic that can applied trustless and verifiable way. the philosophy behind these two types digital contracts very different however. ethereum describes smart contracts, cryptographic "boxes" that contain value. these boxes only unlock certain conditions are met[]. live contracts not directly hold value but describe how two more parties should interact. the intent much closer that traditional (paper) contract. programs. this inherent property the live contract that obtained the way defined. there separate natural language version for legal purposes and coded version for programme execution. ricardian contracts live contract fits within the definition ricardian contract []. most notably, it's easily readable both people and ricardian contract can defined single document that contract offered issuer holders, for valuable right held holders, and managed the issuer, easily readable people (like contract paper), readable programs (parsable like database), digitally signed, carries the keys and server information, and allied with unique and secure identifier. user interface ethereum provides internal turing-complete scripting language, which programmer can use construct any smart contract transaction type that can mathematically defined[]. this makes very abstract the state contained within the contract has intrinsic meaning. interact with such contracts user interface must created for each specific smart contract, more precisely, the interface such contract[]. standards like erc-[] and erc-[] manage decouple the from the contract logic some cases but restrict the possibilities when designing contract. with live contracts, information does have intrinsic meaning. while this restricts use cases, does enable generating interface purely based the data provided the contract and its process. result, any workflow can digitalized and executed the lto platform without the need creating specific for each one. enforcement on-chain enforcement poorly suited for many real-world cases. smart contracts rely proactive enforcement, meaning either breaching the agreement must impossible dropping out must possible for each side[]. take non-disclosure agreement example. the blockchain can't prevent party from disclosing information, nor can force party actively participate resolving breach. for such contract work, self-enforcing agreement[] must hold the full penalty deposit, each party better off participating resolution. having tie large amounts funds deposits for penalty fees arbitrary contracts impractical for most organizations[]. additionally, the effectiveness penalty interest and similar measures are limited the value held the smart contract. most inter-organizational business processes call for offchain dispute resolution via authoritative party. live contract can facilitate resolving dispute. this may include conflict negotiation, mediation and even arbitration (by arbiter judge). running process the lto platform forms verifiable history events, reducing the amount asymmetrical information. the distribution information influences negotiations case dispute[] and influences the assessment the authoritative third party. inite state machine live contract defines workflow finite state machine (fsm)[]. this makes possible visualize the workflow flowchart (figure which makes understandable for both humans and computers. deterministic finite state machine any blockchain logic needs deterministic[]. where computer programs may require extra effort comply with this requirement, dfsm deterministic definition. start request review document declined document accepted party signed party signed party signed party signed fig. example finite state machine visualized flowchart extended finite state machine also visualized figure how problem arises when multiple actions are required get state, but the order which they occur arbitrary. this can modeled transition path for every possible order, done figure however, with this approach, the number states and state transitions will grow exponentially with the number actions. this makes the visualization the workflow less clear, but also makes harder and more error-prone define the workflow. this why instead using regular fsm, live contract uses extended finite state machine[] (efsm), allowing for conditional state transitions. figure defines the same workflow figure using efsm. start document declined request review document accepted party signed [party signed] finalize document parties signed] fig. example extended finite state machine: conditions brackets have true for the transition valid the event chain (see section able function communication channel between two fsms. when two processes are isolated using different event chains, this communication channel non-deterministic, which inherently makes the whole system non-deterministic[]. this can overcome making acknowledgments part the fsm shown section communicating finite state machines finite state machines are limited sequential behavior, they not support concurrent processes. order represent workflows with concurrency, each sequence parallel instructions may represented individual fsm. contract automaton finite state machine can applied agreement between the participants formalizing obligations, permissions and prohibitions that parties impose the other[]. contracts like financial agreements[] and service contracts[] can fully digitized fsm. however, these representations are not sufficient used workflow, they not define the orchestration, communication, and choreography within process. these factors can incorporated, however, this causes the fsm grow exponentially complexity[]. for practicality, fsm will best represent incomplete contract. this doesn't have problem these gaps may filled default rules[]. the system does allow renegotiation live contract, either resolve particular situation general, shown section another thing note that not every action process constitutes binding factor. figure the acceptance the text document does not constitute binding agreement, this only occurs when the document signed. facilitate this distinction, actions can categorized either informative performative actions[]. lternative modeling methodologies communicating extended finite state machines are commonly used describing telecommunication systems and other realtime systems[], but not business processes. more common notations for workflows provide additional challenges when modeling decentralized inter-organizational processes. petri nets petri nets[] are graphical way representing system which there are multiple independent activities running the same time. the ability model multiple activities differentiates petri nets from finite state machines. finite state machine, there always single "current" state that determines which action can occur next. petri nets, there may several states any one which may evolve changing the state the petri net. alternatively, some, even all, these states may evolve parallel causing several independent changes the petri net occur once[]. workflow nets (wf-nets) are subset petri nets that may used describe business processes[]. wf-nets can describe the whole process rather than only one sequence. extended finite state machines use global state hold information. this information must isolated per sequence. failure making the data immutable can exploited shown section.. with petri nets, using global information isn't possible. instead, information needs flow through the workflow. with the approach cefsms, sequences are defined individual processes. this makes trivial apply access control. when representing the workflow whole, this can't addressed the same way. petri nets have interesting notation, which has proven able correctly represent business workflow. given it's possible address the mentioned challenges, the wf-nets notation might preferable over using individual fsms. due the similarity between petri nets and fsms, switching wf-nets does not fundamentally change the solution described this paper. bpmn bpmn the industry standard business model processing and would likely candidate for modeling notation for lto. however, there are number limitation that are particularly problematic for inter-organizational systems[]. the business process execution language (bpel) typically associated with bpmn, non-deterministic turing complete language towards web services[]. this makes ill-suited for automation blockchain. proposed alternative translate bpmn model into petri net, which translated smart contract[]. while the translation into (turing complete) smart contract unnecessary, the translation from bpmn into petri net (or cefsm) might interesting order support the current industry standard. demo "demo" acronym for "design engineering methodology for organizations". this methodology for describing organizations and their business processes based around the "communicative action". uses four models create holistic view; the construction model (cm), process model (pm), action model (am), and fact model (fm)[]. rather than considering each step process individually, establishes generalized workflow for every single performative transaction. such transaction, there are two roles: the initiator and the executor. the standard sequence that follows follows. the initiator does request, the executor makes promise, the executor performs the actions and makes statement about the result, the initiator either accepts this transaction completed rejects it[]. other alternative flows are also modeled, like the executor declining the request, the initiator wanting revoke the request, the executor being unable fulfill the promise, etc. these alternative flows are often not, only partially, modeled when using other modeling methodologies, while practice these are always present. the process model (pm) combines these transactions model complete business process. the difference between this model and workflow that this model everybody works parallel much possible, specifying dependencies between transactions where needed. the models don't give clear overview where are process. also, mutual exclusion information (don't edit document that's ready signed) not immersive but needs specified. demo might good way make high-level model, which yields workflow that can then fine-tuned. this reduces the reliance deviations (see section .). cenario workflow defined data-object; the scenario. consists of: state with the initial state, the set all possible states ..., qn- action, the set all possible actions ..., the transition function the set final states with all actor definitions, all asset definitions, the set embedded data-objects. states states set typically consists of: title: short title for the state, set actions with transaction {(- d), ...}, description: long description for the state, map instructions for specific actors. the state describes the actions that may performed this state and includes the state transition. this allows actions used different states. actions the scenario defines the set all possible actions that can performed the workflow. examples such actions are filling out form, reviewing document, and sending http request response. the action type and object properties are defined using json schema. action defines which the actors from set may execute it, well as, optionally, additional constraints described for the efsm. when action executed, state transition triggered. actions can categorized manual actions that require human interference executed and system actions that can executed automatically the system. optionally actions can define instructions updating actors and assets using data from the response. actors set defines all actors that can have role process. each actor defined object using json schema. actor properties that are relevant the process must defined. actor scenario only static definition that may instantiated process. assets defines all assets that are available process. asset variable data-object. properties that are relevant the process must defined. note that the scenario only defines the structure assets. assets can only instantiated within the process. data objects besides scenarios, other types data-objects may defined. all data-objects, including scenarios, use json schema type definition. common examples are forms, documents, and templates. data-objects can embedded process linked and stored independently. linked objects are identified the sha hash its json representation. ensure json encoding the data always yields the same result, deterministic method json encoding applied. immutability data-objects are immutable the extent that applying modification data-object, yields new data-object. this data object embedded the process asset, the old object replaced with the modified one. importantly, the same data-object available multiple processes, changing the object one process will never propagate other processes. failing could lead exploitable situations. figure shows the process negotiating and signing document. it's clear that the document must not allowed modified during the signing sequence. forms inviting identities add parties process, the scenario needs define actions add other identities. the public keys are known within the process, the identity can added directly. when the public key not known, the identity needs invited (figure this can done through any means deemed secure enough, including e-mail. the inviting system generates one-time key and sends the invited identity. the invited party must replace this with its own secure 'user' and 'system' keys. before new identity can fully participate process, additional authentication may required. this can range from sms verification federated identity verification and even notary approval. form definition uses json schema define the data structure that should result from filling out the form. optionally schema can used specify how corresponding field may rendered and displayed. there are several similar implementations[-] for this. the aim work together with these projects form unified standard. initiate process generate temporary key pair send key pair identity documents digital workflows can largely eliminate the need for paper documents. however legal compliance, backward compatibility, and simply convention may still require the use documents. defining templates part the live contract, natural language documents can generated using data gathered the process. recommend using the open document format[], which supports fields and conditional sections for creating templates. invitee replaces temporary keys with own key pair fig. inviting identity join the process. custom types any json schema that defines object can used dataobject type. usage custom types causes the risk workflow not working properly other parties may participate via node that doesn't support that type. data with unknown types will stored "as is" and unavailable outside the context the process. updating identity identity free modify its own information, except for the identifier. this also allows party switch another node. cases where user should not allowed switch nodes, it's the node the identity reject that change. removing identity can done clearing the sign keys, encrypt key and node uri. updating other identities only possible such action defined the scenario and allowed the current state. dentities identity defines person, team organization within live contract. identity always has the following information: identifier, node uri, custom information, sign keys, encrypt key. identities are not the same actors. actor abstract role like 'student', identity might 'bruce willis' 'acme corp'. sign-keys map with one more public keys associated with the identity. the 'user' key belongs the identity and can only used him/her sign action. the 'system' key owned the node that the identity uses and used sign automated actions. other key types may have meaning defined within process. the public encryption key can used encrypt data, that can only decrypted this identity. rocess where scenario the stateless definition workflow, the process stateful instantiation, consisting of: thx response, where thx ordered list all responses {th ...thn the current state set all available actors set created assets actions executing action always yields response. the response must signed the actor and submitted new event. nodes independently determine the new state based the current state and the executed action. the scenario defined deterministic fsm. however this only concerns the state transitions and the projection. systems like ethereum and hyperledger, all logic must deterministic, it's executed all nodes and needs yield identical results all systems[]. with lto only single node single actor executes action, meaning actions not need deterministic. such, concepts like oracles are not needed. manual actions applications built the lto platform must inform human actors which actions they may perform the current state. human actor will sign his own response event before submitting his node, which will distribute all parties. system actions system actions not require human interference but are executed the node automatically. such, the node signs the response, rather than the human user. these actions are always performed single system and not have deterministic. other parties validate the response and can reject needed. because there human interference involved system actions, the actions are signed the system itself instead the actor. it's also possible schedule system action executed later time. this specified the scenario. allows for timeout state polling external source predetermined frequency. system actions are automatically executed and may yield error when used incorrectly when they fail otherwise. for these actions, not one but two state transitions must defined. one for successful execution and one case error. passive testing scenario that contains loop consisting exclusively system actions could result infinite loop causing massive amount transactions. when validating, want reject scenarios that have such construct. determining program can run forever known the halting problem[]. the problem has been proven unsolvable for turing-complete machines. however, can solved for fsms[]. since fsm has finite amount transition paths, they can all checked for loops. passive tests for efsm models are complicated the presence infeasible paths. this problem has been welldocumented but remains unsolved[, for simplicity reasons, can assume any path feasible ignoring the conditions. accept that this may cause false positives. daptive workflows scenario will model the most typical cases process. it's impossible foresee all situations advance and tedious model every possible edge case. taking code-is-law approach would make the system rigid. instead, live contracts supports three methods resolving such issues. comments process based fsm can only one state time. sub-processes allow live contract hold multiple states and make possible for different procedures done parallel. while these processes share event chain, the data for each process still isolated. facilitate sub-processes, live contract may contain subscenarios that can instantiated from the main scenario. comments are used communicate with other identities. they can, for example, used resolve conflicts conduct discussions outside the process. using comments instead off-chain communication methods makes sure that the conversations are logged the blockchain. also allows backtracking check when the procedure certain conversations took place. comments are not restricted text messages. also possible use images documents assist the communication. comments are not part the process, meaning that adding comment does not trigger state transition. this way always possible conduct discussion about subjects that were not predefined the procedure. sub-processes projection besides the fsm state, the process also contains other stateful data assets and actors. the payload every response can used update this data. the rules how the payload updates the data are defined the scenario. updating the projection deterministic and therefore applying given set responses against the scenario will always yield the same projection. the projection can used set the parameters action. it's also the data for the conditions that make extended finite state machine. data operators data operators may used the scenario for specifying how the projection affects the process. these operators are deterministic functions without side effects. they can used for arithmetic logical operations. the result these operations may stored the projection and can used, for example, base state transitions on. deviation any party may propose deviation from the main flow defining partial scenario. this sub-flow must start from one the states existing scenario and end state that scenario. deviation flows are only executed once they are longer available when the process returns existing state. all parties need agree upon the deviation. note that deviations might lead forks that can only resolved through manual conflict resolution. deviation can used resolve disputes. any party may propose dispute the correctness previous event and present solution how correct that. another typical case using deviations payment arrangement. organizations obviously don't want make that option known forehand. predefined sub-flows allow such arrangements while keeping them under wraps. scenario update may required change the scenario for running process, for instance, when agreement updated new law passed. party may provide new scenario for given process through deviation flow. this flow moves the state out the outdated scenario and ends transition into the new scenario. vent chain private chain order determine the state the fsm and the projection, need process the set responses the given order. inserting removing event, changing the order the events modifying the payload might result radically different state. centralized solution, the controlling party responsible for data integrity. all parties rely trust this party so, represents single source truth. decentralized system, this power and responsibility shared among all parties. facilitate this, the event chain works like hoc private blockchain. each response wrapped event, which can viewed block with single action. the sequence these events form hash chain that shared between the parties. the consensus algorithm ensures the parties agree upon the sequence events. the event chain private chain that only shared between the nodes chosen the identities. nodes are not aware private chains that they are not part of. node stores and facilitates many event chains the same time. unlike side chains, event chains are completely isolated. chains not affect each other directly. this allows for horizontal scaling, given that the activity per event chain reasonably low. cryptographic signatures genesis anybody may create new event chain will. the genesis block this chain contains the identity the user that's creating the process, the subsequent block contains the scenario. part the scenario, other identities will invited this private blockchain. onsensus mechanism each event can uniquely identified using its sha- bit hash. this industry standard algorithm fast and resistant pre-image and second-preimage attacks well collisions[]. it's the recommended cryptographic hashing algorithm nist[]. embedding the hash the previous event the hash the next event creates hash chain, which records the chronology the events. when used combination with cryptographic signatures, hash chain provides adequate measure proving that specific sequence events resulted the current state[]. lto distributed system, where all parties are able participate via their own node. nodes distribute all events their peers, who process them. this means there brief moment where the state the process between the nodes differs. eventual consistency[] guarantees that, given that there new event submitted, eventually the state the process all nodes will the same. however, sometimes new events are submitted before consistency has been achieved. this moment, possible that two more nodes append event upon the event chain. during byzantine failure[], all nodes believe their information valid. however, the overall system inconsistent state. this state, nodes would longer accept new events from one another and need able come consensus, rather than halt. distributed applications use different kind consensus algorithm for this. general, this case byzantine fault tolerance (bft). early byzantine fault tolerance methods not scale well []. the invention better scaling consensus algorithms like proof-of-work [], proof-of-stake and proofof-authorization made possible create distributed networks with large number participants, also called distributed ledger technology. while these consensus methods scale much better than traditional bft methods, they have need for relatively high amount participants order secure. the event chain private blockchain with relatively few participants, meaning those algorithms won't work. rather than trusting majority vote, nodes consider their state correct unless proven otherwise. ensure nobody can falsify forge events others, each event signed before submitted using asymmetric cryptography. the signed event also serves receipt, allowing other parties prove that the action has been executed the signing identity. the platform uses ed[] signatures. these ellipticcurve signatures are widely used, well supported and considered secure institutions like nist[] and enisa[]. elliptic curve cryptography allows for faster single-signature verification and signing without losing security. also reduces the needed size both the keys and the signatures. note that this method itself doesn't grant complete security, any party still able falsify forge their own events. other words, cryptographic signatures can't prove event did not occur. hash chain istribution rather than requiring parties pull information from central server from each other, each party responsible for pushing events the system all other parties. systems need always available order for events not get lost. decoupling and the use message queue reduce issues with temporary unavailability. typical case, all parties will connect node they trust which receives and processes events for them. this node part the larger system (see section .). with the focus organizations and governments, it's these organizations run node. users connect the node their organization, publicly available node their choosing, participate process. chance conflict event chains rely optimistic concurrency control. many conflicts would put strain the consensus algorithm which can relatively slow may have wait block generated. define distributed event chain follows: let the set entities contributing the event chain. let the event chain, sequence consisting events belonging entity and let the set all copies the event chain {cn let's define conflict branch for conflict occur accident, two parties must add block their chain before they received the others chain update. let's call the chance somebody propagating update the chain (x). this chance depends the amount blocks being added the chain during given time frame, the time takes propagate this block the rest the network and the amount entities contributing the chain this time frame. assuming everybody contributes equally the network this can derived formula (x) with: total amount transactions time frame total amount active participants time takes propagate block the rest the network this chance can used calculate the probability that conflict will occur. this probability derived subtracting the chance not having conflict from when there conflict means either nobody has contributed the chain that moment, the chance which calculated formula (), (x))n only one node contributed the chain, the chance which calculated formula (). (x) (x)) therefore the chance conflict calculated (). (c) (x))n (x) (x))n- with network delay see about chance conflict (rmax rmax given equation proves that it's impossible gain directly from spam transactions, with maximum raffle factor less than two. raffle factor close two would make spam transactions nearly free. increasing the importance the network for little denial service attack sha- vulnerability sha- was proven vulnerable when the google research lab managed find collision where two different documents resulted the same hash[]. sha- bit would have similar vulnerability this could devastating for anchoring based merkle tree. collision found, one can claim that the colliding document has been notarized. even worse, given merkle root and random hash, one might able generate valid merkle path. that would allow hacker verify any document. this would still not trivial task for every branch the tree, two hashes need combined that are exactly bytes long. while bruteforcing specific sha- would still require too many computations achieve lifetime, the birthday paradox results much fewer computations being required find collision. the birthday paradox also applies the lto public chain, there are many merkle roots, each with maximum number merkle paths. overcome this, verification might fall back history nodes case the verification disputed. however, this reduces the overall uses anchoring nodes. instead secondary merkle tree might added where the sha- hash hashed with another algorithm like sha- blake. simply double hashing isn't useful when it's possible falsify merkle, only vulnerability the outer algorithm required for exploit. however, there are two merkle trees, both algorithms would need broken. even then, collision needs found for both trees single block, removing the birthday paradox advantage. part iii. platform rchitecture micro architecture the lto node developed using the microservices architecture pattern. this means that all functionality within the node split into microservices, with each service being responsible for only small part the entire node. there are several advantages this pattern: failure isolation, service fails won't necessarily interfere with other services. scalability, all the services within the node are decoupled and can therefore run different machines. this makes really suitable for horizontal scaling. the scaling automated, which can found the description section flexibility, certain functionality flourishes better certain programming languages. each service can developed different programming language. code quality, splitting the node into small and welldefined modules becomes easier for developers read and review. this leads better code quality. the microservices are grouped docker container. all these containers are run using the kubernetes container orchestration platform. this will described section each microservice designed run independently. this means has shared dependencies, each container has it's own database event queue. microservices are also designed operate statelessly, they are easily scalable. application layers and services described section the node split into several services. the services are grouped into different layers. the node consists the following layers: layer: this consists applications that interact with the application layer, application layer: contains all the services that handle actions triggered events from the event chain, private chain layer: takes care the decoupling the node, public chain layer: manages the public chain service. our global public blockchain optimized for storing hashes. each node indexes all hashes, they can easily verified. the actual creation and execution the live contracts are done the workflow service. event received the event chain service contains action the live contract will sent the workflow service. the workflow service will execute the action which will lead state transition the workflow and new projection the workflow. this projection stored mongodb database. rivate ayer the layer contains two frontend applications which enable users easily develop and debug their live contracts. first the chain viewer. the chain viewer allows users connect specific node and list all the chains. the user can only list and view chains which part. the second application the playground application. the playground application lets users develop live contract scenarios. visualizes the scenario state diagram and contains other visualization and verification tools. pplication ayer web server the web server application serves proxy between the frontend and the applications within the node. the web server performs two functions: authentication all requests the services proxies all requests the correct service chain layer the private chain layer decouples the node. decoupling ensures stable system even case bad connectivity high load. the message queue the communication layer for the private chain. the technology providing the message queue will rabbitmq. rabbitmq lightweight message broker which perfectly suited deliver messages within the node but also other nodes. rabbitmq has function called the shovel. shovel will dynamically setup connection with another rabbitmq broker and exchanges messages. this mechanism used send events from one node another. three services manage all inbound and outbound events. eventchain service the service which manages the private chains the event chain service. this service processes all incoming events. during this processing events the services take the following steps: validate the incoming event(s), checking it's correctly signed and the chain isn't broken. validate the chain matches the locally stored chain. not, performs conflict resolution where possible. the event(s) are sent the identity that belongs this node will execute the received event(s). otherwise, will only store them the database. new identity added from different node, the whole chain forwarded this node. all the new events are forwarded the related nodes. for storage, the event chain service uses mongodb database. workflow engine event enqueue service the event enqueue service has the small task putting events the event queue. does this both from services within the node (e.g. the workflow service and the event service) well from external users. event dispatch service all messages the event queue are handled the event dispatch service. picks all the messages and distributes them the event service. the event service processes the message will marked handled. otherwise will moved the dead-letter queue. ublic chain layer anchor service the anchor service the heart the public chain. the anchor service will fork the nxt platform extended with protocol. the anchor service will extended will not only able handle 'normal' transactions but also data transactions. these data transactions will used store hashes from events the private chains described section all these hashes will collected daily and merged deterministically into merkle tree. this way the data transactions can removed from storage reduce the storage footprint but people are still able verify whether the hash existed. able verify whether certain hash stored, all the hashes will indexed. this way verification much faster because you won't have search through all the data transactions. ontainer orchestration since the node build out multiple microservices, container orchestration platform required manage the running the containers. container orchestration platforms take care few tasks such provisioning hosts, instantiating containers, restarting failed containers, scaling the cluster adding removing containers. different container orchestration tools can used for this purpose like docker swarm, mesos, nomad kubernetes. initially, configuration file will included for kubernetes. each service will configured run its own pod with its own load balancer. this done individual services can scale independently each other. scaling services managed using the horizontal pod autoscaler []. references eferences hannah ritchie max roser. technological progress. https: www. com content cbdc afd becddb. accessed: --. christine legner and kristin wende. "the challenges inter-organizational business process design research agenda". in: (). benjamin hermalin and michael katz. "moral hazard and verifiability: the effects renegotiation agency". in: (). audun josang. "the right type trust for distributed systems". in: proceedings the workshop new security paradigms. acm. pp. israel ben-shaul and gail kaiser. paradigm for decentralized process modeling and its realization the environment". in: proceedings the international conference software engineering. ieee computer society press. pp. ray fisman and roberta gatti. "bargaining for bribes: the role institutions". in: international handbook the economics corruption (), pp. jorg becker, michael rosemann, and christoph von uthmann. "guidelines business process modeling". in: business process management. springer, pp. manfred reichert, thomas bauer, and peter dadam. "enterprise-wide and cross-enterprise workflow management: challenges and research issues for adaptive workflows". in: (). vitalik buterin. "ethereum white paper: nextgeneration smart contract and decentralized application platform". in: (). vitalik buterin and karthik gollapudi. next-generation smart contract and decentralized application platform. https github com ethereum wiki wiki white paper ffefbdcbeaeecbfa. accessed: --. ian grigg. "the ricardian contract". in: (). nick sabo. "formalizing and securing relationships public networks". in: (). telser. theory self-enforcing agreements". in: (). david joulfaian douglas holtz-eakin and harvey rosen. "sticking out: entrepreneurial survival and liquidity constraints". in: (). toshi wallet now supports erc tokens and erc collectibles. https blog toshi org toshi wallet now supports erc tokens and erc collectibles eaa. accessed: --. erc- token standard. https://eips.ethereum.org/eips/ eip-. accessed: --. daniel cohen and daniel cohen. introduction computer theory. vol. wiley new york, marko vukolic. "rethinking permissioned blockchains". in: proceedings the acm workshop blockchain, cryptocurrencies and contracts. acm. pp. abdulsalam kalaji, rob mark hierons, and stephen swift. search-based approach for automatic test generation from extended finite state machine (efsm)". in: testing: academic and industrial conference-practice and research techniques, taic part'. ieee. pp. m.g. gouda, e.g. manning, and y.t. yu. "on the progress communication between two finite state machines". in: (). pace and schapachnik. "contracts for interacting two-party systems". in: (). mark flood and oliver goodenough. "contract automaton: the computational representation financial agreements". in: (). davide basile, pierpaolo degano, and gian-luigi ferrari. "automata for service contracts". in: (). pierpaolo degano davide basile and gian-luigi ferrari. "from orchestration choreography through contract automata". in: (). ian ayres and robert gertner. "filling gaps incomplete contracts: economic theory default rules". in: (). jan l.g. dietz. "understanding and modeling business processes with demo". in: (). youngjoon byun, beverly sanders, and chang-sup keum. "design patterns communicating extended finite state machines sdl". in: (). petri. "kommunikation mit automaten". in: (). dennis kafura. notes petri nets. http people vt.edu/kafura/computationalthinking/class- notes/ petri-net-notes-expanded.pdf. accessed: --. wil m.p. van der aalst. "the application petri nets workflow management". in: (). jan recker al. "how good bpmn really? insights from theory and practice". in: (). wil m.p. van der aalst al. "life after bpel?" in: (). luciano garcia-banuelos al. "optimized execution business processes blockchain". in: (). jan l.g. dietz. "demo: towards discipline organisation engineering". in: (). jsonforms react. https://jsonforms.io/. accessed: jsonform bootstrap https://github.com/jsonform/ jsonform. accessed: --. mozilla react-jsonschema-form. https github com mozilla- services/react- jsonschema- form. accessed: angular schema form. http://schemaform.io/. accessed: --. open document format. http www opendocumentformat.org/. accessed: --. sindhu sajana and sethumadhavan. "on blockchain applications: hyperledger fabric and ethereum". in: (). stephen cook. "the complexity theorem-proving procedures". in: proceedings the third annual acm symposium theory computing. acm. pp. daniel brand and pitro zafiropulo. "on communicating finite-state machines". in: journal the acm (jacm) (), pp. robert hierons abdulsalam kalaji and stephen swift. "new approaches for passive testing using extended finite state machine specification". in: (). sury and edmonds. edwards-curve digital security algorithm (eddsa) for dnssec. tech. rep. nist. transition plans for key establishment schemes using public key cryptography. https csrc nist gov news /transition- plans- for- key- establishment- schemes. accessed: --. daniel bernstein al. "high-speed high-security signatures". in: journal cryptographic engineering (), pp. issn: doi: url: https://doi.org/./s--. henri gilbert and helena handschuh. "security analysis sha- and sisters". in: international workshop selected areas cryptography. springer. pp. nist. nist policy hash functions. https://csrc.nist. gov/projects/hash- functions/nist- policy- on- hashfunctions. accessed: --. bruce schneier and john kelsey. "cryptographic support for secure logs untrusted machines." in: usenix security symposium. vol. pp. peter bailis and ali ghodsi. "eventual consistency today: limitations, extensions, and beyond". in: queue (), andrew tanenbaum and maarten van steen. distributed systems: principles and paradigms. prentice-hall, miguel castro and barbara liskov. byzantine fault tolerance. patent ,,. satoshi nakamoto. bitcoin: peer-to-peer electronic cash system. https://bitcoin.org/bitcoin.pdf. accessed: aggelos kiayias al. "ouroboros: provably secure proof-of-stake blockchain protocol". in: annual international cryptology conference. springer. pp. poa network. proof authority: consensus model with identity stake. https medium com poa network proof- of- authority- consensus- model- with- identity- atstake-dbd. accessed: --. git documentation. git branching rebasing. https git scm com book git branching rebasing. accessed: --. aaron van wirdum. "rejecting today's hard fork, the ethereum classic project continues the original chain: here's why". in: bitcoin magazine (). european parliament. regulation (eu) the european parliament and the council: the protection natural persons with regard the processing personal data and the free movement such data, and repealing directive //ec (general data protection regulation). https://eur- lex.europa.eu/legalcontent txt html ?uri celex from=en. accessed: --. olly jackson. "is possible comply with gdpr using blockchain?" in: international financial law review (). goldwasser, micali, and rackoff. "the knowledge complexity interactive proof systems". in: (). blockchain costs per transaction. https://www.blockchain. com/charts/cost-per-transaction. accessed: --. emanuel palm. implications and impact blockchain transaction pruning. wenting al. "towards scalable and private industrial blockchains". in: proceedings the acm workshop blockchain, cryptocurrencies and contracts. acm. pp. serguei popov. probabilistic analysis the nxt forging algorithm". in: ledger (), pp. waves platform. waves whitepaper. https blog wavesplatform com waves whitepaper- ddcaa. accessed: --. chainpoint node api: how create chainpoint proof. https://github.com/chainpoint/chainpoint-node/wiki/ chainpoint- node- api:- how- to- create- chainpointproof. accessed: --. gleb kostarev. review blockchain consensus mechanisms. https://blog.wavesplatform.com/review-of-blockchainconsensus mechanisms fafaef. accessed: nem. nem technical reference. https nem content themes nem files nem techref pdf. accessed: --. lto. "lto token economy". in: (). waves platform. blockchain leasing for proof stake. https blog wavesplatform com blockchain leasing for- proof- of- stake- bacde. accessed: --. mthcl. "the math nxt forging". in: (). waves generators. http://dev.pywaves.org/generators/. accessed: --. nxt blockchain explorer. https://nxtportal.org/monitor/. accessed: --. kofman begicheva. "fair proof stake". in: (). waves-ng stress test: results in! https blog wavesplatform com waves stress test results fbb. accessed: --. haber and w.s. stornetta. "how time-stamp digital document". in: (). ralph merkle. "method providing digital signatures". u.s. pat. jan. begicheva and smagin. "ride: smart contract language for waves". pat. saifedean ammous. "blockchain technology: what good for?" in: (). blockchain number transaction. https://www.blockchain. com charts transactions total. accessed: bip segregated witness (consensus layer). https github com bitcoin bips blob master bip mediawiki. accessed: --. problems ethereum. https://github.com/ethereum/wiki/ wiki/problems. accessed: --. hardin. "the tragedy the common". in: (). nothing considered look nothing stake vulnerability for cryptocurrencies. https pivx org nothing considered look nothing stake vulnerability for-cryptocurrencies/. accessed: --. john douceur. "the sybil attack". in: international workshop peer-to-peer systems. springer. pp. marc stevens al. "the first collision for full sha-". in: (). kubernetes. kubernetes, horizontal pod autoscaling. https: //github.com/kubernetes/community/blob/master/ contributors/design- proposals/autoscaling/horizontalpod-autoscaler.md. accessed: --. field name version timestamp parent block signature consensus block length base target generation signature transaction list hash anchor merkle root generator public key block's signature length table key block structure *** field name amount transactions (x) transaction bytes *** transaction bytes length *** table key block attachment *** *** field name version timestamp parent block signature consensus block length base target generation signature transaction list hash transaction bytes *** transaction bytes balance change summary entry *** balance change summary entry generator public key block's signature table summary block structure field name wallet address balance change length table balance summary entry field name transaction type anchor hash fee timestamp signature length table anchor transactions structure field name transaction type sending address receiving address amount fee timestamp signature length table transfer transaction structure length todo *** todo (table *** (table field name transaction type sending address receiving address expiration date certificate type fee timestamp signature length table issue certificate transaction structure field name transaction type new expiration date fee timestamp signature length table update certificate transaction structure field name transaction type sending address receiving address amount fee timestamp signature length table lease transaction structure field name transaction type sending address receiving address amount fee timestamp signature length table cancel lease transaction structure