platform white paper version: date: (c) chromaway platform white paper executive summary motivation technical design features uses design rationale overview problems with existing platforms blockchain database relational model first-class decentralized applications programming model consensus nodes model overview sybil control mechanism consensus node compensation miscellaneous features decentralized applications transparent apps token model the role chromapolis not controlled single entity. controlled the community users. cannot shut down. censorship-resistant. transparent. privacy. highly available. decentralization quality platform architecture postchain chains system chains: node implementation interaction with other blockchains components governance chromapolis system governance initial centralization rejected alternatives stake coin voting formal governance unique users application governance uses tokens games business uses tokens and incentives fees application fee models hosting fees node incentives node stakes token use games chroma token economics system accounts public good account token distribution promotional token fund decentralization centralization necessary start decentralization through diverse set providers bitcoin dpos ethereum chromapolis number full nodes security blockchain node security governance security light client security dapp client and wallet security executive summary chromapolis new blockchain platform for decentralized applications, conceived response the shortcomings existing platforms and designed enable new generation dapps scale beyond what currently possible. motivation while platforms such ethereum allow any kind application implemented theory, practice they have many limitations: bad user experience, high fees, frustrating developer experience, poor security. this prevents decentralized apps (dapps) from going mainstream. believe that address these problems properly need seriously rethink the blockchain architecture and programming model with the needs decentralized applications mind. our priorities are to: allow dapps scale millions users. improve the user experience dapps achieve parity with centralized applications. allow developers build secure applications with using familiar paradigms. technical design features believe that blockchain serves the role shared database within decentralized application ecosystem: stores application data and makes sure that data additions, updates and transformations are authorized and consistent with the application's rules. for this reason, chromapolis designed and optimized serve the role shared database the best way possible. implemented using the existing postchain framework developed chromaway, and features: relational model: blockchain data and application state are stored relational database. this model considered best class terms flexibility, versatility and consistency. relational programming language: chromapolis dapp backends are written specialized language which deeply integrated with the relational model. this model increases programmer productivity and ensures application consistency. horizontal scaling: each dapp has its own blockchain(s). because each blockchain run subset nodes, possible increase total throughput increasing the number nodes. https://chromaway.com/products/postchain/ codd, e.f (). relational model data for large shared data banks". communications the acm. classics. (): https://dl.acm.org/citation.cfm?doid=. rich indexing and querying: dapps can quickly retrieve information they need directly from nodes running the application. dapp blockchain logic can perform complex queries without severe performance degradation. high i/o throughput: data queries and updates are delegated heavily optimized relational database, allowing dapps perform large number queries and data update operations. pbft-style consensus: transactions can confirmed within seconds. first-class dapps: dapps not arise from "smart contracts" chromapolis, but are considered first-class entities. chromapolis gives dapp developers high degree flexibility and control. dapp level provisioning: allocating resources dapps rather than contracts gives developers the freedom create their own fee and resource use policies. chromapolis offers the same level openness, transparency and decentralization other public blockchains. chromapolis miners are replaced with providers. providers own nodes which produce blocks. has been suggested that the four largest mining pools both bitcoin and ethereum could exert significant control over those networks they colluded. aim ensure that the minimum number node providers whose collusion would required exert such control chromapolis exceeds this number significantly. can therefore said that the chromapolis model does not tend towards centralization any more than the oldest and most trusted public blockchains. chromapolis' pbft-style consensus further hardened anchoring chromapolis chains proof work (pow) blockchain, likely bitcoin ethereum. this ensures that finality, the guarantee that confirmed transactions cannot changed, least strong that the chosen anchoring chain. alter the history anchored portion chromapolis block history would necessary combine pow blockchain reorganization with malicious collusion sufficient number chromapolis nodes. the likelihood any attacker having the resources successfully mount such attack extremely low. uses chromapolis general-purpose platform which suitable for almost all kinds dapps. particularly well suited cases requiring high i/o capacity involving management complex data sets. massively multiplayer online games (mmogs) are example such case. castro, m.; liskov, (). "practical byzantine fault tolerance and proactive recovery". acm transactions computer systems. association for computing machinery. (): https://citeseerx.ist.psu.edu/viewdoc/summary?doi=.... say "own" rather than control, because the incentive system for providers economic character: they own chromapolis resources, and derive profit from them. there some tension between the notions ownership and control those resources, the control chromapolis resources arguably more relevant criterion for assessing the diversity the provider pool. https://blockchain.info/pools https://www.etherchain.org/charts/topminers originally described anchoring "side-chains" https://bitcointalk.org/index.php?topic= more formal discussion anchoring can found the bitfury white paper "on blockchain auditability". https://bitfury.com/content/downloads/bitfury_white_paper_on_blockchain_auditability.pdf blockchain gaming becoming increasingly popular, but mmogs are currently out reach because existing blockchain platform can support them. chromapolis capable hosting entire game worlds the blockchain, making sure that they evolve according predetermined rules and ensuring that one can cheat. believe that implementing mmog will the best way showcase the capabilities chromapolis. mmogs have very demanding set requirements; the capacity run mmogs implies that chromapolis suitable for demanding and complex dapps all kinds. design rationale overview problems with existing platforms ethereum was the first blockchain offer platform for decentralized application development. many application prototypes were created, but developers faced the following issues: limited capacity. because network capacity limited, and usage fees are proportional load, transaction fees can more for complex applications. this cost, typically paid for each interaction with application, makes most applications too expensive practical. prohibitively expensive i/o operations, for the same reason. for example, contract cannot iterate through list users since the cost this action would exceed the block gas limit. thus developers have jump through hoops implement something simple interest payment list users. poor data modelling tools and poor support for queries. application developers have resort centralized indexing and caching layers, using third party services which not provide the same security guarantees the base layer. error-prone contract language which has resulted many high-profile heists. provision for contract upgrades the platform level, this functionality has implemented separate layer which further increases complexity. users are required pay fee for every interaction and confirmations are slow. this results poor user experience (ux). poor light client support. three years after beginning development efforts the ethereum foundation was still struggling offer production-quality light wallet. applications designed with large audience mind need flexible and responsive. they require platform which empowers the developer allocate resources way that suits their users. even ethereum and other platforms currently development tackle scalability issues, they will not able provide sufficient degree developer autonomy and will remain somewhat hostile environment for dapps. believe that properly address these problems need seriously rethink the blockchain architecture and programming model with the needs decentralized applications mind. light client started being somewhat usable around february blockchain database the main role blockchain decentralized application context manage data secure and consistent manner. thus, blockchain can understood database, more specifically secure decentralized database. another major role blockchain prevention double-spending, but this special case data consistency constraints. blockchains which are optimized for payments, such bitcoin, can adopt highly specialized (and optimized) data models. but platform designed for hosting diverse decentralized applications needs general-purpose data model. most blockchain platforms nowadays use key-value data stores (examples: ethereum, neo, fabric). this model is, theory, complete, and enables the use high-performance data stores such leveldb. however, this model very low-level and requires application developers implement core functionality like serialization and indexing, daunting challenge. compounding this, blockchain platforms typically not expose the full functionality key-value stores, such the ability use arbitrary-sized keys and iterate through keys. for example, the ethereum virtual machine (evm) all keys are -bit integers and iterating through stored keys impossible. for these reasons, implementing proper indexed data access the evm both difficult and inefficient. relational model the relational model has been the gold standard for database management for the last five decades. rooted mathematics and logic, known able model complex data efficient way. for this reason, and the reasons stated above, consider the relational data model the lynchpin our blockchain platform. decentralized applications deal with increasingly complex data structures, the advantages the relational model become ever more apparent. further, most software engineers are already familiar with they won't have learn new concepts order implement application. relational model also allows leverage the power sql database management systems (dbms) which have been optimized for decades. instead dapp code which traverses memory cells one one, can send query the dbms and let use its sophisticated query planning, data structures and caching capabilities carry out the query fast possible. course, the choice data model trade off. the relational model might have the following disadvantages: performance hard predict and depends the query planner. this not significant disadvantage the context chromapolis because each dapp will run isolated manner; slow queries will affect only the dapp which performs them rather than the system whole. impossible impose hard bounds query execution time. again, this not problem chromapolis because affects only the performance the application which issues slow queries. parallelization sql databases complex area active research. far know, blockchain platform offers fully automatic parallelization massive scale. thus there evidence that relational model worse than other models. addition, believe that the relational model will make logical sharding and sidechain mechanisms easier implement. first-class decentralized applications ethereum all code lives "contracts". does not differentiate between individual wallet contracts and complex multi-user contracts: they all use the same resource-metering and programming model. ethereum-based dapp will use one more contracts (possibly contract for each user) and front-end components. fact, many ethereum applications make use centralized caching, rendering their "decentralized" credentials somewhat dubious. while this approach quite elegant and can scale different kinds applications, very inconvenient for dapps designed for mass use. end-users have pay for every interaction with their dapp, proportion the computational and storage resources required for their transaction. other words, ethereum doesn't give decentralized applications the flexibility manage resources themselves. for example, "freemium" business model outright impossible. this creates barrier for decentralized application adoption: most users are not ready pay for every single click. chromapolis solves this issue provisioning resources the decentralized application level: each dapp has its own blockchain (sidechain) fees (collected maintain nodes) are paid the dapp whole, not end-users directly consequently, dapps are free implement their own resource management policies, which can aligned with economic rather than technical needs. every blockchain needs anti-spam mechanism, but this mechanism doesn't have tied fees. for example, dapp might allow only action from user each seconds, thus single user won't able spam the blockchain with billions transactions. dapp can also mitigate sybil attacks through limiting new user registration some reasonable rate and/or requiring invitation deposit. this model, not need measure the resources used each operation. instead, provision resources the application whole: each dapp blockchain will run specific set nodes and typically will have its own dedicated cpu thread. dapp needs more than one execution thread, can consist multiple shards each which will sidechain. indeed, the fact that the cost for the user increases more people join the network (greater network congestion higher fees) totally odds with the economies scale upon which computing technologies thrive. this removes resource metering overhead (we longer care how many instructions were executed, application cannot use more resources than was given) allowing dapps perform faster and scale better. besides scheduling, having dapps first-class citizens the platform allows token economics integrated with the fee model, i.e. fees are taken from profits "earned" application. also supports mechanisms for governance and dapp updates which are built-in the platform. these features are discussed more detail later this paper. programming model the postchain framework which chromapolis based allows use existing open source sql database software (specifically, postgresql) implement data store and query capabilities. however, cannot allow dapps perform arbitrary sql queries said queries might unsafe, ambiguous lead excessive resource use. most dapp blockchain platforms use virtual machines various kinds. but traditional virtual machine architecture doesn't work very well with the chromapolis relational data model, need way encode queries well operations. for this reason, are taking more language-centric approach: new language called rell rel ational anguage) will used for dapp programming. this language allows programmers describe the data model/schema, queries, and procedural application code. rell code compiled intermediate binary format which can understood code for specialized virtual machine. chromapolis nodes will then translate queries contained this code into sql (while making sure this translation safe) and execute code needed using interpreter compiler. rell will have the following features: type safety static type checks. it's very important catch programming errors the compilation stage prevent financial losses. rell will much more type-safe than sql, and will make sure that types returned queries match types used procedural code. safety-optimized. arithmetic operations are safe right out the box, programmers not need worry about overflows. authorization checks are explicitly required. concise, expressive and convenient. many developers dislike sql because highly verbose. rell doesn't bother developers with details which can derived automatically. data definition language, rell more compact than sql. allows meta-programming. not want application developers implement the basics from scratch for every dapp. rell will allow functionality bundled templates. our research indicated that existing language environment has this feature set, and thus development new language was absolutely necessary. designed rell such way that easy learn for programmers: programmers can use relational programming idioms they are already familiar with. however, they don't have out their way express everything through relational algebra: rell can seamlessly merge relational constructs with procedural programming. the language deliberately similar modern programming languages like javascript and kotlin. familiar language easier adapt to, and our internal tests show that programmers can become proficient rell matter days. contrast, the algol-style syntax pl/sql generally feels unintuitive modern developers. the ethereum programming model typically described very error-prone. bugs ethereum smart contracts have resulted losses totalling hundreds millions dollars. chromapolis, aim eliminate most common sources problems through better programming model (no weird interactions between different smart contracts the dao case) and safer languages. since ethereum code immutable, often impossible for developer fix her dapp unless she retains full control, thus making not-quite-decentralized. chromapolis, upgrades can deployed through built-in governance and transition mechanism. consensus nodes model overview clear that the full node model doesn't scale particularly well. require users run full node which has complete copy the system state then dapps are severely limited what computations and storage resources they can use. with the aim achieving better performance scale, propose model which individual dapps are hosted subset validator nodes which establish consensus any modifications the dapp state, and handle client queries. the system should permit any user run full replica node desired, but the system should not depend these replica nodes for operations. sybil control mechanism the research done our team indicates that commonly used sybil control mechanisms like pow and proof stake (pos) are unsatisfactory: neither them guarantees sufficient level sybil attack mitigation, even particularly good measure decentralization. evidence indicates that most pow-based blockchains, including bitcoin, might facto controlled small group entities. this problem particularly bad for smaller cryptocurrencies which not list the most serious ethereum vulnerabilities can found here: https://www.dasp.co/ https://blog.ethereum.org////critical-update-re-dao-vulnerability/ https://www.wired.com///-million-hack-just-showed-dao-human/ bentov, i., gabizon, a., mizrahi, (january cryptocurrencies without proof work. https://arxiv.org/abs/. bentov, i., lee, c., mizrahi, a., rosenfeld, (december proof activity: extending bitcoin's proof work via proof stake. https://eprint.iacr.org//.pdf https://download.wpsoftware.net/bitcoin/pos.pdf yet have independent mining ecosystem. pos also comes with decentralization guarantees, and dpos particular prone formation cartels and bribery. thus instead following commonly used approaches will design chromapolis consensus and sybil control mechanisms from first principles. what chromapolis trying achieve can compared cloud computing: application which redundantly uses multiple cloud hosting providers can considered decentralized application, the sense that failure censorship single cloud hosting provider does not result shutdown the whole application. cloud computing model also allows users use thin clients instead hosting complete replica the application backend their personal device. the essential roles the chromapolis model are defined follows. chromapolis software runs nodes physical virtual instances computing power. nodes are controlled perhaps owned some kind individual, organisation, collective which refer provider. users connect such nodes post transactions, query data synchronize their private replicas. byzantine fault tolerant network distinguished from merely fault tolerant network its ability tolerate arbitrary and potentially malicious behaviour network participants. the concept nodes sufficient for designing fault tolerant network, but target proper byzantine fault tolerance must account for conscious provider entities with the potential coordinate multiple nodes. crucially, keep dapp decentralized need make sure that the nodes which run its blockchain(s) belong different and non-colluding providers. that case the application can tolerate subset providers experiencing failures, being compromised performing hostile actions. for this work, network participants need know which nodes each provider controls and ii) make sure that providers are actually distinct. the latter cannot done mechanically, but can done socially. there plenty evidence that microsoft and google are different providers, but there's mechanical way prove it. believe that all decentralised consensus ultimately depends "social consensus". fully automated decentralised systems are fantasy, the end people who determine the rules the system. chromapolis acknowledges this, and includes fundamental design principle. practice, provider distinctness will achieved follows: initially, chromaway will select set distinct providers. believe that our extensive knowledge blockchain and industry will allow choose well, and are incentivized select providers that the users will accept. users who are concerned about provider uniqueness are welcome their own research and contribute the decision making process. delegated proof stake, https://bitshares.org/technology/delegated-proof-of-stake-consensus/ eventually, once the system has sufficiently diverse set providers, will allow providers themselves vote add new providers and the system will longer depend chromaway gatekeeper. consensus each blockchain within chromapolis will associated with set validator nodes which subset all nodes belonging chromapolis. this subset nodes will run bft consensus algorithm. since the set size limited, pbft-like algorithms are the optimal choice they are well-researched, work well with smaller sets validators, and provide definitive finality, making reorganization impossible. however, there are two systemic risks with signature based consensus this kind which must considered: the possibility collusion between providers. the possibility that majority nodes might compromised via "zero-day" exploit some kind. the former risk extremely subtle, and discussed some length elsewhere this paper. the latter generally difficult defend against, the best approach encourage diverse range software and hardware the provider ecosystem. even with mitigation strategies place, the threat compounded the behaviour signature-based consensus under failure conditions. has been shown prone catastrophic failure, meaning that breakdown consensus can corrupt the chain the point that becomes very difficult recover. for this reason, decided implement additional layer protection anchoring blocks pow-based blockchain, such bitcoin ethereum. this can done cheaply, single bitcoin transaction anchoring the entirety chromapolis every few blocks costs very little, and will guarantee that chromapolis confirmation strength will least strong bitcoin blocks which are anchored. for example, user who prefers rely bitcoin security can wait until incoming payment confirmed via bitcoin anchoring before they send goods. node compensation dapps require computational resources and storage and should able pay providers for them. providers should incentivised offer high quality services dapps competitive prices. chromapolis will establish marketplace where dapp developers and node providers can buy and sell resources. chromaway will act key node provider the very early stages. new providers will join the ecosystem gathers momentum, with lower resource prices stimulating dapps and higher prices stimulating providers. eventually market equilibrium will achieved. estimate that the long run the cost using node resources will roughly match the cost cloud computing platforms like aws ec. https://download.wpsoftware.net/bitcoin/pos.pdf miscellaneous features believe that meet the requirements high performance decentralized applications chromapolis has meet the following requirements: confirmation time: second (necessary for good ux, real-time user interactivity...) transaction rate: tps per sidechain. overall rate the whole system unlimited. capacity: updates and reads per second preliminary tests the postchain framework demonstrate that possible meet and exceed these requirements. chromapolis will also come with client sdk which supports development the client side decentralized applications. sdks will offered for javascript (to enable browser-based apps), java and other languages. the sdk will also enable platform-wide single-sign-on and wallet for key management spare users the hassle registering each app separately. decentralized applications assume that the reader this document already familiar with the concept decentralized application. nevertheless, makes sense clarify what exactly refer, connected intimately the goal the platform. 'decentralized application' mean multi-user application which hosted and provided decentralized way. that is, single entity should have control over the functionality such application. potential problems with central control are that the controlling entity can: shut down the application deny service certain categories users monetize users violating their privacy remove functionality which valued users open source and peer-to-peer software addressed the centralized control issue for certain categories apps, such office software and file sharing, but software which relies server-hosted databases much more challenging. bitcoin was arguably the first achieve just this, creating secure decentralized shared database financial transactions and enabling payment applications outside the control centralized entities. however, bitcoin's "database" extremely primitive. more advanced decentralized database makes possible decentralize even more applications, and probably create completely new kinds applications which were previously inconceivable. decentralized applications have the following desirable traits: not controlled single entity. ideally, controlled the community users. cannot shut down censorship-resistant service cannot denied transparent, users can see what going privacy users have control over their data highly available not expect decentralized applications have all these features. fact, some features might contradict each other. for example, dapp may enable the majority users restrict access minority, which case the dapp controlled users, but not censorship-resistant. practice, application developers aim reasonable compromise between decentralization and other priorities. transparent apps some apps are only partially decentralized: only data which critical for transparency hosted the blockchain, while the rest the app centralized. such applications are better described transparent apps (tapps) than decentralized apps. many apps which are marketed dapps are fact tapps. for example, cryptokitties stores kitty ownership information the ethereum blockchain. can shut down unilaterally the company which controls it, and can therefore not called decentralized meaningful sense. can shut down several different ways: shutting down the website. since the client code not open source, without the cryptokitties website becomes impossible play the game. shutting down contracts. the company behind cryptokitties can shut down contracts hosted the ethereum blockchain. thus, practice the only thing which differentiates cryptokitties from centralized app transparency. token model traditional funding and monetization models not work well for decentralized applications. the value calculation made traditional funding model based control centralized 'property' like data, user-base, intellectual property, and patents. decentralized application ideally belongs its users, diverse group stakeholders who form some kind mutually beneficial balance. there central party own assets, add value, and profit from that activity. that's why need different kind funding model which more compatible with distributed ownership. for ownership distributed, necessary denote the proportion ownership stake the system with some sort liquid semi-liquid asset. this makes possible quantify the stake proportion given actor, allows them add value without controlling submitting control, and exchange that value securely. usually this achieved with tokens. popular game that allows players purchase, collect, breed and sell various types virtual cats. https://www.cryptokitties.co/ the basic ico token model looks roughly like this: issue tokens. sell tokens investors. whatever you want with the money. instead that, chromapolis will provide mechanisms which balance the interests developers and users. essential this the chromapolis meta-token called chroma. dapp tokens can automatically backed with chroma, providing liquidity and value which independent investment into the dapp question. dapp investors can compensated chroma through profit-sharing contract. for developers, chromapolis offers the opportunity derive income from dapps. this incentivises the creation and maintenance high quality dapps because better dapps generate more income and create more demand for tokens owned the developer. the chromapolis model designed support sustainable circular economies and foster mutually beneficial relationship between developers, users, and investors. the role chromapolis chromapolis aims the decentralized database component decentralized applications. combination decentralized database and code, which run end-user devices (e.g. mobile browser app), will typically comprise the entire decentralized application. let's see how chromapolis enables dapp features: not controlled single entity. assume that after creating dapp, developers would make both front-end and back-end (i.e. parts which run chromapolis) code open source. this allows the app used and developed without necessarily involving the original developer. the data which belongs the app will hosted chromapolis. this done two tiers: the chromapolis root system consists diverse pool nodes which run application blockchains, manage token conversions, allocate node compensation, and other core functionality. each dapp will select some similarly diverse set nodes manage its data. both these tiers are decentralized cryptoeconomic systems, and thus can say that the application not controlled single entity. typically users will pay for the resources necessary host the application. potential problem that application code might grant control some centralized entity. ideally the users should demand independent review and use the application only control structures are reasonable. controlled the community users. chromapolis will include optional governance mechanisms which will allow users control various aspects dapp functionality. for example, code upgrades. cannot shut down. mentioned above, chromapolis enables decentralized application hosting, this ensures that single entity cannot shut down application. but cannot guarantee that application cannot shut down legal action. chromapolis root structures will dominated few companies (at least within first few years its existence) which have comply with laws. thus application might have evicted from chromapolis. should note, however, that application fundamentally belongs users. chromapolis public hosting platform and completely open source. users disagree with government decision shut down the application, they can simply move their data elsewhere, i.e. they can set different polis (similar fork traditional blockchain) different jurisdiction. long users have need for application and are willing support it, cannot shut down. censorship-resistant. the chromapolis model, application developers will typically delegate operations nodes. nodes process user requests using consensus mechanism. thus neither developers nor nodes have the ability implement censorship whim. theoretically possible that multiple nodes can collude implement censorship, but then users can demand that the application moved other nodes. course, possible that application would have some censorship components (anti-spam, anti-abuse, etc.) features. what reasonable depends the particular application. users believe that censorship unwarranted, they can fork the application and host updated version. transparent. application data will hosted multiple nodes and blockchain consensus makes immutable once it's finalized. believe that many applications will have transparency the only feature. chromapolis neutral technology provider, doesn't itself enforce decentralization. many cases transparency already huge improvement over the status quo. privacy. privacy complex topic. decentralized application data typically public, thus the application has engineered with that mind. for example, might use pseudonymous identities, cryptographic constructs such hashing, zero-knowledge proofs and on. believe that this approach better than traditional approach based trust and secrecy application providers. centralized model, provider's security breached, privacy compromised. our model, since the data data public the first place, cannot compromised. chromapolis plans offer privacy-enhancing features (for use dapps) future. highly available. chromapolis designed withstand node failures. the number failures can withstand configurable parameter. minimal number nodes four, that point can withstand one node failure. higher availability desired, higher number nodes can used. decentralization quality chromapolis aims neutral technical platform rather than moral authority, thus will allow applications hosted regardless their decentralization level. however, believe that decentralization important, and it's important for users know features application they are using. for this reason, plan develop guidelines and evaluation criteria. independent companies will able rank applications these criteria. also encourage users demand independent code audit. platform architecture this section describe the platform architecture, expanding the "design rationale" section. postchain chromapolis based the postchain framework. postchain defines interfaces between the components blockchain-based system and provides number building blocks for networking, consensus, cryptography, etc. the main difference between postchain and other blockchain frameworks that postchain designed store blockchain data (both raw blockchain contents and application state) relational database. not only that, postchain allows transaction logic and consensus fully aligned with relational database; e.g. transactions which violate constraints the database are rejected and excluded from consensus, they not result fatal errors any kind. postchain implemented largely kotlin and runs the java virtual machine (jvm). the jvm one the most commonly used virtual machines, it's geared towards server use cases and has large number libraries available. the jvm provides inherent protection against vulnerabilities such buffer overruns/underruns, data leaks and controls access objects, performs array bounds checking and does not expose error-prone features such raw pointers. thus apps implemented the jvm are usually free problems such remote code execution even when they contain bugs. this very important for blockchain software remote code execution can lead huge losses. kotlin further tightens type checks and particularly ensures null safety within the code written kotlin. believe that use modern programming language designed for safety can reduce the number defects and help make sure remaining defects not lead drastic consequences. source code can found https://bitbucket.org/chromawallet/postchain/ postchain allows multiple blockchains hosted single database and allows one blockchain "see" data belonging another blockchain when that data final (committed). this simplifies implementation inter-blockchain interaction, blockchains can refer shared data without any additional overhead complexity. particular, this can used for inter-blockchain asset transfers. chains chromapolis divided multiple blockchains order achieve horizontal scalability. this model, each node only needs work with data related its corresponding blockchains. this architecture increases scalability and simplifies updates, update single blockchain will have effect others. the overall system consists number "system" blockchains which are essential for chromapolis functionality and number application blockchains which are specific particular applications. system chains: root chain. validators root nodes. purpose: keep track the list root nodes. description: the root chain needed for thin clients able validate any data within chromapolis without downloading the entire blockchain. directory chain. validators root nodes. purpose: keep track all providers, nodes, application blockchains and their validators. description: the directory chain responsible for keeping track all critical information and orchestrating the operations the system. token root chain. validators defined directory. purpose: keep track chroma tokens. description: the token root chain keeps track token distribution between other chains. anchoring chain. validators defined directory. purpose: defend against attacks subset nodes. description: the anchoring chain records hashes blocks other chains. this makes possible detect consensus failures. case consensus failure, blocks anchored the anchoring chain take precedence over other versions blocks. the anchoring chain itself anchored bitcoin ethereum blockchains. (security considerations related the maintenance multiple chains are explained separate section.) node implementation the data model and operations needed for system functionality such node selection and rewards can implemented rell. use high-level, declarative language can simplify the implementation and reduce the possibility defects. interaction with other blockchains interaction with the bitcoin and ethereum blockchains are needed for anchoring. ethereum interaction needed allow eth used for payments within chromapolis and for chroma erc token. this functionality can implemented via indexers: nodes which have interact with ethereum need run ethereum node parallel chromapolis node and import information from the ethereum blockchain the chromapolis database. components the following list software components which plan implement for the chromapolis mvp release: rell compiler and runtime environment rell ide: tooling which makes development easy client sdk: allows front-end (web mobile app) connect and interact with chromapolis. chromapolis node, system chains bitcoin ethereum support needed for anchoring chroma erc contract, gateway chromapolis side auto-conversion smart contract ethereum governance chromapolis supports different governance structures the system and application levels. chromapolis system governance system-level governance covers the following topics: system updates, that is, updates system blockchain structures, their rules and on. tuning parameters such the price running dapp according economic realities. acceptance new members into the system. exclusion bad actors. obviously, governance must decentralized, single entity shouldn't have control over the system. believe that providers are the best position perform governance duties: they can professionally review the proposals. they are motivated keep chromapolis interesting both for users and for application developers. bad governance decision will affect revenues and profits collected providers. thus can require providers vote favor governance proposal approve it. initial centralization the initial launch chromapolis mvp will likely not have sufficient quantity independent providers. thus the initial stage governance will centralized: all decisions will made chromaway consultation with system stakeholders. transition proper decentralized governance will happen when the system ready from technical perspective and the provider ecosystem healthy. rejected alternatives stake coin voting widespread governance model blockchains which have on-chain governance stakeholder vote "coin voting". this particularly common dpos blockchains since stakeholder voting essential part sybil control consensus mechanisms. thoroughly considered this model and rejected for the following reasons: usually not possible control stake decentralization, i.e. tokens might concentrated few hands, therefore cannot guarantee decentralized governance. it's not fair the sense that rich stakeholders have more power. many users keep their tokens exchanges, essentially allowing exchanges vote for them. dpos style voting seems particularly prone problems with bribes, cartels and centralization. these problems have been actually observed the wild. even tokens were more-or-less evenly spread, few users actually through hassle voting, few users can understand the proposals, etc. this was demonstrated the dao case. formal governance some cryptocurrencies, e.g. bitcoin, take pride having formal governance. might work fine all they want "digital gold" after all, gold itself has governance. but chromapolis more complex, and needs able respond challenges timely and coordinated manner, thus chromapolis needs formal governance system. unique users it's tempting give one vote each user thus making governance fairer than "voting with money". but it's impossible identify unique users decentralized setting, and many issues related stake voting still apply. particularly, users might not informed enough make good decisions. still, plan experiment with this kind governance: our plan identify set users who actively want participate governance "citizens chromapolis". sybil control can implemented keeping track the social graph. have immediate plan give these users any formal governance power, but they can cast advisory votes. application governance different applications have different governance needs: some are designed immutable and thus would require governance all. other might exercise direct democracy and give each user right vote. another option implement weighted voting, e.g. proportional tokens one has. dapp developers can also play role governance, and either: maintain full control work together with users through voting, e.g. developer makes proposals which users can approve reject want give developers and users ability decide for themselves and experiment with different forms governance they please.however, want ensure that users always have certain freedoms: the freedom access and copy application data. this inherent property public blockchain. the freedom fork the application. this inherent property free and open source software and public data: anyone can make modified copy software and run copy data. thus not impose any restrictions which aren't inherent property applications running public blockchains. chromapolis will provide tooling which would give users ability fork dapp they are displeased with its governance just want experiment with something different. our goal make sure that this forking can done smooth and civil manner. uses chromapolis general purpose platform suitable for wide range applications. but live world with many competing blockchains, thus makes sense focus relative strengths: chromapolis database-centric, such particularly suited for applications which are similar databases their nature, deal with complex data schema, complex queries, indexing and on. chromapolis has excellent data read-write capacity, thus it's uniquely suitable for applications which require operating large amounts data. chromapolis allows both fast queries and fast confirmations. thus suitable for interactive applications where data needs displayed and updated within seconds. chromapolis very flexible terms resource use policies, thus can accommodate different business models which not work the previous generation blockchains. tokens tokens are the bread and butter blockchains. high capacity: aim support million token transfers per day per blockchain mvp version software. this isn't world record, but should enough support large user bases. token transfer capacity can further improved future versions. low latency: transfers can confirmed within seconds which should enough support in-person payments. flexibility: token implementation fully programmable, any imaginable feature can implemented. custom fee policies: fee policy decided per-dapp basis. this means that transfers can free, subject flat fee, fee proportional the trade amount. native multi-token support and atomic swapping: trustless token exchange implemented transaction format level, doesn't even require any special support the dapp. inter-blockchain transfer: tokens can moved between different blockchains within chromapolis. non-chromapolis blockchains can supported future. thin wallet support: thin wallet (e.g. mobile browser wallet) can validate transfers within seconds, without syncing with blockchain. games blockchain-based gaming fast-growing sector the crypto economy, but current blockchain technology severely limits what games can offer. typically blockchain used only host tradable tokens, while the actual gameplay happens outside blockchain. chromapolis can allow much more advanced kinds games where the entire game world can hosted within the blockchain, evolving over time according predefined rules. updating the game state every cycle requires number read and write operations proportional the number units the game. this means that blockchains which not have high read/write capacity can support relatively few units/players. the evm, loading and storing memory cell which already non-empty costs gas. the block gas limit the time writing ,,. thus ethereum can most read/write operations per block. the entire ethereum blockchain was dedicated single game, most units could updated (e.g. moved) per minute. proof-of-authority public blockchain called gochain offers gas per block and second inter-block interval. this implies cell updates per second. for chromapolis target least cell updates per second the mvp release, offering capacity that twenty times higher than the best available public evm-based chains. plan increase this number future with optimized in-memory blockchain state storage. here's list chromapolis benefits for gaming applications: fast game client load (thanks advanced query capability the entire game state relevant the user can transferred the client matter seconds) interactivity: updates can confirmed within seconds, data can retrieved from blockchain within seconds high read write capacity (upwards updates per second) good support for complex data schemas needed support game worlds ability update code over time comes with game token pegging contracts which can create automatic liquidity for game tokens. token use games will covered more detail the "token" section. business uses based our experience with enterprise blockchain applications, believe chromapolis can used applications where data either open, can openly hosted encrypted form, only commitments (hashes) need revealed. this can particularly relevant applications which are connected transparency. indeed, publishing data via private blockchain hardly makes things more transparent. chromaway planning offer chromapolis-based storage option for its esplix business contract platform, thus allowing businesses utilize esplix contracts without hassle running their own blockchain nodes. tokens and incentives similar how tokens are used ethereum pay transaction fees and compensate block producers, chroma tokens are used chromapolis compensate block-producing nodes. but there difference: the ethereum model, fees are paid directly users who make transactions. chromapolis, fees are paid dapps, which can their turn collect fees from users. this discussed more detail the next section. fees application fee models chromapolis, users pay fees indirectly: the dapp pays nodes hosting fees. fee paid from dapp token account daily basis and depends computational resources requested the application and used data volume. the dapp itself can collect fees from users according its own policies. this means that there's system-wide fee policy for users. dapp developers are free implement any policy they want. believe following fee models might relevant: classic model: fees are paid for each performed action. unlike bitcoin and ethereum the price can fixed, fees not need demand-based. subscription model: user pays subscription and then can perform actions without additional payments, however, these actions should rate-limited prevent abuse. for example, twitter-like service user might restricted messages per day. freemium model: certain action might performed for free, but other actions might require paid subscription. the freemium model very common for internet businesses. subsidized model: application might collect fees from users, and instead rely pre-funded account provided sponsor. this can work well when sponsors derive benefit from users outside blockchain, e.g. the dapp might available only users who bought physical product. this model could work well with manufacturers iot devices sponsoring users who bought the device for use related dapp. donation-based model: wealthy donors might donate tokens provide services users for free. gameplay-connected: user can pay fees indirectly when they perform game actions: buy in-game items, land, etc convert tokens "game gold" trade items pay in-game taxes hosting fees general, chromapolis dapp hosting fees depend not resources consumed application, but resources allocated for application. this similar how dedicated and "virtual private" server hosting works: the hosting company doesn't care what server actually doing, wants compensated for providing server. this also the model used aws ec, google cloud compute engine and similar services. the blockchain space, similar model used eos. applications' needs can very different. some applications require lot computational resources, some need process large number transactions, some need more storage space, some need small amount very fast storage. the kind hardware which optimal for application depends its requirements. for this reason, introduce different node classes. class requirements will likely evolve over time depending needs applications, provider capacity, hardware availability, etc. provisionally, mvp launch want introduce three classes: the fastest class for applications which require high transaction rate expensive processing. specs: ghz cpu, two hardware threads per blockchain, nvme storage. medium class. specs: ghz cpu, hardware threads per blockchain, ssd storage. economy class. specs: ghz cpu, equivalent single ghz hardware thread per blockchain, ssd storage. application hosting fee paid daily basis split into several components: percentage processing time. number transactions. storage. chromapolis doesn't have the means precisely measure computational resources "consumed" application this depends variety complex factors which are outside control chromapolis code (cpu caches, cpu pipelining, context switch overhead, engine optimizations etc.). instead chromapolis will measure the median time taken process block reported block producer nodes. when thread allocated for application never goes idle (i.e. continuously builds applies blocks), the application using processing time. that case pays full price for one day hosting for particular class. when application uses less than processing time, it's eligible for discount. for class and nodes, the discount limited even the application completely idle still has pay half the day hosting price. this necessary because actual physical resources are allocated application whether uses them not. limited discount provided because want encourage applications efficient possible. idle time might increase capacity available other applications, decrease energy consumption and hardware wear. for class node hosting there limit discount and applications which build blocks will pay nothing hosting costs. additionally, class allows applications specify throttling. application that doesn't want pay more than the daily hosting fee can throttled use more than processing time. class nodes will use special algorithms which allow efficient co-hosting large number blockchains. result this, class nodes target rather than guarantee their posted capacity. storage costs and per-transaction costs also depend the class nodes used application. hosting data class nodes will much cheaper than hosting the same amount data class nodes. the hosting price standardised selecting the median prices submitted all providers. more sophisticated market which allows providers auction spare capacity will developed the future once the number providers exceed decentralization needs. node incentives the block building process should properly incentivized. that say, should not profitable for nodes neglect their duties e.g. making only empty blocks blocks all. theory the collective providers has interest offering great service all applications. applications move other blockchain platforms, providers cease make any money. however, also need consider providers who might try cheat the system for individual gain. beyond the basic incentive not create invalid blocks conflicting histories (which can automatically detected and punished automatically excluding node, and possibly its provider, from the system), the system can track the following data: number blocks built node for particular blockchain primary (the role primary rotated over time). number transactions blocks built node primary. number commit messages submitted. this data can used detect nodes which neglect their duty primary are not fast enough submit commit signatures. nodes which systematically underperform can excluded automatically through providers' vote. note that nodes whole have interest accepting many transactions possible and storing much data possible they are paid number transactions and storage used. another resource which other blockchain systems typically neglect node's capability reply queries. indeed, nodes are compensated only for the amount data processed, they are incentivized ignore queries and only process transactions. but users run light clients, queries are absolutely crucial. have developed mechanism which creates incentive for nodes reply queries. explained detail the appendix. simply put, upon receiving response from node client can discover that this response "lucky" via mechanism similar pow. only fraction all responses (e.g. million) "lucky". lucky response published certain blockchain and yields small reward both user and the node which produced the response. special provisions (covered the appendix) are made discourage nodes from farming lucky responses their own. node stakes encourage providers secure their nodes they will required put chroma tokens into separate account which represents the provider's stake the chromapolis economy and used collateral which forfeited when nodes owned provider misbehave. providers can group nodes into units with different levels stake: high, medium, low. high-stake nodes should more thoroughly secured they can used for applications highly sensitive security, such running system blockchains and high-volume financial dapps. low-stake nodes can used for less sensitive dapps such simple games. each dapp can specify minimal stake which required for nodes which run it. the stake level necessary for system blockchains set council providers. token use games the current generation blockchain games are based collectible items and not offer rich gameplay. envision new generation massive multiplayer online games with rich game worlds hosted within chromapolis blockchains, and rich market economies based tokens and tradeable game items. for this kind game chromapolis can offer set smart contracts which make game tokens liquid and valuable. this would allow game developers quickly bootstrap game economies. for game users, pre-made smart contracts offer certain degree stability: they can sure that game tokens they earn won't lose all their value overnight due poorly coded token structure. the heart chromapolis game smart contracts, market making/token conversion algorithm similar widely known "bancor algorithm" similar algorithm was discovered chromapolis team members before bancor). when chroma tokens are converted game tokens (e.g game "gold" tokens), new game tokens are created. chroma tokens are put into the smart contract reserves and the price adjusted. price adjustments work such way that higher demand (more people buying game tokens than selling) results higher price. when game tokens are converted back chroma, the price reduced. the algorithm can configured enable smooth price movement, the game token price against chroma cannot drop significantly unless the vast majority users abandon the game and convert their tokens chroma. fee can collected upon conversion adjusting the buy/sell price. for example, fee can taken out the chroma amount and used to: pay for game dapp hosting fees (i.e. it's transferred dapp's hosting account) pay the game developer and, possibly, investors game token price increasing with demand means that players have incentive invest into game gold. fact, they have incentive discover new interesting games which are going grow popularity over time. indirectly they also have incentive promote and share the games they play. this set incentives can result healthy game community dynamics. the full list chromapolis features developed specifically for use game applications will published separate paper. chroma token economics summarize, the chroma token has the following roles chromapolis: used dapps pay hosting fees, thus compensating the nodes. used "standard" currency within the chromapolis economy, dapps can collect fees, use reserves peg their own tokens, etc. used make sure that providers have stake chromapolis ecosystem thus offsetting incentives collude. since chroma tokens are used for stake and reserve purposes expect significant amount taken out circulation and "locked" for this kind use. system accounts chromapolis has several special chroma token accounts which are used for system-wide purposes: erc token pegging: chroma tokens this account belong owners chroma erc tokens which enable some interoperability with the ethereum blockchain. this account managed the ethereum gateway blockchain. system node compensation pool: nodes which run dapp blockchains are compensated dapps. but nodes running system blockchains also need earn money. for this reason certain percentage (decided the council providers) taken out hosting fees and sent the system node compensation pool, which then used compensate nodes for hosting system blockchains. other words, chromapolis itself can seen dapp which orchestrates and taxes other dapps. future development pool: initially chromaway and its subsidiaries will develop chromapolis, but eventually this role should decentralized. once the economy sufficiently decentralized the "future development pool" can unlocked and used according providers' vote improve chromapolis whole. charity pool: certain situations where tokens are sacrificed (explained below) fraction such tokens can diverted into charity pool. funds from this account can used donate charities according users' votes. this can promote chromapolis ethical and socially-conscious blockchain. public good account certain situations tokens need "sacrificed" (irreparably destroyed burned) avoid conflict interest the possibility abuse. these situations include sybil control mechanisms, punishment misbehaving parties "neutral action" case disagreement between two more parties. chromapolis offers alternative irreparable destruction the form public good account. this virtual account which automatically distributes received tokens into different accounts: tokens are burned; burning tokens indirectly benefits all chroma token holders tokens are permanently removed from circulation tokens are put into the "system node compensation pool" tokens are put into the "future development pool" tokens are put into the "charity pool" thus all chromapolis users indirectly benefit from the public good account the long term. it's very unlikely for the public good account abused control funds are collectively controlled and aren't easily accessible. therefore viable and productive alternative simple "burning". funds will sent the public good account following cases: user would need send chroma tokens the public good account become "chromapolis citizen". this confirms the user's commitment chromapolis and gives certain perks such the ability vote, priority services, the ability participate "lucky request" reward program, etc. (details about this program are covered the appendix.) the lost stake misbehaving nodes sent the public good account. application hosting fees are sent the public good account additionally, encourage dapps use the public good account when the destination tokens unclear for some reason, tokens need destroyed for game-theoretic reasons. for example, "burnable payments" simple game-theoretic mechanism which makes sure that that neither buyer nor seller have incentive cheat: the buyer disagrees with the seller can burn escrowed funds. token distribution one billion tokens will created upon launch the system. that constitutes the token supply limit, tokens will created the future. initial distribution tokens: owned chromaway through its subsidiary chromapolis devcenter sold, awarded team members, invested used any other way put into automatic conversion contract ethereum blockchain enable chromaeth conversion put into system node compensation pool allocated for promotional use: given users try applications hosted chromapolis within the chromaway allocation, (of all tokens) will sold initially select partners. the rest will locked and released slowly over time. will unlocked during the first year after launch, then per year. chromaway and its subsidiaries will hold tokens for least three years. this creates long-term incentive for chromapolis development. after three years chromapolis development and governance must transition decentralized model. promotional tokens will also initially locked, and unlocked rate per month. thus percentage tokens circulation changes over time: start: after year: after years: after years: after years: promotional token fund the use the promotional token fund will initially controlled chromapolis devcenter. its purpose encourage use chromapolis platform and dapps hosted chromapolis. tokens from this fund should given only end users, they shouldn't used fund development projects. the rationale for this fund that it's hard for average internet user acquire tokens: they need register crypto exchanges, which lot hassle. also people are generally reluctant spend money just try out new app (which might not-so-great). thus necessary give away tokens for free build mainstream user base. however, this needs done with caution. obviously, sybil control measures should used -it certainly possible that somebody will try impersonate multiple users acquire large number tokens for free. one possible way mitigate abuse require some form identification (e.g. facebook account). tokens might also given out for use within specific app game. tokens from promotional fund are released gradually to: onboard users the system grows monitor the situation and experiment with different ways distribute tokens avoid disrupting the value chroma per month maximum distribution rate. promotional use deemed inefficient tokens might reserved for later use sent the public good account. decentralization centralization necessary start chromapolis shall true decentralized platform for decentralized applications: not controlled anyone, open for permissionless innovation. decentralization not starting point, but goal. proper decentralization requires strong community with large number independent participants who are committed chromapolis. but building community takes time. the platform needs prove itself before it's deemed interesting enough contribute it. thus chromapolis will centralized start; believe it's better embrace this and use centralized development and governance model speed development than play pretend-decentralization. for this reason, chromaway opened for-profit company called chromapolis devcenter which will act chromapolis development center the initial stages. the largest holder chroma tokens which are locked for years, chromapolis devcenter motivated increase the value chromapolis system, that will likely also increase the value its holdings. after observing the cryptocurrency ecosystem for years, believe that for-profit model the optimal way scale the development the initial stages. here are some examples failures more decentralized community-based models: the colored coins project suffered from slow development and fragmentation. even monetary bounties didn't help attract persistent developer base. developers who joined the project temporarily produced low-quality code and then hopped something else. the mastercoin project (now known omni) bounty-driven process produced three incompatible implementations. eventually they switched centralized process and achieved better results. ethereum foundation failed create working light wallet for three years. result, users had rely unsafe web wallets, struggle with keeping their full node wallet sync. for-profit company, chromapolis devcenter will able set concrete goals and focus them; particularly, focus features which are essential for chromapolis platform adoption and user base growth. beyond development, chromapolis devcenter can also organize promotional events help companies build dapps chromapolis collaborate projects with other companies invest into the dapp ecosystem believe that these activities are better done for-profit, commercial basis. non-profit foundation models can result inefficient use funds, abuse, corruption, etc. it's important highlight that chromapolis devcenter not chromapolis. once launched, chromapolis network will have certain degree autonomy. chromapolis devcenter cannot force people run particular version software. also cannot modify any blockchain records state beyond what was explicitly granted access to. thus cannot held responsible for what happens within the network. with respect chromapolis network, the role chromapolis devcenter the following: produce free and open source node software, which can independently inspected and modified needed. control certain parameters such the pricing resources and selection providers until the network big and decentralized enough control these parameters its own. there are two risks associated with this role: see interview with chromaway cto, the time leading the colored-coins project, coindesk https://www.coindesk.com/colored-coins-paint-sophisticated-future-for-bitcoin/ node software (or other relevant software) will have backdoor other security threat. mitigation: encourage providers and users review software before running it. system parameters provider selection can set values which disrupts the system. mitigation: will limit the rate change via blockchain rules enforced nodes. the worst case providers/users can fork the network avoid disruptive settings. decentralization through diverse set providers once the provider ecosystem mature enough, governance can transition group providers. how does this compare the quality decentralization seen other blockchains? bitcoin satoshi originally described bitcoin cpu vote" kind system. the original user base mostly consisted ordinary internet users interested systems, and block production was extremely decentralized. still, satoshi was essentially the dictator and could change code wants. could, principle, make update which would steal coins from other users. eventually the situation with code updates became better: all code which goes into bitcoin node software reviewed, bitcoin node binaries are built using gitian process which allows multiple parties verify that code the repository corresponds binaries, this means that end users can rely decentralized group developers control for possible backdoors and other issues. the other hand, the situation with block production became worse over time. first, users joined "mining pools" make rewards more predictable. result they longer produce blocks, but instead rent their hashpower pool which produces blocks. this means that mining pool can, principle, produce malicious chain blocks. theory, users should notice this and switch different pool, but will take some time. certain point time, single pool (ghash.io) had total hashpower, and users did nothing. another problem came with the advent asic mining: asic manufacturing companies started mining their own. companies which had more efficient chips got higher profits and could reinvest into expansion. economies scale create positive feedback loop where production mining chips and mining itself becomes more and more centralized. this culminated bitmain shipping more than all mining equipment, and bitmain-affiliated mining pools having more than total hashrate. bitmain doesn't report any statistics, but have every reason believe that warehouses with the bitmain logo them full bitmain miners actually belong bitmain and are the source enormous hashrate. any case, the currently biggest three mining pools can control the network, and two them are affiliated with bitmain. also undeniable that the majority hashpower hosted inside china, thanks cheap power, cheap facilities and on. this gives the chinese government the possibility control bitcoin. could potentially seize facilities and execute attack, soft fork introduce censorship. pow centralization resulted delayed network updates and bitcoin become practically unusable for payments due extremely high fees. summary: while bitcoin development decentralized, block production heavily centralized. dpos was observed that dpos-based blockchains bitshares, lisk, ark, steem, eos have large degree stake centralization, which means that few large token holders can effectively control the network. problems with dpos centralization are thoroughly explained vitalik buterin. ethereum ethereum block production currently pow-based and thus has roughly same problems bitcoin (the three biggest pools can control block production). meant eventually transition proof-of-stake. that doesn't mean that every stakeholder has chance produce block. instead, the number block producers will restricted about entities, thus smaller token owners have delegate block production pools order participate. chromapolis appears that existing projects give control the network very large set people. neither does this appear particularly useful approach, most people not have enough technical knowledge and motivation keep the network safe. person who runs software without carefully inspecting essentially just proxy for the entity which decided what software release. for this reason believe that the chromapolis model where the network controlled limited group providers not impediment decentralization. long these providers are truly independent, pursue their own goals (i.e. profit from hosting dapps), and operate many different countries, the system can considered decentralized. initially plan get least twelve providers. the long run the number can reach thousands, par with the pos scheme proposed for ethereum. another way look barrier entry. bitcoin asic miner can purchased for several thousand dollars, but user won't able generate any blocks his own. become significant player one needs hundreds millions dollars capital acquire hardware and build facilities. the other hand, any professional hosting company can become chromapolis provider and participate building blocks. thus believe that the barrier for entry actually lower than that seen other blockchains. https://vitalik.ca/general////plutocracy.html number full nodes public blockchains such bitcoin and ethereum boast large number full nodes estimated the range. while large number full nodes potentially increases network resilience, also has downsides: the network can't faster than its slowest node. thus both bitcoin and ethereum severely limit number transactions, well computational resources required process transactions. chromapolis takes different trade-off: number full nodes might limited number block producers, which will typically the scale nodes per blockchain. does this result lower network resilience? let's analyze different threats: node hardware failures assuming failures are random, it's extremely unlikely that nodes will fail the same time, before new replicas can made. network dos while certain scenarios bigger number nodes helpful, network can effectively disabled specifically targeting block producers, and the number independent node producers might actually higher case chromapolis. network partitions networks based pow consensus typically nothing detect network partitions, thus they can simply work through minor disruptions. but case major disruption might result double-spends the different sides the partition. the fact that chromapolis-style network stops case partition actually feature, not bug. should noted that chromapolis does not discourage users from running full nodes. every blockchain running chromapolis should public, therefore any user who wishes run full observing node for particular blockchain should able so, long has access modern hardware. fact, compare chromapolis ethereum, can said that chromapolis architecture makes easier run full node: ethereum user forced download data all dapps and all users. chromapolis user can choose what dapps interested and sync only the corresponding blockchain data. the number chromapolis full nodes might lower not because it's harder run node, but because with properly working light client it's just not necessary, and expect that fewer hobbyists care about specific dapps than about "the world computer". security blockchain the role the blockchain make sure that there single application state seen all users, and that double-spend and replay attacks are not possible. light client security model, blockchain nodes also take responsibility for validating state transitions and transactions. will discuss light client security separate section; this section will focus solely the security aspects the "full node" model. the most basic threat are protecting against single node wilfully violating the rules the system. this can occur because whoever controls has become corrupt for some reason, because has been compromised external attacker. centralized systems built using traditional software architecture have protection against that single compromised server can result arbitrary data modification, which case financial data can lead arbitrary losses. particularly this might happen the following scenarios: external intrusion through exploitation software hardware vulnerability. rogue employee system administrator other person who has access the server can exploit for personal gain. hosting provider's tampering physical access server allows provider modify data. the company itself can arbitrarily change data rules its own gain. the first layer protection against these scenarios application logic which requires both cryptographic authorization and deterministic computation model. when user's nodes have complete data they can detect cases where rules are violated and thus reject false application state. chromapolis this accomplished requiring applications developed rell: rell has deterministic computation model and makes easy implement cryptographic authorization for all data mutations. the overall architecture also makes possible for user nodes receive full input data (blocks and transactions) and independently compute the application state. more sophisticated attacker can exploit situations where multiple valid application states can exist the same time. this attack usually described double-spending, for example: attacker produces application state which merchant was paid ship some goods. the merchant ships the goods. the attacker replaces the application state with another where the merchant not paid, instead the funds are directed back the attacker's account. now the attacker has both the goods and the money. many variations this attack exist. for example, can done using different kinds tokens and merchant can exchange.to protect against this attack the system mutually incompatible application states aren't allowed exist. corruption here encompasses range possible scenarios which the node provider has incentives act way which detrimental the goals the collective which participates. financial gain, coercion, deception, mental instability; there are many reasons why node operator might become corrupt. this can done using byzantine fault tolerant (bft) consensus algorithm which "confirms" single application state and rejects all incompatible states after that. has been demonstrated that asynchronous network (i.e. without confirmation packet delivery) bft consensus algorithm can tolerate node failures. strictly speaking, plus one node must remain honest. for example, system with nodes can tolerate failures, i.e. will keep working when nodes are compromised. chromapolis uses pbft-style consensus algorithm build the blockchain. when the number blockchain's validator nodes f+, block must receive "votes" confirmed (i.e. more than all votes). users' nodes only deal with blocks which are confirmed. thus chromapolis can tolerate arbitrary corruption minority (less than blockchain's validators nodes with drastic consequences except possible slowdown. chromapolis will attempt ensure that any blockchain will allocated nodes from different providers that single failure cannot result blockchain corruption. requirements will especially stringent for system chains. this the fundamental assumption chromapolis individual nodes (as well individual providers) can and will fail, but should have effect chromapolis users. but also need consider situations when more than validators for particular blockchain fail. consider this unlikely, but possible. while cannot guarantee smooth operation case attack", can try minimize the damage and enable speedy recovery particularly, chromapolis needs features to: make difficult for attackers profit from the attack. make possible for the chromapolis system detect the attack early possible, that recovery steps can taken. make possible for chromapolis users detect the attack early possible, they can abstain from operations which might result financial loss. allow chromapolis users wait for stronger confirmations for high-value transactions desired. the most powerful tool our disposal anchoring way boosting the confirmation strength one blockchain using another. let's consider the simplest anchoring scheme. suppose want anchor blocks blockchain blockchain that: when block x_i confirmed blockchain one the block producers will publish tuple (x, hash(x_i)) blockchain once that publication confirmed blockchain user's node (which follows both blockchain and blockchain can find the first tuple form (x, which published blockchain block x_i said anchored when (x, hash(x_i)) the first such tuple. consensus blockchain fails and different block x'_i produced, the anchored block x_i should take precedence. that is, case recovery the blockchain should include the last anchored block, and blocks incompatible with must deleted. it's easy see how merchant can use anchoring boost confirmation strength. suppose merchant will wait until block x_i which contains payment him both confirmed and anchored before ships the goods. this case consensus blockchain fails (e.g. x's nodes are compromised and produce several incompatible histories), but blockchain stays correct, merchant does not suffer loss once blockchain restarted (e.g. with new validators) the block x_i will included and thus merchant will receive the money. technical implementations anchoring might differ in: what being published (e.g. just commitment) who can publish information whether light-client proofs are possible how easy for node detect anchoring failure chromapolis will make use multi-level anchoring, that is, blocks from dapp blockchain will anchored special anchoring-chain maintained another set nodes. let's consider example. first consider the situation without anchoring. suppose dapp blockchain run validator nodes all which are compromised. tokens from this dappchain are traded centralized exchange, compromised nodes might used perform attack: nodes will prepare two versions block the same height: block x_i contains payment from the attacker the exchange, and block x'_i doesn't the exchange sees block x_i and credits tokens the attacker's account. the attacker sells his tokens for bitcoins and withdraws bitcoins from the exchange. block x'_i revealed all other nodes and subsequent blocks are built top it. it's not possible tell whether block x_i block x'_i should take precedence. obviously, block x_i better for the exchange, but block x'_i might include other important payments. thus the exchange might suffer loss even after faulty nodes are replaced, the blockchain might built block x'_i. situation with anchoring, the exchange can protect itself from this risk. should wait until the payment anchored block x_i before crediting the money. this case even nodes try build alternate block x'_i that block won't included into blockchain after nodes are replaced not anchored. the merchant can suffer loss only when the anchoring chain itself compromised. however, the chromapolis anchoring chain will include larger number validator nodes from different providers, say, hundred. might enough compromise nodes compromise the dapp blockchain, however, will take least nodes/providers compromised anchor two incompatible blocks. that is, requires collusion large scale. however, cannot completely rule this situation out. for this reason, the anchoring chain will itself anchored pow blockchains bitcoin and ethereum. exchange wallet high-security mode can wait until block x_i anchored block a_j and block a_j itself anchored bitcoin's block b_k. this case revert payment one would need compromise significant number chromapolis nodes, and, top that, perform bitcoin blockchain reorganization. believe that this situation exceptionally unlikely. confirmation strength can further boosted anchoring multiple blockchains. particularly, consider establishing network notaries and highly reputable institutions multiple countries. anchor the chromapolis anchoring chain this notary chain will impossible revert chromapolis blocks without worldwide conspiracy. node security believe that collusion among chromapolis providers unlikely loss stake, profits and, possible legal action serves deterrent. however, software exploit which allows attacker execute arbitrary code chromapolis node were discovered, multiple chromapolis nodes could compromised the same time. the most common causes remotely exploitable vulnerabilities are memory corruption bugs within the application code. for this reason, chromapolis implemented using safe language which protects against memory corruption (kotlin) and executed the jvm which provides memory safety. another possible source vulnerabilities dapp code. chromapolis dapps will implemented rell which itself memory-safe language; top that the rell execution environment implemented kotlin and runs within the jvm, thus for application break out the sandbox will need defeat both rell and jvm safety mechanisms, which believe practically impossible. the remaining source vulnerability code written that the host (e.g. linux) and dbms (e.g. postgresql). exploitable vulnerabilities the linux kernel itself seem extremely rare, and access postgresql will mediated rell which limits the possibility attacks. nevertheless, will research further options reduce the possible attack surface: run security-oriented linux distribution with all non-essential components disabled consider using which further reduces the footprint attack surface (e.g. osv) consider switching jvm-based database engine, implement new database engine specifically for chromapolis http://osv.io/ another possible attack vector hardware and firmware. for example, the intel management engine present the vast majority intel's products, and effectively runs separate which can potentially compromised. this could provide vector compromise the node running the same cpu. mitigate this attack vector will recommend providers diversify and use hardware from different vendors. will also advise providers limit their exposure cloud providers. the bulk chromapolis nodes run on, for example, aws, amazon has power fork shut down the network. governance security governance can source security problems. can take example from the corporate world: while the ceo herself might not able tamper with servers directly, she can replace the system administrator with one who will, for example, delete some crucial data. chromapolis governance mechanisms must therefore also designed with security mind. particularly: should not possible introduce changes which can used fork destroy blockchains. all changes must applied with delay that they can reviewed and, necessary, mitigating measures can taken, the most severe cases this might emergency hard fork. the rate changes should limited. light client security most chromapolis users will use light clients which not process the entirety blockchain data. they will have rely chromapolis nodes query data from the blockchain state, and supply the confirmation status transactions and payments. how can light client users authenticate this data? short, they have trust validator nodes. each block signed bft majority all validator nodes. thus, confirm invalid transaction, more than two thirds validator nodes would need compromised. light client security isn't significantly worse than full node security. just over one third nodes need compromised produce fork, but more than two thirds need compromised produce invalid block. the first scenario far more likely, and light clients are protected against the same extent full nodes. light clients can also take advantage anchoring, including anchoring into pow blockchains. anchoring methods used chromapolis can produce compact proofs, this means that user can benefit from anchoring without needing run full node. some cases the data retrieved from nodes not important and does not need authenticated. scenarios where the data does need authenticated, different data structures can used depending the nature the data: total validator nodes transaction merkle tree: can used check that transaction confirmed and valid. e.g. this can used verify payment. the transaction merkle tree root present the block header and signed nodes part the consensus algorithm. state commitment merkle tree: typically block header will commit the set rows which represent the blockchain state. this allows light client make sure that certain row returned response query present the latest blockchain state. state commitments can disabled high-performance blockchains they increase blockchain overhead. state commitment merkle root present the block header and thus signed same way the transaction merkle root. assertions and indexers: special data structures can used prove that the entire query response correct and doesn't omit any data. present, they are signed the same way the block header. signed query responses: when query response important but cannot proven through indexers, light client can submit requests multiple nodes and receive signed responses. light client can authenticate data via validator node signatures only when knows validator node public keys. validator node pubkeys can obtained from the directory chain. the directory chain itself can validated using the root chain. the resolution process follows: light client comes with built-in, hard-coded hash the genesis block the root blockchain well initial list root node public keys. light client downloads the entire root blockchain get up-to-date list root nodes. root chain extremely sparse with only one block per day, and thus this operation not lot burden even light client. light client can query any directory chain replica retrieve list validators for the blockchain interested and validate them with state commitment mechanism, i.e. checking the signatures root nodes. results query the directory chain should also confirmed via the anchoring chain and pow anchoring. dapp client and wallet security the chromapolis team will develop chromawallet wallet which can used hold chroma tokens well any tokens any chromapolis blockchain which follows the flexibletokens standard. will also provide ability interact with dapps using simple form-based interface and manage dapp accounts. chromawallet will provided desktop, mobile, and web app formats and will target hardware wallet integration. future version chromawallet will able function general-purpose dapp browser, sandboxing dapp code execution and offering graphical interface rendering web technology stack. the dapp browser will able download dapp code from chromapolis blockchain. course, won't able guarantee that this code free bugs security step necessary makes sure that collusion root nodes cannot compromise any other blockchain. defects, but will able ensure that code can only updated together with the dapp itself and that all users run identical code (i.e. code cannot bugged specifically for one user). note that the dapp browser functionality won't present the mvp version. instead, dapps which require complex ui, such games, can implemented using separate client delivered web mobile application. this case security can controlled through the use sub-accounts. the dapp client will receive private key sub-account which belongs user and will able sign transaction behalf the user. this means that the user can perform game actions natural way, similar how "normal" games work. there will confirmation dialogs bugging users for each action takes game, seen ethereum metamask and eos scatter. however, actions which are sensitive, such transfer large sum tokens, might require confirmation using different sub-account which managed chromawallet. this means that malicious dapp code won't able significant harm. this also means that large-value transactions can benefit from hardware wallet integration implemented chromawallet.