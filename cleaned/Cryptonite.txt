the mini-blockchain scheme j.d. bruce july rev march rev www.cryptonite.info abstract almost all crypto-currencies prevent double spending and similar such attacks with bulky "blockchain" scheme, and the ones which not typically use some sort pseudo-decentralized solution manage the transactions. here propose purely crypto-currency scheme where old transactions can forgotten the network. since nodes only require the newest portion the blockchain order sync with the network, call this portion the chain the "mini-blockchain". argue that the loss security this trimming process incurs can solved with small "proof chain" and the loss coin ownership data solved with database which holds the balance all non-empty addresses, dubbed the "account tree". the proof chain secures the miniblockchain and the mini-blockchain secures the account tree. this paper will describe the way which these three mechanisms can work together form system which provides high level integrity and security, yet much slimmer than all other purely currencies. also offers other potential benefits such faster transactions and lower fees, quicker network synchronization, support for high levels traffic, more block space for custom messages, and potentially even increased anonymity. introduction was over five years ago now that "satoshi nakamoto" first released bitcoin into the public domain and forever changed the way many people think about finance and economics []. back then the difficulty was low and the blockchain was small. for the first two years things looked great, many believed the blockchain wouldn't become problematic for long time the issue was put the side. are now july and the blockchain close gigabytes size []. while still manageable, becoming serious issue concern. the core developers bitcoin now direct much their attention handling the everincreasing levels network traffic. today the bitcointalk.org forum observes almost daily threads concerning methods for minimizing the size the blockchain and decreasing the synchronization time. one the most effective measures taken date was switch from berkeley leveldb []. bdb much slower and the switch over ldb resulted major performance boost terms synchronization and block verification speeds. another promising endeavor the "ultimate blockchain compression" project which aims achieve "near-optimal blockchain compression" implementing blockchain pruning techniques including "balance-tree information" which "maintained and verified separate blockchain through merged mining". blockchain pruning indeed promising venture and could prove provide high level compression, but adds extra layer complexity and doesn't solve all the scalability issues entirely satisfying manner. the bitcointalk forum also observes many threads about changing the max block size limit (with many for and against it). one group people against the change released "bitcoin blocksize problem video" which they argue against increasing the max block size because "it will become more expensive run node". gavin andresen, lead core bitcoin developer, replies "the block size will raised. your video will just make lot people worried about nothing". every day this issue seems become more pressing. the max block size definitely will raised some point, right now the transaction capacity restricted transactions per second and eventually that just wont enough. raising the max block size bitcoin will require coordinated hardfork because all the older clients won't know how deal with the larger blocks. there are legitimate reasons concerned about increasing the max block size, but that doesn't mean it's not needed. there are several cons and pros which must considered. increasing the max block size would increase transaction bandwidth and lower fees, but would cause the blockchain grow even faster and put more stress nodes. many members the bitcointalk forum say it's not the max block size which problem, instead they blame gambling services such satoshi dice for "spamming" the network with many transactions. other members note that satoshi dice "is providing stress-testing for the network, and showing that unless the block size limit lifted, there will problem" []. should concerned? mentioned moment ago, there are several ways can attempt deal with the size the blockchain. the bitcoin stack exchange user sean chapman asks "are there any studies into the size the blockchain scaling over time?". meni rosenfeld, writer the top answer, explains that although isn't aware any studies that meet chapman's request, can outline reasons why needn't concerned about blockchain scalability []: not every user needs run full network node. spent outputs can pruned from the blockchain. off-chain transactions can help reduce stress the network. transaction fees can offset the block storage costs. moore's law still going strong for the foreseeable future. satoshi spoke about the point back late when said the network grows mining "would left more and more specialists with server farms specialized hardware" []. this perhaps satisfactory solution but will result continued centralization and eventually these specialists will control large percentage the network power making harder for the smaller players participate. the point was already mentioned; pruning offers promise but it's complex process and the results are limited. the main problem with proposals such the ultimate blockchain compression scheme that lot the "dust" generated services such satoshi dice still clog the system. the way bitcoin links transactions together makes impossible achieve the level scalability really need from crypto-currency. the last points also have some validity them well, but regardless those points are still stuck with blockchain which never stops growing and still doesn't provide with truly light weight scheme. should looking for innovative new ways solve these scalability issues concise and satisfying manner. the bitcoin wiki states "at very high transaction rates each block can over half gigabyte size" []. really feasible for bitcoin reach that level network traffic and attempt store all ever-growing blockchain? for coins such bitcoin high level centralization may the only solution the end. it's clear that move into the future better solution will become necessary. odds are that bitcoin here stay for while, it's highly unlikely any new altcoin will suddenly make bitcoin obsolete. the mini-blockchain scheme offers better functionality some areas but also lacks some features that most coins have due the simple transaction model use. our goal build the work satoshi create open and free market the best crypto-currencies where competition can thrive. the scheme proposed here can provide with truly fresh and unique advantages. finding solution what follows proposal for entirely new alternative crypto-currency which similar bitcoin many aspects but also very different other aspects. extremely hard make any large changes the bitcoin code base, and the following scheme unfortunately not compatible with bitcoin. the scheme eliminates the need for full blockchain unlinking transactions, thus allowing all transactions discarded after enough time has passed, but doing removes script from the protocol, something bitcoin can't do. the proposed solution described this paper comes understanding the different purposes the blockchain and then separating that functionality into individual mechanisms which are each optimized serve their purpose. the blockchain has main functions. the bitcoin blockchain combines these functions into one single mechanism and result doesn't scale well. requires you store lot data which doesn't really need stored forever. breaking the functions the blockchain the key. functions the blockchain: coordinate how the network processes transactions encapsulate the proof-of-work which secures the network manage account balances; record the ownership coins since the original version this proposal was written early has been improved and modified significantly []. with help from other bitcointalk forum members, the miniblockchain scheme has been fleshed out, project wiki was created expand upon the ideas the original white paper, and new coin called cryptonite was implemented using the scheme []. the process implementing has helped immensely fine tuning the concepts underpinning the mini-blockchain scheme. essence the mini-blockchain scheme works storing the balance all non-empty addresses structure call the "account tree", don't actually need any the transactions calculate the balance any given address. have removed the script system and along with the entire idea interlocking transactions, and replaced with much simpler concept where transactions perform basic operations the account tree such "subtract coins from balance address and add balance address b". the inputs and outputs the transactions not point other transactions, they simply point addresses the account tree, the transactions aren't linked together the same way they are bitcoin, and can discard all transactions after safe amount time has elapsed (enough make the secret chain attack infeasible, discussed later). with cryptonite nodes are able delete all transactions bit older than week, but they can choose store much history they want, it's unlikely the full chain will ever lost. the account tree this proposal starts with the concept "account tree". why should record every single transaction and save forever all need know the balance all non-empty addresses? the function the blockchain replaced with the account tree. the account tree essentially what could thought decentralized "balance sheet". will contain every unique non-empty address and the balance all those addresses, along with some other fields which make withdrawal limits possible (more this later). when the balance address changes all need update numbers the account tree instead adding new data it. course this wont provide truly finite amount data work with because new non-empty addresses will appearing all the time, but comes close finite probably possible. finite some sense because the coins will have limited divisibility, and can't really expect the world population the number internet users continue growing forever. any case it's scalable and manageable. even with population billion people where each person had different non-empty addresses, would only need keep track billion addresses. since can remove empty addresses from the database and since transaction would simply require peers shift around numbers this database instead adding new data it, the size the account tree should always remain considerably small. the time reach anything close billion unique non-empty addresses our computers will much faster. owners non-empty address the account tree prove their ownership with their private key. like bitcoin, transactions are created signed set data and broadcast over the network. like bitcoin, miners who accept the transaction then put into their blocks and work solving difficult problem get into the mini-blockchain (more this the next sections). nodes who accept the block will update their own copy the account tree shifting around coins doing what ever was necessary. the proposed database named the "account tree" because should have hash tree structure. each "account" the tree has corresponding hash and acts leaf node the bottom the tree. being hash tree, can combine the hashes each account build pyramid hashes and calculate the "master hash" the top. note that "account" isn't collection addresses like "bitcoin account". this case each account refers only one address leaf node (obviously normal "accounts" will also exist). figure figure shows generic radix tree/trie structure (source: wikipedia). reality cryptonite uses type binary radix trie combined with merkle hashing. what isn't shown the diagram how the nodes are hashed. all the hashes together produce the master hash/root hash the top. the master hash will change even just one account within the tree altered any way. this hash tree system provides integrity our data because the master hash also stored block headers the tree secured the blockchain. the advantages using binary radix trie structure include: well suited for looking addresses (public key hashes) faster and more memory efficient than many other tree structures small parts the tree can verified without the whole and completeness can proven inserting the same data into the trie any order will always generate the same structure the mini-blockchain the mini-blockchain provides our blockchain function. the mini-blockchain essentially just normal blockchain, except that don't need keep copy historic blocks. again, isn't truly finite, because changing the max block size could increase the average size the mini-blockchain. later this paper describe mechanism for having dynamically determined max block size but it's not necessary part the scheme. are going keep track our database with set node hashes and master hash, can't allow every single separate transaction alter the database demand. must break them into groups transactions which are inserted into the database periodic intervals time. without having the transactions solved groups transactions blocks have viable method maintaining the account tree. this creates inherent need for blockchain, but since can discard old blocks let's call "mini-blockchain". bitcoin requires the full blockchain because that's the only real way determine the full balance all the addresses. however have the account tree fulfill the task managing account balances and recording the ownership coins. don't need the full thing, can throw away old blocks and save immense amount disk space. however keep few hundred few thousand the newest blocks and that makes our miniblockchain. the mini-blockchain also provides with level security. each block has the master hash embedded the header and can verify each block the mini-blockchain starting from the beginning, making sure the transactions each block always correspond the master hash the previous block. since there proof-of-work process required for each block before will accepted into the mini-blockchain, becomes extremely difficult for attacker generate fake mini-blockchain. although difficult, totally delete old blocks, far from impossible. with bitcoin can start the very beginning and work our way the latest point because have the full blockchain. attacker creates new mini-blockchain from the oldest block available, new nodes would have trouble telling apart from the real miniblockchain, because before that oldest block they have history what happened. the attacker can spend much time they need building the cumulative difficulty their mini-blockchain because it's not ever-growing chain they have out-pace. the attacker could then start broadcasting the fake chain and might propagate enough impose risk becoming the main chain. the proof chain solves this providing mechanism which can act container for storing the long term proof-of-work history that can calculate the total cumulative difficulty any chain. instead totally deleting old blocks must maintain the block headers that can always trace the history any given chain and compare the total cumulative difficulty each chain. the proof chain the proof chain, which provides our function the blockchain, essentially just chain block headers. when nodes discard the old blocks, they will not discard the block headers, only the transactions. basically the mini-blockchain blockchain pruned all but the most recent transactions. this means all nodes can still use the chain block headers verify the best mini-blockchain with the highest cumulative difficulty, and thanks the account tree they don't need old transactions calculate address balances. figure have what essentially normal blockchain, mining can work the same way does bitcoin. nodes must hash the block headers and search for resulting hashes below the current target. it's possible discard old transactions and store only chain block headers because proving the solution doesn't rely upon knowing the transactions the block. it's secure for the same reason bitcoin secure, each proof the proof chain feeds into the next proof, making nearly impossible generate fake proof chain. the master hash needs the block headers detailed figure because allows the nodes verify the transactions the block and make sure their account tree has been altered correctly the block. the master hash stored the block header calculated after the transactions the block have been applied the account tree. can work our way from the start the proof chain where feeds into the mini-blockchain and can verify that the most recent blocks have are valid. the proof chain proves which mini-blockchain has the most long-term computational backing. longer does the attacker have forever sit around generating fake proof chain because the proof chain must feed into the mini-blockchain. now attacker tries create totally invalid mini-blockchain they will also need strong proof chain along with it. this essentially takes back the level security offered typical full blockchain scheme, but it's still not perfectly secure all situations. the main problem that attacker could build the legitimate proof chain secret using invalid account tree, and then release the secret chain the network when the they think it's long that one will have history going back that far. that situation new nodes would not able detect which chain was real. call this "the secret chain attack". all transactions can discarded after week (as cryptonite) the attacker must maintain the majority the hashing power for more than week (in secret). believe even this attack does happen wont catastrophic because: the attack will only affect nodes who haven't synced with the network more than week, all other nodes can detect the attack and reject the fake chain. possible secret chain attack underway can detected new nodes, although they cannot know which chain the real one. the release "community checkpoints" can point nodes the correct chain the very unlikely event this attack did happen. summary network behavior network synchronization network synchronization achieved steps: acquire proof chain with the highest cumulative difficulty. acquire mini-blockchain which associated with proof chain. build account tree requesting slices and verifying the hashes. use recent transactions complete sync account tree. first the node will use "headers first" approach locate the chain with the highest cumulative difficulty. then will acquire collection the most recent blocks connected those block headers. then will attempt acquire slices the account tree until has complete tree. the account tree structure allows the node prove has received complete slices that the node can sure has the all the accounts. finally, the node can use recent transactions update all slices the tree the latest master hash. one required store old account tree data but the node must build account tree which fully consistent with the master hash they have; they can't mix and match slices associated with different master hashes. that why the height each slice must determined, that know what transactions need applied step since all slices contain the master hash, when node requests particular slice can match the slice against particular block comparing the hashes. nodes will generally attempt acquire slices synced near the point where becomes safe discard old transactions. other nodes are able provide these old slices because because they can undo recent changes the account tree and generate old slices upon request. new nodes will attempt build account tree such old point because they need able create large "inversion database" which holds instructions for undoing changes made the account tree, which useful for generating old slices and handling forks. simple terms, new nodes will attempt build complete account tree around the point where old blocks can pruned, then will "fast forward" using transactions from the most recent blocks and the same time build inversion database, that has inversions going back the point where inversions are longer needed. course this description the process very much simplified and you'd have read the source code cryptonite for more detailed technical understanding how synchronization works. notice this process does not rely upon much examination blocks, one trusts the blocks they have because the proof chain backs them. it's extremely easy verify the proof chain and once that complete the node only needs make sure the blocks gets match the proof chain. the account tree being built the only thing which matters that ends having the master hash the latest block. once that complete and the node synchronized can begin update the account tree normally accepting valid blocks. transactions bitcoin keeps track address balances simply reading through the blockchain see what has happened, it's continual ledger instead self contained balance sheet. bitcoin transactions use system which include "inputs" and "outputs" and the inputs most new transactions usually reference the outputs previous transactions. the mini-blockchain scheme uses the basic inputs and outputs concept but the inputs point accounts the account tree and the outputs also refer accounts the account tree. the input accounts will fund the coins which are sent the output accounts. this operation will cause the balance the input accounts decrease and the balance the output accounts increase. fees are still used normal give priority transactions and provide incentive miners. obviously transaction should not accepted valid reduces the balance any account below requests anything which conflicts with the value any balance, tries anything doesn't have permission do. order make sure the same signed transaction isn't processed the network more than once, the transaction must also contain "lockheight" field. the transaction becomes invalid once the lockheight outside the range blocks which nodes are required keep (lets call this the blocks "in view"), and same txid cannot included twice any the blocks which are view. this makes impossible use the same txid twice. however this solution requires that the txid not malleable. there are several things which need considered when attempting solve transaction malleability, but most importantly can't include the signatures when hashing transaction because signing the same data with the same key produces different signatures each time. the sender will sign the txid, but signing many times way alters the txid, only the signatures. thus attempting alter the contents the transaction will always change the txid and result invalidate the signature(s). account tree there are number ways the account tree can implemented, but the data structure must fulfill certain requirements: all data should able efficiently summarized deterministic hash (master hash ledger fingerprint). efficient support for operations: add account, modify account, remove account, lookup account. after every modification one should able efficiently update the account tree master hash. should allow efficient verification the correctness subset the accounts without downloading the entire structure. new accounts are inserted into the trie structure leaf nodes when coins are sent address which does not already exist and they are removed from the trie when the address emptied. when the address does exist the transaction will simply alter existing account the trie. the mini-blockchain acts coordinate when the tree updated. when node receives new block they will carry out the transactions listed within the block altering their account tree accordingly. the proposed account tree structure allows all address balances summarized "balance sheet" format and allows old transactions safely discarded all nodes. however, without way coordinate when and how the account tree changed still can't ensure consistency between nodes. that where the mini-blockchain comes in. each time new block accepted into the mini-blockchain, nodes will use that block update their copy the account tree consistent and coordinated fashion. distributed network impossible for every node apply transactions the moment sees them. transactions must joined together and applied bulk. such list transactions grouped together form block and together with headers form the blockchain. nodes collect the transactions and apply them the account tree achieve new account tree state. the master hash the new tree state included the block header. other nodes which receive such blocks can replay transactions themselves and check the hashes match. discussing new network protocols dynamic max block size noted the introduction section this paper there's lot heated debate concerning the maximum block size. one potential new network protocol worth discussing the idea dynamic max block size. could made floating value determined perhaps several factors. two methods which immediately come mind are mining-based voting system and system which analyzes some number previous blocks and calculates the average block size derive new block size limit (eg *average). voting system sounds feasible and could allow manage the max block size through group consensus, but gives groups such mining pools lot power over what the max block size will be. better solution simply calculate the average size some number recent blocks and then multiply that some value derive the new maximum block size, with some arbitrary lower limit. that way don't need store all the voting data the blocks. this the approach decided take with cryptonite. even with our light weight scheme there does need max block size because our network can only handle much traffic before virtually stops working. even with finite blockchain can grow extremely quickly with large enough blocks. however the future may capable handling much larger blocks need way gradually changing over time. mentioned earlier, hardfork not very convenient. automated readjustment system would self-regulated and much more seamless. pruning the account tree the bulkiest part the mini-blockchain scheme actually the account tree. given enough time the account tree may become filled with many low balance accounts and would advantageous could prune this type "dust" from the tree once the accounts were old enough. there are several ways this can potentially achieved but none them are remotely simple easy implement. the best approach seems one where you collect "account maintenance" fees for maintaining account the account tree. the fees would collected when withdrawal made from account, and included along with the transaction fees. the fee would calculated based the age the sending account. this way low balance accounts eventually reach balance and get pruned from the tree. even withdrawals are made from the account could have system for allowing the pruning accounts which would have non-positive balance had they been paying their account maintenance fees. the benefit this type system that places cost storing data the account tree, which economically beneficial, and helps keep the account tree compact. the other useful feature this system that can feed the maintenance fees back into the "coinbase account" (pays out block rewards) and ensure that the block reward never reaches without actually inflating the money supply, just recycling coins back through the mining system, maintaining finite money supply while not cutting off the minting process. withdrawal limits withdrawal limits can set individual accounts rather easily this scheme due our balance sheet approach. withdrawal limit dictates the maximum number coins which can withdrawn from the account each block, which can useful for several different reasons. three extra fields need added the account structure make this possible: time when account was last modified (this also useful for pruning the account tree) the current withdrawal limit potentially queued withdrawal limit. the limit self-set account owners using special transaction and the default withdrawal limit for new accounts unlimited. the main purpose withdrawal limits help prevent double spending and make merchants more confident transactions with low number confirmations. they know only certain number coins can withdrawn from the account each block then they know even -confirmation transaction likely through since the attacker can't withdraw all his coins once. brief outline how withdrawal limits would work: send the network special transaction modify the withdrawal limit your account. limit specified number coins per block, and saved into queue field. such change will take effect eg. blocks and after that time the queued value overwrites the actual withdrawal limit value. network accepts the special transaction and after blocks will reject any transaction that would cause newly specified limit exceeded. merchant can ensure will receive funds by: checking that there queued withdrawal limit change sending account. check that sending account balance high enough can't emptied too fast. ensure transaction not low priority and has propagated enough network. deciding technical specifications mini-blockchain the proof chain providing most our security, first glance seems almost unnecessary store anything beyond blocks. course necessary have least few hundred blocks because it's too short the secret chain attack becomes much more feasible. need least some reasonable amount minimum block history held all nodes for several reasons. felt that week was good number for cryptonite but there's lot room for experimentation this particular area find the best trade offs. the other important factor need consider the time between blocks. having set too short can have problems, such higher number orphaned blocks due blocks being solved the same time, but having set too long makes waiting for just confirmation totally unpractical. based brief examination alt-coins the optimal block time seems the general vicinity minutes. cryptonite happens have block time minute because it's quite fast but not fast causes too many orphaned blocks. coin supply and distribution bitcoin makes use quadrillion units where each coin made million units, resulting total million coins which are divisible decimal places. however, internally bitcoin uses bit integers, and could handle much larger number coins, million may sound like rather arbitrary number, but fact not. many applications make extensive use double precision floats but doubles can only store integers and that ultimately why bitcoin only has units. however possible use extended precision floats exploit the full range the bit integer. this gives the coin supply much higher level granularity and based natural upper limit. coin supply with bits granularity made approximately billions coins, each which are divisible decimal places. have used extended precision floats cryptonite that we're longer held back the limits the double precision float, enabling extremely large coin supply. there are many ways coin distribution can done, with cryptonite will take years for half the coin supply the mined, with repeating half life years, but the block reward adjusted every block that changes gradually over time. sudden large changes the block reward are not healthy for the network, and it's not clear why bitcoin was designed have such long intervals time between changes the block reward. cryptonite also updates the difficulty every block for similar reasons. conclusion this paper have described variant the bitcoin network protocol which designed eliminate the need for full blockchain and significantly reduce the need for long term data storage. this achieved separating the functions the blockchain into individual mechanisms optimized perform certain tasks. the result offers purely cryptocurrency with many benefits such increased block space. has also been suggested that homomorphic encryption techniques can used achieve high levels privacy []. the nature the account tree and mini-blockchain may also offer increased level user privacy since old transactions might not locatable, but it's unlikely wont have nodes dedicated storing the full chain. achieve much greater level scalability the expense some security trade offs, but it's nothing that can't dealt with. the end result does have high level security, but the same time it's super compact and scalable. many respects superior bitcoin but not all areas (e.g. scripting capabilities). what will the future crypto-currency look like? with the advent scalable cryptocurrency technology it's looking better. crypto-currency can change the way the world works, but only scales well enough handle the needs the world. ideas alone aren't enough though, must implement those ideas. satoshi very respectable that sense because took the initiative create vastly complex system built array new and exotic concepts which hadn't ever been tested before, and changed the world forever. references nakamoto, bitcoin: peer-to-peer electronic cash system. http://bitcoin.org/bitcoin.pdf blockchain.info. blockchain size data. https://blockchain.info/charts/blocks-size andresen, bitcoin-qt bitcoind version released. https://bitcointalk.org/index.php?topic= reiner, ultimate blockchain compression. https://bitcointalk.org/index.php?topic= todd, bitcoin blocksize problem video. https://bitcointalk.org/index.php?topic= bitcoin wiki. scalability. https://en.bitcoin.it/wiki/scalability rosenfeld, are there any studies into the size the blockchain scaling over time? http://bitcoin.stackexchange.com/questions// nakamoto, re: bitcoin e-cash paper. http://www.mail-archive.com/cryptography@metzdowd.com/msg.html bruce, cryptocurrency with finite "mini-blockchain" https://bitcointalk.org/index.php?topic= mini-blockchain project, cryptonite. http://cryptonite.info/ and wiki: http://cryptonite.info/wiki/ franca, b.f. homomorphic mini-blockchain scheme. http://cryptonite.info/files/hmbc.pdf