temporal innovation the blockchain chronologic october abstract current generation blockchains lack the crucial time-based functionality like transaction scheduling. the proposed paper discusses potential implementable solutions and challenges for enabling such functionality. contents introduction centralized scheduling decentralized scheduling ethereum alarm clock architecture smart contracts timenode claiming mechanism remote providers mitigation efforts recommendation cryptoeconomics limitations gas price account abstraction gas cost protocol fees multi-network protocol day token chronos next generation scheduling protocol conditional scheduling day token staking second layer execution markets delegated execution execution market timenode beyond the scheduling appendix the on-chain claiming mechanism claiming mechanism a.. claiming a.. execution economics a.. expected payout definition simulation chapter introduction scheduling feature that native the modern financial world. schedule our routine bank transfers and bill payments; whenever know ahead time when payment should through, set automatic payments instead waiting for the exact time and date. financial transactions are increasingly moving the self-sovereign and trustless world cryptocurrencies. more volume moved networks like ethereum daily, there are higher expectations the foundational tooling that fiat world provides. users expect scheduling transactions feature from the ethereum ecosystem because they have learned rely their everyday lives. fact, scheduling calls ethereum more powerful than scheduling movements money the fiat world users can now schedule smart contracts execution. they have access much more complex logic. also identify the tooling gap that exists for developers working the ethereum stack, used cron jobs unix. contrary intuition, scheduling calls decentralized peer-to-peer blockchain not trivial problem solve. there are many reasons why person would want schedule smart contract calls. the most facile use cases involves the simple scheduling value transfers the movement ether erc token from one address another. with the future indoctrination concepts such daos the world will start see smart contracts employed the use organizational governance and other high stakes uses. for instance, users may want schedule vote dao that will determine the zoning the neighborhood they live in. additionally, developers may invent new use cases which scheduling used under the hood, without bothering the user with the complexity behind the application that they are interacting with. blockchains are the new software platform. people who set and maintain software environments use cron schedule jobs (commands shell scripts) run periodically fixed times, dates, intervals. there need for cron the world ethereum. https://www.ethereum.org/ https://en.wikipedia.org/wiki/decentralized_autonomous_organization https://en.wikipedia.org/wiki/cron centralized scheduling the ethereum platform offers native way have smart contract called specified time the future, nor way make this call recurring. the obvious need for this feature has led developers create their own solutions. the (now deprecated) parity there was built-in scheduling feature that would locally hold the transaction in-memory before sending the desired time. although the solution worked fine, there were some major drawbacks including the necessity the user run their own local node and use the specific parity client software, and the single point failure experienced cases where the local node disconnected from the peer-to-peer network. these multiple issues can actually combined into one: centralization. decentralized scheduling the advantages decentralized protocol over centralized one that does not have single point failure. the scheduling aspect the ethereum alarm clock done entirely through smart contracts running ethereum the backend and allows for permission-less implementations user-friendly front-ends the execution aspect the protocol handled network off-chain clients known timenodes. timenodes are incentivized operate the user-set bounty payment, which can thought small reward offered the user the timenode compensate its expenses for monitoring the state ethereum and keeping the network alive. the users not have aware the existence timenodes. they can pay the small premium the bounty without the need understand the execution flow the ethereum alarm clock protocol entirely. https://github.com/paritytech/parity-ui the ethereum alarm clock was created piper merriam, now lead the python team ethereum, august throughout its development history was deployed the ethereum network and maintained almost solely single developer. the adoption the protocol did not take off and after the ddos attacks the ethereum network the smart contracts started fall out date piper began pursuing new projects among two the already implemented front-ends the current iteration the ethereum alarm clock are the chronologic chronos dapp https://app.chronologic.network and native integration with the popular mycrypto wallet https://mycrypto.com chapter ethereum alarm clock november nearly one year after the ddos attacks that metaphorically threw ratchet the ethereum alarm clock's gears, developers from the chronologic team began work and reboot the ethereum alarm clock protocol. after about nine months work, including updating the core smart contracts, rewriting the test suite javascript for the truffle framework, building developer libraries, constructing new timenode client typescript, performing numerous internal audits and external audit with notable member the community, the chronologic team deployed the stable release the ethereum alarm clock smart contracts august the following information will discuss the architecture, analyze the cryptoeconomic incentives, and enumerate some the limitations found the stable release. architecture the ethereum alarm clock architecture best described two symbiotic and differential components. the first component the ethereum alarm clock architecture are the smart contracts. they are deployed the ethereum main chain and operate trustlessly. the second component the timenode network. timenodes are off-chain execution agents charge handling the logic executions. smart contracts the smart contracts the ethereum alarm clock can thought consisting mainly three parts: requestfactory, schedulers (further divided into the timestampscheduler and blockscheduler), and transactionrequestcore. within these three main sections the architecture are numerous libraries that contain various pieces the core logic and functionality. there are nine library contracts, two top-level scheduler contracts, contract for requestfactory and one for transactionrequestcore, adding zeppelin's figure ethereum alarm clock architecture overview safemath and ownable, brings the total smart contracts which make the entire ethereum alarm clock architecture. the logic for the scheduled transactions exists the transactionrequestcore contract, which acts the central library for the numerous instances the delegatecall clone contracts that get deployed via the requestfactory. below shown the code example the primary actions the transactionrequestcore, which allows timenodes execute, cancel claim scheduled transaction. function execute() public returns (bool); function cancel() public returns (bool); function claim() public payable returns (bool); the schedulers (blockscheduler.sol and timestampscheduler.sol are the top level apis which will get exposed the user facing applications. these contracts provide simpler interface taking only the necessary parameters for scheduled transaction and setting the rest the options sane defaults. the scheduler contracts are also the objects which hold the data concerning https://github.com/ethereum/eips/issues/ figure ethereum alarm clock smart contracts overview the taking fees. the purpose separating the logic for taking fees into the scheduler contracts allow third-party developers and new integrations customize their fee structure (and fee destination) their own preferred way. allowing the option for third party integration customize their fee structures creates incentive for them integrate the ethereum alarm clock into their own product. each scheduler contracts works off the same requestfactory backend, benefiting from the same network timenodes. the requestfactory contract the core the ethereum alarm clock protocol and deploys the new delegatecall clone contracts. possible call the request factory directly, but most the time the request factory will called "internal transaction" from one the scheduler contracts. the requestfactory has two functions which perform different kinds validation the parameters which are passed in. the lower level 'createrequest()' will attempt the raw creation transactionrequest without any validation. not performing the validation, the function call saves gas but may lead the possibility that the parameters contained error and will not executed properly. for most use cases some validation the input parameters desired and the 'createvalidatedrequest()' will used instead. the requestfactory will also the factory that timenodes watch order keep date with scheduled transactions, since emits the 'requestcreated' event which alerts timenodes user scheduled transactions. timenode timenodes are the off-chain execution agents which represent individual nodes the decentralized peer-to-peer execution network behind the ethereum alarm clock. figure ethereum alarm clock timenodes network the first and primary timenode action the execute function while the second action claim which we'll into detail the next section. execute called anytime timenode tries execute transaction that has been scheduled executed. executing transaction, timenode receives reward (bounty). this helps incentivize timenodes execute incoming scheduled transactions. the execute action run triggering function within the smart contract that holds the scheduled transaction. this trigger requires the timenode spend small amount gas trigger this action. problem arises when multiple timenodes send the execute trigger the same time, i.e. within the same block. only one them will trigger the execution, while the other timenode's transaction will get reverted and cost small amount gas. should timenode notice that often collides with other timenodes during the execution time scheduled transactions, can choose claim transactions. claiming mechanism claiming advanced opt-in feature the ethereum alarm clock protocol which helps timenodes lower the risk transaction collisions. when users schedule transaction, this scheduled transaction appears the blockchain and timenodes keep track them. once scheduled, timenode can attempt claim the scheduled transaction depositing small amount eth. claiming transactions removes the risk colliding with other timenodes during the execution time, but brings forward another set problems: transaction collisions the same transaction collisions that used happen the execute function will now problem with the claim function. there chance multiple timenodes trying claim the same transaction within the same block, which will again result transaction collision and only one those will able claim it. deposit loss when timenode claims transaction deposits small amount eth guarantee that will online execute when the time right. should timenode (due unforeseen circumstances) offline the exact time which the scheduled transaction was due executed, will lose its deposit. remote providers the effect sending the claim execute actions for scheduled transaction can bring more risks, depending whether timenode connected local remote node. connecting the timenode remote provider can introduce delays due network conditions and can facilitate failed claims/executions. running local rpc provider node would the recommended way running the timenode eliminate the risk slow responses for the rpc requests made the timenode. mitigation efforts efforts have been made mitigate the risks mentioned above introducing the haspending check the timenode-core library. haspending allows the timen odes check the transaction pool (txpool) the providers connected for any incoming execute claim actions certain scheduled transactions. this allows the timenodes avoid transaction collisions they use node that has txpool such parity geth. keep mind that rpc providers without txpool (e.g. infura over http) will not work with this feature. recommendation order avoid the mentioned risks running timenode, recommend the following setup: connect the timenode local parity/geth node turn claiming transactions reliable internet connection minimum offline time these risks are currently unquantifiable and still not clear how the network will behave real world conditions. cryptoeconomics the ethereum alarm clock protocol incorporates cryptoeconomic incentives reward the decentralized network timenodes continue their operation. the incentive consists the extra amount ether sent the timenode following execution. the amount the bounty variable and depends when the transaction was claimed well how much extra gas was paid for the execution the transaction. general rule, timenodes will not execute transactions which will return net loss their eth balance. the formula for the bounty calculation provided below. btotal bset (gactual gset where payment modifier given that scheduled transactions are expected executed the exact time and the network competing nodes exists, expect face the "swarming" problem which can described as: uncoordinated attempts execution nodes the same time. this problem may result unnecessary costs for timenodes, making the operations potentially not profitable only -of-n going earn the timebounty for the execution. other timenodes trying execute the same block will still have pay the transaction cost their failed transaction. introducing the payment modifier timenode operators are able pick theirs profitability point. this effectively mitigates the "swarming" problem, expect timenodes try claim different blocks/moments time. however, under perfect competition, the profitability metric the timenode trends towards perfect zero, leading timenodes often send the claim transaction within the same block. for detailed timenode economics refer appendix limitations gas price the ethereum network uses the concept gas unit measuring the computational work performed over the network. every transaction broadcasted the network sets the gas limit and the gas price. gas limit describes the maximum amount gas allowed consumed the transaction, gas price describes the amount ether (eth) you are willing pay for each unit gas. while setting the gas limit most cases very straightforward and automatic, setting the correct gas price not trivial task. gas price determines the time between broadcasting and block inclusion, and depends current network capacity. observed many spikes the gas price due popular icos cryptokitties last fcoin on-chain voting. given the nature scheduled transactions, the ethereum alarm clock protocol needs handle the execution using predicted gas price. the most important characteristics are: execution prioritization timenode withholding protection there are three possible solution for this problem. let's analyze each them separately: fixed gas price allows setting the exact gas price that has used timenode for execution, declared gas price reimbursed the scheduler. pros: simple protects from timenode withholding cons: fails upon gas price spikes requires users guess the price the future range gas price allows setting minimum and maximum gas price the scheduler, the maximum gas price reimbursed, any gas price used the timenode between min and max (spot price) will allow the split the remaining budget between the scheduler and the timenode. for e.g, the scheduler sets the range from gwei gwei and thus locks enough funds cover gwei gas limit. timenode incentivized pick good price between and let's say remaining split, making timenode earn extra pros: https://en.wikipedia.org/wiki/initial_coin_offering protects from timenode withholding incentivize timenodes pick correct price within bounds cons: given the front-running, the equilibrium max requires decently high max order cover the spikes minimum gas price allows setting the minimum gas price the scheduler, the minimum gas price reimbursed, higher gas prices covered timenode (effectively reducing the reward for execution) pros: protects from timenode withholding allows the timenode decide where equilibrium cons: covers spikes the minimum reimbursement reward order pick the right solution need understand the ethereum alarm clock execution process. there are different time windows used for: pre-execution claiming process: where timenodes are bidding reservation for execution reserved execution: time period for timenode that claimed transaction execution: free for all execution, when timenode that claimed missed the execution claiming happened minimum gas price the best option for both reserved execution and execution, allows the timenodes control and pick the gas price that best fits their own profit model. account abstraction for cases where the address the sender has known upfront, and given the ethereum alarm clock architecture where each scheduled transaction represented separate smart contract with unique ethereum address, there need use proxy wallet. the address the proxy wallet will seen msg.sender the destination contract/account. example procedure scheduling transaction using proxy wallet could described follows: create schedule request such that the destination set the proxy wallet send the scheduling request using proxy wallet that becomes the owner the request whitelist the scheduled request the proxy wallet can relayed the need for such workaround will not necessary when native account abstraction will available the ethereum network. gas cost using the storage smart contract for keeping the data with conditions and parameters for scheduled transaction comes with cost. currently each scheduled transaction costs approximately gas. even though the total cost usd below the "premium" for scheduling over compared regular eth transfers. protocol fees potential business model for the ethereum alarm clock protocol based the fee that can enabled for each transaction. the architecture the protocol allows deployment many schedulers that can used specific party wallets. each scheduler can deployed with different fee setting. multi-network protocol ethereum alarm clock can deployed any evm compatible blockchain like ethereum classic rsk multi-network protocol can handled timenodes listening those networks and providing execution. the wallets those timenodes would have keep native cryptocurrency used those blockchains order cover the transaction fees. multi-network deployment would expand the scheduling user base beyond the ethereum blockchain. day token running the web and desktop versions the timenode software requires users prove the ownership day tokens. the required amount can held any ethereum account controlled the timenode operator. running the client using cli tool does not require day tokens, however, when compared the cli, the timenode superior its analytics and ease use. https://github.com/ethereum/eips/issues/ given current .gwei gas price https://ethereumclassic.org/ https://www.rsk.co/ https://app.chronologic.network https://github.com/chronologic/eth-alarm-clock-dapp/releases https://etherscan.io/token/xeaeeacdbcedacdff https://github.com/ethereum-alarm-clock/cli chapter chronos next generation scheduling protocol conditional scheduling time-based scheduling very powerful idea, but it's not capable handling if-this-then-that type scheduling. the idea explore this type scheduling was sparked discussions with teams and projects the ethereum space about potential use-cases for the ethereum alarm clock. some them were based state change, rather than specific time period. let's take closer look the example how could implement decentralized stop-loss functionality using the ethereum alarm clock. one the possible solutions for the problem that could implemented can defined follows: create smart contact called stoploss with execute function that going check decentralized exchange for your current position and will place the sell order certain conditions are met use the ethereum alarm clock protocol create scheduled transaction with recurring execution for execute for e.g every min while this solution works, would generate enormously high cost for the users. given gas, the daily cost approximately gas making this unfeasible. general, the problem with this approach that every trigger costs gas regardless whether succeeds not. much more efficient solution for this problem would have scheduler that allows one store conditions given eth usd and gasprice=.gwei directly the contract and allows the execution only when these conditions are met. looking through that lens, came the conclusion that time-based scheduling just special case conditional scheduling. the conditions are: time then block then. timenodes (the off-chain executors) are checking time and block conditions before the execution (by reading them from the smart contract) which means that they attempt the sending transactions only when those conditions are met. instead defining time block, delegate this check external contracts that, for e.g has method inexecutionwindow(uint windowstart, uint windowsize) returns (bool) which checks whether the block.number within the given window. day token staking ethereum alarm clock protocol using claiming process order improve cryptoeconomics reducing collisions amongst the timenodes. for chronos protocol, different approach solve this problem taken into account implementing claiming mechanism based day token staking. hypothetical staking model assumes that day tokens act collateral for claiming actions and align the incentives for execution. any commitment the timenode would have backed amount day tokens. lack execution will result token slashing. whether complete stake partial slashing, still seen. example staking model called the priority queue can described follows: client running timenode software must first register their intent claiming timenode the blockchain sending transaction containing some amount tokens contract. inside this transaction, the timenode specifies its preferences for what kinds transactions wants execute. these preferences include how big bounty attached the scheduledtransaction and when the execution window starts. each time timenode enters the claiming queue the entry with the highest amount staked moved the top the queue while all other entries are sorted downward. when user wants schedule transaction, they send transaction the chronos scheduler contract containing the data the transaction they would like executed later time (or when later conditionals return true). the next timenode the claiming queue which fits the preferences that timenode will popped off the queue and "assigned" that transaction. upon execution time, that timenode which was assigned has the exclusive rights send the execute transaction and the other timenodes will not even try. chapter second layer execution markets delegated execution delegated execution pattern that used both ethereum alarm clock, chronos and others the high level, enables safe transaction delegation party agents exchange for reward. figure delegated execution example execution market currently the ethereum ecosystem there are multiple projects working their own execution markets for their purpose. the drawback this approach that the economic incentive participate such market depends the amount delegation available. protocols and dapps will scatter the market into smaller ones, potentially not profitable join. the issues with the siloed markets are: amount nodes depends the amount bounties gnosis safe, uport relayers... https://en.wikipedia.org/wiki/decentralized_application figure siloed relayers markets reliability the network depends the amount nodes networks run the protocol and dapps creators are subject low censorship resistance the solution this problem would conceptualize the common market, that able handle multiple protocols and dapps. figure common relayers markets order design such market, there are few pre-conditions: agree interfaces for off-chain and on-chain representations (eip- and erc- agree bounties representation (erc- https://eips.ethereum.org/eips/eip- https://github.com/ethereum/eips/issues/ https://github.com/ethereum/eips/issues/ timenode beyond the scheduling timenode one very first working implementation the delegated execution pattern and could potentially serve blueprint for other implementations generalized handle other cases beyond scheduling. appendix the on-chain claiming mechanism economics claiming mechanism claiming mechanism can described follows: for any transaction that has been deployed the network and expected executed nodes the network. the process execution divided into two steps: claiming and execution. claiming process reserving the transaction for further execution. a.. claiming can happen before execution every node has the same chance successfully claim claiming requires deposit locked claimant deposit lost claimant when execution won't happen within exclusive execution window every node can fail claiming when was already claimed figure a.: scheduled transaction life cycle claiming requires sending transaction that has cost described when successful and when unsuccessful beginning claiming window payment modifier pmod (t) end claiming window claiming optional a.. execution successful execution has reward described imebounty execution cost reimbursed the scheduler when successful execution cost has cost described when unsuccessful deposit locked the claimant can acquired node when the claimant failed execute a.. expected payout definition let's define the expected payout for node pnf where the expected payout after successful claim and execution the expected payout after successful claim but missed execution pnf the expected payout after another node loses its deposit network with nodes for network nodes with can define expected payouts as: (pmod pmod imebounty -cc deposit pnf imebounty network with nodes for that case the expected reward will imebounty assuming that probability successful claiming equal for all nodes. also case failing transaction node will pay the (pmod pmod imebounty -cc deposit imebounty deposit order improve the cost failing transactions, let's introduce mechanism that prevents sending the transaction that will fail, the accuracy mechanism defined pnf (ax pmod pmod imebounty -cc deposit imebounty deposit the last part introduce pld probability timenode loosing the deposit pnf (ax (ax pld pmod (ax pmod pld (pf (ax pnf (ax pld simulation are going simulate few cases using equation formulated section a... pld pmod are the variables that depends reliability and running costs timenode owners. all calculated results are going represented gas let's now define the profitability threshold. will assume monthly running cost for the timenode usd (this based current rates heroku cloud). translating usd gas get: h/u gasp rice gwei gas this shows that running costs are covered after acquiring gas. now let's take look how this translates the amount executed transactions. order calculate (ax pld pmod use the script listed below. moreover are using following values describing timenode operations and network conditions: imebounty gas deposit gas .(%) pld .(%) gas gas target gas results using these parameters are: p_mod res results data frame contains columns: mod payment modifier (pmod res expected amount gas earned timenode per transaction num number transactions executed order cover running costs the results achieved running this simulation should treated informational rather than something taken for granted. the expected payout depends all the variables described above, for simulation purpose picked values using our intuition. the variable controlled the timenode operator pmod which the major component. low enough pmod allows timenode claim transaction before others, still, order profitable using low pmod the timenode running cost has low. the timenode market has many characteristics the perfect competition market there perfect information, barriers entry, they deliver the same service, timenode are the price takers. based that, long-term may get the situation where marginal cost equal average cost. http://www.economicsonline.co.uk/business_economics/perfect_competition.html