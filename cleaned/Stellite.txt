stellite modern, secure and decentralized cryptocurrency. april summary stellite solves issues that have been puzzling cryptocurrency developers for years topics such efficient and decentralized method distributing peer list without hard coding them, using the billions small devices combine their computing power and form part huge proof-of-work network which helps people use their own small devices not only supporting factor the network but also provisioned small reward doing so. stellite unique linking both the ipfs and zeronet technologies into cryptocurrency and scaling globally for both mobile and desktop usage. stellite will the first cryptocurrency worldwide provide scalable global mobile mining. the next coming paragraphs, will explaining the implementation methodologies and the technologies used for making stellite. node list distribution most cryptocurrencies (including bitcoin, monero, etc.) hard-code trusted nodes and peers help users set their own nodes. this has been proven work, but calls for noticeable security risk. hacking hard-coded node will cause all future nodes from that point create hiccups for new users and making their daemons and clients useless. stellite's proposed solution publish the node list decentralized network called ipfs and using zeronet technologies serve the front end for adding new nodes the ipfs ledger list nodes. simple terms ipfs acts like permanent storage the node list and zeronet will the dynamic front end this permanent storage. zeronet uses bitcoin cryptography and bittorrent technology build decentralized censorship-resistant network. users can publish static dynamic websites into zeronet and visitors can choose also serve the website. websites will remain online even being served only one peer. when site updated its owner, all nodes serving that site (previous visitors) will receive only the incremental updates done the site content. zeronet comes with built-in sql database. this makes content-heavy site development easy. the also synced with hosting nodes with incremental updates.[] the inter planetary file system (ipfs) protocol works like single bittorrent swarm, people exchanging objects part single tree repository. they're based content-addressed block storage model. ipfs combines distributed hashtable, incentivized block exchange, and self-certifying namespace. ipfs has single point failure, and nodes not need trust each other. these make ipfs the best candidate host single peer list file that contains nodes which can contribute being the backbone for the entire stellite network.[] traditionally the addition new file onto ipfs and the retrieval has steps, creation the file, addition the file and the actual retrieval. this happens automatically certain predefined interval but for the sake demonstration are going doing manually. viewing the node_list.dat file created added ipfs adding the file ipfs and retrieving the hash for the file the hash unique for each file that uploaded onto ipfs, the list can distributed across multitude ipfs peers without being tampered with. viewing the stored file using ipfs gateway the gateway tricky thing because there are ways approaching this, could use single gateway and retrieve the file using the unique hash from the centralized gateway could bundle ipfs daemon and gateway along with the stellite daemon and then retrieve the file using the unique hash locally. are implementing stellite run its own ipfs daemon and fetch the list from the unique hash without needing centralized gateway. another question that arises how the hash will delivered the stellite daemon. this where zeronet comes in. have hard coded zeronet address retrieve the latest peer list hash from. zeronet python application which runs along with the daemon every time updating self with the latest list with the latest hash that has been provisioned the zeronet decentralized site. the below given image example zeronet address giving ipfs hash for file retrieval. the zeronet site that hardcoded into the stellite daemon used get the hash which turn used download the node list. ipfs and zeronet based blockchain import utility syncing the blockchain tedious and time consuming process especially the chain question few years old, even user has considerable amount network bandwidth the downloading, verifying addition the blockchain the local database from other peers will take time. solve this issue propose raw copy the blockchain stored ipfs and the hash ipfs stored zeronet can easily changed weekly even daily intervals. how this compares using the traditional websites that ipfs content tamper proof and the raw blockchain can downloaded with utmost confidence. the utility will cross platform with intuitive frontend and more people support the storage the content the download will get faster. complete node anonymity nodes are not private, they are open the public internet, other nodes malicious actors can take advantage this specific property track transactions that are being relayed them and then break the untraceability the coin. avoid this will providing the users with easily configurable tor and kovri (an open source implementation protocol) instance with which user the particular node can mask their clear net address. true mining for all devices stellite plans bring mining all sorts devices, from smartphones smart tv's, this running our custom miner such way that doesn't damage any the internal aspects the machine it's being run on. person can create address and mine that address from endless number devices. this can help countries such india where there abundance hash power the form smart devices the ones mentioned above and all them currently are being under utilized. our calculations the stellite app takes less cpu toll than apps such the facebook app. the math involved this simple, mid tier smartphone provides around h/s full throttle, when usage provides around h/s. user can use her specific wallet address 'x' mine many devices possible. alice has devices she has hashes .kh/s. which equivalent gtx graphics card running full potential. this possible due variable difficulty algorithm have worked on, device such smartphone can only provide h/s the improved pool server immediately gives out block templates exactly corresponding that hashrate improving not just speed but efficiency too. the new pool works event loop and also has adequate proxy servers for running millions workers. this will not just strengthen the network but also redistributes wealth globally. the main problem with many the past implementation were that software which are use for most mobile miners don't take care the device's internal aspect but with our custom miner with it's own protocol for power and temperature control, aim solve that problem exactly. amayc protocol amayc protocol uses deep learning find devices optimal settings, allowing mine without damaging hardware while easing power consumption. benchmarking done the client side the first few mining cpu cycles which takes around seconds mid tier smartphone. makes use pre trained neural network give efficiency rating used the miner calibrate later on. the dataset training the network culmination data from hundreds devices, providing with clear cut idea how good can perform without damaging itself. below given sample set data which used train the neural network. hashes per second temperature rating mobile miner the mobile miner application able solve low diff blocks given any pool server that supports it. the limit the miner set degree celcius, even though device can get warmer, which seems safe limit for most new generation smartphones. when the cpu reaches that limit, the miner turns itself off until the phone gets back normal temperatures and then begins once the device back potential range. this way can ensure the device never gets warm that the lithium ion battery suffers any damage. neural network implementation for amayc protocol traditional benchmarking techniques not fit well the mobile devices use cases. they are too slow, computationally intensive and usually not take the device temperature account. with the neural network will able find the standard very short span time and also resource efficiently. for the implementation will using simple classifier. have made custom node module for tests, the usage very simple shown below, the code for this module will opensourced along with the miner. var minerclassifier require('stellitenn'); var network new minerclassifier.neuralnetwork(); just some data for very simple neural network. network.train([{input: output: bad: }}, {input: output: good: }}, {input: output: bad: }}, {input: output: good: }}]); var result network.run({ }); //{ bad: good: from the above code shows that the hash rate h/s degree celsius somewhat okay clocking rating. from this can truly understand the potential this benchmarking approach. cryptonote algorithm[] the cryptonote algorithm released under open source license and has been adopted and incorporated into stellite forms the basis for solid, well tested cryptocurrency application. the same technology used some the best currencies out there like monero and bytecoin. now can discuss some the merits the currency well cryptonote. untraceable payments the ordinary digital signature (e.g. (ec)dsa, schnorr, etc...) verification process involves the public key the signer. necessary condition, because the signature actually proves that the author possesses the corresponding secret key. but not always sufficient condition. ring signature more sophisticated scheme, which fact may demand several different public keys for verification. the case ring signature, have group individuals, each with their own secret and public key. the statement proved ring signatures that the signer given message member the group. the main distinction with the ordinary digital signature schemes that the signer needs single secret key, but verifier cannot establish the exact identity the signer. therefore, you encounter ring signature with the public keys alice, bob and carol, you can only claim that one these individuals was the signer but you will not able pinpoint him her. this concept can used make digital transactions sent the network untraceable using the public keys other members the ring signature one will apply the transaction. this approach proves that the creator the transaction eligible spend the amount specified the transaction but his identity will indistinguishable from the users whose public keys used his ring signatures. should noted that foreign transactions not restrict you from spending your own money. your public key may appear dozens others' ring signatures but only muddling factor (even you already used the corresponding secret key for signing your own transaction). moreover, two users create ring signatures with the same set public keys, the signatures will different (unless they use the same private key). unlinkable transactions normally, when you post your public address, anyone can check all your incoming transactions even they are hidden behind ring signature. avoid linking you can create hundreds keys and send them your payers privately, but that deprives you the convenience having single public address. stellite's cryptonote solves this dilemma automatic creation multiple unique one-time keys, derived from the single public key, for each payment. the solution lies clever modification the diffie-hellman exchange protocol. originally allows two parties produce common secret key derived from their public keys. our version the sender uses the receiver's public address and his own random data compute one-time key for the payment. the sender can produce only the public part the key, whereas only the receiver can compute the private part; hence the receiver the only one who can release the funds after the transaction committed. only needs perform singleformula check each transactions establish belongs him. this process involves his private key, therefore third party can perform this check and discover the link between the one-time key generated the sender and the receiver's unique public address. important part our protocol usage random data the sender. always results different one-time key even the sender and the receiver both remain the same for all transactions (that why the key called "onetime"). moreover, even they are both the same person, all the one-time keys will also absolutely unique. double-spending proof fully anonymous signatures would allow spending the same funds many times which, course, incompatible with any payment system's principles. the problem can fixed follows. ring signature actually class crypto-algorithms with different features. the one stellites's cryptonote uses the modified version the "traceable ring signature". fact transformed traceability into linkability. this property restricts signer's anonymity follows: creates more than one ring signature using the same private key (the set foreign public keys irrelevant), these signatures will linked together which indicates double-spending attempt. support linkability, stellite's cryptonote introduced special marker being created user while signing, which called key image. the value cryptographic one-way function the secret key, math terms actually image this key. one-wayness means that given only the key image impossible recover the private key. the other hand, computationally impossible find collision (two different private keys, which have the same image). using any formula, except for the specified one, will result unverifiable signature. all things considered, the key image unavoidable, unambiguous and yet anonymous marker the private key. all users keep the list the used key images (compared with the history all valid transactions requires insignificant amount storage) and immediately reject any new ring signature with duplicate key image. will not identify the misbehaving user, but does prevent any double-spending attempts, caused malicious intentions software errors. blockchain analysis resistance there are many academic papers dedicated the analysis the bitcoin's blockchain. their authors trace the money flow, identify the owners coins, determine wallet balances and on. the ability make such analysis due the fact that all the transfers between addresses are transparent: every input transaction refers unique output. moreover, users often re-use their old addresses, receiving and sending coins from them many times, which simplifies the analyst's work. happens unintentionally: you have public address (for example, for donations), you are sure use this address many inputs and transactions. stellite's cryptonote designed mitigate the risks associated with key re-usage and one-input-to-one-output tracing. every address for payment unique one-time key, derived from both the sender's and the recipient's data. can appear twice with probability -bit hash collision. soon you use ring signature your input, entails the uncertainty: which output has just been spent? trying draw graph with addresses the vertices and transactions the edges, one will get tree: graph without any cycles (because key/address was used twice). moreover, there are billions possible graphs, since every ring signature produces ambiguity. thus, you can't certain from which possible sender the transaction edge comes the addressvertice. depending the size the ring you will guess from "one out two" "one out thousand". every next transaction increases the entropy and creates additional obstacles for analyst. standard cryptonote transactions standard stellite cryptonote transaction generated the following sequence covered the white paper. bob decides spend output, which was sent the one-time public key. needs extra (), txoutnumber (), and his account private key recover his one-time private key (). when sending transaction carol, bob generates its extra value random (). uses extra (), txoutnumber and carol's account public key get her output public key (). the input bob hides the link his output among the foreign keys (). prevent double-spending also packs the key image, derived from his one-time private key (). finally, bob signs the transaction, using his one-time private key (), all the public keys and key image (). appends the resulting ring signature the end the transaction (). zero confirmation transactions one stellite's main goals are get adopted the masses, used everyday life for simple transactions. this greatly hindered the fact that transactions takes time added into blocks. have made custom point-of-sale system that works with our mobile wallets allow transactions through merchant less than few seconds. the inner working this function are very simple. when transaction broadcasted onto the network, first goes into pool transactions called the txpool the memory pool, from here added onto block, even with our block time being seconds, could take couple minutes more depending amount transactions the pool. avoid this waiting period are allowing merchants accept confirmation transactions. the point sale will also come with option where the merchant can set the amount confirmation needed, for instance the transaction high value. another solution provide the users use proprietary application called stellitepay which uses centralized database transaction handled similar fashion how traditional exchanges handle them, which using simple pool transactions single server before commiting onto the network, this mostly for the novice users for whom setting regular node node which connects remote node not feasible. thus increasing even more the adoption capabilities. adaptive limits decentralized payment system must not depend single person's decisions, even this person core developer. hard constants and magic numbers the code deter the system's evolution and therefore should eliminated (or least cut down the minimum). every crucial limit (like max block size min fee amount) should re-calculated based the system's previous state. therefore, always changes adaptively and independently, allowing the network develop it's own. stellite's cryptonote has the following parameters which adjust automatically for each new block: difficulty the general idea our algorithm sum all the work that nodes have performed during the last blocks and divide the time they have spent accomplish it. the measure the work the corresponding difficulty value for each the blocks. the time calculated follows: sort all the timestamps and cut-off the outliers. the range the rest values the time which was spent for the corresponding blocks max block size let the median value the last blocks sizes. then the "hard-limit" for the size accepting blocks *mn. averts blockchain bloating but still allows the limit slowly grow with the time necessary. transaction size does not need limited explicitly. bounded the size the block. improvements the difficulty adjustment algorithm the general idea our original difficulty algorithm sum all the work that nodes have performed during the last blocks and divide the time they have spent accomplish it. the measure the work the corresponding difficulty value for each the blocks. the time calculated follows sort all the timestamps and cut-off the outliers. the range the rest values the time which was spent for the corresponding blocks. the downside simple moving average algorithm that way too slow adjust the difficulty and causes long time delay large hashrate miner comes the network. hence curb the issue hardforked height use new difficulty algorithm which adjusts much faster the net hashpower network.the new algorithm adjusts difficulty based the harmonic mean the difficulties (the inverse the average target) divided the linearly weighted moving average (lwma) the solvetimes. gives more weight the most recent solvetimes. difficulty will double blocks during the introduction high hashrate miner, and drop back down close normal blocks the high hashrate miner leaves the network. smooth emission the upper bound for the overall amount all digital coins also digital: msupply atomic units this natural restriction based only the implementation limits, not intuition like coins ought enough for everybody". make the emission process smoother stellite's cryptonote uses the following formula for block rewards basereward (msupply where amount previously generated coins. gives predictable growth the money supply without any breakpoints. egalitarian proof work the proof work mechanism actually voting system. users vote for the right order the transactions, for enabling new features the protocol and for the honest money supply distribution. therefore, important that during the voting process all participant have equal voting rights. stellite's cryptonote brings the equality with egalitarian proof-of-work pricing function, which perfectly suitable for ordinary pcs. utilizes built-in cpu instructions, which are very hard and too expensive implement special purpose devices fast memory on-chip devices with low latency. propose new memory-bound algorithm for the proof-of-work pricing function. relies random access slow memory and emphasizes latency dependence. opposed scrypt, every new block bytes length) depends all the previous blocks. result hypothetical "memory-saver" should increase his calculation speed exponentially. our algorithm requires about per instance for the following reasons: fits the cache (per core) modern processors, which should become mainstream few years. megabyte internal memory almost unacceptable size for modern asic pipeline. gpus may run hundreds concurrent instances, but they are limited other ways: gddr memory slower than the cpu cache and remarkable for its bandwidth, not random access speed. significant expansion the scratchpad would require increase iterations, which turn implies overall time increase. "heavy" calls trust-less network may lead serious vulnerabilities, because nodes are obliged check every new block's proof-of-work. node spends considerable amount time each hash evaluation, can easily ddosed flood fake objects with arbitrary work data (nonce values). one the proof-of-work algorithms that line with our propositions cryptonight. designed make cpu and gpu mining roughly equally efficient and restrict asic mining. solution restrict asic mining the drawback most cryptocurrencies like bitcoin that the proof work algorithm which uses the sha- hash function can mined special application specific integrated circuits (asics). this due the huge gaps efficiency when compared with cpu/gpu mining. this gap can make asic the only device that capable mining, this threat our ideology. wish make mining further decentralized helping people mine their smartphones. solve the asic dilemma will changing our current pow algorithm(cryptonightv) slightly regular protocol upgrades/hard forks which will render asics useless they are meant for just one specific function and cannot adapt like regular cpus/gpus. even done largely spaced intervals pow changes poses significant drop network hash rate for considerable amount time, parallel with lwma our difficulty adjustment algorithm the net difficulty will reflect the real network hash rate the span few hours. below given graph during our first pow change with lwma. you can see the difficulty dropped significantly short span blocks but also regained momentum more people joined later time. references and citations: cryptonote white paper: https://cryptonote.org/whitepaper.pdf cryptonote inside: https://cryptonote.org/inside bitcoin white paper: https://bitcoin.org/bitcoin.pdf electroneum white paper: https://electroneum.com/technical-white-paper.pdf ipfs white paper: https://ipfs.io/ipfs/qmrgsqmcxeagayrzndefqvulxokzrjalx/ipfs.draft.pdf zeronet documentation: https://zeronet.readthedocs.io