celer network: bring internet scale every blockchain scalesphere foundation ltd. ("foundation") june draft, subject change. abstract. just like how the kbps dialup internet the cannot possibly support video streaming, the insufficient scalability today's blockchain the key factor limiting its use cases. current blockchains have low throughput because each operation needs processed the vast majority nodes reach on-chain consensus, which exactly "how build super slow distribution system". ironically, the on-chain consensus scheme also leads poor privacy any node can see the full transaction history one another. while new consensus algorithms keep getting proposed and developed, hard free on-chain consensus from its fundamental limitations. o|-chain scaling techniques allow mutually distrustful parties execute contract locally among themselves instead the global blockchain. parties involved the transaction maintain multi-signature fraud-proof o|-chain replicated state machine, and only resort on-chain consensus when absolutely necessary (e.g., when two parties disagree state). o|-chain scaling the only way support fully scale-out decentralized applications ("dapps") with better privacy and compromise the trust and decentralization guarantees. the inflection point for blockchain mass adoption, and will the engine behind all scalable dapps. celer network internet-scale, trust-free, and privacy-preserving platform where everyone can quickly build, operate, and use highly scalable dapps. not standalone blockchain but networked system running top existing and future blockchains. provides unprecedented performance and flexibility through innovation o|-chain scaling techniques and incentive-aligned cryptoeconomics. celer network embraces layered architecture with clean abstractions that enable rapid evolution each individual component, including generalized state channel and sidechain suite that supports fast and generic o|-chain state transitions; provably optimal value transfer routing mechanism that achieves order magnitude higher throughput compared state-of-the-art solutions; powerful development framework and runtime for o|-chain applications; and new cryptoeconomic model that provides network e|ect, stable liquidity, and high availability for the o|-chain ecosystem. important: you must read the following disclaimer full before continuing the sale ("token sale") celr ("tokens"), the cryotographic token associated with the celer network detailed this whitepaper ("whitepaper"), only intended for, made directed at, only certain persons. this whitepaper not prospectus offer document any sort and not intended constitute offer securities any form, units business trust, units collective investment scheme any other form investment, solicitation for any form investment any jurisdiction. regulatory authority has examined approved any the information set out this whitepaper. this whitepaper has not been registered with any regulatory authority any jurisdiction. accessing and/or accepting possession any information this whitepaper such part thereof (as the case may be), you represent and warrant cspeed ltd (bvi business company number (the "token vendor") that: (a) you are not excluded person (as defined below); (b) you are not located jurisdiction where the token sale prohibited, restricted unauthorised any form manner whether full part under its laws, regulatory requirements rules; (c) you have read the entirety this whitepaper and understand the risks entailed your purchase the tokens; (d) you agree bound the limitations and restrictions described herein; and (e) you acknowledge that this whitepaper has been prepared for delivery you assist you making decision whether purchase the tokens, and purely for reference without any intention create legal relations between you and the token vendor, legally binding enforceable you against the token vendor. please not proceed further into the contents this whitepaper you not agree with any the above. please refer the section entitled "important notice" and the sections entitled "disclaimer liability", "no representations and warranties", "representations and warranties you", "cautionary note forward-looking statements", "third party information and consent other persons", "terms used", "no advice", "no further information update", "restrictions distribution and dissemination", "no offer investment registration" and "risks and uncertainties" carefully before proceeding further with this whitepaper. contents introduction celer technology stack celer cryptoeconomics cchannel: the foundation o|-chain scaling generalized state channel key idea and simple example design goals general specification common utilities out-of-box features alternative channel model with sidechains croute: provably-optimal value transfer routing challenges state channel network routing distributed balanced routing (dbr) system model protocol description throughput performance dbr discussions dbr failure resilience privacy simulation results cos: o|-chain decentralized application operating system directed acyclic graph conditionally dependent states o|-chain application development framework o|-chain application runtime ceconomy: o|-chain cryptoeconomics mechanism design tradeo|s o|-chain ecosystems o|-chain scalability vs. liquidity o|-chain scalability vs. availability ceconomy design proof liquidity commitment (polc) mining liquidity backing auction (liba) state guardian network summary conclusion founding team introduction many modern economic activities are essentially the flow and exchange information and value. over the past two centuries, the transfer information has evolved from discrete events through pigeon networks continuous flows through the speed-of-light internet. however, the value transfer portion far from light speed and still very much discrete events controlled segregated financial silos. this mismatch creates devastating bottleneck economic evolution: matter how fast information flows, the expensive and slow value transaction limiting the productive exchange the two. essentially revolutionary abstraction trust among distrustful parties that results incentive-aligned distributed consensus, blockchain technology o|ers the foundation dismantle segregated financial silos and dramatically expand the scope and freedom global value flows. practice, however, blockchain deviating further away from the speed-of-light vision due its low processing power compared traditional value transfer tools. scalability fundamental challenge that hindering mass adoption blockchain technology. envision future with decentralized ecosystems where people, computers, mobile and internet-of-things ("iot") devices can perform secure, private, and trust-free information-value exchange massive scale. achieve this, blockchains should match the scale the internet and support hundreds millions billions transactions per second. however, given the processing speed existing blockchains (i.e., few tens transactions per second), really possible bring the scale the internet blockchains? the answer yes but only with o|-chain scaling. while on-chain consensus the foundation blockchain technology, its limitations are also obvious. sense, consensus the opposite scalability. for any distributed system, all nodes need reach consensus every single transaction, its performance will better (in fact, much worse due communication overhead) than centralized system with single node that processes every transaction, which means the system eventually bottlenecked the processing power the slowest node. on-chain consensus also has severe implications privacy, because all transactions are permanently public. few on-chain consensus improvements have been proposed including sharding and various proof-of-x mechanisms. they make the blockchain relatively faster with di|erent tradeo|s performance, decentralization, security, and finality, but cannot change the fundamental limitations on-chain consensus. enable internet-scale blockchain systems with better privacy and compromise trust decentralization, have look beyond on-chain consensus improvements. the core principle design scalable distributed system make operations di|erent nodes mostly independent. this simple insight shows that the only way fully scale out decentralized applications bring most the transactions o|-chain, avoid on-chain consensus much possible and use last resort. related techniques include state channel, sidechain, and o|-chain computing oracle. despite its high potentials, o|-chain scaling technology still its infancy with many technical and economic challenges remaining unresolved. enable o|-chain scaling for prime-time use, propose celer network coherent architecture that brings internet scale existing and future blockchains. celer network consists carefully designed o|-chain technology stack that achieves high scalability and flexibility with strong security and privacy guarantees, and gametheoretical cryptoeconomic model that balances any new tradeo|s. celer technology stack comprehensive full-stack platform that can built upon existing future blockchains, celer network encompasses cleanly layered architecture that decouples sophisticated o|-chain platform into hierarchical modules. this architecture greatly simplifies the system design, development, and maintenance, that each individual component can easily evolve and adapt changes. well-designed layered architecture should have open interfaces that enable and encourage di|erent implementation each layer long they support the same cross-layer interfaces. each layer only needs focus achieving its own functionality. inspired the successful layered design the internet, celer network adopts o|chain technology stack that can built di|erent blockchains, named cstack, which consists the following layers bottom-up order: cchannel: generalized state channel and sidechain suite. croute: provably optimal value transfer routing. cos: development framework and runtime for o|-chain enabled applications celer swift, fast latin, the for the speed light figure celer network layered architecture. celer architecture provides innovative solutions all layers. below highlight the technical challenges and features cchannel, croute, and cos. cchannel. this the bottom layer celer network that interacts with di|erent underlying blockchains and provides the upper layer with common abstraction upto-date states and bounded-time finality. cchannel uses state channel and sidechain techniques, which are both cornerstones o|-chain scaling platforms. state channel allows mutually distrustful parties execute program o|-chain and quickly settle the latest agreed states, with their security and finality guaranteed on-chain bond contracts. was initially introduced lightning network support high-throughput o|-chain bitcoin micropayments. since the introduction lightning network, there have been several research works that addressed di|erent problems the context payment channel networks, such routing time lock optimization [], and privacy []. however, o|-chain network still its early stage, facing few major challenges terms modularity, flexibility, and costefficiency. cchannel meets current challenges o|ering set new features. generic o|-chain state transition. o|-chain transactions can arbitrary state transitions with dependency dag. this allows celer network support complex high-performance o|-chain dapps such gaming, online auction, insurance, prediction market and decentralized exchanges. flexible and efficient value transfer. multiple state channel and sidechain constructions with di|erent tradeo|s efficiency and finality are provided support fast value transfer with generic condition dependency, minimal on-chain interactions, and minimal fund lockup. pure o|-chain contract. any contract that not directly associated with on-chain deposits does not need any on-chain operation initialization unless dispute triggered. every pure o|-chain contract object has uniquely identifiable o|-chain address, and only needs deployed blockchains when necessary with on-chain address assigned the built-in o|-chain address translator. croute. celer network platform for highly scalable dapps, designed support high-throughput value transfer. o|-chain value transfer essential requirement many o|-chain applications. while celer network capable supporting dapps beyond payment solutions, also makes groundbreaking improvements o|-chain payment routing directly determines how much and how fast value can transferred within the ecosystem. all the existing o|-chain payment routing proposals boil down conventional "shortest path routing" algorithms, which may achieve poor performance o|-chain payment network due the fundamental di|erences the link model. the link capacity computer network stateless and stable (i.e., not a|ected past transmissions). however, the link capacity o|-chain payment network stateful (i.e., determined on-chain deposits and past payments), which leads highly dynamic network where the topology and link states are constantly changing. this makes conventional shortest path routing algorithms hard converge, and thus yields low throughput, long delay, and even outages. counter this fundamental challenge, celer network's payment routing module, croute, introduces distributed balanced routing (dbr), which routes payment traffic using distributed congestion gradients. highlight few unique properties dbr (details ..). provably optimal throughput. prove that for any global payment arrival rate, there exists routing algorithm that can support the rate, then dbr can achieve that. our evaluation shows that dbr achieves higher throughput and higher channel utilization ratio compared state-of-art solutions. transparent channel balancing. "keeping the channels balanced" has been our goal since the proposal lightning network. however, existing attempts the ratio between the amount transferred fund each time slot and the total deposits all channels. channel balancing comprise heuristics that require heavy on-chain o|-chain coordination with poor guarantees. dbr embeds the channel balancing process along with routing and constantly balances the network without requiring any additional coordination. fully decentralized. the dbr algorithm fully decentralized algorithm where each node only needs "talk" its neighbors the state channel network topology. dbr's protocol also lowers messaging cost. failure resilience. the dbr algorithm highly robust against failures: can quickly detect and adapt unresponsive nodes, supporting the maximum possible throughput over the remaining available nodes. privacy preserving. the dbr algorithm can seamlessly integrated with onion routing preserve anonymity for sources/destinations. due its multi-path nature, the dbr algorithm naturally preserves the privacy regarding the amount transferred value, without using any additional privacy-preserving techniques (e.g., zksnark). cos. on-chain dapp simply frontend connecting the blockchain. o|-chain dapps, though with great potentials for high scalability, are not easy build and use the traditional on-chain dapps. celer network introduces cos which development framework and runtime for everyone easily develop, operate, and interact with scalable o|-chain dapps without being bogged down the additional complexities introduced o|-chain scaling. celer network allows developers concentrate the application logic and create the best user experience, with the cos dealing with the heavy lifting including the following tasks. figure out the dependency between arbitrary o|-chain and on-chain states. handle the tracking, storage, and dispute o|-chain states. tolerate intermediate node failures transparently. support multiple concurrent o|-chain dapps. compile unified implementation di|erent on-chain and o|-chain modules. celer cryptoeconomics celer network's cryptoeconomic mechanism, ceconomy, designed based fundamental principle: good cryptoeconomic (token) model should provide additional values and enable new game-theoretical dynamics that are otherwise impossible. while gaining scalability, o|-chain platform also making tradeo|s network liquidity and state availability, and will never take without cryptoeconomic model that can enable new dynamics balance out these tradeo|s. new tradeo|s. o|-chain platform gains scalability making the following tradeo|s. scalability vs. liquidity. o|-chain value transfer requires deposits locked on-chain network liquidity. this especially challenging for potential o|-chain service providers, because significant amount liquidity needed provide e|ective o|-chain services for global blockchain users, either outgoing deposits state channels fraud penalty bond sidechains. however, owners large number crypto assets (whales) may not have the business interest technical capability run o|-chain service infrastructure, while people who have the technical capability running reliable and scalable o|-chain service often not have enough capital for channel deposits fraud-proof bonds. such mismatch creates huge hurdle for the mass adoption and technical evolution o|-chain operating networks. scalability vs. availability. while o|-chain scaling does not make any compromise the trust-free property the blockchain, does sacrifice the availability guarantee. each state channel o|-chain contract associated with dispute timeout, and the involved party will risk when staying o|-line longer than the timeout, when the local states are lost. therefore, need incentive-compatible mechanism provide sufficient liquidity for entities which are capable running reliable and scalable o|-chain service infrastructure, and guarantee that the o|-chain states are always available for possible on-chain dispute. new cryptoeconomics. complete the o|-chain scaling solution, introduce suite cryptoeconomic mechanisms, named ceconomy, that brings indispensable value and provides network e|ect, stable liquidity, and high availability through the celer network's protocol token ("celr and three tightly coupled components. proof liquidity commitment(polc). polc virtual mining process that acquires abundant and stable liquidity for the o|-chain ecosystem. participate, one simply needs commits (locks) his idle liquidity (in the form digital assets, including but not limited cryptocurrencies and celr) the o|-chain platform for certain period time with celr rewarded incentives such users. liquidity backing auction (liba). liba enables o|-chain service providers solicit liquidity through "crowd lending" with negotiated interest rates. lenders are ranked according their "happiness scores" that are determined the interest rate, the amount provisioned liquidity and the amount staked celr. particular, lenders who stake more celr (as indicator for their past contributions the ecosystems) have higher priority selected provide liquidity o|-chain service providers. state guardian network (sgn). sgn special compact sidechain that guards the states when users are oine that the users' states are always available for dispute. guardians need stake their celr into sgn earn guarding opportunities and service fees from the users. section introduces ceconomy mechanisms detail with analysis the celr value and model incentive-compatibility. cchannel: the foundation o|-chain scaling celer network's cchannel aims provide framework enable state channel and sidechain network with maximum flexibility and efficiency. this section starts with the generalized channel construct and outlines the key elements support arbitrary conditional dependency between on-chain verifiable states. then expand the horizon beyond classic state channel and examine how encapsulate sidechain into the same interface exposed the upper layer. ... generalized state channel key idea and simple example one major limitation the existing payment network solutions the lack support for generalized state transitions. the need for generalized state transitions comes with the rise smart contract platforms such ethereum. smart contract enables asynchronous value transfer based arbitrary contractual logic. improve the scalability such blockchains using o|-chain state channel concepts, on-chain state transitions should put into o|-chain state channels and the corresponding value transfer should made aware such state transitions. use simple example conditional payment illustrate the key idea about how transform on-chain states transition o|-chain states transitions. let's say alice and carl want play board game while betting the result such game trust-free manner: alice will pay carl carl wins and vice versa. this simple logic implement on-chain. one could build smart contract that holds alice's and carl's payment before the game starts. alice and carl will just play that game calling the on-chain smart contract's functions. when one them loses the game, surrenders, times out, the winner gets the loser's deposit. the deposits can seen payments that are conditionally issued (i.e. condition that the counterparty wins). unfortunately, on-chain smart contract operations are extremely slow and expensive every transaction involves on-chain transaction. o|-chain state channel can used significantly improve scalability while maintaining the same semantic. let's assume there payment channel between alice and carl. enable the above semantic, need expand the functionality channel's state proof include conditional lock that depends the game's winner state. alice can then send carl o|-chain conditional payment e|ectively saying: will pay carl the game contract's who winner function says carl wins". the game state transitions can also moved o|-chain. the most straightforward way still have on-chain contract governing the rule the board game and that contract's address referenced the conditional payment. all the state transitions are happening o|-chain via mutually signed game states that can injected into the on-chain contract when necessary. but fact, since there requirement for any kind value bond for the program states, the entire game contract and the associated states can always stay o|-chain long involved parties are collaborative. the only requirement that the relevant game states are on-chain verifiable when need be. on-chain verifiable state means other contracts objects can refer with ambiguity. realize that, need have reference translator contract that maps o|-chain references (such the hash contract code, constructor parameters, and nonce) on-chain references (contract address). with these constructs, the game between alice and carl involves only one long-term on-chain contract that not specific the game logic, and on-chain operation initialization for the gaming. the example above reflects specialized and simple instance o|-chain design patterns and can much more sophisticated. the conditional payment can more complicated than just simple boolean conditions, and can designed way redistribute locked liquidity based arbitrary contractual logic. fact, conditional payments simply special case more generalized conditional state transition. the channel dependency can also more complicated than one-to-one dependency realize the common pattern multi-hop state relays. detail out the technical specification the followings sections. ... design goals our top goal achieve fast, flexible and trust-free o|-chain interactions. expect most cases o|-chain state transitions will stay o|-chain until final resolution. therefore, aim optimize commonly used o|-chain patterns into succinct interactions with built-in support from on-chain components. our second goal design data structure and object interaction logic that works for di|erent blockchains. celer network aims build blockchain-agnostic platform and run di|erent blockchains that support smart contracts. therefore, common data structure schema and certain layer indirection are required. besides these two highlighted goals, plan employ formal specification channel state machines and verify the security properties along with the communication protocols that alter those states. should also aim provide efficient on-chain resolution mechanism whenever possible. ... general specification this section, provide specifications for the core components cchannel's generalized state channel with top-down approach, and describes the common state channel interface that applies any state channel with value transfer and arbitrary contractual logic. there could extensive specialization and optimization for di|erent concrete use cases, but the principles stay the same. before the detailed specification generalized state channel, first introduce several important notations and terms that will used throughout this section. (state). denote the state channel. for bi-party payment channel, represents the available balances the two parties; for board game, represents the board state. (state proof state proof serves bridge data structure between on-chain contracts and o|-chain communication protocols. state proof contains the following fields where seq, merkle root, sigs denotes the accumulative state updates until now. note that given base state and state update can uniquely produce new channel state for example, bi-party payment channel, the base state corresponds deposits the two parties and the state update mapping that indicates the amount tokens transferred from one participant the other participant. seq the sequence number for the state proof. state proof with higher sequence number will disable state proofs with lower sequence numbers. merkle root the root the merkle tree all pending condition groups and crucial for creating conditional dependency between states cchannel. finally, sigs represents the signature from all parties this state proof. state proof valid only all parties signatures are present. (condition). condition cond the data structure representing the basic unit conditional dependency and this where the conditional dependency dags are weaved. condition can specified follows. cond timeout, -isfinalized(args), -queryresult(args) here, timeout the timeout after which the condition expires. for example, for condition that depends the results board game, timeout may correspond the maximum duration the board game (e.g., tens minutes). boolean function pointer isfinalized(args) used check whether the condition has been resolved and settled before the condition timeout. the arguments for this function call are application-specific. for example, the board game, the arguments could simple args [blocknumber] querying whether the game winner has been determined before blocknumber. addition, queryresult(args) result query function pointer that returns arbitrary bytes the condition's resolving result. for example, the board game, the arguments could args [player] querying whether player the winner (boolean condition); the second-price auction, the arguments could args [participant, participant, participantn querying who the winner and the amount money each participant should pay (generic condition). the resolution process for condition first perform isfinalized(args) and then perform result query queryresult(args). (condition group). condition group cond group higher-level abstraction for group conditions express generalized state dependencies. condition group can specified follows. cond group resolvegroup(cond results) where denotes set conditions contained this condition group. each condition cond resolves arbitrary bytes array (i.e., the output cond.queryresult(args)). these bytes array are handled group resolving function resolvegroup(cond results) which takes the resolving results all conditions inputs and returns state update for payment channel, each con- dition group corresponds conditional payment. for example, conditional payment saying that pays wins the gomoku game" corresponds condition group that contains two the conditions: the hashed time lock condition (for multi-hop relay) and the gomoku game condition ("b wins the game"). the resolvegroup function simply returns transfer from both conditions are true. now are ready specify the interface for state channel. state channel can specified the following tuple: sp, ..., the set participants this channel. the on-chain base state for this channel (e.g., initial deposits for each participant payment channel). represents the most updated known state proof for the channel. the updated channel state after state proof fully settled. the settlement timeout increment for the state proof that will specified later. contains set standard functions that should implemented every state channel: resolvestateproof(sp, cond groups). this function updates the current state proof resolving attached condition groups. getupdatedstate(sp, this function used get the most updated state based o|-chain state proof and on-chain base states updatestate(s). this function allows on-chain updates state channel's currently resolved state intendsettle(new sp). this function opens challenge period before the settlement timeout. during the challenge period, this function takes state proof input and update the current state proof the input newer. confirmsettle(sp). this function validates and confirms the current state proof fully settled given the current time has exceeded the settlement timeout. isfinalized(args) and queryresult(args) are the entry points for resolving conditional dependency. accepts outside queries with necessary arguments for the querying contract interpret accordingly. fact, some patterns are used frequently enough, cchannel's implementation, separate them into pre-defined function interfaces. closestatechannel(s). this function terminates the life cycle the state channel and distributes necessary states out according the latest settled state settlement timeout determined based time last called resolvestateproof settlestateproof and the settlement timeout increment dependency constraints. when create dependencies among di|erent state channels, some constraints need enforced order guarantee proper resolution the dependency dag. suppose state channel depends state channel then required that the participants should subset the participants such that the participants have the necessary information resolving its dependency ... common utilities the above abstraction defines the common pattern for generalized state channel construction. di|erent blockchains, the actual implementation might di|erent. for example, ethereum, cross-contract calls contains return value but dfinity, crosscontract calls only trigger registered callbacks. reviewing multiple blockchains' implementations state transition vms, identify two common utilities that are essential for the operation generalized state channel practice followings: o|-chain address translator (oat). the above abstraction, condition and condition group are associated with di|erent functions. these functions should the reference on-chain contract's functions, but since program (smart contract) states are not inherently bound constraints the blockchain, there should fundamental requirement have on-chain presence. the only barrier moving them entirely o|-chain the possible ambiguity reference for functions such isfinalized and queryresult. resolve this ambiguity, can define on-chain rule set map o|-chain references on-chain references. o|-chain address translator built for that. for contract with value involved, can referenced unique identifier generated through its contract code, initial states, and certain nonce. call such unique identifier o|-chain address. when resolving conditions on-chain, the referenced contracts need deployed and the corresponding functions (e.g., isfinalized and queryresult) should able translate o|-chain addresses on-chain addresses. realize such functionality, oat needs able deploy contract code and initial states on-chain get the on-chain contract and establish the mapping from o|-chain address on-chain address. hash time lock registry(htlr). hash time lock commonly used the scenario where transactions involving multiple state channels need happen atomically. for example, multi-hop relayed payment (unconditional conditional), atomic swap between di|erent tokens, cross-chain bridges and more. htl can implemented entirely o|-chain, but sprite has pointed out, this overoptimization that actually limits the o|-chain scalability. therefore, sprite proposes central registry where all locks can refer to. extend and modify sprite fit cchannel's common model. e|ectively, htlr provides dependency endpoints (isfinalized, queryresult) for conditions that act locks. isfinalized takes hash and block number and returns true the corresponding pre-image has been registered before the block number. queryresult takes hash and returns true the pre-image the hash registered. these two functions can simplified further into one, but for the sake generality, can simply keep them two separate functions. note that htlr, and associated isfinalized and queryresult, always on-chain. ... out-of-box features addition, need look into patterns that would commonly used and enhance certain on-chain components with out-of-box features simplify the corresponding o|chain interactions. generalized payment channel (gpc) very good example that. generalized payment channel payment channel that conforms the general state channel specification and therefore can support various conditional payments based further on-chain o|-chain objects. first make the abstract model more concrete the context gpc. represents the static deposit map for each party represents the final netted value each party owns. submitstateproof the function submit state proof and trigger timeout challenge period before settlestateproof can called and confirm the state proof. isfinalized and queryresult are functions check whether the state this payment channel has been finalized and query the current balances. one may wonder why payment channel has interface for outside query. this because some other payments states may depend existence certain conditional payment locked sp. resolvestateproof the most interesting part this where lot specialized optimization will happen and greatly reduce the o|-chain interaction complexity. getupdatedstate straightforward function compute the netted out payment for each party based the initial deposit and the fully resolved sp. closestatechannel simply closes the channel and distributes the netted out the final balance for each party. with this basic model, discuss how can further optimize the gpc constructs enable useful out-of-box features. cooperative settling most cases, counterparties state channel applications are cooperative. result, added complexity and expense through the challenge period and then settle. therefore, cchannel enables cooperative settling where counterparties not only sign the most recent state proof, but also sign the resulting signature show the agreement that the state update described that state proof indeed the final state. with this, the number transactions settle state proof can reduce from single-transaction channel opening another optimization cchannel brings reduce the number on-chain operation open channel from this achieved using dependency contract store deposits for counterparties. the counterparties will just sign the authorization withdrawal entirely o|-chain and one counterparty can submit that on-chain complete the channel opening process. direct final state claim when building generalized state channel applications, conditional state dependency commonly used. when finalizing the gpc, one party may want avoid the process traversing the conditional dependency graph. this limit the griefing scenario the counter-party, where the counterparty goes o|-line and refuse cooperatively convert some conditiongroup unconditional state update. limit the work needed for the disputing party, introduce the method direct final state claim. allows the online party directly claim final state without actually performing any additional traversal dependency graph. counterparty signatures are needed. avoid abuse, fraud-proof bond also required for the claiming party. after challenging period, the state will become final without needing perform any additional operations. dynamic deposit and withdrawal. common requirement for gpc enable seamless on-chain transactions when the counterparty not connected the network. for withdrawals funds, introduces pair functions intendwithdraw and confirmwithdraw, meet this requirement. intendtowithdraw changes the base state with challenge period. counterparty can submit conflicting dispute. dispute happens before the challenge period defined confirmtowithdraw called confirm and distribute the withdrawal. these two functions work very much like intendsettle and confirmsettle. deposit straightforward only changes the base state boolean circuit condition group. expect that gpc's most common use case would boolean circuit based conditional payment. for example, pays function function return true". optimize for such payment, tweak the interface condition group and condition. particular, can specialize function resolvegroup release pre-defined conditional payment any the condition resolving results (or any boolean circuit condition results) holds true. this way, saved the trouble creating additional objects for resolvegroup and the corresponding multi-party communication overhead. also specify condition boolean condition that require the depending objects should have interface with the e|ect "issatisfied" that returns true false based the state queried. fund assignment condition group. another more generalized use case for gpc generalized state assignment. implement this introducing another di|erent type condition group, which only has one condition it. queryresult will directly return state assignment map dictating update for this enables more general plug-in point for gpc. one can plugin o|-chain contract that was initialized with certain locked liquidity. this contract can check not only who wins game (boolean) but how many steps the winner took win the game, and then assign the liquidity carrying out certain computation. the involved parties can generate condition group that references the check function the o|-chain contract address they mutually agree on. there can many more common patterns defined for di|erent patterns, but the above example illustrates the design principle for such optimization. alternative channel model with sidechains besides the above-mentioned generalized state channel model, cchannel also introduces alternative state channel model that facilitated sidechains []. for example, consider the scenario where multiple users need pay each other. users can pool their deposits central contract, which acts like sidechain contract with the o|-chain service providers playing the role block proposers (forming "multi-party hub" with o|-chain service providers being "hub operators"), and therefore enables one-to-many payment relationships within hub. the integrity the o|-chain service providers ensured certain level fraud-proof bond acceptable participants. specifically, celer network, each o|-chain service provider can run sidechain- aided state channel: {s, where the sidechain state, the single block proposer (the o|-chain service provider), the fraud bond and represents the finality timeout. each node can send sidechain transactions every other node the channel update the latest state. just like any sidechain transactions, node will not only sign this transaction but also sign another transaction prove that has seen this transaction included the block created the second signed transaction can used proof for node long participants have block data fully available, the finality this sidechain transaction can confirmed quickly well. this sidechain-aided channel model comes with the following expected benefits when compared previously mentioned channel models. on-chain transaction and online presence needed for the receiver. this natural benefit inherited from sidechain properties. the reason that the receiver can redeem their fund received the sidechain-aided channel without actually performing any sidechain deposit themselves. per-party fund lock-up. this benefit the context payment channels. when side-chain based channels are used for multi-party payment, each party does not need lock their deposit advance before they pay each other (except for the block proposer who needs deposit fraud-proof bond). however, the ecosystem should clearly aware the downsides this channel model the following: fraud proof bond still needed. the case sidechain based channels, the fraud-proof bond still needed from either the block proposer directly whoever providing auditing and insurance services. should clearly understood that the worst-case liquidity requirement for the block proposer (i.e., the o|-chain service provider) actually unbounded. the reason that with enough colluding, malicious party can create unbounded repeated spending. data availability issue may complicate finality. even malicious parties are involved, the inherent finality delay for sidechain model still haunts this channel model, especially when data availability becomes issue. when the block data not always available among relevant parties, the sidechain faces inevitable re-organization and therefore finality will delayed the best and the entire sidechain will abandoned the worst case. these sidechain based channels can further connected each other via the common state channels. croute: provably-optimal value transfer routing challenges state channel network routing the need for state routing (or "payment routing" the case payment channel networks) apparent: impractical establish direct state channels between every pair nodes due channel opening costs and deposit liquidity lockup. therefore, necessary build network consisting state channels, where state transitions should relayed trust-free manner. the design state routing crucial for the level scalability that state channel network can provide, i.e., how fast and how many transactions can flow given network. however, existing proposals all fall short meet the fundamental challenges imposed the unique properties state channel networks. landmark routing has been proposed one option for decentralized payment routing several payment channel networks. for example, lightning network adopts landmark routing protocol called flare []. similar algorithm also used the decentralized iou credit network silentwhispers []. the key idea landmark routing determine the shortest path from sender receiver through intermediate node, called landmark, usually well-known node with high connectivity. raiden network payment channel network) mentioned few implementation alternatives for payment routing, such tree search which distributed implementation shortest path routing. addition, since route discovery hard but crucial, nodes can provide pathfinding services for other nodes for some convenience fees raiden network. recently proposed speedymurmurs enhances the previous shortest path routing algorithms (as used lightning network and raiden network) accounting for the available balances each payment channel. specifically, speedymurmurs based time slot time slot time slot figure shortest path routing leads frequent topology changes due channel imbalance. the embedding-based routing algorithms that are commonly used networks [], which first constructs prefix tree and then assigns coordinate for each node. the forwarding each payment based the distances between the coordinate known that node and the coordinate the destination. the prefix tree and the coordinate each node will adjusted there any link that needs removed (i.e., when link runs out balance) added (i.e., when depleted link receives new funding). can observed that all the existing routing mechanisms boil down "shortest path routing with available balance consideration". traditional data networks, shortest path routing does provide reasonably good throughput and delay performance, based the assumption that network topology remains relatively stable and link capacity "stateless" (i.e., the capacity each link not a|ected past transmissions). unfortunately, such assumption longer holds for o|-chain state channel network due its "stateful" link model, i.e., the capacity (available balance) each directed link keeps changing payments through that link. note that shortest path routing does not account for channel balancing, and thus each link may quickly run out its capacity, which further leads frequent changes network topology. figure illustrates scenario which shortest path routing leads topology changes every time slot. suppose that the beginning each time slot, node node and node each initiates payment tokens node node and node respectively. under the initial channel balance distribution (time slot every pair nodes are connected bi-directional link, and each node selects direct route its destination under shortest path routing. however, this results uni-directional transfer over each channel, and thus the distribution channel balances becomes highly skewed time slot where the underlying topology counter-clockwise cycle. this new topology, shortest path routing continues make uni-directional transfers (e.g., selects route for payment b), and channel balances are pushed the other extreme, where the underlying topology completely reversed clockwise cycle (time slot the same pattern will repeat indefinitely. contrast, node takes longer route every channel will remain balanced all the time, and the network topology never changes. for any decentralized implementation shortest path routing, such frequent topology changes could lead poor performance since takes time for the algorithm converge the new topology (e.g., reconstruct the prefix tree speedymurmurs []), during which sub-optimal routes may taken. what's even worse that the network topology may change again before the algorithm converges, and thus the algorithm may never converge and achieve continually poor throughput performance. note that the recent project revive proposes explicit channel rebalancing scheme. however, revive does not account for state routing, which means that its channel rebalancing procedure not transparent the underlying routing process and requires extra out-of-band coordination. moreover, revive only works restricted class network topologies that contain cyclic structures, and does not provide any guarantee that its channel rebalancing procedure feasible general topology. comparison, propose routing algorithm that achieves transparent and optimal channel balancing during the routing process. distributed balanced routing (dbr) propose distributed balanced routing (dbr) efficient routing protocol for value transfers o|-chain state channel network. the dbr algorithm inspired the backpressure routing algorithm that was originally used wireless networks. based completely di|erent design philosophy from the traditional shortest path routing. particular, dbr does not perform any explicit path computation from source destination. instead, the routing direction guided the current network's congestion gradients. think water flowing from the top hill destination the foot the hill. the water does not need know the route its destination; all needs follow the direction gravity. the dbr algorithm uses similar design philosophy but also accounts for the stateful link model state channel networks. particular, the dbr algorithm augmented with state channel balancing ability that transparently maintains balanced transfer flows for each state channel. compared with existing routing algorithms, the proposed dbr algorithm has the following advantages: provably optimal throughput. other words, for given arrival rate value transfer requests, there exists any routing algorithm that "supports" the rate, dbr also able that. the meaning "support" will specified section ... transparent channel balancing. dbr, the channel rebalancing process naturally embedded the routing process without any additional coordination. automatically rebalances each state channel maintain balanced value transfers the long term. fully decentralized. the dbr algorithm fully decentralized algorithm where each node only needs talk its neighbors the state channel network topology. dbr also has low messaging cost the protocol. failure resilience. the dbr algorithm highly robust against failures: can quickly detect and adapt unresponsive nodes, supporting the maximum possible throughput over the remaining available nodes. privacy preserving. due its multi-path nature, the dbr algorithm naturally preserves the privacy regarding the amount transferred values, without using any additional privacy-preserving techniques (e.g., zksnark). more importantly, the dbr algorithm can seamlessly integrated with onion routing preserve anonymity for sources/destinations. the following, first introduce the state channel network model, then describe the dbr algorithm, and finally prove the performance dbr. note that for the ease exposition, restrict our attention bi-party payment channels this section, but the same ideas apply any state channel network that has value transfer requirements. ... system model our model, time discretized into slots fixed length, where the length each slot usually corresponds the physical transmission delay over one hop. suppose that there are nodes the network. for each pair nodes and pair directed links and exit there bi-directional payment channel between node and node let cij (t) the capacity link slot which corresponds the remaining balance the payment channel that can transferred from node node the beginning that slot. there total deposit constraint for each bi-directional payment channel between node and node cij (t) cji (t) bi$j (t), where bi$j (t) the total deposit bi-directional payment channel the beginning slot note that the total deposit bi$j (t) may change over time due dynamic on-chain fund deposit/withdrawal. during each slot each node receives new payment requests from outside the network, where the total amount tokens that should delivered node (k) (t) (k) also denote uij (t) the amount tokens (required delivered node sent over link slot which referred routing variable. ... protocol description before the description dbr, first introduce several important notions: debt queue, channel imbalance and congestion-plus-imbalance (cpi) weight. (debt queue). the operation dbr, each node needs maintain "debt (k) queue" for payments destined each node whose queue length (t) corresponds the amount tokens (with destination that should relayed node the next hop but have not been relayed yet the beginning slot intuitively, the length the debt queue indicator congestion over each link. the queue length evolution follows: (k) (k) (k) (k) (t) (t) uji (t) jni jni (k) uij (t) where [x]+ max{, (since queue length cannot negative) and the set neighbor nodes node the above equation simply means that slot the change queue length caused three components: new token transfer requests from (k) outside the network (i.e., (t)), tokens routed from neighbors node i.e., (k) jni uji (t), and tokens routed from node its neighbors, i.e., (k) jni uij (t). should noted that the queue length the destination node always zero, i.e., (i) (t) for each node which guarantees that every packet can eventually delivered its destination under the dbr algorithm. (channel imbalance). for each link define the channel imbalance (t) xx| parameter adjusting the importance channel balancing. intuitively, (k) the above weight the sum the di|erential backlog (t) (k) (t) for payments destined node between node and node (i.e., congestion gradient) and the channel imbalance (t) between node and node the former used reduce network congestion and improve network throughput while the latter used balance payment channels. distributed balanced routing (dbr) the following protocol locally executed each node each time slot node first exchanges the queue length information with its neighbors and calculates the cpi weights. then for each link node calculates the best payment flow transmit over that link: (k) arg max wij (t). (k- wij (k) (k- (k- (t) then uij (t) cij (t) otherwise uij (t) for any set uij (t) remark. each slot dbr essentially tries solve the following weighted-sum optimization problem: max s.t. (k) (k) uij (t)wij (t) (k) uij (t) (k) uji (t) bi$j (t), the above optimization problem also called maxweight and derived from our theoretical analysis dbr (see the next section). the aforementioned algorithm description gives approximate solution maxweight. ... throughput performance dbr analyze the throughput performance dbr, first introduce few definitions. state channel network said stable (k) (t) lim which implies that the long-term arrival rate each debt queue equals the long-term departure rate from that queue. state channel network said balanced lim (t) channel other words, for each payment channel the long-term sending rate from node node equals the sending rate from node node define (k) (k) lim the long-term average arrival rate node for payments with destination arrival rate vector (k) )i,k said supportable there exists routing algorithm that can keep the network stable and balanced under this arrival rate vector. the throughput region state channel network the set supportable arrival rate vectors. routing algorithm throughput-optimal can support any payment arrival rate vector inside the throughput region. for the ease exposition, assume that the external payment arrival process (k) {ai (t)}t stationary and has steady-state distribution, and that the total de- posit for each payment channel remains fixed, i.e., bi$j (t) bi$j for any our analysis can extended the case where the arrival process non-stationary and channel deposits are time-varying (e.g., dynamic on-chain deposit/withdraw), the expense unwieldy notations. the following theorem shows the throughput performance dbr. theorem the dbr algorithm throughput-optimal. other words, long there exists routing algorithm that can keep the payment network stable and balanced, the dbr algorithm can also achieve that. the rest ss.. below the proof theorem first introduce lemma which characterizes the throughput region for state channel network. lemma arrival rate vector (k) )i,k supportable and only there (k) exist flow variables (fij )i,j,k that satisfy the following conditions: (k) jni (k) fij (k) fji (k) fij jni (k) fij (k) (k) fji fji bi$j proof. the necessity the above conditions trivial. inequality corresponds the flow conservation requirement. violated, then the arrival rate node larger than the departure rate, and the state channel network unstable. equation corresponds the channel balance requirement. violated, then channel imbalanced. inequality corresponds the channel capacity constraint, since the sum tokens transferred over each channel cannot exceed the total channel deposit bi$j order prove the sufficiency the above conditions, construct algorithm that can stabilize and balance the state channel network when the arrival rate vector satisfies ()-(). the algorithm straightforward: each slot set the routing (k) (k) variable uij (t) fij for any clearly, under this routing algorithm every chanp (k) (k) (k) nel remains balanced each slot since uij (t) fij fji (k) uji (t). moreover, the network stable under the algorithm since the flow con- servation requirement satisfied for every node. note that each link may have (k) insufficient fund initially (i.e., cij figure instant payment throughput comparison among dbr (avg: pay.links line ments/slot), speedymurmurs (avg: stroke: payments/slot) and flare (avg: paystroke-opacity: ments/slot). .nodes circle stroke: #fff; that dbr consistently stroke-width: .px; figure channel utilization comparison among dbr, speedymurmurs and flare. higher channel utilization implies higher level channel balancing. achieves high (nearly channel utilization while the other routing algorithms only achieve less than channel utilization due the lack https://bl.ocks.org/mbostock/ channel balancing. the total token deposits all channels. for example, the total amount deposits and only them are moved slot then the overall channel utilization that slot cos: o|-chain decentralized application operating system help everyone quickly build, operate, and use scalable o|-chain decentralized applications without being hassled the additional complexities introduced o|-chain scaling, celer network innovates higher level abstraction: cos, combination application development framework (sdk) and runtime system. this section provides the high-level vision, design objectives and illustrations cos. directed acyclic graph conditionally dependent states this section, provide view our abstraction model the construct o|-chain applications, and describe how the model integrated with state channel networks. order support use cases beyond simple payments, model system o|-chain applications directed acyclic graph (dag) conditionally dependent states, where the edges represent the dependencies among them. figure dag conditionally dependent states figure illustrates the system model, where the generalized conditional payment channel the payment networks are the only contracts with on-chain states. the settlement these on-chain states depends one more conditional payment objects (e.g. conditional payment object which are completely o|-chain but on-chain enforceable. want highlight that these conditional payment objects are not only simple time hash locked transactions, but can conditioned o|-chain application contract states, such "o|-chain app figure the conditional payment objects can relayed through multiple hops just like simple unconditional payments objects. for example, payment channel can channel connecting alice and bob and payment channel can channel connecting bob and carl. let "o|-chain app o|-chain chess game alice playing with carl, and suppose alice wants express the semantic "alice will pay carl eth carl wins the game". even without direct channel between alice and carl, alice can send conditional payment carl through bob with two layers conditional locks. the first layer simple time hashed lock make sure that bob relays and resolves the payment reasonable amount time. the second layer locks the payment conditioning the result the chess game. with this two-hop relay, the conditional payment between alice and carl can settled via bob even though bob did not involve the chess game. this minimized example how dependency graph formed generalized state channels, conditional payment objects and o|-chain applications can support arbitrarily complex multi-party interactions. note that o|-chain objects not have depend only o|-chain objects. for example, alice can pay carl when the latter successfully transfers certain ens name the former. other words, the payment depends the o|-chain condition that the owner the ens name changes from carl alice. also, o|-chain payment objects not always have conditional: conditional payment object can "degenerate" into unconditional balance proof the application runs. more generally speaking, conditional dependencies are transient nature: application state updates are done via pair two topological traversals the underlying state graph. the first traversal goes the forward direction and the second one the reverse direction. the forward traversal, starting from the on-chain state-channel contracts, creates additional transient conditional dependency edges and modifies existing ones. the reverse traversal may remove existing transient conditional dependency edges, because some conditions evaluate constant true when traversing backward. o|-chain application development framework much like how modern high-level languages and operating systems abstract away the details about the underlying hardware, the complexity interacting with conditional state dependency graphs necessitates dedicated development framework. with the principle "ease use" our mind, celer network presents the cos sdk, complete toolchain solution for the creation, tracking, and resolution states o|-chain applications. hope that the sdk will accelerate the adoption the o|-chain scaling solution and the payment network provided celer network, fostering strong ecosystem. capp platform-specific code cos api smart contract cos state compiler state dependency graph figure structure decentralized application celer network (capp) general, categorize decentralized applications into two classes: simple payper-use applications and more complex multi-party applications. the pay-per-use applications include examples like the orchid protocol, where the user keeps receiving microservices (e.g. data relay) from real-world entity and streams payments through the payment network. since there need for conditional dependency other o|chain states, lean transport layer api top the routing layer, both which are provided celer network, suffice for such cases. the class multi-party applications, the general structure which illustrated figure where the idea conditional state dependency graphs really shines. the sdk defines set design patterns and common framework for developers express the conditional dependencies. plan extend the existing smart contract languages with modern software construction techniques such metaprogramming, annotation processing, and dependency injection that the dependency information can written out explicitly without being too intrusive. compiler then processes the application code, extracts the declared o|-chain objects, and generates the conditional dependency graph. the compiler detects invalid unfulfillable dependency information and generates human-readable errors assist the developer debugging. help developers reason about the dependencies even further, the sdk will able serialize the graphs into common formats such graphviz, with which they can easily visualized and presented. the sdk also provides code generator that generates set "bridge methods" for interacting with smart contracts whose code available compile time. the code generator parses the application binary interface (abi), which specifies the signature all callable functions smart contract, and generates the corresponding bridge methods platform-specific languages such java. the main advantage this approach type safety: the glue methods replicate the method signatures the functions the smart contract faithfully, providing static and robust compile-time check before dispatching the method the cos runtime for execution. o|-chain application runtime the cos runtime serves the interface between capps and the celer network transport layer. supports capps terms both network communication and local o|chain state management. the overall architecture illustrated figure capp capp capp cos vm-native bridge smart contract communicate cchannel dispute blockchain handoff state guardian network persist local storage figure cos runtime architecture the network front, the runtime handles multi-party communication during the lifecycle capp. also provides set primitives for secure multi-party computation capable supporting complex use cases such gaming. the case counter-party failure, whether fail-stop byzantine, the runtime relays disputes the on-chain state. the case the client going oine, the runtime handles availability ooading the state guardian network. when the client comes back online, the runtime synchronizes the local states with the state guardian network. name decentralized applications running celer network capps. for local o|-chain state management, the conditional state graphs synthesized the cos sdk bundled within the capp and passed the runtime for o|-chain execution. the runtime serves the infrastructure create, update, store and monitor o|-chain states locally celer network clients. tracks the internal logic the applications running top and performs the dag traversal state updates outlined also gracefully handles payment reliability issues such insufficient capacity for routing the payment. its core, the cos runtime bundles native virtual machine (vm) for running smart contracts. while intend deploy cos many platforms including desktop, web, mobile and iot devices, have adopted the ambitious design principle "write once, run anywhere". other words, enable developers write the common business logic once and run the exact same on-chain smart contract code every environment opposed having implement multiple variants the same logic. adopting this principle, aim eliminate code duplication and ensure high degree consistency across various platforms. the platform-specific part capps, such user interface (ui), can built languages most suitable each platform (eg. kotlin for android and swift for ios). the code also free use platform-specific utilities and libraries, that the look and feel capps match the respective design guidelines each platform. the cos runtime provides vm-native bridge implementations di|erent languages for the platform-specific code interact with the underlying business logic. for example, consider capp representing chess game running ios with the written swift and business logic written solidity. naturally, the layer will need query the cos for the state the game board, and will able via the solidity-swift bridge. because the code for the contract available compile time, the code generator cos sdk would have generated bridge method named chess.getboardstate, which dispatched the for the actual query. whenever possible, make use the language's foreign function interface (eg. jni) reduce the overhead calling back-and-forth between smart contracts and the native code. the developer will also able use the same debugging and profiling tools for on-chain smart contracts the o|-chain development scenario. order genuinely replicate the state changes that would have happened onchain the o|-chain environment, the progresses through the same bytecode they were executed on-chain, with the caveat few di|erences. the first major di|erence that the needs update and store the states locally instead the blockchain. achieve seamless and transparent inter-operation between the and the rest cos, will implement set apis that bridge platform-specific storage backends with the vm. the second major di|erence that opposed being always online, local can shut down unexpectedly any time due software bugs, hardware failure simply loss power. avoid corruption local states, need implement robust logging, checkpointing and committing protocol. third minor di|erence that the logic for gas metering can omitted, because the execution happens locally and does not make sense charge gas fees. the bundled needs lightweight and performant that can run well mobile and iot devices, which tend operate under tight processor power, memory capacity and battery life constraints. while currently embed lightweight ethereum cos, are researching into adopting more common bytecode formats (eg. webassembly) with the goal supporting more contract languages and other blockchains. our ultimate vision the cos vm, will apply modern techniques such ahead-of-time compilation (aot) and just-in-time compilation (jit) achieve nearnative performance o|-chain smart contract execution. instead interpreting the smart contract bytecodes like what most ethereum vms currently do, compile the bytecodes lower level intermediate representations that are closer native code. the code for certain contract available compile time (eg. contract that already deployed on-chain), perform the compilation ahead time and statically link the binary with the rest the application. for the contracts that are dynamically loaded runtime, profile them for frequently-called functions (i.e. "hot" code) and perform just-in-time compilation. believe that the combination these two techniques will bring great balance between performance and energy consumption, which are both crucial for mobile and iot devices. ceconomy: o|-chain cryptoeconomics mechanism design the native digital cryptographically-secured protocol token the celer network, (celr) major component the ecosystem the celer network, and de- signed used solely the network. celr non-refundable functional utility token which will used the platform currency the ecosystem the celer network. celr does not any way represent any shareholding, participation, right, title, interest the token vendor, the foundation, their affiliates, any other company, enterprise undertaking, nor will celr entitle token holders any promise fees, revenue, profits investment returns, and are not intended constitute securities singapore any relevant jurisdiction. celr may only utilized the celer network, and ownership celr carries rights, express implied, other than the right use celr means enable usage and interaction with the celer network. the following, introduce celer network's cryptoeconomics mechanisms, ceconomy, whose design based the principle that good cryptoeconomics model (token model) should provide additional values and enable new game-theoretical dynamics that are otherwise impossible. the following, first elaborate the fundamental tradeo|s o|-chain ecosystems (section and then demonstrate how ceconomy can bring value and enable new dynamics "balance out" those tradeo|s (section .). tradeo|s o|-chain ecosystems any o|-chain solution, while gaining scalability, also making tradeo|s. the following, describe two fundamental tradeo|s o|-chain ecosystems: scalability-liquidity tradeo|s and scalability-availability tradeo|s. ... o|-chain scalability vs. liquidity o|-chain platform gains scalability first trading network liquidity. for example, bi-party payment state channel, the two involved parties can safely send each other payments high speeds without hitting the underlying blockchain because they have deposited liquidity the on-chain bond contract the beginning. liquidity-locking this nature works fine for the end users because the end users can simply deposit their own liquidity the open channels and enjoy the scalable dapps. however, poses significant challenge for those who want operate o|-chain service providers (osps). using state channels example, osps need make deposits each channel with outgoing payment possibility. those deposits can easily aggregate astronomical amount. even though celer networks sidechain channels can significantly reduce the level liquidity requirement, each block proposer still needs deposit fraud-proof bonds proportional the level value transfer "at stake". all all, significant amount liquidity needed provide e|ective o|-chain services for global blockchain users. however, whales may not have the business interest technical capability run o|-chain service infrastructure, while people who have the technical capability running reliable and scalable o|-chain service often not have enough capital for channel deposits fraud-proof bonds. such mismatch creates huge hurdle for the mass adoption and technical evolution o|-chain platforms. not mitigated, eventually only the rich can serve osps. this high capital barrier becoming osp will result centralized network that providing undermines the entire premise blockchain's decentralization vision. from more practical view, censorship, poor service quality and privacy breach will hurt users today's centralized services do. ... o|-chain scalability vs. availability while o|-chain platform improves scalability bringing application states o|chain, imposes impractical "always online" responsibility the users, because the o|-chain states should always available for on-chain disputes. for example, biparty payment state channel, one party goes oine, the counterparty may get hacked act maliciously, and try settle old but more favorable state for himself. the data availability issue even more critical sidechain channel where block proposers need independently monitored and validated while the participants are oine; this matter security and should scrutinized carefully. this challenge even more critical machine machine communication scenarios where iot devices are not likely online all the time. therefore, crucial design proper mechanisms that guarantee data availability o|-chain platform. solving this challenge requires systematic thinking the entire o|-chain ecosystem and existing solutions all fail provide the important properties decentralization, efficiency, simplicity, flexibility, and security will discuss more the following section. figure relationship among ceconomy components. ceconomy design balance the above-mentioned tradeo|s, propose suite cryptoeconomics mechanisms called ceconomy that includes three tightly interconnected components: proof liquidity commitment (polc) mining, liquidity backing auction (liba) and state guardian network (sgn). the relationship among the three components illustrated figure before moving the details these components, first introduce several terms that will used throughout this section. specifically, user our ceconomy system may play any the three roles: o|-chain service provider (osp), end users (eu), network liquidity backer (nlb) and state guardians (sg). o|-chain service providers (osp) are entities who have the technical capability run highly redundant, scalable and secure o|-chain infrastructures. end users (eu) can access the o|-chain services provided osp (e.g., pay and receive cryptocurrency). they can common consumers they can iot devices, vpn providers, live video streaming providers and cdn providers, counterparties machine machine (mm) systems, even o|-chain/on-chain smart contract. network liquidity backers (nlb) are entities that lock their liquidity the system support the operations o|-chain infrastructure. state guardians are those who provide eus decentralized, secure, flexible and efficient state guarding service through state guardian network. ... proof liquidity commitment (polc) mining our first goal balance out the scalability-liquidity tradeo| lowering the liquidity barrier for technically capable parties become o|-chain service providers and thus creating efficient and competitive market for good and reliable o|-chain services. the gist the idea enable service providers tap into large amounts liquidity whenever they need to. the first part realize this idea provision abundant and stable liquidity pool that can smooth out short-term liquidity supply fluctuation. that end, propose the proof liquidity commitment (polc) virtual mining process. from high level, the polc mining process incentivize network liquidity backers (nlb) lock their liquidity (which can the form digital assets, including but not limited cryptocurrencies and celr) celer network for long time rewarding them with celr tokens and therefore establishing stable and abundant liquidity pool. more specifically, the mining process involves nlbs commit (lock) their idle liquidity (for example, eth) "dumb box", called collateral commitment contract (ccc), for certain period time. during this period time when the digital assets are locked, the nlb's assets can only used the liquidity backing process and nothing else. more formally, the polc mining process can defined the following. definition (polc power). nlb locks amount local cryptocurrency blockchain (e.g. eth) for time, its polc power computed definition (polc incentive mechanism). for limited period time, celer network intends provide incentives the form celr nlbs who lock their ccc show support for the system. incentives will distributed proportional each nlb's polc power. let denote the incentives one has: where the total reward for the current block. note that locking liquidity ccc does not carry any inherent counterparty risk simply shows liquidity commitment celer network. also, note that early unlocking ccc not allowed. one may try create "spoofed liquidation" with appearance one's ccc getting liquefied due "hacking" faked osp. prevent this spoofing, the newly mined celr not available for withdrawal and usage until ccc unlocks. any early liquidation will cause the already mined ccc forfeited and redistributed other miners. the construct common denominator liquidity polc also important question. for the initial launch the platform, will use the native currency the target blockchain and later use more heterogeneous crypto assets through external price oracles. with these mechanisms place, the polc mining process ensures that the polc power the system will grow the system and utility the celr grows, forming positive loop. this point, one may wonder why celr valuable that can act such incentive? explain that the following sections describing liquidity backing auction and state guardian networks. ... liquidity backing auction (liba) the second part for solving the liquidity puzzle enable way for o|-chain service providers access liquidity pool globally, which achieved via the liquidity backing auction (liba). liba enables o|-chain service providers solicit liquidity through "crowd lending". essence, o|-chain service provider starts liba celer network "borrow" certain amount liquidity for certain amount time. interested liquidity backer can submit bid that contains the interest rate o|ered, amount liquidity and the amount celr that she willing stake for the said period time. the amount liquidity can submitted via ccc. that is, ccc has the functionality act liquidity backing asset. the borrowed liquidity will used fraud-proof bond outgoing channel deposit. liba generalized multi-attribute vickrey-clarke-groves (sealed-bid secondscore) auction. start auction process, osp creates standard liba contract through the celer network's central liba registry with information regarding the total amount requested liquidity (q), duration the request (d) and the highest interest rate (rmax that can accept. nlbs who watch the registry will notice this new liba contract and can start the bidding process. celer network requires all crypto assets locked ccc for the bidding process. note that ccc can "lock-free" and simply used backing asset without the functionality polc mining. ccc acts container for crypto assets and provides unified verifiable value heterogeneous crypto assets. moreover, the use ccc makes easier for nlbs participate liba without moving crypto assets around every time they bid and thus simplifies the backing process and improve security. nlb submits the bid the form tuple (ri where interest rate, the total amount celr willing lock during the contract time and the aggregate currency value contained the set cccs bonded with this bid. once the bid submitted, the corresponding cccs are temporarily frozen. after sealed bidding, the liba contract uses reverse second-score auction determine winning bids with the following three steps. (scoring rule). for each bid (ri the bid set ..., with its score calculated the following: s(bi fmax rmax where fmax max{f ..., and rmax max{r ..., and are weights for the two components and are initially ensure take into account interest rate with higher weight and then take into account the amount staked celr. (winner determination). determine who has the opportunity become the network liquidity backer, the liba contract sorts the bids descending order their scores. the sorted bid set denoted {b- ..., b-n where s(b- s(b- *** where s(b-n (ties are broken randomly). winners are the first bids and since and can fill the entire request, they are selected winners. should noted that even though and have the same interest rate (%) and provide the same amount liquidity eth), bidder selected winner while bidder loses; this due the fact that their committed celr tokens, symbol their contributions this platform, are significantly di|erent. finally, according the second-score staking rule, and lock (or consume) their celr tokens match the score for days. after the auction process finishes, the osp who initiated the liquidity request pays the interests the wining liquidity backers depositing into the liba contract. upon receiving the payment interests, the liba contract then gives the interests the corresponding liquidity backers and issues backed ceths (using eth example) that match the liquidity request amount. although ceth essentially iou, brings risk the user these ious are insured the network liquidity backers the liba contract. normal cases, the liba contract resolved before the timeout when the osp sends back all the ceth tokens. basically, before the timeout, the osp will settle all paid ceths eus with real eths withdrawing from upstream channels collectively. the case where the osp may get hacked, celer network's trust model can vary. the simplest trust model without any protocol-level overhead reputation-driven, where nlbs choose reputable osp without any history default. this simple model, nlbs are exposed the risk losing funds and assets their cccs are insurances for the eus the osp defaults. however, arguable that even this simple trust model, operating highly reliable and reputable osp possible; very unlikely that all backings will lost. there are additional security features which may added around liba further alleviate the potential risk. for example, newly issued ceths are only allowed deposited whitelist state channel contracts; ceths are only allowed used incrementally with upper bound spending speed. there are also lot things osp can maintain secure infrastructure such compartmentalized multi-node deployment, formal verification security access rule network infrastructure and more. addition, enable enhanced security model where randomly selected quorum nlb will need co-sign osp's operations (e.g. payment). these nlbs will only allow outgoing transfer and only they see incoming transaction with matching amount. these nlbs are also tethered the incoming payments osp. osp fails make the repayment eventually, nlbs will have the first-priority right claim the incoming funds osp from other channels. however, note that this operation model will inevitably tradeo| some efficiency the network. having said these, believe the ultimate balance the trust model should defined the market demand. open both trust model for the market organically evolve. envision that the trust-free model will more favorable the early days network launch and then will become more trust-based. regardless the liba's trust model, want highlight that the liba process ensures that end users never take any security risk the required liquidity "insured" the liba contract. celer network's system, strive make sure that the benevolent end users not need worry about the security their received fund and liba achieves that. polc and liba together incentivize abundant liquidity pool, lower the barrier becoming o|-chain service provider, reduce centralization risk, and accelerate network adoption. ... state guardian network another usage celr provide o|-chain data availability with novel insurance model and simple interactions, which balances out the scalability-availability tradeo|s mentioned section ... from the surface, the availability problem seems easy one solve. one possible answer that question might be: let's build some monitoring services the future and people will pay for these monitoring services when themselves are not online. feels like reasonable solution first look, but drive this train thought just little bit forward, will immediately see track-wrecking flaws. let's start with this question: are these monitoring services trust-based? the answer yes, then creates another centralized choking point, single point failure and just not secure. malicious counterparty can easily bribe these monitoring services hurt benevolent end users. can construct monitoring service that trust-free? for example, may punish the monitoring service providers they fail defend the states for the users. however, when delving into this idea, immediately see some caveats that render this approach impractical. how much penalty should monitoring service providers pay? ignoring the frictions, the total penalty bond for monitoring service providers should equal the largest potential loss incurred the party that went oine. this e|ectively doubles the liquidity requirement for o|-chain network because whenever someone goes oine, addition the existing locked liquidity channels fraud-proof bond sidechains, monitoring service providers also need lock the same amount liquidity penalty deposits. worse, the monitoring service providers need retain di|erent assets for di|erent monitoring tasks and things can get really complicated when the involved states are complex and multiple assets classes are play. sometimes, there not even straightforward translation from state the underlying value, given all the complex state dependency for generalized state channels. even there enough liquidity, the "insurance" model here really rigid: basically saying that you get back once the monitoring service providers fail defend your states. you choose large value can become really expensive due the additional liquidity locking, but you choose small value can become really insecure. top these disadvantages, unclear how the price state monitoring services should determined market information still segregated with low efficiency. this low efficiency and the per-party bond heterogeneous assets will further cause complicated on-chain and o|-chain interactions with monitoring services and smash the usability any o|-chain platform. there are more issues, but above are already bad enough. solve these issues, propose state guardian network (sgn). state guardian network special compact side chain guard o|-chain states when users are oine. celr token holders can stake their celr into sgn and become state guardians. before user goes oine, she can submit her state sgn with certain fee and ask the guardians guard her state for certain period time. number guardians are then randomly selected responsible for this state based state hash and the "responsibility score". the detailed rules for selecting the guardians are follows. (state guarding request). state guarding request tuple (si where the state that should guarded, the amount service fee paid guardians and the duration for which this state should guarded. (responsibility score). the responsibility score state guarding request calculated as: user's responsibility score essentially the income flow generated this user the sgn. (number guardian stakes). given set outstanding state guarding request the number celr stake for each request where the total number celr stakes that guardians stake the sgn. other words, the amount responsible celr staked proportional the ratio between this requests responsibility score the sum all outstanding states responsibility scores. (assignment guardian stakes). given state guarding request let the hash value for the corresponding state (e.g., keccak hash). each celr stake associated with (which also hash value). let the distance between two hash values and (e.g., the distance measure used chord dht []). then celr stakes are sorted ascending order their distance the hash value suppose that (pk (ties are broken randomly). the first celr stakes that have the smallest distance are selected, and the corresponding stake owner will become the state guardian for this request. (state guarding service fee distribution). for each state guarding request (si the attached service fee distributed state guardians according the following rule. for each state guardian let the amount his/her staked celr that were selected for this state guarding request. then the service fee that guardian gets from state guarding request note that each staked celr has the same probability being selected for state guarding request. result, from the view sg, the more celr staked sgn, the more such sg's stakes will selected expectation (i.e., the value will larger), thus the amount service fees that will receive will increase. that a|ords celr significant value membership the sgn. (security and collusion resistance). each guardian assigned dispute slot based the settlement timeout. the guardian fails dispute its slot when ought to, subsequent guardians can report the event and get the failed guardian's celr stake. result, long least one the selected guardians are not corrupted and fulfills the job, end user's state always safe and available for dispute. the sgn mechanism also brings the following additional values. does not require significant liquidity lock-up for guardians. guardians are only staking their celr which can used guard arbitrary states regardless the type/amount the underlying value/tokens. provides unified interface for arbitrary state monitoring. regardless whether the state related eth, any erc tokens complicated states, the users would just attach fee and send sgn. sgn does not care about the underlying states and involved value, and simply allocates the amount celr proportional the fee paid responsible for the state. enables simple interactions. users celer network not need contact individual guardians and they only need submit states this sidechain. most importantly, enables entirely new and flexible state guarding economic dynamics. instead forcing the rigid and opaque "get back" model, sgn brings users novel mechanism "get money back period time" and efficient pricing mechanism for that fluid insurance model. all guardians stake fail dispute for user, she will get the celr stakes from these guardians compensation. steady state, celr tokens that are staked the sgn represent incoming flow (e.g., earning dai/second). ignoring the cost state monitoring and other frictions, when user submits the state sgn, she can choose explicitly how much celr "covering" for her state choosing fees paid per second (i.e., the responsibility score). ... summary thinking systematically, ceconomy covers the full life-cycle o|-chain platform. liba and polc mining are about bringing intermediary transactions o|-chain low-barrier fashion. sgn about securing the capability bring most up-to-date states back on-chain when needed. such, believe ceconomy the first comprehensive o|-chain platform cryptoeconomics that brings new value and enables otherwise impossible dynamics. conclusion celer network coherent technology and economic architecture that brings internetlevel scalability existing and future blockchains. horizontally scalable, trustfree, decentralized and privacy-preserving. encompasses layered architecture with significant technical innovations each layer. addition, celer network proposes principled o|-chain cryptoeconomics design balance tradeo|s made achieve scalability. celer network mission fully unleash the power blockchain and revolutionize how decentralized applications are built and used. founding team dr. dong received his ph.d. from uiuc. his research focuses learning based networking protocol design, distributed systems, formal verification and game theory. dr. dong led project revolutionizing internet tcp and improved cross-continental data transfer speed with non-regret learning algorithms. his work was published top conferences, won internet innovative application award and being adopted major internet content and service providers. dr. dong was founding engineer and product manager veriflow, startup specializes network formal verification. the formal verification algorithms developed protecting networking security for fortune companies. dr. dong also experienced applying algorithmic game theory, especially auction theory, computer system protocol designs. has been teaching full-stack smart contract courses. produces technical blogs and videos blockchain with over subscribers. dr. junda liu received his ph.d. from berkeley, advised prof. scott shenker. was the first propose and develop dag based routing achieve nanosecond network recovery improvement over state art). dr. liu joined google apply his pioneer research googles global infrastructure. the tech lead, developed dynamic datacenter topology capable terabit/s bisection bandwidth and interconnecting more than million nodes. dr. liu became founding member project (googles innovative mobile service). was the tech lead for seamless carrier switching, and oversaw from concept $m+/year business within years. was also the android tech lead for carrier services, which run more than devices. dr. liu holds patents and published numerous papers top conferences. received and from tsinghua university. dr. xiaozhou received his ph.d. from princeton university and broadly interested distributed systems, networking, storage, and data management research. publishes top venues including sosp, nsdi, fast, sigmod, eurosys, conext, and won the nsdi' best paper award for building distributed coordination service with multi-billion qps throughput and ten microseconds latency. xiaozhou specializes developing scalable algorithms and protocols that achieve high performance low cost, some which have become core components widely deployed systems such google tensorflow machine learning platform and intel dpdk packet processing framework. xiaozhou worked barefoot networks, startup company designing the worlds fastest and most programmable networks, where led several groundbreaking projects, drove technical engagement with key customers, and filed six u.s. patents. dr. qingkai liang received his ph.d. degree from mit the field distributed systems, specializing optimal network control algorithms adversarial environments. first-authored over top-tier papers and invented high-performance and highly-robust adversarial resistant routing algorithms that have been successfully applied the industry such raytheon bbn technologies and bell labs. was the recipient best paper nominee ieee mascots and best-in-session presentation award ieee infocom and references plasma: https://plasma.io/plasma.pdf, raiden network documentation: https://raiden-network.readthedocs.io. accessed january khalil and gervais, revive: rebalancing o|-blockchain payment networks, proceedings the acm sigsac conference computer and communications security. acm, pp. malavolta, moreno-sanchez, kate, and ma|ei, silentwhispers: enforcing security and privacy credit networks, ndss, miller, bentov, kumaresan, and mccorry, sprites: payment channels that faster than lightning, corr abs/. (). available http://arxiv.org/abs/.. moreno-sanchez, kate, ma|ei, and pecina, privacy preserving payments credit networks, network and distributed security symposium. m.j. neely, modiano, and c.e. rohrs, dynamic power allocation and routing for timevarying wireless networks, ieee journal selected areas communications (), pp. pham, teich, wallenius, and wallenius, multi-attribute online reverse auctions: recent research trends, european journal operational research (), pp. poon and dryja, the bitcoin lightning network: scalable o|-chain instant payments, technical report (draft) (). prihodko, zhigulin, sahno, ostrovskiy, and osuntokun, flare: approach routing lightning network (). m.g. reed, p.f. syverson, and d.m. goldschlag, anonymous connections and onion routing, ieee journal selected areas communications (), pp. roos, beck, and strufe, anonymous addresses for efficient and resilient routing overlays, computer communications, ieee infocom -the annual ieee international conference on. ieee, pp. roos, moreno-sanchez, kate, and goldberg, settling payments fast and private: efficient decentralized routing for path-based transactions, arxiv preprint arxiv:. (). stoica, morris, liben-nowell, d.r. karger, m.f. kaashoek, dabek, and balakrishnan, chord: scalable peer-to-peer lookup protocol for internet applications, ieee/acm transactions networking (ton) (), pp. tassiulas and ephremides, stability properties constrained queueing systems and scheduling policies for maximum throughput multihop radio networks, ieee transactions automatic control (), pp. p.f. tsuchiya, the landmark hierarchy: new hierarchy for routing very large networks, acm sigcomm computer communication review, vol. acm, pp. h.r. varian and harris, the vcg auction theory and practice, american economic review (), pp. important notice this whitepaper its current form being circulated for general information and invite investor feedback only the celer network presently conceived, and subject review and revision the directors, the advisors, and/or the legal advisors the token vendor. please not replicate distribute any part this whitepaper without this note accompaniment. part this whitepaper intended create legal relations between recipient this whitepaper and the token vendor, legally binding enforceable such recipient against the token vendor. updated version this whitepaper may published date determined and announced the token vendor due course. please read this section and the following sections entitled "disclaimer liability", "no representations and warranties", "representations and warranties you", "cautionary note forward-looking statements", "third party information and consent other persons", "terms used", "no advice", "no further information update", "restrictions distribution and dissemination", "no offer investment registration" and "risks and uncertainties" carefully. you are any doubt the action you should take, you should consult your legal, financial, tax other professional advisor(s). while make every effort ensure that any material this whitepaper accurate and date, such material way constitutes the provision professional advice. the token vendor and its affiliates not guarantee, and accepts legal liability whatsoever arising from connected to, the accuracy, reliability, currency, completeness any material contained this whitepaper. participants and potential holders tokens should seek appropriate independent professional advice prior relying on, entering into any commitment transaction based on, material published this whitepaper, which material purely published for reference purposes alone. for the purposes this whitepaper, "affiliates" the token vendor mean (i) any other person directly indirectly controlling, controlled by, under common control with, the token vendor, and (ii) the foundation and any other entity developing and operating the celer network. the tokens will issued cryptographic token. the tokens are not intended constitute, and should not construed constitute, securities any form, units business trust, units collective investment scheme any other form investment any jurisdiction. this whitepaper does not constitute prospectus offer document any sort and not intended constitute offer securities any form, units business trust, units collective investment scheme any other form investment, solicitation for any form investment any jurisdiction. this whitepaper does not constitute form part any opinion any advice acquire, sell, any solicitation any offer the token vendor acquire any tokens, nor shall any part it, the fact its presentation, form the basis of, relied upon connection with, any contract investment decision. person bound enter into any contract binding legal commitment relation the acquisition tokens and cryptocurrency other form payment accepted the basis this whitepaper. any agreement between the token vendor and you participant the token sale, and relation any purchase tokens, governed separate document setting out the terms and conditions (the "token sale terms") such agreement. the event any inconsistencies between the token sale terms and this whitepaper, the former shall prevail. please note that the token vendor will not offer sell you, and you are not eligible and you are not purchase any tokens the token sale if: (a) you are citizen, domiciled in, resident of, located excluded jursidiction; (b) you are incorporated in, operate out of, excluded jursidiction; and/or (c) you are otherwise prohibited ineligible any way, whether full part, under any law applicable you from participating any part the token sale (collectively, "excluded persons"). for the purposes hereof: "excluded jurisdiction" means (i) jurisdictions with strategic anti-money laundering counter-financing terrorism deficiencies most recently identified the financial action task force (last accessed july] (ii) jurisdictions which designated individuals and entities are identified the monetary authority singapore for the purposes regulations promulgated under the monetary authority singapore act (chapter singapore, the united nations act (chapter singapore the terrorism (suppression financing) act (chapter singapore; (iii) canada; (iv) new zealand; (v) the people's republic china; (vi) the united states america; and (vii) any jurisdiction which the token sale prohibited, restricted unauthorised any form manner whether full part under the laws, requirements rules such jurisdiction. regulatory authority has examined approved any the information set out this whitepaper. such action has been will taken under the laws, regulatory requirements rules any jurisdiction. the publication, distribution dissemination this whitepaper does not imply that the applicable laws, regulatory requirements rules have been complied with. there are risks and uncertainties associated with the token vendor and its affiliates and their respective business and operations, tokens, the token sale, and the celer network. please refer the section entitled "risks and disclosures" set out this whitepaper. this whitepaper, any part thereof and any copy thereof must not taken transmitted any country where distribution dissemination this whitepaper prohibited restricted. part this whitepaper reproduced, distributed disseminated without including this section and the following sections entitled "disclaimer liability", "no representations and warranties", "representations and warranties you", "cautionary note forward-looking statements", "third party information and consent other persons", "terms used", "no advice", "no further information update", "restrictions distribution and dissemination", "no offer investment registration" and "risks and uncertainties". disclaimer liability the maximum extent permitted all applicable laws, regulations and rules, the token vendor any its affiliates shall not liable for any indirect, special, incidental, consequential other losses any kind, tort, contract otherwise (including but not limited loss revenue, income profits, and loss use data), arising out connection with any acceptance reliance this whitepaper any part thereof you any person whom you transmit any part the whitepaper (whether authorised unauthorised any the token vendor any its affiliates). representations and warranties none the token vendor its affiliates makes purports make, and hereby disclaims, any representation, warranty undertaking any form whatsoever any entity person, including any representation, warranty undertaking relation the truth, accuracy and completeness any the information set out this whitepaper. representations and warranties you accessing and/or accepting possession any information this whitepaper such part thereof (as the case may be), you represent and warrant the token vendor follows: (a) you agree and acknowledge that tokens not constitute securities any form, units business trust, units collective investment scheme any other form investment any jurisdiction; (b) you are not excluded person; (c) you are not citizen resident any jurisdiction which either the purchase of, receipt, holding tokens prohibited, restricted, curtailed, hindered, impaired otherwise adversely affected any applicable law, regulation rule; (d) none you (in the case corporation) any your subsidiaries (if any), any your directors officers nor, any your employees, agents any other person acting behalf you any your subsidiaries individual entity that, owned controlled individual entity that: (e) (i) listed the monetary authority singapore ("mas") designated individuals entities defined the respective regulations promulgated under the monetary authority singapore act (chapter singapore, the united nations act (chapter singapore the terrorism (suppression financing) act (chapter singapore such other law, regulation rule may prescribed the mas from time time; (ii) the subject sanctions administered enforced singapore, the united states america (including without limitation the u.s. department the treasury's office foreign asset control), the united kingdom great britain and northern ireland, the european union any other governmental authority (collectively, "sanctions"); (iii) located, organised resident country territory that the subject country-wide territory-wide sanctions (including, without limitation, the democratic people's republic korea, the democratic republic congo, eritea, iran, libya, somalia, south sudan, sudan, and yemen); (iv) has engaged and not now engaged any dealings transactions with any government, person, entity project targeted by, located any country territory, that the time the dealing transaction, was the subject any sanctions; (v) otherwise party with which the token vendor prohibited from dealing under laws applicable you; none of: (i) you; (ii) any person controlling controlled you; (iii) you are privately-held entity, any person having beneficial interest you; (iv) any person for whom you are acting agent nominee connection with your participation the token sale senior foreign political figure, any immediate family member close associate senior foreign political figure, such terms are defined below. "senior foreign political figure" defined senior official the executive, legislative, administrative, military judicial branch government (whether elected not), senior official major political party, senior executive foreign government-owned corporation, and includes any corporation, business other entity that has been formed by, for the benefit of, senior foreign political figure. "immediate family" senior foreign political figure typically includes such figure's parents, siblings, spouse, children and in-laws. "close associate" senior foreign political figure person who widely and publicly known maintain unusually close relationship with such senior foreign political figure, and includes person who position conduct substantial domestic and international financial transactions behalf such senior foreign political figure. (f) you are affiliated with non-u.s. banking institution ("foreign bank"), you receive deposits from, make payments behalf of, handle other financial transactions related foreign bank, you represent and warrant the token vendor that: (i) the foreign bank has fixed address, and not solely electronic address, country which the foreign bank authorised conduct banking activities; (ii) the foreign bank maintains operating records related its banking activities; (iii) the foreign bank subject inspection the banking authority that licensed the foreign bank conduct its banking activities; and (iv) the foreign bank does not provide banking services any other foreign bank that does not have physical presence any country and that not regulated affiliate; (g) you agree and acknowledge that this whitepaper does not constitute prospectus offer document any sort and not intended constitute offer securities any form, units business trust, units collective investment scheme any other form investment any jurisdiction, solicitation for any form investment, and you are not bound enter into any contract binding legal commitment, and cryptocurrency other form payment accepted, the basis this whitepaper; (h) you acknowledge and understand that tokens should construed, interpreted, classified treated enabling, according any opportunity to, token holders participate receive profits, income, other payments returns arising from connection with tokens the proceeds the token sale, receive sums paid out such profits, income, other payments returns; (i) you agree and acknowledge that regulatory authority has examined approved the information set out this whitepaper, action has been will taken under the laws, regulatory requirements rules any jurisdiction and the publication, distribution dissemination this whitepaper you does not imply that the applicable laws, regulatory requirements rules have been complied with; (j) you agree and acknowledge that this whitepaper, the undertaking and/or the completion the token sale, future trading tokens any cryptocurrency exchange, shall not construed, interpreted deemed you indication the merits the token vendor and its affiliates, the tokens, the token sale, and/or the celer network; (k) the distribution dissemination this whitepaper, any part thereof any copy thereof, acceptance the same you, not prohibited restricted the applicable laws, regulations rules your jurisdiction, and where any restrictions relation possession are applicable, you have observed and complied with all such restrictions your own expense and without liability the token vendor and/or its affiliates; (l) you agree and acknowledge that the case where you wish acquire any tokens, tokens are not construed, interpreted, classified treated as: (i) any kind currency other than cryptocurrency; (ii) debentures, stocks shares issued any person entity; (iii) rights, options derivatives respect such debentures, stocks shares; (iv) rights under contract for differences under any other contract the purpose pretended purpose which secure profit avoid loss; (v) units collective investment scheme; (vi) units business trust; (vii) derivatives units business trust; (viii) any form investment; (m) you are legally permitted participate the token sale and all actions contemplated associated with such participation, including the holding and use tokens; (n) the amounts that you use acquire tokens were not and are not directly indirectly derived from any activities that contravene the laws and regulations any jurisdiction, including anti-money laundering laws and regulations; (o) you are natural person, you are sufficient age and capacity under the applicable laws the jurisdiction which you reside and the jurisdiction which you are citizen participate the token sale; (p) you are not obtaining using tokens for any illegal purpose; (q) you have basic degree understanding the operation, functionality, usage, storage, transmission mechanisms and other material characteristics cryptocurrencies, blockchain-based software systems, cryptocurrency wallets other related token storage mechanisms, blockchain technology, and smart contract technology; (r) you are fully aware and understand that the case where you wish purchase any tokens, there are risks associated with the token vendor and its affiliates and their respective business and operations, tokens, the token sale, and celer network; (s) you bear the sole responsibility determine what tax implications purchase tokens may have for you and agree not hold the token vendor, its affiliates and/or any other person involved the token sale liable for any tax liability associated with arising therefrom; (t) you agree and acknowledge that neither the token vendor nor its affiliates are liable for any direct, indirect, special, incidental, consequential other losses any kind, tort, contract otherwise (including but not limited loss revenue, income profits, and loss use data), arising out connection with any acceptance reliance this whitepaper any part thereof you; (u) you waive the right participate class action lawsuit class wide arbitration against the token vendor, its affiliates and/or any person involved the token sale and/or with the creation and distribution tokens; and (v) all the above representations and warranties are true, complete, accurate and nonmisleading from the time your access and/or acceptance possession this whitepaper such part thereof (as the case may be). cautionary note forward-looking statements all statements contained this whitepaper, statements made press releases any place accessible the public and oral statements that may made the token vendor its directors, executive officers employees acting behalf the token vendor (as the case may be), that are not statements historical fact, constitute "forward-looking statements". some these statements can identified forward-looking terms such "aim", "target", "anticipate", "believe", "could", "estimate", "expect", "if", "intend", "may", "plan", "possible", "probable", "project", "should", "would", "will" other similar terms. however, these terms are not the exclusive means identifying forward-looking statements. all statements regarding the token vendor and/or its affiliates' business strategies, plans and prospects and the future prospects the industry which the token vendor and/or its affiliates are are forward-looking statements. these forward-looking statements, including but not limited statements the token vendor and/or its affiliates' prospects, future plans, other expected industry trends and other matters discussed this whitepaper regarding the token vendor and/or its affiliates are matters that are not historic facts, but only predictions. these forward-looking statements involve known and unknown risks, uncertainties and other factors that may cause the actual future results, performance achievements the token vendor and/or its affiliates materially different from any future results, performance achievements expected, expressed implied such forward-looking statements. these factors include, amongst others: (a) changes political, social, economic and stock cryptocurrency market conditions, and the regulatory environment the countries which the token vendor and/or its affiliates conduct their respective businesses and operations; (b) the risk that the token vendor and/or its affiliates may unable execute implement its business strategies and future plans; (c) changes interest rates and exchange rates fiat currencies and cryptocurrencies; (d) changes the anticipated growth strategies and expected internal growth the token vendor, its affiliates and/or the celer network; (e) changes the availability and fees payable the token vendor and/or its affiliates connection with their respective businesses and operations the celer network; (f) changes the availability and salaries employees who are required the token vendor and/or its affiliates operate their respective businesses and operations; (g) changes preferences users the celer network; (h) changes competitive conditions under which the token vendor and/or its affiliates operate, and the ability the token vendor and/or its affiliates compete under such conditions; (i) changes the future capital needs the token vendor and/or its affiliates and the availability financing and capital fund such needs; (j) war acts international domestic terrorism; (k) occurrences catastrophic events, natural disasters and acts god that affect the businesses and/or operations the token vendor and/or its affiliates; (l) other factors beyond the control the token vendor and/or its affiliates; and (m) any risk and uncertainties associated with the token vendor and/or its affiliates and their respective business and operations, tokens, the token sale, and the celer network. all forward-looking statements made attributable the token vendor and/or its affiliates and/or persons acting behalf the token vendor and/or its affiliates are expressly qualified their entirety such factors. given that risks and uncertainties that may cause the actual future results, performance achievements the token vendor and/or its affiliates materially different from that expected, expressed implied the forward-looking statements this whitepaper, undue reliance must not placed these statements. these forward-looking statements are applicable only the date this whitepaper. neither the token vendor and/or its affiliates nor any other person represents, warrants, and/or undertakes that the actual future results, performance achievements the token vendor and/or its affiliates will discussed those forward-looking statements. the actual results, performance achievements the token vendor and/or its affiliates may differ materially from those anticipated these forward-looking statements. nothing contained this whitepaper may relied upon promise, representation undertaking the future performance policies the token vendor and/or its affiliates. further, the token vendor and/or its affiliates disclaim any responsibility update any those forward-looking statements publicly announce any revisions those forwardlooking statements reflect future developments, events circumstances, even new information becomes available other events occur the future. third party information and consent other persons this whitepaper includes information obtained from various third party sources ("third party information"). none the publishers third party information has consented the inclusion third party information this whitepaper and therefore not liable for third party information. while reasonable action has been taken ensure that third party information has been included their proper form and context, neither the token vendor nor its directors, executive officers, and employees acting their behalf, has independently verified the accuracy, reliability, completeness the contents, ascertained any applicable underlying assumption, the relevant third party information. consequently, neither the token vendor nor their directors, executive officers and employees acting its behalf makes any representation warranty the accuracy, reliability completeness such information and shall not obliged provide any updates the same. terms used facilitate better understanding tokens being the subject the sale conducted the token vendor, and the business and operations the token vendor and/or its affiliates, certain technical terms and abbreviations, well as, certain instances, their descriptions, have been used this whitepaper. these descriptions and assigned meanings should not treated being definitive their meanings and may not correspond standard industry meanings usage. words importing the singular shall, where applicable, include the plural and vice versa and words importing the masculine gender shall, where applicable, include the feminine and neuter genders and vice versa. references persons shall include corporations. advice information this whitepaper should considered business, legal, financial tax advice regarding the token vendor and/or its affiliates, tokens, the token sale, and/or the celer network. you should consult your own legal, financial, tax other professional adviser regarding the token vendor and/or its affiliates and their respective business and operations, tokens, the token sale, and the celer network. you should aware that you may required bear the financial risk any purchase tokens for indefinite period time. none the advisors engaged has made purports make any statement the whitepaper any statement upon which statement the whitepaper based and each them makes representation regarding any statement the whitepaper and the maximum extent permitted law, expressly disclaims and takes responsibility for any liability any person which based on, arises out of, any statement, information opinions in, omission from, the whitepaper. further information update person has been authorised give any information representation not contained this whitepaper connection with the token vendor and/or its affiliates and their respective business and operations, tokens, the token sale, the celer network. given, such information representation must not relied upon having been authorised behalf the token vendor and/or its affiliates. the token sale shall not, under any circumstances, constitute continuing representation create any suggestion implication that there has been change, development reasonably likely involve material change the affairs, conditions and prospects the token vendor and/or its affiliates any statement fact information contained this whitepaper since the date hereof. restrictions distribution and dissemination the distribution dissemination this whitepaper any part thereof may prohibited restricted the laws, regulatory requirements, and rules any jurisdiction. the case where any restriction applies, you are inform yourself about, and observe, any restrictions which are applicable your possession this whitepaper such part thereof (as the case may be) your own expense and without liability the token vendor and/or its affiliates. persons whom copy this whitepaper has been distributed disseminated, provided access who otherwise have the whitepaper their possession shall not circulate any other persons, reproduce otherwise distribute this whitepaper any information contained herein for any purpose whatsoever nor permit cause the same occur. offer investment registration this whitepaper does not constitute prospectus offer document any sort and not intended constitute offer securities any form, units business trust, units collective investment scheme any other form investment, solicitation for any form investment any jurisdiction. person bound enter into any contract binding legal commitment and cryptocurrency other form payment accepted the basis this whitepaper. regulatory authority has examined approved any the information set out this whitepaper. such action has been will taken under the laws, regulatory requirements rules any jurisdiction. the publication, distribution dissemination this whitepaper does not imply that the applicable laws, regulatory requirements rules have been complied with. prevailing language the english language version this whitepaper the only official version force. there any inconsistency between this whitepaper and other translations this whitepaper, the english version this whitepaper shall prevail. you acknowledge and agree that any translation you may have reviewed which may have been made available you for your reference only and are not certified the token vendor its affiliates. names any laws and regulations, governmental authorities, institutions, natural persons other entities which have been translated into english and included this whitepaper and for which official english translation exists are unofficial translations for your reference only. risks and uncertainties prospective purchasers tokens should carefully consider and evaluate all risks and uncertainties associated with the token vendor and/or its affiliates and their respective business and operations, tokens, the token sale, and the celer network, all information set out this whitepaper and the token sale terms prior any purchase tokens. further details the risk factors relating participating the token sale and the token vendor will set out the token sale terms. any such risks and uncertainties develops into actual events, the business, financial condition, results operations and prospects the token vendor and/or its affiliates could materially and adversely affected. such cases, you may lose all part the value tokens.