technical paper contents introduction ................................................................................................................................................ the blockchain .................................................................................................................................... subsystems.......................................................................................................................... the network ................................................................................................................. the global shared state and execution layer ..................................................................... consensus layer .................................................................................................................. block execution layer .......................................................................................................... graphene trading engine ............................................................................................................ transaction types ....................................................................................................................... transaction fees ......................................................................................................................... tokens ................................................................................................................................................. dascoin ....................................................................................................................................... webeuro ..................................................................................................................................... issuance authority............................................................................................................... pegging mechanism ............................................................................................................ cycles .......................................................................................................................................... minting and issuance .......................................................................................................................... description .................................................................................................................................. licence levels ............................................................................................................................ governance ....................................................................................................................................... description .................................................................................................................................. structure ................................................................................................................................... voting nodes ..................................................................................................................... the dascoin board ............................................................................................................ chain authorities ............................................................................................................... frequency ......................................................................................................................................... description ................................................................................................................................ global frequency ...................................................................................................................... centralize vs. calculation algorithm.......................................................................................... upgrades ................................................................................................................................... age description ........................................................................................................................ current cycle implementation .................................................................................................. bonus cycles ............................................................................................................................. cycles issuance authority description ....................................................................................... nodes ................................................................................................................................................ master nodes ............................................................................................................................ ledger nodes ............................................................................................................................ node operations ....................................................................................................................... create witness operation ................................................................................................. update witness operation ................................................................................................ remove witness operation ................................................................................................ activate witness operation ................................................................................................ webwallet ........................................................................................................................................ security ..................................................................................................................................... validator ................................................................................................................................... identity management ................................................................................................................ kyc .................................................................................................................................... sample .................................................................................................................................. api ..................................................................................................................................................... websocket calls notifications ............................................................................................... requesting api access ....................................................................................................... database notifications ...................................................................................................... example session ................................................................................................................ account recovery .............................................................................................................. operations ................................................................................................................................ appendix blockchain api .............................................................................................................. database api ............................................................................................................................. account history api................................................................................................................... crypto api ................................................................................................................................. network broadcast api ............................................................................................................. network nodes api ................................................................................................................... wallet api ................................................................................................................................. appendix operations .................................................................................................................... age introduction dascoin has been designed solve the core problems inherent storing and exchanging value. the dascoin blockchain mutual distributed ledger that creates and distributes cryptographic assets, and then securely facilitates their storage and exchange. prime objective dascoin use the infrastructure digital asset system build effective network trust, enabling all participants and stake holders share common goal increasing the value the network and cultivating its growth. private, permissioned blockchain architecture has been incorporated due its enhanced security, inherent efficiency, and ability scale more easily (due deployment control). fortifying this secure foundation the authentication all users accordance with bankingstandard kyc (know your customer) requirements and the implementation "hardware required" digital wallet system. however, just like every other system value dascoin must establish few fundamental elements. these include defining: initial money supply, initial distribution, basis value, expansion/contraction mechanisms the money supply, who controls the means production, and the allocation inflation (and/or allocation credit). dascoin offers hybrid structure solve the issues associated with these economics-based elements. this technical whitepaper will depth about the technical specifications the dascoin blockchain that will establish these fundamental elements. will start with basic description the blockchain give the reader general overview. will follow with more chapters that will clarify the specific individual parts that are used the blockchain. the end will include full list api calls that are used this paper. finish off, added appendix for more detailed explanation about the api itself. age the blockchain description the dascoin blockchain distributed ledger-based payment and token exchange system that supports the base system tokens (cycles, dascoin) and enables the creation arbitrary number different asset tokens. the dascoin blockchain determines block production assigning authorized nodes (master nodes) block validators. the system relies the centralized distribution dascoin through the minting process well semi-decentralized governance mechanism which the dascoin board determines chain parameters and determines block producers from eligible candidates. the dascoin blockchain built upon the graphene toolkit, which itself the direct basis for the bitshares blockchain and indirectly for the steem and eos blockchains. the dascoin blockchain inherits the base consensus model from graphene, well the network, the execution user operations, and system wide on-block-produced actions. the main differences lie the implementation governance and dascoin distribution (minting), well the storing user states and the implementation user and administrative actions via on-chain operations. subsystems the dascoin blockchain can seen union subsystems which handle the tasks facilitating communication between nodes the system, executing user and block operations, updating the global shared state, and maintaining the ledger confirmed transaction updates. the network the node network the base layer the dascoin blockchain. part the graphene toolkit. the network responsible for handling connections between nodes and user endpoints (wallet instances) through websockets, well relaying messages between nodes. upon receiving messages from client endpoint, the network layer handles unmarshalling the message and passes off the operations layer. the network layer also marshals the response back the client (if any) regarding the success the state update, query interaction. the network layer also handles the connections between nodes. the nodes not have discovery protocol, relying instead preconfigured addresses. the network layer maintains the gossip state update protocol. each node broadcasts relevant messages such valid transactions and created blocks all known nodes. left the consensus mechanism and the global shared state fto handle deduplication updates. the global shared state and execution layer the global shared state in-memory database all relevant user and system data objects. part the graphene toolkit. all nodes have the entire copy the global shared state. all objects have unique identifier based three-number system (denoting domain, type and in-order number instantiation). all object types can accessed via generalized object api, while more specific formatting apis handle client needs. age the global shared state features transaction rollback mechanism, necessary for establishing consensus. the rollback mechanism can detect and roll back the state case dominant block history emerging, maximum defined divergence point. this most commonly manifested block updates, where pending transaction state discarded and replaced with the result the confirmed transactions the blocks. the execution layer verifies and executes user-initiated operations. the operations received from the network layer are first checked for the presence correct signatures. operation validly signed, then first validated for checks independent the current state (ie. for sending negative balance transfer). the operation properly signed and valid independent the current state, then checked against relevant objects the state (ie. transfer would check the from account balance sufficient). once the operation fully verified, the state locked, and the operation executed the current state, performing state transition. this multi-step validation system ensures early fail invalid transactions and lowers the time execution. operations can additionally bundled into transactions, with similar functionality database management systems. executed transactions are sent the network layer rebroadcast all nodes. the execution layer also features deduplication mechanism, making sure that two the same transaction cannot executed. executed transactions (and thus operations) are placed pending state. they are verified and executed but have not been confirmed consensus. the state the node always matches the last transaction executed, regardless its confirmed state. once block update received, checked for signatures and whether matches the block production schedule (is signed the right block producer the right time). that the case, the transactions are rolled back the last joining point the next block the blockchain. unless there chain split, this usually the last block. the transactions from the block update are then executed order and new confirmed state formed. consensus layer the consensus layer ensures byzantine fault tolerance the guarantee that the entire network can converge globally shared state. also updates the local copy the block ledger well maintains the set execution rules and platform rules. the consensus layer modified graphene implementation. dascoin blockchain consensus based known set validators, which are nodes that have authorized block signing private key. block signed with the correct master key properly signed. the block producers are added the list active block producers the dascoin board, through signing the appropriate operation. the board also has the privilege remove master node from the block producer list. the block production algorithm proceeds rounds. each block producer shuffled into schedule which valid for single round. each block producer given time slot based their respective position within the schedule. each slot the length unit block time (initially set seconds). the duty the block producer collate all user transactions, verify and execute them, produce signed block and send through the network. the nodes actively listen block updates. block update received node the network, and properly signed, checked against the schedule. the block producer not scheduled produce block that moment time, the block rejected. this ensures that all block producers have chance produce block, thus distributing trust age through the network, while the same time maintaining fast and predictable speed confirmed transactions. block execution layer certain system wide actions can attached the predictable rhythm producing blocks. each node executes certain system defined code when block produced. this can also set multiple number blocks (every block, for example, corresponds currently each minute). this enables actions that are time based, with the maximum resolution the block time (currently seconds). the process minting dascoin, parts trade engine operation, well cleanup unused memory implemented this layer. the system also periodically reserves time (currently each day) for system wide maintenance interval during which block production stalled. this allow all nodes compute resource intensive changes state parallel execution available. all changes that require reading writing large part the state (such upgrades) are relegated this interval. graphene trading engine the decentralized exchange (dex) built top the consensus and operations layer the blockchain. it's native application feature that does not rely user defined code execution, all functionality built the node software itself. the dex and trading engine are both parts the graphene toolkit. the dex allows users create limit orders trade different assets the dascoin blockchain. the present moment, the exchange supports the trade dascoin (dasc) and webeuro (weur) assets. when user creates trade, placed market. the market tracks all open and filled orders for certain trading pair and tracks the last price and volume. there are two markets defined (dasc:weur and weur:dasc), but the dex supports arbitrary number markets (as well assets). any order matched the engine the criteria best price and time creation once fitting order created the dex. the orders can partially filled, with the remainder remaining open position. user also has the option create fill-or-kill order that must matched creation. users may also cancel open orders any time. the dex enabled user signed operations that create and cancel limit orders. the user must properly sign valid create limit order operation order create limit order. the operation considered valid the user has enough funds create the order. once the operation executed, the trading engine will attempt match the order. this not tied block creation the consensus mechanism confirming transactions. the trading engine will proceed search all limit orders for given market pair sorted price ratio and time creation. match made, and the order fully filled, the trading engine will exchange the assets between trading accounts, swapping the appropriate amounts tokens complete the trade. the order partially matched, not matched, unique order object created the global share state, and the user notified its id. this unique order object contains the information about the amount and type tokens sell, well the minimal amount receive. the values are equal the original values input the user the create limit order operation the order was not filled, they are adjusted match the partial filling the order match has happened, but age the order was not fully filled. this object persists the state until either filled entirely another created limit order cancelled the user. the user may cancel open limit order properly signing valid cancel limit order operation. the operation valid contains existing limit order object and signed the creator the object (and the limit order itself). important thing note that trades are executed immediately, regardless confirmation. achieve additional confidence, the user may wish wait for confirmed limit order appear, meaning only such order that was confirmed block, and then trade accordance with the confirmed order. block types explained the description section this document, the dascoin blockchain contains mechanism for executing system code when block being produced. this mechanism used minting blocks, which are blocks designated distribute dascoin the way the minting queue. blocks may also designated perform staking rewards and execute delayed user code. for more information about these operations see appendix: operations. transaction types explained the description section this document, the dascoin blockchain based user signed operations that modify the global shared state. all operations are bundled into transactions such way that all operations transaction must pass order they all fail and are rolled back. each transaction thus must contain least one operation. operations can divided between authority and user operations. authority operations must signed named authority and are responsible for governing the chain and handling actions that require trust. good example would choosing block producers (handled root authority) and issuing licenses (handled license authority). both these actions require oracle input from outside the chain, and such must signed trusted authorities. user operations can signed any user. they are actions that manipulate user state (such token balance, open trade orders, etc.). user operations are valid only the bounds user state (and thus must properly signed). for more information and list all operations see appendix operations. transaction fees almost all exchanges and digital wallets charge fee for all conducted transactions. and almost all cases, this fee calculated the currency you are trading and comes the form percentage the amount being traded. however, since the cryptocurrency market volatile, and the price coin can rise fall drastically short period time, the actual fee user pays depends the current value the coin they are trading. avoid this kind volatility, instead charging fees dascoin, will instead using cycles the heart the dascoin platform for our transaction fees. any transaction user conducts, regardless the amount they are sending, will always cost only one cycle. user uses all their cycles, they'll always able purchase more. the last dascoin user's account always reserved for the purchase cycles, they can never get into situation when they have neither cycles nor dascoin with which purchase them. age tokens dascoin dascoin hybrid currency designed combine the best qualities decentralized cryptocurrencies with the best aspects centralized currencies and eliminate their respective weaknesses. dascoin the convertible "store value" unit that serves the foundation the digital asset system. dascoin our main crypto asset, and previously described, customers acquire dascoin through licenses and minting. webeuro webeuro cryptographic asset defined the dascoin blockchain that represents the euro denomination. issuance authority issuance authority that responsible for webeuro called issue_webasset, you can find more details about this operation the appendix section. pegging mechanism mentioned before, webeuro equivalent fiat currency euro, its value has fixed exchange rate. you earn webeuro through trading dascoin the internal market through netleaders commission bonuses. customers can cash out their webeuros into the same amount euros manually through our netleaders platform. cycles cycles are cryptographic asset defined the dascoin blockchain. cycles represent stored capacity within dasnet and can used either for paying fees the dascoin blockchain, for paying network services, they can submitted the minting queue exchanged for dascoins. cycle indivisible asset, meaning that cannot have half cycle, quarter. cycles can only acquired through the purchase system license using either bitcoin euros can bought for dascoin order buy fees the dascoin blockchain. internally, cycles are represented asset, equal webeuro dascoin, but they cannot traded the exchange nor can they transferred from one wallet another. they can still transferred from license vault which has been tethered wallet. periodically, accordance with predetermined upgrade interval, all cycle balances will experience upgrade and those balances the accounts will double. cycles are already the dascoin minting queue, these cycles will unaffected (unless they are associated with account that has frequency lock). age minting and issuance description the process producing and distributing new dascoins known minting. minting allows person entity store value the form dascoin. order obtain dascoins people can submit cycles the network and then assigned place the dascoin minting queue. the minting queue functions first-in-first-out basis. dascoins are distributed the account that next line the distribution queue. each dascoin distribution interval specific amount dascoins are distributed participants the queue. the amount dascoins user receives regulated adjustable conversion factor called frequency. dascoin distribution functions such way that the amount cycles submitted divided the frequency, equals the number dascoins that will distributed that person. cycles are deducted the time submission the "minting queue", and the time distribution the dascoins are automatically transferred the account the blockchain software. the total amount dascoins that can minted capped power there are parties (neither executives nor developers) who are able pre-mint, pre-mine predistribute dascoins themselves. cycles can only received exchange for value transferred the system, and cycles must submitted the system for there direct distribution dascoins through the minting process. for customer mint dascoin, they need have cycles. cycles are resource defined the dascoin blockchain. they can only acquired through the purchase system license (netleaders) using either bitcoin euros. they can either used for network services submitted exchange for dascoins. cycles can only received exchange for value transferred the system, and user must submit them the system order acquire dascoins through the minting process. age depending the conversion factor (frequency), customer will receive certain amount dascoins the end the minting process. frequency the conversion factor used the minting process cycles dascoins. the value the cycles you have the blockchain secured the distributed ledger. the precise amounts are encoded the blockchain state and are currently fixed. the only way change the base amount cycles license provides vote involving all committed shareholders (of dascoin), either through direct vote through delegates. the blockchain has called minting queue that has the following elements: amount cycles the number cycles that where submitted customers the queue frequency value determined the license from which user submits cycles user unique account identifier customer can submit certain number cycles from license the minting queue. the minting mechanism has two elements that determine how the queue processed. the moment time that the queue processed called dascoin reward event. during one dascoin reward event there only certain amount dascoins that can produced and distributed. reward interval the time interval between each dascoin reward event reward amount the amount coins that will produced and distributed during the dascoin reward event for example, pro license has higher number cycles than standard license, take smaller amount cycles from the standard license and larger amount from the pro. when dascoin are minted, redistribute the larger portion the client who owned the pro license and the smaller portion the client who owned the standard. your cycles will begin converted dascoin and added your wallet when your license tapped for cycles (which happens chronologically based when your license was purchased i.e. clients who purchased licenses before you did will have their cycles submitted before you will). more your cycles are used, they will, eventually, reach the determined amount dascoin that your license supposed receive. however, this not 'immediate' thing. process that accumulates over time. upon license purchase cycles are migrated the webwallet vault and the cycles from the vault are submitted the minting queue with certain frequency lock. calculate the amount dascoin you would receive from your initial submission, you would divide the amount cycles (c) associated with your license level the frequency lock (fl) given time license activation. when upgrade period reached, this time, the amount cycles that have, thus far, been submitted the dasnet system are matched netleaders and the resulting amount cycles are resubmitted the dasnet system for minting. licence levels previously mentioned, participate the minting dascoin, customer needs acquire netleaders license. license provides the customer with three things: authentication: customers identity will verified. authorization: the customer will receive license certificate and will able generate the keys webwallet that will provide them access dasnet. capacity: the customer will receive cycles units network capacity dasnet. depending the level their license, customer will receive certain amount cycles that she can use mint dascoins. there are currently types licenses: license name number cycles bonus cycles network upgrades price standard eur manager eur pro eur executive eur vicepresident eur president eur frequency visit our website see the current frequency this something that can subjected change, you can see more details about licenses and our marketing incentives through our netleaders platform here: https://netleaders.com/en/products governance dascoin governed elected individuals and businesses. the so-called committee set many individuals), can change blockchain parameters such block size, block confirmation time and others. most importantly, though, they deal with the business plan the blockchain and tweak costs and revenue streams (mainly transaction fees). fortunately, the shareholders have the final say approve the executive committee. hence, see businesses competing for seats the committee define blockchain parameters. business ideas requires certain blockchain parameters particular set fees profitable, there are several options: argue with shareholders approve committee members that vote their favour get elected committee member showing that the business worth being available that particular chain deploy the innovative business and have the shareholders approve the upgrade structure voting nodes voting nodes are non-authoritative influencers the dascoin blockchain. these nodes not control any the daily functions the dascoin system, but fully control who sits the dascoin board and what proposals are passed within the system. voting nodes represent significant stakeholders who have demonstrated that they have long-term view dascoin, and therefore are given the privilege influence over chain governance. any qualified voting node can initiate proposal. the dascoin board responsible for organizing and presenting the proposals the voting node population. there also mechanism within the voting system that allows the voting nodes directly present referendum their membership without going through the board review process (to prevent the board from withholding certain proposal from the voting nodes). the dascoin board the dascoin blockchain enables governing board regulate the parameters the network. the dascoin board will comprised members elected the voting nodes. the role the board to: propose and modify chain parameters support the normal functioning and growth the network delegate certain executive roles certain chain executives (such issuing licenses and authenticating said licenses) act check the power said executives having the ability terminate their access the network. the board itself has control the state the database the construction the dascoin blockchain and programmatically prevented from making any changes it. since the network itself manages and maintains the state and the transaction ledger, the only way make any undesired change subvert the majority master nodes. the board designed consist individual directors, each whom bestowed with full voting privileges. generally, each director serves for year term, though initial directors will serving staggered terms (of years) ensure continuity experience. minimum directors are required for the governance the dascoin ecosystem, and many may serve the board. addition, there ombudsman member the board, who does not vote and does not hold any responsibilities within the board, but who attends all board meetings and provides degree independence and transparency the board's governance process. finally, there executive director who works for the board and responsible for ensuring that all its decisions and initiatives are enacted and enforced. the executive director attends all board meetings but not permitted vote. the executive director responsible for directly overseeing all chain authorities chain authorities chain authority roles exist handle smooth inputs the blockchain user data that exists outside the system. the problem with fully decentralized systems the fact that they cannot have reliable inputs: for example, bitcoin created internally the bitcoin blockchain and merely transferred around. order for proof value work, there must certainty that the user actually bringing value the network. value cannot exist without independent observer and the only way verify that the user has submitted value the system maintain impartial observer. each authority role set such way that: there way for the authority make meaningful unwanted impact the state the network the network can fall back failsafe state. the actions the authority are checked separate authentication authority and there are programed measures assure there minimal chance collusion. there are incentives perform the best interest the network. any malicious action the chain authority transparent and will lead that account being marked untrustworthy, shut off from the network and penalized. ... dascoin board the board sets the procedures and ensures the proper execution the following: the level the frequency each -week interval. the process involves the board selecting which range algorithms best reflects the current growth state the network. the primary factors considered include: overall amount cycles the system amount cycles authorized the most recent -week period velocity cycle growth previous periods, and projected cycle growth within the system. the size the minting blocks the start each upgrade interval the size the super blocks and treasury blocks the proposals submitted the voting nodes, the use funds from treasury blocks the authorization master nodes and ledger nodes within the dasnet infrastructure intervention times crisis, and other elements the executive director oversees the performance all chain authorities and kyc functions, manages the flow proposals for the board consider, facilitates referendums the proper thresholds have been surpassed, responsible for enforcing all board initiatives and decisions, and fully accountable the board for all operations within the system. chain authorities oversee the issuance and authentication licenses and webeuros, under the supervision the executive director. upgrades automatically occur system-wide basis specific dates, starting days from the launch the dascoin blockchain. unlikely that this interval will altered any point the future, but remains within the capability the board make such adjustment should they feel needed. listed below the set parameters that the dascoin board can propose changes upon: license issuing authority the privilege assign license vault account and determine the level license. license authenticating authority the ability cancel the issuance new license account the event error. webeuro issuing authority the privilege transfer webeur balance vault account. webeuro authenticating authority the ability cancel the issuance webeur balance account the event error. cycle upgrade date interval the exact date upgrade and the upgrade interval. the upgrade interval current set days and not expected ever changed. frequency the conversion factor which cycles can exchanged for dascoins part the minting process. block measurement for accumulated transactions. the system currently records block accordance with designated period, known block interval. block interval the time takes create confirmation, single block transactions. default, transactions are confirmed every seconds. the future, this will decreased the code base further optimized. minting block the amount dascoins distributed the completion each minting interval. minting interval the time takes for minting block created. the default minting interval the system minutes and not expected ever changed. maintenance period the number blocks that must pass before maintenance performed the blockchain. maintenance skip slots during maintenance period some blocks will skipped: this parameter sets how many the system should skip while performing maintenance period. super block the amount dascoins distributed the completion each type super block interval. the size super blocks expressed percentage the cumulative dascoins distributed minting blocks within that super block interval. super block intervals the time takes for super blocks created. there are super block intervals within the system, each which corresponds with type super block. the voting super block intervals are week duration, the ledger super block intervals are weeks duration, and the master super block intervals are weeks duration. treasury block the amount dascoins distributed the completion treasury block interval. like super blocks, treasury blocks are expressed percentage the cumulative dascoins distributed minting blocks within the treasury block interval. treasury block interval the time takes for treasury block created. treasury block intervals are weeks duration. maximum block size maximum size bytes that block can that signed the blockchain. maximum transaction size this the maximum allowable size bytes for single transaction. maximum witness count this the maximum number master nodes that could active the network. ... license issuing authority holds the privilege assign license vault account and determine the level license. ... license authenticating authority holds the ability cancel the issuance new license account the event error. ... license administrator authority holds the ability manage license limits, upgrades etc. ... webeuro issuing authority holds the privilege transfer webeuro balance vault account. ... webeuro authenticating authority holds the ability cancel the issuance webeuro balance account the event error. ... cycle issuing authority holds the privilege issue cycles vault account. ... cycle authenticating authority holds the privilege allow cycle operations. ... registrar authority holds the privilege register account. ... personal information authority holds the privilege validation personal information and key roll back. ... wire out authority holds the privilege handling wire_out payments. frequency description frequency the conversion factor used the minting process cycles dascoins. the dasnet expands, number positive dynamics occur: risk reduced, the circle users widens, and the infrastructure the system grows larger. consequently, the value unit stored value dascoin the system increases relation unit stored network capacity cycle. this results more cycles being needed produce single unit dascoin. this dynamic reflected increase the frequency, which proportionate the incremental growth the network. creating index based the initial network size and increasing that index direct proportion the increase the network size allows steady decrease the amount dascoin that put into circulation. steadily decreasing the level dascoin actually put into circulation allows for certain amount control over any potential loss value due inflation and ensures that dascoin's monetary value and exchange rate are maintained and kept steady. global frequency there basically difference between the global frequency and the frequency that you use the calculation. global frequency just current representation the frequency our website. however, during the calculation use the frequency number that was the global frequency when you purchase the license. for example, the global frequency when customer bought their license was "", this number will used later when that customer mints their coins, disregarding the current global frequency. call this "frequency locking", frequency locked the number that was effect when you purchased the license. centralize vs. calculation algorithm currently are manually calculating the frequency based the network size and number coins. however, will soon implement calculation algorithm which will this automatically. described the "minting" section, take the total number coins and calculate the frequency based the distribution forecast, can control the number dascoins that will available any given time. upgrades description cycles are issued licensees generations (lasting months). the current generation cycles began operations efficiency. however, the efficiency cycles gradually decreases over time due the impact moore's law and related technology dynamics. the efficiency the current generation cycles measured against the potential efficiency the next generation cycles. whenever the efficiency the current generation cycles drops upgrade occurs which immediately doubles the number cycles available the network. this why the number "upgrades" stated your software license important the more upgrades you are eligible for, the more times your cycles have the opportunity double number. every days all cycles that haven't been submitted the minting queue are doubled reflect the growing power the network. this powerful reward, allowing you benefit the efficiency dasnet increases. current cycle implementation mentioned before, cycles are implemented cryptographic asset, and they not have decimals. this means that, the case that you have cycles, the lowest value that you can have cycle. bonus cycles with each purchased license, customer also rewarded with bonus cycles. the amount added cycles what they receive just from license purchase. this part our promotion event and also our way saying "thank you" new people who are helping expand the network. cycles issuance authority description the authority responsible for the issuance cycles called issue_cycles_to_ license. you can find details the operations appendix. nodes master nodes master nodes are exclusively hosted data centers based requirement that access the server rack physically secured. they are compatible and connected other data centers around the world over leased direct lines affording reliable and highly connected bandwidth. this approach gives dasnet control the entire path between data centers and permits prevention man-in-the-middle attacks well denial service and distributed denial service attacks among the nodes that maintain the blockchain and its connectivity service. dasnet has additional layers for handling transaction capture and network connectivity addition the core infrastructure features mentioned previously. the server configuration involves state-of-the-art quality components and protection for high-end threat prevention and hardware-based firewall solutions that are commonly utilized banks and other highly secure environments. addition, dasnet hosted powerful servers that operate with cores per server which provides efficient space and power consumption scale into very high traffic and global utilization. dasnet will have total core master nodes operating data centers different jurisdictions throughout the world. core master node installations will occur pace approximately per month. there will also approximately core ledger nodes running dasnet. please note that the moment one can connect their own nodes our peer-to-peer network permission-based network. the role the master node aggregate transactions with the intention produce blocks. only master nodes have the authority write transactions into the blockchain ledger history. each master node aware the others and they must have been voted the governing system. master nodes are novel that their authority represented with cryptographic keys. this means that each master node must have registered its public key and will sign with its private key during the time block production. therefore, possible hold any one particular master node accountable for its actions. the moment there are master nodes and the end our plan have much more. ledger nodes ledger nodes are non-authoritative maintainers the dascoin blockchain. other words, ledger nodes not produce blocks, yet they aggregate transactions and pass them the master nodes for block inclusion. ledger nodes can verify transactions and are therefore useful for both increasing the footprint the dascoin consensus network and permitting connectivity reach farther without requiring the need assign authority the nodes. transaction propagation accelerated because ledger nodes. currently have ledger nodes that are located the following locations: belgrade london oregon taiwan amsterdam frankfurt bangalore sydney brazil the first five ledger nodes are deployed the belgrade datacenter; the london, oregon and taiwan ledger nodes are located google cloud datacenters; and the rest are digitalocean and amazon datacenters. ledger node the same node structure master node, except not permitted sign blocks. does everything else the same way master node. block production the same graphene. master node picking different there voting for master nodes. are permissioned blockchain and our system master nodes are chosen 'root authority'. able promote your ledger node into master node, you have run the node ledger, and starting ledger you need provide additional parameters 'witness-id' and 'private-key'. then 'root authority' has issue operations that will make your node behave master node. operations related this functionality are: create_witness_operation update_witness_operation remove_witness_operation activate_witness_operation deactivate_witness_operation node operations create witness operation the operation 'create_witness_operation' used make witness object the object database. those objects are marked with the '..x' and this needs provided when running master node argument 'witness-id'. operation properties are: 'fee' amount fee payed (this currently free-of-charge operation) 'authority' this root account authority. 'witness_account' existing account that want promote into master node candidate. 'block_signing_key' public key that used for signing blocks 'url' optional field used specify url address witness node 'comment' optional field update witness operation the operation 'update_witness_operation' used change the properties already existent witness object. operation properties are: 'fee' amount fee payed (this currently free-of-charge operation) 'witness' the witness object database 'authority' this root account authority 'witness_account' optional field used specify existing account that want promote into master node candidate 'block_signing_key' optional field used specify public key that used for signing blocks 'url' optional field used specify the url address witness node 'comment' optional field remove witness operation the operation 'remove_witness_operation' used remove existent witness object from the database. operation properties are: 'fee' amount fee payed (this currently free-of-charge operation) 'witness' witness object database that will deleted 'authority' this root account authority 'comment' optional field activate witness operation the operation 'activate_witness_operation' used add existent witness object active witness objects. witness scheduler will reserve slot for this witness every signing round, and this witness (node instance) will able sign blocks its slot time. the node instance not running, the slot will empty, and will have missing blocks. example: have witness nodes active and only two them running will have every third slot time missing block. operation properties are: 'fee' amount fee payed (this currently free-of-charge operation) 'witness' witness object database that will activated 'authority' this root account authority. 'comment' optional field webwallet webwallet secure access point for users access relevant data the dascoin blockchain and interact with the global state way signing transactions. cryptographic web-based wallet with the client front end running the user's browser and the application server backend hosted internet web server. the webwallet serves the user's point entry into the secure dascoin network. each webwallet account links the users their vaults and wallets and used store and validate personal kyc and aml information. users authenticated through webwallet can access their relevant data from the global blockchain state balances from vaults, license purchases, transaction history, etc. webwallet consists vault and hotwallet. the vault used for storing all assets that come from the netleaders site. every netleaders account has corresponding vault. webwallet may contain single multiple vaults, depending how user registers their account after they received their webwallet invitation email. assets that are stored the vault are: dascoin can received your vault after the minting process, you purchased them the exchange; reserved webeuros your reserve euro commission earnings from netleaders are automatically transferred your vault and are converted the dasexchange currency webeuros; cash webeuros when you transfer euros from your netleaders balance, they your vault and are converted the dasexchange currency webeuros. you can also accumulate cash webeuros from selling dascoins the internal exchange; cycles cycles acquired from licenses that can manually submitted the minting queue from your vault. security each vault account must licensed for person entity access dasnet. the license level and corresponding kyc levels also determine the daily amounts vault account eligible transfer wallet account. higher license level enables the person entity increase their level authentication and therefore increases their access more capacity within the system and higher withdrawal privileges. this way the dascoin blockchain and dasnet can fully compliant with global regulations that require account holders identified and good standing before engaging commerce with other participants dasnet. this type authentication protocol results higher level integrity among participants and likely lead more acceptance within regulated jurisdictions throughout the world. validator webwallet relies cryptographic hardware store for managing keys and securely signing blockchain transactions. this proprietary hardware device known the validator and has the ability generate and store ecdsa private keys corresponding the users' blockchain vaults. the validator also secured with pin/passphrase that prevents misuse and theft keys. when signing blockchain transactions, webwallet interfaces with the validator hardware device. the user must first unlock their validator before the required private ecdsa key can transferred into the browser memory the javascript client application upon confirmation transaction. dascoin transaction can made without validation through this cryptographic hardware device. this system provides the highest level safety and security the authentication transactions. the key stored the memory for the shortest possible time required sign the transaction upon which purged from the client memory. the private key never 'hot' never crosses the wire, not even encrypted form. you will need your validator to: withdraw euros from your webwallet account send dascoin another webwallet account trade dascoin via dasexchange access your reserve funds set your hotwallet and transfer funds account recovery the user can back mnemonic consisting words used entropy for generating the private key. case theft loss the hardware device, the user can use the mnemonic reconstruct the original private key, thereby restoring access their account. identity management kyc aml stands for anti-money laundering. phrase that applies the procedures, laws and regulations designed stop the practice generating income through illegal actions. dasnet, verify your identity using bank standard "know your customer" protocols that help safeguard dascoin's position the currency trust. depending your country residence, the kyc verification process typically takes around minutes. certain cases, however, can take during the process, you may required upload additional documents verify your identity. additional documents are required, will contact you via email with instructions. will also provide status updates during the process needed. you can upload government-issued documents such personal cards, driver's licenses and passports. proof address, you can upload government-issued documents which your residential address visible, credit card/bank statement less than three month old. before you can really enjoy all the benefits the platform provides, kyc verification mandatory step. without kyc, customer will not receive access webwallet. for successful kyc verification, you need upload document types: proof address proof front proof back sample here quick preview the webwallet interface, the structure webwallet consist of: the webwallet website gui representation customers' wallets, well easy access our dasexchange vault used for storing all your assets coming from the netleaders website hotwallet where you hold funds trade and withdraw minting queue used mint dascoins from cycles internal exchange dasexchange one the main parts the webwallet platform our internal exchange where customers can sell buy their dascoins. dasexchange extremely easy use and contains all the information that customer might need from overview value fluctuation that can set daily, weekly, monthly periods (or period extending from the moment our platform went live the present day) information like trade history, buy orders and sell orders. api for full list api calls and details please see the appendix visit our regularly updated api website here: https://docs.dascoin.com websocket calls notifications call format dascoin, websocket calls are stateful and accessible via regular websocket connection. the json call has the following structure: "id":, "method":"call", "params":[, "get_accounts", [[".."]]] the parameters params have the following structure: [api-identifier, method-to-call, call-parameters] the example above, query the database api which carries the identifier our example. example call with wscat note: examples this section assume that you have full node running and listening port locally. the following will show the usage websocket connections. make use the wscat application available via npm: npm install wscat non-restricted call against full-node would take the form: wscat ws://...: {"id":, "method":"call", "params":[, "get_accounts", [[".."]]]} successful calls the api will return json formatted response carrying the same the request distinguish subsequent calls. "id":, "result": ..data.. errors case error, the resulting answer will carry error attribute and detailed description: "id":, "ssid": "error": "data": "code": error-code, "name": name exception .." "message": message exception ..", "stack": stack trace "code": requesting api access the dascoin full node offers wide range apis that can accessed via websockets. the procedure works follows: login the full node request access api obtain the api identifier call methods specific api providing the identifier please find list available apis below: database api account history api network broadcast api network nodes api login the first thing need log in: {"id":,"method":"call", "params":[, "login", ["",""]]} {"id":,"method":"call", "params":[, "database",[]]} obtain the api identifier after requesting access, the full node will either deny access return identifier used future calls: {"id":,"method":"call", "params":[database_api_id,"get_accounts", [[".."]]]} database notifications dascoin, the websocket connection used for notifications when objects the database change particular event (such filled orders) occurs. available subscriptions set_subscribe_callback set_subscribe_callback( int identifier, bool clear_filter simplify development, global subscription callback can registered. every notification initiated the full node will carry particular defined the user with the identifier parameter. set_pending_transaction_callback set_pending_transaction_callback(int identifier) notifications for incoming unconfirmed transactions. set_block_applied_callback set_block_applied_callback(block_id) gives notification whenever the block block_id applied the blockchain. subscribe_to_market subscribe_to_market(int identifier, asset_id asset_id b)) subscribes market changes market a:b and sends notifications with identifier. get_full_accounts get_full_accounts(array account_ids, bool subscribe) returns the full account object for the accounts array account_ids and subscribes changed that account subscribe set true. subscription format let's first get global subscription callback distinguish our notifications from regular rpc calls:: {"id":,"method":"call","params":[database_api_id,"set_subscribe_callback", [subscription_id, true]]} this call above will register subscription_id the for notifications. now, whenever you get object from the witness (e.g. via get_objects) you will automatically subscribe any future changes that object. after calling set_subscribe_callback the witness will start send notices every time the object changes:: {"id":,"method":"call","params":[,"login",["",""]]} {"id":,"method":"call","params":[,"database",[]]} {"id":,"method":"call","params":[,"history",[]]} {"id":,"method":"call","params":[,"set_subscribe_callback",[,false]]} {"id":,"method":"call","params":[,"get_objects",[[".."]]]} (plenty data coming from this point on) for the complete list dascoin api calls see appendix operations for full list operations and details please see appendix appendix blockchain api database api the database api available from the full node via websockets. you have not set your websockets connection, please read this article. ... objects fc::variants graphene::app::database_api::get_objects(const vector &ids) const get the objects corresponding the provided ids. any the provided ids does not map object, null variant returned its position. return the objects retrieved, the order they are mentioned ids parameters ids: ids the objects retrieve any the provided ids does not map object, null variant returned its position. ... subscriptions void graphene::app::database_api::set_subscribe_callback(std::function cb, bool notify_remove_create) void graphene::app::database_api::set_pending_transaction_callback(std::function cb) void graphene::app::database_api::set_block_applied_callback(std::function cb) void graphene::app::database_api::cancel_all_subscriptions() stop receiving any notifications. this unsubscribes from all subscribed markets and objects. ... blocks and transactions optional graphene::app::database_api::get_block_header(uint_t block_num) const retrieve block header. return header the referenced block, null matching block was found parameters block_num: height the block whose header should returned optional graphene::app::database_api::get_block(uint_t block_num) const retrieve full, signed block. return the referenced block, null matching block was found parameters block_num: height the block returned vector graphene::app::database_api::get_blocks uint_t start_block_num, uint_t count) const return array full, signed blocks starting from specified height. parameters start_block_num: height the block returned count: number blocks return vector graphene::app::database_api::get_blocks_with_virtual_operations uint_t start_block_num, uint_t count, std::vector virtual_operation_ids const return array full, signed blocks that contains virtual operations starting from specified height. return array enumerated blocks parameters start_block_num: height the starting block. count: number blocks return virtual_operation_ids: array virtual operation ids that should included result returned processed_transaction graphene::app::database_api::get_transaction(uint_t block_num, uint_t trx_in_block) const used fetch individual transaction. optional graphene::app::database_api::get_recent_transaction_by_id( const transaction_id_type &id) const the transaction has not expired, this method will return the transaction for the given will return null not known. just because not known does not mean wasn't included the blockchain. ... globals chain_property_object graphene::app::database_api::get_chain_properties() const retrieve the chain_property_object associated with the chain. global_property_object graphene::app::database_api::get_global_properties() const retrieve the current global_property_object. fc::variant_object graphene::app::database_api::get_config() const retrieve compile-time constants. chain_id_type graphene::app::database_api::get_chain_id() const get the chain id. dynamic_global_property_object graphene::app::database_api::get_dynamic_global_properties() const retrieve the current dynamic_global_property_object. ... keys vector> graphene::app::database_api::get_key_references(vector key) const ... accounts vector> graphene::app::database_api::get_accounts( const vector &account_ids) const get list accounts id. this function has semantics identical get_objects. return the accounts corresponding the provided ids parameters account_ids: ids the accounts retrieve std::map graphene::app::database_api::get_full_accounts( const vector &names_or_ids, bool subscribe) fetch all objects relevant the specified accounts and subscribe updates. this function fetches all relevant objects for the given accounts, and subscribes updates the given accounts. any the strings names_or_ids cannot tied account, that input will ignored. all other accounts will retrieved and subscribed. return map string from names_or_ids the corresponding account parameters callback: function call with updates names_or_ids: each item must the name account retrieve optional graphene::app::database_api::get_account_by_name(string name) const vector graphene::app::database_api::get_account_references( account_id_type account_id) const return all accounts that refer the key account their owner active authorities. vector> graphene::app::database_api::lookup_account_names( const vector &account_names) const get list accounts name. this function has semantics identical get_objects. return the accounts holding the provided names parameters account_names: names the accounts retrieve map graphene::app::database_api::lookup_accounts( const string &lower_bound_name, uint_t limit) const get names and ids for registered accounts. return map account names corresponding ids parameters lower_bound_name: lower bound the first name return limit: maximum number results return must not exceed uint_t graphene::app::database_api::get_account_count() const get the total number accounts registered with the blockchain. optional graphene::app::database_api::get_vault_info(account_id_type get vault information. return vault_info_res (optional) parameters vault_id vector graphene::app::database_api::get_vaults_info( vector vault_ids) const get vault information for list vaults. return json object containing vault and optional vault information (if vault exists). parameters vault_ids: list vault id's. ... balances vector graphene::app::database_api::get_account_balances( account_id_type id, const flat_set &assets) const get account's balances various assets. return balances the account parameters id: the account get balances for assets: ids the assets get balances of; empty, get all assets account has balance vector graphene::app::database_api::get_named_account_balances( const std::string &name, constflat_set &assets) const semantically equivalent get_account_balances, but takes name instead id. vector graphene::app::database_api::get_balance_objects(const vector &addrs) const return all unclaimed balance objects for set addresses vector graphene::app::database_api::get_vested_balances( const vector &objs) const vector graphene::app::database_api::get_vesting_balances( account_id_type account_id) const acc_id_share_t_res graphene::app::database_api::get_free_cycle_balance(account_id_type account_id) const (deprecated) get free cycle amount for account return number issued free cycles account parameters account_id: account_ids the account retrieve vector graphene::app::database_api::get_free_cycle_balances_for_accounts( vector ids) const (deprecated) get remaining amount cycles. return vector objects containing account and cycle balance parameters ids: vector account ids acc_id_vec_cycle_agreement_res graphene::app::database_api::get_all_cycle_balances( account_id_type account_id) const (deprecated) get cycle amounts per cycle agreement for account return vector cycle amounts and frequency locks account parameters account_id: the account retrieve vector graphene::app::database_api::get_all_cycle_balances_for_accounts( vector ids) const (deprecated) get cycle balances for list accounts. return vector objects containing account id, cycle amount and frequency lock parameters ids: vector account ids signed_transaction graphene::app::database_api::purchase_cycle_asset(string account, string amount_to_sell, string symbol_to_sell, double frequency, double amount_of_cycles_to_receive, bool broadcast false) purchase cycles parameters account: account name amount_to_sell: amount asset sell symbol_to_sell: symbol asset sell frequency: frequency which buy amount_of_cycles_to_receive: amount cycles receive this buy optional graphene::wallet::wallet_api::calculate_cycle_price(share_type cycle_amount, asset_id_type asset_id) const calculates and returns the amount asset one needs pay get the given amount cycles return cycle_price structure (optional) parameters cycle_amount: desired amount cycles get asset_id_type: asset pay acc_id_share_t_res graphene::app::database_api::get_dascoin_balance( account_id_type id) const get amount dascoin for account. return object containing and balance account parameters id: the account retrieve ... reward queue vector graphene::app::database_api::get_reward_queue() const return the entire reward queue. return vector all reward queue objects. vector graphene::app::database_api::get_reward_queue_by_page( uint_t from, uint_t amount) const return portion the reward queue. parameters from: starting page amount: number pages get returns vector which represent portion that queue unit_t graphene::app::database_api::get_reward_queue_size() const get the size the dascoin reward queue. return number elements the dascoin queue. acc_id_queue_subs_w_pos_res graphene::app::database_api::get_queue_submissions_with_pos( account_id_type account_id) const get all current submissions reward queue single account. parameters account_id: account whose submissions should returned return all elements dascoin reward queue submitted given account vector graphene::app::database_api::get_queue_submissions_with_pos_for_accounts (vector ids) const get all current submissions reward queue multiple account. parameters ids: vector account ids return all elements dascoin reward queue submitted given accounts ... requests vector graphene::app::database_api::get_all_webasset_issue_requests() const get all webasset issue request objects, sorted expiration. return vector webasset issue request objects. vector graphene::app::database_api::get_all_wire_out_holders() const get all wire out holder objects. return vector wire out holder objects. vector graphene::app::database_api::get_all_wire_out_with_fee_holders() const get all wire out with fee holder objects. return vector wire out with fee holder objects. ... assets vector> graphene::app::database_api::get_assets( const vector &asset_ids) const get list assets id. this function has semantics identical get_objects. return the assets corresponding the provided ids parameters asset_ids: ids the assets retrieve vector graphene::app::database_api::list_assets( const string &lower_bound_symbol, uint_t limit) const get assets alphabetically symbol name. return the assets found parameters lower_bound_symbol: lower bound symbol names retrieve limit: maximum number assets fetch (must not exceed vector> graphene::app::database_api::lookup_asset_symbols( const vector &symbols_or_ids) const get list assets symbol. this function has semantics identical get_objects. return the assets corresponding the provided symbols ids parameters asset_symbols: symbols stringified ids the assets retrieve optional graphene::app::database_api::lookup_asset_symbol const string &symbols_or_id) const get asset symbol. return the asset corresponding the provided symbol parameters asset_symbols: symbols stringified ids the assets retrieve uint_t graphene::app::database_api::get_account_count() const get the total number accounts registered with the bool graphene::app::database_api::check_issued_asset( const string &unique_id, const string &asset) const check asset issue with the corresponding unique was completed the chain. blockchain. bool graphene::app::database_api::check_issued_webeur(const string &unique_id) const check webeur issue with the corresponding unique was completed the chain. ... markets feeds order_book graphene::app::database_api::get_order_book( const string &base, const string &quote, unsigned limit const returns the order book for the market base:quote. return order book the market parameters base: string name the first asset quote: string name the second asset depth: the order book. depth each asks and bids, capped prioritizes most moderate each vector graphene::app::database_api::get_limit_orders( asset_id_type asset_id_type uint_t limit) const get limit orders given market. return the limit orders, ordered from least price greatest parameters asset being sold asset being purchased limit: maximum number orders retrieve vector graphene::app::database_api::get_limit_orders( asset_id_type asset_id_type uint_t limit) const get limit orders given market. return the limit orders, ordered from least price greatest parameters asset being sold asset being purchased limit: maximum number orders retrieve vector graphene::app::database_api::get_limit_orders_for_account( asset_id_type asset_id_type uint_t limit) const get limit orders given market. return the limit orders, ordered from least price greatest parameters id: the account get limit orders for asset being sold asset being purchased limit: maximum number orders retrieve limit_orders_grouped_by_price graphene::app::database_api::get_limit_orders_grouped_by_price( asset_id_type asset_id_type uint_t limit) const get limit orders given market grouped price and divided buy and sell vectors. return the call orders, ordered from earliest called latest parameters asset being sold asset being purchased limit: maximum number orders retrieve vector graphene::app::database_api::get_settle_orders( asset_id_type uint_t limit) const get forced settlement orders given asset. return the settle orders, ordered from earliest settlement date latest parameters asset being settled limit: maximum number orders retrieve vector graphene::app::database_api::get_margin_positions( const account_id_type &id) const return all open margin positions for given account id. void graphene::app::database_api::subscribe_to_market( std::function callback, asset_id_type asset_id_type request notification when the active orders the market between two assets changes. callback will passed variant containing vector>. the vector will contain, order, the operations which changed the market, and their results. parameters callback: callback method which called when the market changes first asset second asset void graphene::app::database_api::unsubscribe_from_market(asset_id_type asset_id_type unsubscribe from updates given market. parameters first asset second asset market_ticker graphene::app::database_api::get_ticker(const string &base, const string &quote) const returns the ticker for the market asseta:assetb. return the market ticker for the past hours. parameters string name the first asset string name the second asset market_hi_lo_volume graphene::app::database_api::get__hi_lo_volume( const string &base, const string &quote) const returns the hour high, low and volume for the market asseta:assetb. return the market high, low and volume over the past hours parameters string name the first asset string name the second asset vector graphene::app::database_api::get_trade_history( const string &base, const string &quote, fc::time_point_sec start, fc::time_point_sec stop, unsigned limit const returns recent trades for the market asseta:assetb note: currentlt, timezone offsets are not supported. the time must utc. return recent transactions the market parameters string name the first asset string name the second asset stop: stop time unix timestamp limit: number transactions retrieve, capped start: start time unix timestamp vector graphene::app::database_api::get_trade_history_by_sequence( const string &base, const string &quote, fc::time_point_sec start, fc::time_point_sec stop, unsigned limit const returns recent trades for the market asseta:assetb note: currentlt, timezone offsets are not supported. the time must utc. return recent transactions the market parameters string name the first asset string name the second asset stop: stop time unix timestamp start: start sequence integer, the latest trade retrieve limit: number transactions retrieve, capped ... witnesses vector> graphene::app::database_api::get_witnesses( const vector &witness_ids) const get list witnesses id. this function has semantics identical get_objects return the witnesses corresponding the provided ids parameters witness_ids: ids the witnesses retrieve fc::optional graphene::app::database_api::get_witness_by_account( account_id_type account) const get the witness owned given account. return the witness object, null the account does not have witness parameters account: the the account whose witness should retrieved map graphene::app::database_api::lookup_witness_accounts( const string &lower_bound_name, uint_t limit) const get names and ids for registered witnesses. return map witness names corresponding ids parameters lower_bound_name: lower bound the first name return limit: maximum number results return must not exceed uint_t graphene::app::database_api::get_witness_count() const get the total number witnesses registered with the blockchain. ... committee members vector> graphene::app::database_api::get_committee_members( const vector &committee_member_ids) const get list committee_members id. this function has semantics identical get_objects return the committee_members corresponding the provided ids parameters committee_member_ids: ids the committee_members retrieve fc::optional graphene::app::database_api::get_committee_member_by_account( account_id_type account) const get the committee_member owned given account. return the committee_member object, null the account does not have committee_member parameters account: the the account whose committee_member should retrieved map graphene::app::database_api::lookup_committee_member_accounts( const string &lower_bound_name, uint_t limit) const get names and ids for registered committee_members. return map committee_member names corresponding ids parameters lower_bound_name: lower bound the first name limit: maximum number results return must not exceed ... workers vector graphene::app::database_api::get_workers_by_account( account_id_type account) return const return the worker objects associated with this account. ... votes vector graphene::app::database_api::lookup_vote_ids(const vector &votes) const given set votes, return the objects they are voting for. this will mixture committee_member_object, witness_objects, and worker_objects. the results will the same order the votes. null will returned for any vote ids that are not found. ... authority validation std::string graphene::app::database_api::get_transaction_hex(const signed_transaction &trx) const get hexdump the serialized binary form transaction. set graphene::app::database_api::get_required_signatures(const signed_transaction &trx, constflat_set &available_keys) const this api will take partially signed transaction and set public keys that the owner has the ability sign for and return the minimal subset public keys that should add signatures the transaction. set graphene::app::database_api::get_potential_signatures(const signed_transaction &trx) const this method will return the set all public keys that could possibly sign for given transaction. this call can used wallets filter their set public keys just the relevant subset prior calling get_required_signatures get the minimum subset. set graphene::app::database_api::get_potential_address_signatures(const signed_transaction &trx) const bool graphene::app::database_api::verify_authority(const signed_transaction &trx) const return true the trx has all the required signatures, otherwise throws exception bool graphene::app::database_api::verify_account_authority( const string &name_or_id, const flat_set &signers) const return true the signers have enough authority authorize account processed_transaction graphene::app::database_api::validate_transaction(const signed_transaction &trx) const validates transaction against the current state without broadcasting the network. vector graphene::app::database_api::get_required_fees(const vector &ops, asset_id_type id)const for each operation calculate the required fee the specified asset type. the asset type does not have valid core_exchange_rate. ... proposed transactions vector graphene::app::database_api::get_proposed_transactions( account_id_type id) return the set proposed transactions relevant the specified account id. ... blinded balances vector graphene::app::database_api::get_blinded_balances( const flat_set &commitments) const return the set blinded balance objects commitment ... licenses optional graphene::app::database_api::get_license_type( const license_type_id_type) const get license type-ids found the blockchain. returns the license type-id found. parameters license_type_id_type-id: used the block vector graphene::app::database_api::get_license_types() const get all license type-ids found the blockchain. returns vector license type-ids found vector> graphene::app::database_api::get_license_type_names_ids() const get all name/license type-ids found the blockchain. returns vector license name/type-ids pairs found vector graphene::app::database_api::get_license_type_names_ids_grouped_by_kind() get all license type-ids grouped kind found the const blockchain. returns vector license type-ids found grouped kind vector graphene::app::database_api::get_license_objects_grouped_by_kind() const get all license objects grouped kind found the blockchain. returns vector license objects found grouped kind vector graphene::app::database_api::list_license_types_by_name( const string& lower_bound_name, uint_t get license types active the blockchain name. returns the license types found limit) const parameters lower_bound_symbol: lower bound license type names retrieve limit: maximum number license types fetch (must not exceed vector graphene::app::database_api::list_license_types_by_amount( const uint_t lower_bound_amount, uint_t limit) const get license types active the blockchain amount. returns the license types found. parameters lower_bound_symbol: lower bound license type names retrieve. limit: maximum number license types fetch (must not exceed vector> graphene::app::database_api::lookup_license_type_names( const vector &names_or_ids) const get list license types names. this function has semantics identical get_objects returns the assets corresponding the provided symbols ids parameters asset_symbols: symbols stringified ids the assets retrieve vector> graphene::app::database_api::get_license_information( const vector &account_ids) const get list account issued license types. this function has semantics identical get_objects. returns vector issued license information objects parameters account_ids: ids the accounts retrieve vector graphene::app::database_api::get_upgrade_events() const get list upgrade events. returns list upgrade events, scheduled executed account history api the history_api class implements the rpc api for account history. ... account history vector graphene::app::history_api::get_account_history (account_id_type account, operation_history_id_type stop operation_history_id_type (), unsigned limit operation_history_id_type start operation_history_id_type ()) const get operations relevant the specified account. return list operations performed account, ordered from most recent oldest. parameters account: the account whose history should queried stop: the earliest operation retrieve limit: maximum number operations retrieve (must not exceed start: the most recent operation retrieve vector graphene::app::history_api::get_account_history_by_operation (account_id_type account, flat_set operation_types, operation_history_id_type stop operation_history_id_type (), unsigned limit operation_history_id_type start operation_history_id_type ()) const get operations relevant the specified account filtering operation type. return list operations performed account, ordered from most recent oldest. parameters account: the account whose history should queried operation_types: the ids the operation want get operations the account( transfer limit order create, ...) stop: the earliest operation retrieve limit: maximum number operations retrieve (must not exceed start: the most recent operation retrieve vector graphene::app::history_api::get_relative_account_history (account_id_type account, uint_t stop unsigned limit ,uint_t start const get operations relevant the specified account referenced event numbering specific the account. the current number operations for the account can found the account statistics (or use for start). return list operations performed account, ordered from most recent oldest. parameters account: the account whose history should queried stop: sequence number earliest operation. default and will query 'limit' number operations. limit: maximum number operations retrieve (must not exceed start: sequence number the most recent operation retrieve. default, which will start querying from the most recent operation. ... market history vector graphene::app::history_api::get_fill_order_history(asset_id_type asset_id_type uint_t limit) const vector graphene::app::history_api::get_market_history(asset_id_type asset_id_type uint_t bucket_seconds, fc::time_point_sec start, fc::time_point_sec end) const flat_set graphene::app::history_api::get_market_history_buckets() const crypto api ... blinding and un-blinding blind_signature graphene::app::crypto_api::blind_sign(const extended_private_key_type &key, const fc::ecc::blinded_hash &hash, int signature_type graphene::app::crypto_api::unblind_signature(const extended_private_key_type &key, const extended_public_key_type &bob, const fc::ecc::blind_signature &sig, const fc::sha &hash, int commitment_type graphene::app::crypto_api::blind(const fc::ecc::blind_factor_type &blind, uint_t value) blind_factor_type graphene::app::crypto_api::blind_sum(const std::vector &blinds_in, uint_t non_neg) ... rage proofs range_proof_info graphene::app::crypto_api::range_get_info(const std::vector &proof) std::vector graphene::app::crypto_api::range_proof_sign(uint_t min_value, const commitment_type &commit, const blind_factor_type &commit_blind, const blind_factor_type &nonce, int_t base_exp, uint_t min_bits, uint_t actual_value) ... verification bool graphene::app::crypto_api::verify_sum(const std::vector &commits_in, const std::vector &neg_commits_in, int_t excess) verify_range_result graphene::app::crypto_api::verify_range(const fc::ecc::commitment_type &commit, const std::vector &proof) verify_range_proof_rewind_result graphene::app::crypto_api::verify_range_proof_rewind(const blind_factor_type &nonce, const fc::ecc::commitment_type &commit, const std::vector &proof) network broadcast api the network_broadcast_api class allows broadcasting transactions. ... transactions void graphene::app::network_broadcast_api::broadcast_transaction(const signed_transaction &trx) broadcast transaction the network. the transaction will checked for validity the local database prior broadcasting. fails apply locally, error will thrown and the transaction will not broadcast. parameters trx: the transaction broadcast void graphene::app::network_broadcast_api::broadcast_transaction_with_callback (confirmation_callback cb, const signed_transaction &trx) this version broadcast transaction registers callback method that will called when the transaction included into block. the callback method includes the transaction id, block number, and transaction number the block. ... block void graphene::app::network_broadcast_api::broadcast_block(const signed_block &block) network nodes api the network_node_api class allows maintenance connections. ... obtain network information fc::variant_object graphene::app::network_node_api::get_info() const return general network information, such port. std::vector graphene::app::network_node_api::get_connected_peers() const get status all current connections peers. std::vector graphene::app::network_node_api::get_potential_peers() const return list potential peers. fc::variant_object graphene::app::network_node_api::get_advanced_node_parameters() const get advanced node parameters, such desired and max number connections. ... change network settings void graphene::app::network_node_api::add_node(const fc::ip::endpoint &ep) add_node connect new peer parameters ep: the ip/port the peer connect void graphene::app::network_node_api::set_advanced_node_parameters(const fc::variant_object &params) set advanced node parameters, such desired and max number connections. parameters params: json object containing the name/value pairs for the parameters set wallet api ... general calls help string graphene::wallet::wallet_api::help() const returns list all commands supported the wallet api. this lists each command, along with its arguments and return types. for more detailed help single command, use get_help() return multiline string suitable for displaying terminal gethelp string graphene::wallet::wallet_api::gethelp(const string &method) const returns detailed help single api command. return multi-line string suitable for displaying terminal parameters method: the name the api command you want help with variant info graphene::wallet::wallet_api::info() returns json string with informations about current blockchain state return json string about variant_object graphene::wallet::wallet_api::about() const returns info such client version, git version graphene/fc, version boost, openssl. return compile time info and client and dependencies versions network_add_nodes void graphene::wallet::wallet_api::network_add_nodes(const vector &nodes) connect new peer parameters nodes: list the addresses and ports new nodes network_get_connected_peers vector graphene::wallet::wallet_api::network_get_connected_peers() get status all current connections peers ... wallet calls is_new bool graphene::wallet::wallet_api::is_new() const checks whether the wallet has just been created and has not yet had password set. calling set_password() will transition the wallet the locked state. return true the wallet new is_locked bool graphene::wallet::wallet_api::is_locked() const checks whether the wallet locked (is unable use its private keys). this state can changed calling lock() unlock(). return true the wallet locked lock void graphene::wallet::wallet_api::lock() locks the wallet immediately. unlock void graphene::wallet::wallet_api::unlock(string password) unlocks the wallet. the wallet remain unlocked until the lock called the program exits. parameters password: the password previously set with set_password() set_password void graphene::wallet::wallet_api::set_password(string password) sets new password the wallet. the wallet must either 'new' 'unlocked' execute this command. parameters password: new password dump_private_keys map graphene::wallet::wallet_api::dump_private_keys() dumps all private keys owned the wallet. the keys are printed wif format. you can import these keys into another wallet using import_key() return map containing the private keys, indexed their public key import_key bool graphene::wallet::wallet_api::import_key(string account_name_or_id, string wif_key) imports the private key for existing account. the private key must match either owner key active key for the named account. see dump_private_keys() return true the key was imported parameters account_name_or_id: the account owning the key wif_key: the private key wif format import_accounts map graphene::wallet::wallet_api::import_accounts(string filename, string password) import_account_keys bool graphene::wallet::wallet_api::import_account_keys(string filename, string password, string src_account_name, string dest_account_name) import_balance vector graphene::wallet::wallet_api::import_balance(string account_name_or_id, const vector &wif_keys, bool broadcast) this call will construct transaction(s) that will claim all balances controlled wif_keys and deposit them into the given account. suggest_brain_key brain_key_info graphene::wallet::wallet_api::suggest_brain_key() const suggests safe brain key use for creating your account. create_account_with_brain_key() requires you specify 'brain key', long passphrase that provides enough entropy generate cryptographic keys. this function will suggest suitably random string that should easy write down (and, with effort, memorize). see create_account_with_brain_key() return suggested brain_key get_transaction_id transaction_id_type graphene::wallet::wallet_api::get_transaction_id(const signed_transaction &trx) const this method used convert json transaction its transaction id. get_private_key string graphene::wallet::wallet_api::get_private_key(public_key_type pubkey) const get the wif private key corresponding public key. the private key must already the wallet. load_wallet_file bool graphene::wallet::wallet_api::load_wallet_file(string wallet_filename "") loads specified graphene wallet. the current wallet closed before the new wallet loaded. warning: this does not change the filename that will used for future wallet writes, this may cause you overwrite your original wallet unless you also call set_wallet_filename() return true the specified wallet loaded parameters wallet_filename: the filename the wallet json file load. wallet_filename empty, reloads the existing wallet file get_wallet_filename string graphene::wallet::wallet_api::get_wallet_filename() returns the current wallet filename. this the filename that will used when automatically saving the wallet. see set_wallet_filename() return the wallet filename set_wallet_filename void graphene::wallet::wallet_api::set_wallet_filename(string wallet_filename) sets the wallet filename used for future writes. this does not trigger save, only changes the default filename that will used the next time save triggered. parameters wallet_filename: the new filename use for future saves normalize_brain_key string graphene::wallet::wallet_api::normalize_brain_key(string const transforms brain key reduce the chance errors when re-entering the key from memory. this takes user-supplied brain key and normalizes into the form used for generating private keys. particular, this upper-cases all ascii characters and collapses multiple spaces into one. return the brain key its normalized form parameters the brain key supplied the user save_wallet_file void graphene::wallet::wallet_api::save_wallet_file(string wallet_filename "") saves the current wallet the given filename. warning: this does not change the wallet filename that will used for future writes, think this function 'save copy as...' instead 'save as...'. use set_wallet_filename() make the filename persist. parameters wallet_filename: the filename the new wallet json file create overwrite. wallet_filename empty, save the current filename. ... account calls list_my_accounts vector graphene::wallet::wallet_api::list_my_accounts() lists all accounts controlled this wallet. this returns list the full account objects for all accounts whose private keys possess. return list account objects list_accounts map graphene::wallet::wallet_api::list_accounts(const string &lowerbound, uint_t limit) lists all accounts registered the blockchain. this returns list all account names and their account ids, sorted account name. use the lowerbound and limit parameters page through the list. retrieve all accounts, start setting lowerbound the empty string "", and then each iteration, pass the last account name returned the lowerbound for the next list_accounts() call. return list accounts mapping account names account ids parameters lowerbound: the name the first account return. the named account does not exist, the list will start the account that comes after lowerbound limit: the maximum number accounts return (max: list_account_balances vector graphene::wallet::wallet_api::list_account_balances(const string &id) list the balances account. each account can have multiple balances, one for each type asset owned that account. the returned list will only contain assets for which the account has nonzero balance return list the given account balances parameters id: the name the account whose balances you want register_account signed_transaction graphene::wallet::wallet_api::register_account(string name, public_key_type owner, public_key_type active, string registrar_account, string referrer_account, uint_t referrer_percent, bool broadcast false) registers third party's account the blockchain. this function used register account for which you not own the private keys. when acting registrar, end user will generate their own private keys and send you the public keys. the registrar will use this function register the account behalf the end user. see create_account_with_brain_key() return the signed transaction registering the account parameters name: the name the account, must unique the blockchain. shorter names are more expensive register; the rules are still flux, but general names more than characters with least one digit will cheap. owner: the owner key for the new account active: the active key for the new account registrar_account: the account which will pay the fee register the user referrer_account: the account who acting referrer, and may receive portion the user's transaction fees. this can the same the registrar_account there referrer. referrer_percent: the percentage the new user's transaction fees not claimed the blockchain that will distributed the referrer; the rest will sent the registrar. will multiplied graphene__percent when constructing the transaction. broadcast: true broadcast the transaction the network register_vault_account signed_transaction graphene::wallet::wallet_api::register_vault_account(string name, public_key_type owner, public_key_type active, bool broadcast false) registers third party's vault account the blockchain. this function used register vault account for which you not own the private keys. when acting registrar, end user will generate their own private keys and send you the public keys. the registrar will use this function register the account behalf the end user. see register_account() return the signed transaction registering vault account parameters name: the name the account, must unique the blockchain. shorter names are more expensive register; the rules are still flux, but general names more than characters with least one digit will cheap. owner: the owner key for the new account active: the active key for the new account broadcast: true broadcast the transaction the network tether_accounts signed_transaction graphene::wallet::wallet_api::tether_accounts(string wallet, string vault, bool broadcast false) tethers wallet account vault account the blockchain. this function used tether two accounts wallet and vault) return the signed transaction tethering two accounts parameters wallet: the name the wallet account tether vault: the name the vault account tether broadcast: true broadcast the transaction the network upgrade_account signed_transaction graphene::wallet::wallet_api::upgrade_account(string name, bool broadcast) upgrades account prime status. this makes the account holder 'lifetime member'. return the signed transaction upgrading the account parameters name: the name the account upgrade broadcast: true broadcast the transaction the network create_account_with_brain_key signed_transaction graphene::wallet::wallet_api::create_account_with_brain_key(string brain_key, string account_name, string registrar_account, string referrer_account, bool broadcast false) creates new account and registers the blockchain. see suggest_brain_key() register_account() return the signed transaction registering the account parameters brain_key: the brain key used for generating the account's private keys account_name: the name the account, must unique the blockchain. shorter names are more expensive register; the rules are still flux, but general names more than characters with least one digit will cheap. registrar_account: the account which will pay the fee register the user referrer_account: the account who acting referrer, and may receive portion the user's transaction fees. this can the same the registrar_account there referrer. broadcast: true broadcast the transaction the network create_account signed_transaction graphene::wallet::wallet_api::create_account(account_kind kind, string name, public_key_type owner, public_key_type active, bool broadcast false) registers third party's account the blockchain. this function used register account for which you not own the private keys. when acting registrar, end user will generate their own private keys and send you the public keys. the registrar will use this function register the account behalf the end user. see create_account_with_brain_key() return the signed transaction registering the account parameters kind: the kind the account, i.e. vault name: the name the account, must unique the blockchain. shorter names are more expensive register; the rules are still flux, but general names more than characters with least one digit will cheap. owner: the owner key for the new account active: the active key for the new account broadcast: true broadcast the transaction the network transfer signed_transaction graphene::wallet::wallet_api::transfer(string from, string to, string amount, string asset_symbol, string memo, bool broadcast false) transfer amount from one account another. return the signed transaction transferring funds parameters from: the name the account sending the funds to: the name the account receiving the funds amount: the amount send (in nominal units send half bts, specify asset_symbol: the symbol the asset send memo: memo attach the transaction. the memo will encrypted the transaction and readable for the receiver. there length limit other than the limit imposed maximum transaction size, but transaction increase with transaction size broadcast: true broadcast the transaction the network transfer pair graphene::wallet::wallet_api::transfer(string from, string to, string amount, string asset_symbol, string memo) this method works just like transfer, except always broadcasts and returns the transaction along with the signed transaction. whitelist_account signed_transaction graphene::wallet::wallet_api::whitelist_account(string authorizing_account, string account_to_list, account_whitelist_operation::account_listing new_listing_status, bool broadcast false) whitelist and blacklist accounts, primarily for transacting whitelisted assets. accounts can freely specify opinions about other accounts, the form either whitelisting blacklisting them. this information used chain validation only determine whether account authorized transact asset type which enforces whitelist, but third parties can use this information for other uses well, long does not conflict with the use whitelisted assets. asset which enforces whitelist specifies list accounts maintain its whitelist, and list accounts maintain its blacklist. order for given account hold and transact whitelisted asset must whitelisted least one s's whitelist_authorities and blacklisted none s's blacklist_authorities. receives balance and later removed from the whitelist(s) which allowed hold added any blacklist specifies authoritative, a's balance will frozen until a's authorization reinstated. return the signed transaction changing the whitelisting status parameters authorizing_account: the account who doing the whitelisting account_to_list: the account being whitelisted new_listing_status: the new whitelisting status broadcast: true broadcast the transaction the network get_vesting_balances vector graphene::wallet::wallet_api::get_vesting_balances(string account_name) get information about vesting balance object. parameters account_name: account name, account id, vesting balance object id. withdraw_vesting signed_transaction graphene::wallet::wallet_api::withdraw_vesting(string witness_name, string amount, string asset_symbol, bool broadcast false) withdraw vesting balance. parameters witness_name: the account name the witness, also accepts account vesting balance type. amount: the amount withdraw. asset_symbol: the symbol the asset withdraw. broadcast: true you wish broadcast the transaction get_account account_object graphene::wallet::wallet_api::get_account(string account_name_or_id) const returns information about the given account. return the public account data stored the blockchain parameters account_name_or_id: the name the account provide information about get_account_id account_id_type graphene::wallet::wallet_api::get_account_id(string account_name_or_id) const lookup the named account. return the the named account parameters account_name_or_id: the name the account look get_account_history vector graphene::wallet::wallet_api::get_account_history(string name, int limit) const returns the most recent operations the named account. this returns list operation history objects, which describe activity the account. return list operation_history_objects parameters name: the name the account limit: the number entries return (starting from the most recent) approve_proposal signed_transaction graphene::wallet::wallet_api::approve_proposal(const string &fee_paying_account, const string &proposal_id, const approval_delta &delta, bool broadcast) approve disapprove proposal. return the signed version the transaction parameters fee_paying_account: the account paying the fee for the op. proposal_id: the proposal modify. delta: members contain approvals create remove. json you can leave empty members undefined. broadcast: true you wish broadcast the transaction get_account_cycle_balance acc_id_share_t_res graphene::wallet::wallet_api::get_account_cycle_balance(const string& account) const get the amount cycles the account. return cycle balance the account. parameters account: account name stringified id. get_full_cycle_balances acc_id_vec_cycle_agreement_res graphene::wallet::wallet_api::get_full_cycle_balances(const string& account) const deprecated purchase_cycle_asset signed_transaction graphene::wallet::wallet_api::purchase_cycle_asset(string account, string amount_to_sell, string symbol_to_sell, double frequency, double amount_of_cycles_to_receive, bool broadcast false) purchase cycles. parameters account: account name amount_to_sell: amount asset sell symbol_to_sell: symbol asset sell frequency: frequency which buy amount_of_cycles_to_receive: amount cycles receive this buy calculate_cycle_price optional graphene::wallet::wallet_api::calculate_cycle_price(share_type cycle_amount, asset_id_type asset_id) const calculates and returns the amount asset one needs pay get the given amount cycles return cycle_price structure (optional) parameters cycle_amount: desired amount cycles get asset_id_type: asset pay get_dascoin_balance acc_id_share_t_res graphene::wallet::wallet_api::get_dascoin_balance(const string& account) const get amount dascoin for account. return object containing dascoin balance account parameters account: account name stringified id. ... wire out calls wire_out signed_transaction graphene::wallet::wallet_api::wire_out(const string& account, share_type amount, bool broadcast) const wire out some webasset return the signed transaction wiring out webasset parameters account: account name stringified amount: the amount wire out broadcast: true broadcast the transaction the network wire_out_with_fee signed_transaction graphene::wallet::wallet_api::wire_out_with_fee(const string& account, share_type amount, const string& currency_of_choice, const string& to_address, const string& memo, bool broadcast) const wire out with fee some webasset return the signed transaction wiring out webasset parameters account: account name stringified amount: the amount wire out ... currency_of_choice: currency choice (string abbreviation) which user wants wire out to_address: destination blockchain address which the amount needs wired memo: optional note broadcast: true broadcast the transaction the network trading calls sell_asset signed_transaction graphene::wallet::wallet_api::sell_asset(string seller_account, string amount_to_sell, string symbol_to_sell, string min_to_receive, string symbol_to_receive, uint_t timeout_sec bool fill_or_kill false, bool broadcast false) place limit order attempting sell one asset for another. buying and selling are the same operation graphene; you want buy dasc with usd, you should sell usd for dasc. the blockchain will attempt sell the symbol_to_sell for much symbol_to_receive possible, long the price least min_to_receive amount_to_sell. addition the transaction fees, market fees will apply specified the issuer both the selling asset and the receiving asset percentage the amount exchanged. either the selling asset the receiving asset whitelist restricted, the order will only created the seller the whitelist the restricted asset type. market orders are matched the order they are included the blockchain. return the signed transaction selling the funds parameters seller_account: the account providing the asset being sold, and which will receive the proceeds the sale. amount_to_sell: the amount the asset being sold sell (in nominal units) symbol_to_sell: the name the asset sell min_to_receive: the minimum amount you are willing receive return for selling the entire amount_to_sell symbol_to_receive: the name the asset you wish receive timeout_sec: the order does not fill immediately, this the length time the order will remain the order books before cancelled and the un-spent funds are returned the seller's account fill_or_kill: true, the order will only included the blockchain filled immediately; false, open order will left the books fill any amount that cannot filled immediately. broadcast: true broadcast the transaction the network sell signed_transaction graphene::wallet::wallet_api::sell(string seller_account, string base, string quote, string rate, double amount, bool broadcast false) place limit order attempting sell one asset for another. this api call abstracts away some the details the sell_asset() call more user friendly. all orders placed with sell never timeout and will not killed they cannot filled immediately. you wish for one these parameters different, then sell_asset() should used instead. return the signed transaction selling the funds parameters seller_account: the account providing the asset being sold, and which will receive the proceeds the sale. base: the name the asset sell. quote: the name the asset receive. rate: the rate base:quote which you want sell. amount: the amount base you want sell. broadcast: true broadcast the transaction the network buy signed_transaction graphene::wallet::wallet_api::buy(string buyer_account, string base, string quote, double rate, double amount, bool broadcast false) place limit order attempting buy one asset with another. this api call abstracts away some the details the sell_asset() call more user friendly. all orders placed with buy never timeout and will not killed they cannot filled immediately. you wish for one these parameters different, then sell_asset() should used instead return the signed transaction buying the funds parameters buyer_account: the account buying the asset for another asset base: the name the asset buy. quote: the name the asset being offered payment. rate: the rate base:quote which you want buy. amount: the amount base you want buy. broadcast: true broadcast the transaction the network borrow_asset signed_transaction graphene::wallet::wallet_api::borrow_asset(string borrower_name, string amount_to_borrow, string asset_symbol, string amount_of_collateral, bool broadcast false) borrow asset update the debt/collateral ratio for the loan. this the first step shorting asset. call sell_asset() complete the short. return the signed transaction borrowing the asset parameters borrower_name: the name the account associated with the transaction. amount_to_borrow: the amount the asset being borrowed. make this value negative pay back debt. asset_symbol: the symbol the asset being borrowed. amount_of_collateral: the amount the backing asset add your collateral position. make this negative claim back some your collateral. the backing asset defined the bitasset_options for the asset being borrowed. broadcast: true broadcast the transaction the network cancel_order signed_transaction graphene::wallet::wallet_api::cancel_order(object_id_type order_id, bool broadcast false) cancel existing order return the signed transaction canceling the order parameters order_id: the order cancelled broadcast: true broadcast the transaction the network settle_asset signed_transaction graphene::wallet::wallet_api::settle_asset(string account_to_settle, string amount_to_settle, string symbol, bool broadcast false) schedules market-issued asset for automatic settlement. holders market-issued assets may request forced settlement for some amount their asset. this means that the specified sum will locked the chain and held for the settlement period, after which time the chain will choose margin position holder and buy the settled asset using the margin collateral. the price this sale will based the feed price for the market-issued asset being settled. the exact settlement price will the feed price the time settlement with offset favor the margin position, where the offset blockchain parameter set the global_property_object. return the signed transaction settling the named asset parameters account_to_settle: the name the account owning the asset amount_to_settle: the amount the named asset schedule for settlement symbol: the name the asset settlement broadcast: true broadcast the transaction the network get_market_history vector graphene::wallet::wallet_api::get_market_history(string symbol, string symbol, uint_t bucket, fc::time_point_sec start, fc::time_point_sec end) const get_limit_orders vector graphene::wallet::wallet_api::get_limit_orders(string string uint_t limit) const get_call_orders vector graphene::wallet::wallet_api::get_call_orders(string uint_t limit) const get_settle_orders vector graphene::wallet::wallet_api::get_settle_orders(string uint_t limit) const ... asset calls list_assets vector graphene::wallet::wallet_api::list_assets(const string &lowerbound, uint_t limit) const lists all assets registered the blockchain. list all assets, pass the empty string for the lowerbound start the beginning the list, and iterate necessary. return the list asset objects, ordered symbol parameters lowerbound: the symbol the first asset include the list. limit: the maximum number assets return (max: create_asset signed_transaction graphene::wallet::wallet_api::create_asset(string issuer, string symbol, uint_t precision, asset_options common, fc::optional bitasset_opts, bool broadcast false) creates new user-issued market-issued asset. many options can changed later using update_asset(). right now this function difficult use because you must provide raw json data structures for the options objects, and those include prices and asset ids. return the signed transaction creating new asset parameters issuer: the name the account who will pay the fee and become the issuer the new asset. this can updated later symbol: the ticker symbol the new asset precision: the number digits precision the right the decimal point, must less than equal common: asset options required for all new assets. note that core_exchange_rate technically needs store the asset this new asset. since this not known the time this operation created, create this price though the new asset has instance and the chain will overwrite with the new asset's id. bitasset_opts: options specific bitassets. this may null unless the market_issued flag set common.flags broadcast: true broadcast the transaction the network update_asset signed_transaction graphene::wallet::wallet_api::update_asset(string symbol, optional new_issuer, asset_options new_options, bool broadcast false) update the core options asset. there are number options which all assets the network use. these options are enumerated the asset_object::asset_options struct. this command used update these options for existing asset. note: this operation cannot used update bitasset-specific options. for these options, update_bitasset() instead. return the signed transaction updating the asset parameters symbol: the name the asset update new_issuer: changing the asset's issuer, the name the new issuer. null you wish remain the issuer the asset new_options: the new asset_options object, which will entirely replace the existing options. broadcast: true broadcast the transaction the network update_bitasset signed_transaction graphene::wallet::wallet_api::update_bitasset(string symbol, bitasset_options new_options, bool broadcast false) update the options specific bitasset. bitassets have some options which are not relevant other asset types. this operation used update those options existing bitasset. see update_asset() return the signed transaction updating the bitasset parameters symbol: the name the asset update, which must market-issued asset new_options: the new bitasset_options object, which will entirely replace the existing options. broadcast: true broadcast the transaction the network update_asset_feed_producers signed_transaction graphene::wallet::wallet_api::update_asset_feed_producers(string symbol, flat_set new_feed_producers, bool broadcast false) update the set feed-producing accounts for bitasset. bitassets have price feeds selected taking the median values recommendations from set feed producers. this command used specify which accounts may produce feeds for given bitasset. return the signed transaction updating the bitasset's feed producers parameters symbol: the name the asset update new_feed_producers: list account names ids which are authorized produce feeds for the asset. this list will completely replace the existing list broadcast: true broadcast the transaction the network publish_asset_feed signed_transaction graphene::wallet::wallet_api::publish_asset_feed(string publishing_account, string symbol, price_feed feed, bool broadcast false) publishes price feed for the named asset. price feed providers use this command publish their price feeds for market-issued assets. price feed used tune the market for particular market-issued asset. for each value the feed, the median across all committee_member feeds for that asset calculated and the market for the asset configured with the median that value. the feed object this command contains three prices: call price limit, short price limit, and settlement price. the call limit price structured (collateral asset) (debt asset) and the short limit price structured (asset for sale) (collateral asset). note that the asset ids are opposite each other, we're publishing feed for usd, the call limit price will core/usd and the short limit price will usd/core. the settlement price may flipped either direction, long ratio between the marketissued asset and its collateral. return the signed transaction updating the price feed for the given asset parameters publishing_account: the account publishing the price feed symbol: the name the asset whose feed we're publishing feed: the price_feed object containing the three prices making the feed broadcast: true broadcast the transaction the network issue_asset signed_transaction graphene::wallet::wallet_api::issue_asset(string to_account, string amount, string symbol, string memo, bool broadcast false) issue new shares asset. return the signed transaction issuing the new shares parameters to_account: the name the account receive the new shares amount: the amount issue, nominal units symbol: the ticker symbol the asset issue memo: memo include the transaction, readable the recipient broadcast: true broadcast the transaction the network issue_webasset signed_transaction graphene::wallet::wallet_api::issue_webasset(string to_account, string amount, string reserved, bool broadcast false) issue webasset account's balance. return the signed transaction issuing webasset parameters to_account: the name the account receive the new shares amount: the amount issue, nominal units reserved: reserved amount issue, nominal units broadcast: true broadcast the transaction the network get_asset asset_object graphene::wallet::wallet_api::get_asset(string asset_name_or_id) const returns information about the given asset. return the information about the asset stored the blockchain parameters asset_name_or_id: the symbol the asset question get_asset_id asset_id_type graphene::wallet::wallet_api::get_asset_id(string asset_name_or_id) const lookup the named asset. return the the given asset parameters asset_name_or_id: the symbol the asset question get_bitasset_data asset_bitasset_data_object graphene::wallet::wallet_api::get_bitasset_data(string asset_name_or_id) const returns the bitasset-specific data for given asset. market-issued assets's behavior are determined both their "bitasset data" and their basic asset data, returned get_asset(). return the bitasset-specific data for this asset parameters asset_name_or_id: the symbol the bitasset question fund_asset_fee_pool signed_transaction graphene::wallet::wallet_api::fund_asset_fee_pool(string from, string symbol, string amount, bool broadcast false) pay into the fee pool for the given asset. user-issued assets can optionally have pool the core asset which automatically used pay transaction fees for any transaction using that asset (using the asset's core exchange rate). this command allows anyone deposit the core asset into this fee pool. return the signed transaction funding the fee pool parameters from: the name the account sending the core asset symbol: the name the asset whose fee pool you wish fund amount: the amount the core asset deposit broadcast: true broadcast the transaction the network reserve_asset signed_transaction graphene::wallet::wallet_api::reserve_asset(string from, string amount, string symbol, bool broadcast false) burns the given user-issued asset. this command burns the user-issued asset reduce the amount circulation. note: you cannot burn market-issued assets. return the signed transaction burning the asset parameters from: the account containing the asset you wish burn amount: the amount burn, nominal units symbol: the name the asset burn broadcast: true broadcast the transaction the network global_settle_asset signed_transaction graphene::wallet::wallet_api::global_settle_asset(string symbol, price settle_price, bool broadcast false) forces global settling the given asset (black swan prediction markets). order use this operation, asset_to_settle must have the global_settle flag set. when this operation executed all balances are converted into the backing asset the settle_price and all open margin positions are called the settle price. this asset used backing for other bitassets, those bitassets will force settled their current feed price. note: this operation used only the asset issuer, settle_asset() may used any user owning the asset return the signed transaction settling the named asset parameters symbol: the name the asset force settlement settle_price: the price which settle broadcast: true broadcast the transaction the network ... licence calls issue_license signed_transaction graphene::wallet::wallet_api::issue_license(const string& issuer, const string& account, const string& license, share_type bonus_percentage, frequency_type frequency, bool broadcast false); issue license account. this will create license request object that can denied the license authentication authority. return the signed version the transaction parameters issuer: this must the license issuing chain authority. account: the account that will benefit the license. license: the the license that will granted the account. bonus_percentage: bonus percentage license base cycles issued. value must greater than frequency: frequency lock for this license. broadcast: true you wish broadcast the transaction. get_license_types vector graphene::wallet::wallet_api::get_license_types() const get all license type ids found the blockchain returns vector license type ids get_license_type_names_ids vector> graphene::wallet::wallet_api::get_license_type_names_ids() const; get names and license type ids found the blockchain. return vector license name/type-ids pairs get_license_information vector> graphene::wallet::wallet_api::get_license_information(const vector& account_ids) const; get list account issued license types. this function has semantics identical get_objects. return vector issued license information objects parameters account_ids: ids the accounts retrieve. ... reward queue calls update_queue_parameters signed_transaction graphene::wallet::wallet_api::update_queue_parameters(optional enable_dascoin_queue, optional reward_interval_time_seconds, optional dascoin_reward_amount, bool broadcast) const; update various reward queue parameters return signed transaction updating the queue parameters enable_dascoin_queue: true minting enabled reward_interval_time_seconds: the time interval between dascoin reward events dascoin_reward_amount: the amount dascoins produced the dascoin reward event broadcast: true you wish broadcast the transaction get_order_book order_book graphene::wallet::wallet_api::get_order_book(const string& base, const string& quote, unsigned limit returns the order book for the market base:quote. return order book the market parameters base: name the first asset quote: name the second asset limit: the order book. limit each asks and bids, capped prioritizes most moderate each get_reward_queue_size uint_t graphene::wallet::wallet_api::get_reward_queue_size() const gives the size the dascoin reward queue return number elements the dascoin queue get_reward_queue vector graphene::wallet::wallet_api::get_reward_queue() const gives the entire reward queue. return vector all reward queue objects get_reward_queue_by_page vector graphene::wallet::wallet_api::get_reward_queue_by_page(uint_t from, uint_t amount) const returns part the reward queue. return vector reward queue objects parameters from: starting page amount: number pages get get_queue_submissions_with_pos acc_id_queue_subs_w_pos_res get_queue_submissions_with_pos(account_id_type account_id) const get all current submissions reward queue account return all elements dascoin reward queue submitted given account parameters account_id: account whose submissions should returned ... requests inspection get_all_webasset_issue_requests vector graphene::app::database_api::get_all_webasset_issue_requests() const get all webasset issue request objects, sorted expiration. return vector webasset issue request objects. get_all_wire_out_holders vector graphene::app::database_api::get_all_wire_out_holders() const get all wire out holder objects. return vector wire out holder objects. get_all_wire_out_with_fee_holder vector graphene::app::database_api::get_all_wire_out_with_fee_holders() const get all wire out with fee holder objects. return vector wire out with fee holder objects. ... governance create_committee_member signed_transaction graphene::wallet::wallet_api::create_committee_member(string owner_account, string url, bool broadcast false) creates committee_member object owned the given account. account can have most one committee_member object. return the signed transaction registering committee_member parameters owner_account: the name the account which creating the committee_member url: url include the committee_member record the blockchain. clients may display this when showing list committee_members. may blank. broadcast: true broadcast the transaction the network get_witness witness_object graphene::wallet::wallet_api::get_witness(string owner_account) returns information about the given witness. return the information about the witness stored the blockchain parameters owner_account: the name the witness account owner, the the witness get_committee_member committee_member_object graphene::wallet::wallet_api::get_committee_member(string owner_account) returns information about the given committee_member. return the information about the committee_member stored the blockchain parameters owner_account: the name the committee_member account owner, the the committee_member list_witnesses map graphene::wallet::wallet_api::list_witnesses(const string &lowerbound, uint_t limit) lists all witnesses registered the blockchain. this returns list all account names that own witnesses, and the associated witness id, sorted name. this lists witnesses whether they are currently voted not. use the lowerbound and limit parameters page through the list. retrieve all witnesses, start setting lowerbound the empty string "", and then each iteration, pass the last witness name returned the lowerbound for the next list_witnesss() call. return list witnesses mapping witness names witness ids parameters lowerbound: the name the first witness return. the named witness does not exist, the list will start the witness that comes after lowerbound limit: the maximum number witnesses return (max: list_committee_members map graphene::wallet::wallet_api::list_committee_members(const string &lowerbound, uint_t limit) lists all committee_members registered the blockchain. this returns list all account names that own committee_members, and the associated committee_member id, sorted name. this lists committee_members whether they are currently voted not. use the lowerbound and limit parameters page through the list. retrieve all committee_members, start setting lowerbound the empty string "", and then each iteration, pass the last committee_member name returned the lowerbound for the next list_committee_members() call. return list committee_members mapping committee_member names committee_member ids parameters lowerbound: the name the first committee_member return. the named committee_member does not exist, the list will start the committee_member that comes after lowerbound limit: the maximum number committee_members return (max: create_witness signed_transaction graphene::wallet::wallet_api::create_witness(string owner_account, string url, bool broadcast false) creates witness object owned the given account. account can have most one witness object. return the signed transaction registering witness parameters owner_account: the name the account which creating the witness url: url include the witness record the blockchain. clients may display this when showing list witnesses. may blank. broadcast: true broadcast the transaction the network update_witness signed_transaction graphene::wallet::wallet_api::update_witness(string witness_name, string url, string block_signing_key, bool broadcast false) update witness object owned the given account. return signed transaction parameters witness: the name the witness's owner account. also accepts the the owner account the the witness. url: same for create_witness. the empty string makes remain the same. block_signing_key: the new block signing public key. the empty string makes remain the same. broadcast: true you wish broadcast the transaction. create_worker signed_transaction graphene::wallet::wallet_api::create_worker(string owner_account, time_point_sec work_begin_date, time_point_sec work_end_date, share_type daily_pay, string name, string url, variant worker_settings, bool broadcast false) create worker object. parameters owner_account: the account which owns the worker and will paid work_begin_date: when the work begins work_end_date: when the work ends daily_pay: amount pay per day (not per maint interval) name: any text url: any text worker_settings: {"type" "burn"|"refund"|"vesting", "pay_vesting_period_days" broadcast: true you wish broadcast the transaction. update_worker_votes signed_transaction graphene::wallet::wallet_api::update_worker_votes(string account, worker_vote_delta delta, bool broadcast false) update your votes for worker parameters account: the account which will pay the fee and update votes. worker_vote_delta: {"vote_for" [...], "vote_against" [...], "vote_abstain" [...]} broadcast: true you wish broadcast the transaction. vote_for_committee_member signed_transaction graphene::wallet::wallet_api::vote_for_committee_member(string voting_account, string committee_member, bool approve, bool broadcast false) vote for given committee_member. account can publish list all committee_memberes they approve of. this command allows you add remove committee_memberes from this list. each account's vote weighted according the number shares the core asset owned that account the time the votes are tallied. note: you cannot vote against committee_member, you can only vote for the committee_member not vote for the committee_member. return the signed transaction changing your vote for the given committee_member parameters voting_account: the name the account who voting with their shares committee_member: the name the committee_member' owner account approve: true you wish vote favor that committee_member, false remove your vote favor that committee_member broadcast: true you wish broadcast the transaction vote_for_witness signed_transaction graphene::wallet::wallet_api::vote_for_witness(string voting_account, string witness, bool approve, bool broadcast false) vote for given witness. account can publish list all witnesses they approve of. this command allows you add remove witnesses from this list. each account's vote weighted according the number shares the core asset owned that account the time the votes are tallied. note: you cannot vote against witness, you can only vote for the witness not vote for the witness. return the signed transaction changing your vote for the given witness parameters voting_account: the name the account who voting with their shares witness: the name the witness' owner account approve: true you wish vote favor that witness, false remove your vote favor that witness broadcast: true you wish broadcast the transaction set_voting_proxy signed_transaction graphene::wallet::wallet_api::set_voting_proxy(string account_to_modify, optional voting_account, bool broadcast false) set the voting proxy for account. user does not wish take active part voting, they can choose allow another account vote their stake. setting vote proxy does not remove your previous votes from the blockchain, they remain there but are ignored. you later null out your vote proxy, your previous votes will take effect again. this setting can changed any time. return the signed transaction changing your vote proxy settings parameters account_to_modify: the name the account update voting_account: the name account authorized vote account_to_modify's shares, null vote your own shares broadcast: true you wish broadcast the transaction set_desired_witness_and_committee_member_count signed_transaction graphene::wallet::wallet_api::set_desired_witness_and_committee_member_count( string account_to_modify, uint_t desired_number_of_witnesses, uint_t desired_number_of_committee_members, bool broadcast false) set your vote for the number witnesses and committee_members the system. each account can voice their opinion how many committee_members and how many witnesses there should the active committee_member/active witness list. these are independent each other. you must vote your approval least many committee_members witnesses you claim there should (you can't say that there should committee_members but only vote for there are maximum values for each set the blockchain parameters (currently defaulting this setting can changed any time. your account has voting proxy set, your preferences will ignored. return the signed transaction changing your vote proxy settings parameters account_to_modify: the name the account update number_of_committee_members: the number broadcast: true you wish broadcast the transaction propose_parameter_change signed_transaction graphene::wallet::wallet_api::propose_parameter_change(const string &proposing_account, fc::time_point_sec expiration_time, const variant_object &changed_values, bool broadcast false) creates transaction propose parameter change. multiple parameters can specified atomic change desired. return the signed version the transaction parameters proposing_account: the account paying the fee propose the expiration_time: timestamp specifying when the proposal will either take effect expire. changed_values: the values change; all other chain parameters are filled with default values broadcast: true you wish broadcast the transaction propose_fee_change signed_transaction graphene::wallet::wallet_api::propose_fee_change(const string &proposing_account, fc::time_point_sec expiration_time, const variant_object &changed_values, bool broadcast false) propose fee change. return the signed version the transaction parameters proposing_account: the account paying the fee propose the expiration_time: timestamp specifying when the proposal will either take effect expire. changed_values: map operation type new fee. operations may specified name id. the "scale" key changes the scale. all other operations will maintain current values. broadcast: true you wish broadcast the transaction ... privacy mode set_key_label bool graphene::wallet::wallet_api::set_key_label(public_key_type key, string label) these methods are used for stealth transfers this method can used set the label for public key. note: two keys can have the same label. return true the label was set, otherwise false get_key_label string graphene::wallet::wallet_api::get_key_label(public_key_type key) const get_public_key public_key_type graphene::wallet::wallet_api::get_public_key(string label) const return the public key associated with the given label get_blind_accounts map graphene::wallet::wallet_api::get_blind_accounts() const return all blind accounts get_my_blind_accounts map graphene::wallet::wallet_api::get_my_blind_accounts() const return all blind accounts for which this wallet has the private key get_blind_balances vector graphene::wallet::wallet_api::get_blind_balances(string key_or_label) return the total balance all blinded commitments that can claimed the given account key label create_blind_account public_key_type graphene::wallet::wallet_api::create_blind_account(string label, string brain_key) generates new blind account for the given brain key and assigns the given label. transfer_to_blind blind_confirmation graphene::wallet::wallet_api::transfer_to_blind(string from_account_id_or_name, string asset_symbol, vector> to_amounts, bool broadcast false) transfers public balance from one more blinded balances using stealth transfer. parameters to_amounts: map from key label amount transfer_from_blind blind_confirmation graphene::wallet::wallet_api::transfer_from_blind(string from_blind_account_key_or_label, string to_account_id_or_name, string amount, string asset_symbol, bool broadcast false) transfers funds from set blinded balances public account balance. blind_transfer blind_confirmation graphene::wallet::wallet_api::blind_transfer(string from_key_or_label, string to_key_or_label, string amount, string symbol, bool broadcast false) used transfer from one set blinded balances another blind_history vector graphene::wallet::wallet_api::blind_history(string key_or_account) return all blind receipts to/form particular account receive_blind_transfer blind_receipt graphene::wallet::wallet_api::receive_blind_transfer(string confirmation_receipt, string opt_from, string opt_memo) given confirmation receipt, this method will parse for blinded balance and confirm that exists the blockchain. exists then will report the amount received and who sent it. parameters confirmation_receipt: base encoded stealth confirmation opt_from: not empty and the sender unknown public key, then the unknown public key will given the label opt_from ... blockchain inspection get_block optional graphene::wallet::wallet_api::get_block(uint_t num) get_account_count uint_t graphene::wallet::wallet_api::get_account_count() const returns the number accounts registered the blockchain get_global_properties global_property_object graphene::wallet::wallet_api::get_global_properties() const returns the block chain's slowly-changing settings. this object contains all the properties the blockchain that are fixed that change only once per maintenance interval (daily) such the current list witnesses, committee_members, block interval, etc. see get_dynamic_global_properties() for frequently changing properties get_dynamic_global_properties dynamic_global_property_object graphene::wallet::wallet_api::get_dynamic_global_properties() const returns the block chain's rapidly-changing properties. the returned object contains information that changes every block interval such the head block number, the next witness, etc. see get_global_properties() for less-frequently changing properties get_object variant graphene::wallet::wallet_api::get_object(object_id_type id) const returns the blockchain object corresponding the given id. this generic function can used retrieve any object from the blockchain that assigned id. certain types objects have specialized convenience functions return their objects e.g., assets have get_asset(), accounts have get_account(), but this function will work for any object. return the requested object parameters id: the the object return ... transaction builder begin_builder_transaction transaction_handle_type graphene::wallet::wallet_api::begin_builder_transaction() add_operation_to_builder_transaction void graphene::wallet::wallet_api::add_operation_to_builder_transaction(transactio n_handle_type transaction_handle, const operation &op) replace_operation_in_builder_transaction void graphene::wallet::wallet_api::replace_operation_in_builder_transaction(transa ction_handle_type handle, unsigned operation_index, const operation &new_op) set_fees_on_builder_transaction asset graphene::wallet::wallet_api::set_fees_on_builder_transaction(transaction_han dle_type handle, string fee_asset graphene_symbol) preview_builder_transaction transaction graphene::wallet::wallet_api::preview_builder_transaction(transaction_handle_ type handle) sign_builder_transaction signed_transaction graphene::wallet::wallet_api::sign_builder_transaction(transaction_handle_typ transaction_handle, bool broadcast true) propose_builder_transaction signed_transaction graphene::wallet::wallet_api::propose_builder_transaction(transaction_handle_ type handle, time_point_sec expiration time_point::now()+fc::minutes(), uint_t review_period_seconds bool broadcast true) propose_builder_transaction signed_transaction graphene::wallet::wallet_api::propose_builder_transaction(transaction_handle _type handle, string account_name_or_id, time_point_sec expiration time_point::now()+fc::minutes(), uint_t review_period_seconds bool broadcast true) remove_builder_transaction void graphene::wallet::wallet_api::remove_builder_transaction(transaction_handle_t ype handle) serialize_transaction string graphene::wallet::wallet_api::serialize_transaction(signed_transaction tx) const converts signed_transaction json form its binary representation. return the binary form the transaction. will not hex encoded, this returns raw string that may have null characters embedded parameters tx: the transaction serialize sign_transaction signed_transaction graphene::wallet::wallet_api::sign_transaction(signed_transaction tx, bool broadcast false) signs transaction. given fully-formed transaction that only lacking signatures, this signs the transaction with the necessary keys and optionally broadcasts the transaction return the signed version the transaction parameters tx: the unsigned transaction broadcast: true you wish broadcast the transaction sign_transaction_with_keys signed_transaction graphene::wallet::wallet_api::sign_transaction(signed_transaction tx, std::vector wif_keys, bool broadcast false) signs transaction. given fully-formed transaction that only lacking signatures and list keys, this signs the transaction and optionally broadcasts the transaction return the signed version the transaction parameters tx: the unsigned transaction wif_keys: list keys broadcast: true you wish broadcast the transaction get_prototype_operation operation graphene::wallet::wallet_api::get_prototype_operation(string operation_type) returns uninitialized object representing given blockchain operation. this returns defaultinitialized object the given type; can used during early development the wallet when don't yet have custom commands for creating all the operations the blockchain supports. any operation the blockchain supports can created using the transaction builder's add_operation_to_builder_transaction() but that from the cli you need know what the json form the operation looks like. this will give you template you can fill in. it's better than nothing. return default-constructed operation the given type parameters operation_type: the type operation return, must one the operations defined graphene/chain/operations.hpp (e.g., "global_parameters_update_operation") appendix operations here full list our operations and their details. transfer_operation transfer amount from one account another. fees are paid the "from" account parameters asset fee account_id_type from: account transfer asset from. account_id_type to: account transfer asset to. asset amount: the amount asset transfer from from to. optional memo: user provided data encrypted the memo key the "to" account. extensions_type extensions precondition amount.amount fee.amount from postcondition from account's balance will reduced fee and amount account's balance will increased amount limit_order_create_operation instructs the blockchain attempt sell one asset for another. the blockchain will atempt sell amount_to_sell.asset_id for much min_to_receive.asset_id possible. the fee will paid the seller's account. market fees will apply specified the issuer both the selling asset and the receiving asset percentage the amount exchanged. either the selling asset the receiving asset white list restricted, the order will only created the seller the white list the restricted asset type. market orders are matched the order they are included the blockchain. parameters asset fee account_id_type seller asset amount_to_sell asset min_to_receive share_type reserved_amount optional account_to_credit time_point_sec expiration time_point_sec::maximum() bool fill_or_kill false: this flag set the entire order must filled the operation rejected extensions_type extensions limit_order_cancel_operation used cancel existing limit order. both fee_pay_account and the account receive the proceeds must the same order->seller. returns the amount actually refunded parameters asset fee limit_order_id_type order account_id_type fee_paying_account extensions_type extensions call_order_update_operation this operation can used add collateral, cover, and adjust the margin call price for particular user. for prediction markets the collateral and debt must always equal. this operation will fail would trigger margin call that couldn't filled. the margin call hits the call price limit then will fail the call price above the settlement price. note: this operation can used force market order using the collateral without requiring outside funds. parameters asset fee account_id_type funding_account: pays fee, collateral, and cover asset delta_collateral: the amount collateral add the margin position asset delta_debt: the amount the debt paid off, may negative issue new debt extensions_type extensions account_create_operation create account parameters asset fee uint_t kind: the account kind: wallet, vault, special... account_id_type registrar: this must the current registrar chain authority. account_id_type referrer: this account receives portion the fee split between registrar and referrer. must member. uint_t referrer_percent string name authority owner authority active account_options options extension extensions account_update_operation update existing account. this operation used update existing account. can used update the authorities, adjust the options the account. see account_object::options_type for the options which may updated. parameters asset fee account_id_type account: the account update. optional owner: new owner authority. set, this operation requires owner authority execute. optional active: new active authority. this can updated the current active authority. optional new_options: new account options. extension extensions account_whitelist_operation this operation used whitelist and blacklist accounts, primarily for transacting whitelisted assets. accounts can freely specify opinions about other accounts, the form either whitelisting blacklisting them. this information used chain validation only determine whether account authorized transact asset type which enforces whitelist, but third parties can use this information for other uses well, long does not conflict with the use whitelisted assets. asset which enforces whitelist specifies list accounts maintain its whitelist, and list accounts maintain its blacklist. order for given account hold and transact whitelisted asset must whitelisted least one s's whitelist_authorities and blacklisted none s's blacklist_authorities. receives balance and later removed from the whitelist(s) which allowed hold added any blacklist specifies authoritative, a's balance will frozen until a's authorization reinstated. this operation requires authorizing_account's signature, but not account_to_list's. the fee paid authorizing_account. parameters asset fee: paid authorizing_account. account_id_type authorizing_account: the account which specifying opinion another account. account_id_type account_to_list: the account being opined about. uint_t new_listing no_listing extensions_type extensions account_upgrade_operation manage account's membership status. this operation used upgrade account member, renew its subscription. account which unexpired annual subscription member publishes this operation with upgrade_to_lifetime_member set false, the account's membership expiration date will pushed backward one year. basic account publishes with upgrade_to_lifetime_member set false, the account will upgraded subscription member with expiration date one year after the processing time this operation. any account may use this operation become lifetime member setting upgrade_to_lifetime_member true. once account has become lifetime member, may not use this operation anymore. parameters asset fee account_id_type account_to_upgrade: the account upgrade; must not already lifetime member. bool upgrade_to_lifetime_member false: true, the account will upgraded lifetime member; otherwise, will add year the subscription. extensions_type extensions account_transfer_operation transfers the account another account while clearing the white list. theory account can transferred simply updating the authorities, but that kind transfer lacks semantic meaning and more often done rotate keys without transferring ownership. this operation used indicate the legal transfer title this account and break the operation history. the account_id's owner/active/voting/memo authority should set new_owner this operation will clear the account's whitelist statuses, but not the blacklist statuses. parameters asset fee account_id_type account_id account_id_type new_owner extensions_type extensions asset_create_operation creates asset parameters asset fee account_id_type issuer: this account must sign and pay the fee for this operation. later, this account may update the asset. string symbol: the ticker symbol this asset. uint_t precision number digits the right decimal point, must less than equal asset_options common_options optional bitasset_opts bool is_prediction_market false: for bitassets, set this true the asset implements prediction market; false otherwise. extensions_type extensions asset_update_operation update options common all assets. there are number options which all assets the network use. these options are enumerated the asset_options struct. this operation used update these options for existing asset. note: this operation cannot used update bitasset-specific options. for these options, use asset_update_bitasset_operation instead. parameters asset fee account_id_type issuer asset_id_type asset_to_update optional new_issuer: the asset given new issuer, specify his here. asset_options new_options extensions_type extensions precondition issuer shall existing account and must match asset_object::issuer asset_to_update fee shall nonnegative, and issuer must have sufficient balance pay new_options shall internally consistent, verified validate() postcondition asset_to_update will have options matching those new_options asset_update_bitasset_operation update options specific bitassets. bitassets have some options which are not relevant other asset types. this operation used update those options existing bitasset. parameters asset fee account_id_type issuer asset_id_type asset_to_update bitasset_options new_options extensions_type extensions precondition issuer must existing account and must match asset_object::issuer asset_to_update asset_to_update must bitasset, i.e. asset_object::is_market_issued() returns true fee must nonnegative, and issuer must have sufficient balance pay new_options shall internally consistent, verified validate() postcondition asset_to_update will have bitasset-specific options matching those new_options asset_update_feed_producers_operation update the set feed-producing accounts for bitasset. bitassets have price feeds selected taking the median values recommendations from set feed producers. this operation used specify which accounts may produce feeds for given bitasset. parameters asset fee account_id_type issuer asset_id_type asset_to_update flat_set new_feed_producers extensions_type extensions precondition issuer must existing account, and must match asset_object::issuer asset_to_update issuer must not the committee account asset_to_update must bitasset, i.e. asset_object::is_market_issued() returns true fee must nonnegative, and issuer must have sufficient balance pay cardinality new_feed_producers must not exceed chain_parameters::maximum_asset_feed_publishers postcondition asset_to_update will have set feed producers matching new_feed_producers all valid feeds supplied feed producers new_feed_producers, which were already feed producers prior execution this operation, will preserved asset_issue_operation issues asset account parameters asset fee account_id_type issuer: must asset_to_issue->asset_id->issuer. asset asset_to_issue account_id_type issue_to_account optional memo extensions_type extensions asset_reserve_operation used take asset out circulation, returning the issuer. note: you cannot use this operation market-issued assets. parameters asset fee account_id_type payer asset amount_to_reserve extensions_type extensions asset_fund_fee_pool_operation parameters asset fee: core asset account_id_type from_account asset_id_type asset_id share_type amount: core asset extensions_type extensions asset_settle_operation schedules market-issued asset for automatic settlement. holders market-issued assests may request forced settlement for some amount their asset. this means that the specified sum will locked the chain and held for the settlement period, after which time the chain will choose margin posision holder and buy the settled asset using the margin's collateral. the price this sale will based the feed price for the market-issued asset being settled. the exact settlement price will the feed price the time settlement with offset favor the margin position, where the offset blockchain parameter set the global_property_object. the fee paid account, and account must authorize this operation parameters asset fee account_id_type account: account requesting the force settlement. this account pays the fee. asset amount: amount asset force settle. this must market-issued asset. extensions_type extensions asset_global_settle_operation allows global settling bitassets (black swan prediction markets). order use this operation, asset_to_settle must have the global_settle flag set. when this operation executed all balances are converted into the backing asset the settle_price and all open margin positions are called the settle price. this asset used backing for other bitassets, those bitassets will force settled their current feed price. parameters asset fee account_id_type issuer: must equal asset_to_settle->issuer asset_id_type asset_to_settle price settle_price extensions_type extensions asset_publish_feed_operation publish price feeds for market-issued assets. price feed providers use this operation publish their price feeds for market-issued assets. price feed used tune the market for particular market-issued asset. for each value the feed, the median across all committee_member feeds for that asset calculated and the market for the asset configured with the median that value. the feed the operation contains three prices: call price limit, short price limit, and settlement price. the call limit price structured (collateral asset) (debt asset) and the short limit price structured (asset for sale) (collateral asset). note that the asset ids are opposite each other, we're publishing feed for usd, the call limit price will core/usd and the short limit price will usd/core. the settlement price may flipped either direction, long ratio between the market-issued asset and its collateral. parameters asset fee: paid for publisher account_id_type publisher asset_id_type asset_id: asset for which the feed published price_feed feed extensions_type extensions witness_create_operation create witness object, bid hold witness position the network. accounts which wish become witnesses may use this operation create witness object which stakeholders may vote approve its position witness. parameters asset fee account_id_type witness_account: the account which owns the witness. this account pays the fee for this operation string url public_key_type block_signing_key witness_update_operation update witness object's url and block signing key parameters asset fee: paid for publisher witness_id_type witness: the witness object update. account_id_type witness_account: the account which owns the witness. this account pays the fee for this operation. optional new_url: the new url. optional new_signing_key: the new block signing key. proposal_create_operation the proposal_create_operation creates transaction proposal, for use multi-sig scenarios. creates transaction proposal. the operations which compose the transaction are listed order proposed_ops, and expiration_time specifies the time which the proposal must accepted will fail permanently. the expiration_time cannot farther the future than the maximum expiration time set the global properties object. parameters asset fee account_id_type fee_paying_account vector proposed_ops time_point_sec expiration_time optional review_period_seconds extensions_type extensions proposal_update_operation this operation allows accounts add revoke approval proposed transaction. signatures sufficient satisfy the authority each account approvals are required the transaction containing this operation. account with multi-signature authority listed approvals_to_add approvals_to_remove, either all required signatures satisfy that account's authority must provided the transaction containing this operation, secondary proposal must created which contains this operation. note: the proposal requires only account's active authority, the account must not update adding its owner authority's approval. this considered error. owner approval may only added the proposal requires the owner's authority. account's owner and active authority are both required, only the owner authority may approve. attempt add remove active authority approval such proposal will fail. parameters account_id_type fee_paying_account asset fee proposal_id_type proposal flat_set active_approvals_to_add flat_set active_approvals_to_remove flat_set owner_approvals_to_add flat_set owner_approvals_to_remove flat_set key_approvals_to_add flat_set key_approvals_to_remove extensions_type extensions proposal_delete_operation the proposal_delete_operation deletes existing transaction proposal. this operation allows the early veto proposed transaction. may used any account which required authority the proposed transaction, when that account's holder feels the proposal illadvised and decides will never approve and wishes put end all discussion the issue. because required authority, could simply refuse add his approval, but this would leave the topic open for debate until the proposal expires. using this operation, can prevent any further breath from being wasted such absurd proposal. parameters account_id_type fee_paying_account bool using_owner_authority false asset fee proposal_id_type proposal extensions_type extensions withdraw_permission_create_operation create new withdrawal permission. this operation creates withdrawal permission, which allows some authorized account withdraw from authorizing account. this operation primarily useful for scheduling recurring payments. withdrawal permissions define withdrawal periods, which span time during which the authorized account may make withdrawal. any number withdrawals may made long the total amount withdrawn per period does not exceed the limit for any given period. withdrawal permissions authorize only specific pairing, i.e. permission only authorizes one specified authorized account withdraw from one specified authorizing account. withdrawals are limited and may not exceed the withdrawal limit. the withdrawal must made the same asset the limit; attempts with withdraw any other asset type will rejected. the fee for this operation paid withdraw_from_account, and this account required authorize this operation. parameters asset fee account_id_type withdraw_from_account: the account authorizing withdrawals from its balances account_id_type authorized_account: the account authorized make withdrawals from withdraw_from_account. asset withdrawal_limit: the maximum amount authorized_account allowed withdraw given withdrawal period. uint_t withdrawal_period_sec length the withdrawal period seconds. uint_t periods_until_expiration the number withdrawal periods this permission valid for. time_point_sec period_start_time: time which the first withdrawal period begins; must the future. withdraw_permission_update_operation update existing withdraw permission. this operation used update the settings for existing withdrawal permission. the accounts withdraw and from may never updated. the fields which may updated are the withdrawal limit (both amount and asset type may updated), the withdrawal period length, the remaining number periods until expiration, and the starting time the new period. fee paid withdraw_from_account, which required authorize this operation parameters asset fee account_id_type withdraw_from_account: this account pays the fee. must match permission_to_update->withdraw_from_account account_id_type authorized_account: the account authorized make withdrawals. must match permission_to_update->authorized_account withdraw_permission_id_type permission_to_update: the permission which being updated asset withdrawal_limit: new maximum amount the withdrawer allowed charge per withdrawal period uint_t withdrawal_period_sec new length the period between withdrawals. time_point_sec period_start_time: new beginning the next withdrawal period; must the future uint_t periods_until_expiration the new number withdrawal periods for which this permission will valid withdraw_permission_claim_operation withdraw from account which has published withdrawal permission. this operation used withdraw from account which has authorized such withdrawal. may executed most once per withdrawal period for the given permission. execution, amount_to_withdraw transferred from withdraw_from_account withdraw_to_account, assuming amount_to_withdraw within the withdrawal limit. the withdrawal permission will updated note that the withdrawal for the current period has occurred, and further withdrawals will not permitted until the next withdrawal period, assuming the permission has not expired. this operation may executed any time within the current withdrawal period. fee paid withdraw_to_account, which required authorize this operation parameters asset fee: paid withdraw_to_account withdraw_permission_id_type withdraw_permission: the permission authorizing this withdrawal account_id_type withdraw_from_account: must match withdraw_permission>withdraw_from_account account_id_type withdraw_to_account: must match withdraw_permision>authorized_account asset amount_to_withdraw: amount withdraw. must not exceed withdraw_permission>withdrawal_limit. optional memo: memo for withdraw_from_account. should generally encrypted with withdraw_from_account->memo_key. withdraw_permission_delete_operation delete existing withdrawal permission. this operation cancels withdrawal permission, thus preventing any future withdrawals using that permission. fee paid withdraw_from_account, which required authorize this operation parameters asset fee account_id_type withdraw_from_account: must match withdrawal_permission>withdraw_from_account. this account pays the fee account_id_type authorized_account: the account previously authorized make withdrawals. must match withdrawal_permission->authorized_account. withdraw_permission_id_type withdrawal_permission: the permission revoked committee_member_create_operation create committee_member object, bid hold committee_member seat the network. accounts which wish become committee_members may use this operation create committee_member object which stakeholders may vote approve its position committee_member. parameters asset fee account_id_type committee_member_account: the account which owns the committee_member. this account pays the fee for this operation string url committee_member_update_operation update committee_member object. currently the only field which can updated the url field. parameters asset fee committee_member_id_type committee_member: the committee member update account_id_type committee_member_account: the account which owns the committee_member. this account pays the fee for this operation optional new_url committee_member_update_global_parameters_operation used committee_members update the global parameters the blockchain. this operation allows the committee_members update the global parameters the blockchain. these control various tunable aspects the chain, including block and maintenance intervals, maximum data sizes, the fees charged the network, etc. this operation may only used proposed transaction, and proposed transaction which contains this operation must have review period specified the current global parameters before may accepted. parameters asset fee chain_parameters new_parameters vesting_balance_create_operation create vesting balance. the chain allows user create vesting balance. normally, vesting balances are created automatically part cashback and worker operations. this operation allows vesting balances created manually well. manual creation vesting balances can used stakeholder publicly demonstrate that they are committed the chain. can also used building block create transactions that function like public debt. finally, useful for testing vesting balance functionality. returns newly created vesting_balance_object parameters asset fee account_id_type creator: who provides funds initially account_id_type owner: who able withdraw the balance asset amount vesting_policy_initializer policy vesting_balance_withdraw_operation withdraw from vesting balance. withdrawal from not-completely-mature vesting balance will result paying fees parameters asset fee vesting_balance_id_type vesting_balance account_id_type owner: must vesting_balance.owner asset amount worker_create_operation create new worker object parameters asset fee account_id_type owner time_point_sec work_begin_date time_point_sec work_end_date share_type daily_pay string name string url worker_initializer initializer: this should set the initializer appropriate for the type worker created custom_operation provides generic way add higher level protocols top witness consensus. there validation for this operation other than that required auths are valid and fee paid that appropriate for the data contained. parameters asset fee account_id_type payer flat_set required_auths uint_t vector data assert_operation assert that some conditions are true. this operation performs changes the database state, but can but used verify pre post conditions for other operations. parameters asset fee account_id_type fee_paying_account vector predicates flat_set required_auths extensions_type extensions balance_claim_operation claim balance balanc_object. this operation used claim the balance given balance_object. the balance object contains vesting balance, total_claimed must not exceed balance_object::available the time evaluation. the object contains non-vesting balance, total_claimed must the full balance the object. parameters asset fee account_id_type deposit_to_account balance_id_type balance_to_claim public_key_type balance_owner_key asset total_claimed override_transfer_operation allows the issuer asset transfer asset from any account any account they have override_authority. parameters asset fee account_id_type issuer account_id_type from: account transfer asset from account_id_type to: account transfer asset asset amount: the amount asset transfer from from optional memo: user provided data encrypted the memo key the "to" account extensions_type extensions precondition amount.asset_id->issuer issuer issuer from because this pointless, use normal transfer operation transfer_to_blind_operation converts public account balance blinded stealth balance. parameters asset fee asset amount account_id_type from blind_factor_type blinding_factor vector outputs blind_transfer_operation transfers from blind blind. there are two ways transfer value while maintaining privacy: account account with amount kept secret stealth transfers with amount sender/receiver kept secret when doing account account transfers, everyone with access the memo key can see the amounts, but they will not have access the funds. when using stealth transfers the same key used for control and reading the memo. this operation more expensive than normal transfer and has fee proportional the size the operation. all assets blind transfer must the same type: fee.asset_id the fee_payer the temp account and can funded from the blinded values. using this operation you can transfer from account and/or blinded balances account and/or blinded balances. stealth transfers: assuming receiver has key pair r,r and has shared public key with sender assuming sender has key pair s,s generate one time key pair o,o s.child(nonce) where nonce can inferred from transaction calculate secret o*r blinding_factor sha(v) memo encrypted via aes owner r.child(sha(blinding_factor)) sender gives receiver output complete the payment. this process can also used send money cold wallet without having pre-register any accounts. outputs are assigned the same ids the inputs until more input ids are available, which case the return value will the first allocated for output. additional output ids are allocated sequentially thereafter. there are fewer outputs than inputs then the input ids are freed and never used again. parameters asset fee vector inputs vector outputs transfer_from_blind_operation converts blinded/stealth balance public account balance. parameters asset fee asset amount account_id_type blind_factor_type blinding_factor vector inputs asset_claim_fees_operation used transfer accumulated fees back the issuer's balance parameters asset fee account_id_type issuer asset amount_to_claim extensions_type extensions preconditions amount_to_claim.asset_id->issuer must issuer board_update_chain_authority_operation used board members update chain authorities. this operation allows the committee members update chain authority the global properties object the blockchain. the kind must match the number assigned said authority. this operation may only used proposed transaction, and proposed transaction which contains this operation must have review period specified the current global parameters before may accepted. parameters asset fee string kind account_id_type account account_id_type committee_member_account update_queue_parameters_operation parameters asset fee account_id_type issuer optional enable_dascoin_queue optional reward_interval_time_seconds optional dascoin_reward_amount extensions_type extensions create_license_type_operation create new type license. must signed the current license_administration authority. parameters asset fee account_id_type admin string name share_type amount string kind upgrade_multiplier_type balance_multipliers upgrade_multiplier_type requeue_multipliers upgrade_multiplier_type return_multipliers share_type eur_limit issue_license_operation request license granted account. grant license account. this operation must signed the current license_issuer authority. parameters asset fee account_id_type issuer account_id_type account license_type_id_type license share_type bonus_percentage frequency_type frequency_lock time_point_sec activated_at extensions_type extensions tether_accounts_operation tethers vault and wallet account together. parameters asset fee account_id_type wallet_account account_id_type vault_account extensions_type extensions asset_create_issue_request_operation for dual authority issued assets, create asset issue request that can denied the asset authenticator. note: you cannot use this operation single issuer assets. parameters asset fee account_id_type issuer account_id_type receiver share_type amount asset_id_type asset_id share_type reserved_amount string unique_id string comment extensions_type extensions asset_deny_issue_request_operation the asset authenticator dual authentication issuing asset, deny asset issue request. parameters asset fee account_id_type authenticator issue_asset_request_id_type request extensions_type extensions wire_out_operation parameters asset fee account_id_type account asset asset_to_wire string memo extensions_type extensions wire_out_complete_operation parameters asset fee account_id_type wire_out_handler wire_out_holder_id_type holder_object_id extensions_type extensions wire_out_reject_operation parameters asset fee account_id_type wire_out_handler wire_out_holder_id_type holder_object_id extensions_type extensions transfer_vault_to_wallet_operation transfers assets from tethered vault its parent wallet, with limits enforced. parameters asset fee account_id_type from_vault account_id_type to_wallet asset asset_to_transfer share_type reserved_to_transfer extensions_type extensions transfer_wallet_to_vault_operation transfers assets from tethered vault its parent wallet. limits are enforced. parameters asset fee account_id_type from_wallet account_id_type to_vault asset asset_to_transfer share_type reserved_to_transfer extensions_type extensions submit_reserve_cycles_to_queue_operation request issue cycles account. authorized cycle issuing authority can request issue certain amount cycles. independent authorized cycle authentication authority must inspect and approve this request. parameters asset fee account_id_type issuer account_id_type account share_type amount frequency_type frequency_lock string comment extensions_type extensions submit_cycles_to_queue_operation submit cycles the dascoin distribution queue. user can submit their cycles the dascoin distribution queue where they await minted. asset fee account_id_type account share_type amount frequency_type frequency string comment extensions_type extensions change_public_keys_operation parameters asset fee account_id_type account optional active optional owner extensions_type extensions update_global_frequency_operation parameters asset fee account_id_type authority frequency_type frequency string comment extensions_type extensions issue_free_cycles_operation parameters asset fee account_id_type authority uint_t origin account_id_type account share_type amount string comment extensions_type extensions edit_license_type_operation parameters asset fee account_id_type authority license_type_id_type license_type optional name optional amount optional eur_limit update_euro_limit_operation allows the authority disable enable the euro limit account. parameters asset fee account_id_type authority account_id_type account bool disable_limit optional eur_limit string comment extensions_type extensions submit_cycles_to_queue_by_license_operation submit cycles license the dascoin distribution queue. user can submit their cycles the dascoin distribution queue where they await minted. parameters asset fee account_id_type account share_type amount license_type_id_type license_type frequency_type frequency_lock string comment extensions_type extensions update_license_operation update license issued account. update license issued account. this operation must signed the current license_issuer authority. parameters asset fee account_id_type authority account_id_type account license_type_id_type license optional bonus_percentage optional frequency_lock optional activated_at extensions_type extensions issue_cycles_to_license_operation parameters asset fee account_id_type authority account_id_type account license_type_id_type license share_type amount string origin string comment extensions_type extensions remove_root_authority_operation parameters asset fee account_id_type root_account: root account whose authority will revoke. this account pays the fee for this operation. string comment create_witness_operation parameters asset fee account_id_type authority: root account authority. this account pays the fee for this operation. account_id_type witness_account: existing account that want promote into master node candidate. public_key_type block_signing_key: public key that used for signing blocks. string url string comment update_witness_operation parameters asset fee witness_id_type witness account_id_type authority: root account authority. this account pays the fee for this operation optional witness_account: existing account that want promote into master node candidate. optional block_signing_key: public key that used for signing blocks. optional url optional comment remove_witness_operation parameters asset fee witness_id_type witness account_id_type authority: root account authority. this account pays the fee for this operation optional comment activate_witness_operation parameters asset fee witness_id_type witness account_id_type authority: root account authority. this account pays the fee for this operation optional comment deactivate_witness_operation parameters asset fee witness_id_type witness account_id_type authority: root account authority. this account pays the fee for this operation optional comment create_upgrade_event_operation parameters asset fee account_id_type upgrade_creator time_point_sec execution_time optional cutoff_time vector subsequent_execution_times string comment extensions_type extensions update_upgrade_event_operation parameters asset fee account_id_type upgrade_creator upgrade_event_id_type upgrade_event_id optional execution_time optional cutoff_time optional> subsequent_execution_times optional comment extensions_type extensions delete_upgrade_event_operation parameters asset fee account_id_type upgrade_creator upgrade_event_id_type upgrade_event_id extensions_type extensions remove_vault_limit_operation allows the authority remove limits all vaults system parameters asset fee account_id_type authority string comment extensions_type extensions change_operation_fee_operation request change fee for particular operation parameters asset fee account_id_type issuer uint_t new_fee unsigned op_num string comment extensions_type extensions change_fee_pool_account_operation request change fee for particular operation parameters asset fee account_id_type issuer account_id_type fee_pool_account_id string comment extensions_type extensions purchase_cycle_asset_operation parameters asset fee account_id_type wallet_id share_type amount frequency_type frequency share_type expected_amount extensions_type extensions transfer_cycles_from_licence_to_wallet_operation parameters asset fee account_id_type vault_id license_type_id_type license_id share_type amount account_id_type wallet_id extensions_type extensions wire_out_with_fee_operation parameters asset fee account_id_type account asset asset_to_wire string currency_of_choice string to_address string memo extensions_type extensions wire_out_with_fee_complete_operation parameters asset fee account_id_type wire_out_handler wire_out_with_fee_holder_id_type holder_object_id extensions_type extensions wire_out_with_fee_reject_operation parameters asset fee account_id_type wire_out_handler wire_out_with_fee_holder_id_type holder_object_id extensions_type extensions set_starting_cycle_asset_amount_operation sets global value for starting amount cycles new accounts. changes the value global property starting_cycle_asset_amount, that represents number cycles that given each new wallet custodian account. parameters asset fee account_id_type issuer: operation issuer, must root authority uint_t new_amount dascoin_default_starting_cycle_asset_amount: value set the amount extensions_type extensions;