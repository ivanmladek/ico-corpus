multivac: high-throughput flexible public blockchain based trusted sharding computation core@mtv.ac multivac foundation june, version abstract: multivac next-generation high-performance public blockchain for industrial-scale decentralized applications. its trusted sharding technology allows for unlimited and sustainable scalability, and provides novel approach towards solving the blockchain scalability problem currently preventing mainsteam blockchains from reaching industrial capability. multivac the first propose sharding model based verifiable random functions (vrf) and applies this model transactions, computation, and storage. confirm transactions our network through classic utxo model with miners dynamically selected through probability model. multivac allows for the high levels safety and reliability needed industrial applications while only requiring processing small number nodes, producing significant speed improvements. top our fast and scalable blockchain model, multivac the first the industry provide computational model for smart contracts which allows developers flexibly decide for themselves the tradeoff between consistency, availability, and partition tolerance, parameters that are often stiffly fixed the designs many public blockchains. achieve this providing general-purpose virtual machine mvm equipped with specially designed blockchain instruction set (bisc) and powerful method validate the correctness smart contract executions (poie). with this suite breakthroughs, multivac extremely fast, totally scalable, and robustly allows for the development extremely complicated business logic its application layer, ideal blockchain serve the foundational layer public diversified blockchain ecosystem. keywords: blockchain; shard; reliability; probability model; flexibility problems with traditional blockchain blockchains must scalable achieve their full economic use society. this statement necessarily entails compromises. known that blockchain protocols suffer from the so-called "impossible triangle": impossible for single blockchain have once the three desiderata security, decentralization, and scalability. the largest public blockchains today compromise between the three features; for example, bitcoin[] and ethereum[] are secure and decentralized but are also completely unscalable. the computational power their entire network stuck the level single miner. the other hand, sharding models such zilliqa[] and dfinity[] abandon security guarantees for scalability, and models like eos[] abandon decentralization and attempt solve the performance bottleneck using supernodes. state channel technologies such plasma[] take yet another approach, taking the transactions off-chain when attempting solve the scaling issue. massive amounts research and development are already being invested into scaling blockchain, leading recent throughput levels several thousand transactions per second (e.g. eos[] and seele[] reach tps some experiments, tps transactions per second). despite this, the low hardware processing capacity single miner still the major bottleneck. these networks' speed not improve they scale node number, there significant incentive pushing them enlarge, resulting network growth underwhelming rates: noon (utc time) may there were only full nodes the ten-year-old bitcoin blockchain and only ethereum []. multivac believes that the viability blockchain for businesses today depend whether not blockchains can provide general-purpose computation, whole-network transactions, and network-wide contract processing scalable, expandable, and adaptable way. propose trusted sharding model that solves the scalability problem, allowing for the unlimited accumulation transaction power from nodes worldwide, i.e. scalability without limit. construct and exploit relationship between the network division labor and consensus reliability make our model effective. multivac performs sharding independently for transaction processing and for smart contract execution, creating incredibly supportive and flexible base-layer blockchain platform. dapps multivac can realize generalpurpose computational business logic and can flexibly decide according their own security needs how many nodes which they wish run their code. multivac solves three fundamental problems: how create shards from network nodes for transaction and smart contract processing trustworthy manner, allowing the network scale. how process transactions and update records using trusted shards the use case transaction processing. how verify the correct and honest execution smart contract code network nodes the use case smart contract processing. summarize the presentation our system this paper: multivac creates shards through novel probability model based verifiable random functions (vrf), solving the problem how safely, efficiently, and randomly shard the network. use the byzantine consensus family reach internal consensus within shard, achieving the construction trustworthy shard-based consensus. ready our blockchain for smart-contract deployment designing optimized virtual machine mvm capable general-purpose computation, which equipped with special blockchain instruction set bisc, and which verifies correctness contract execution through proof instruction execution (poie). this creates not only trusted but also flexible execution environment that allows for the execution complicated general-purpose business logic. verifiable random functions consensus algorithm mechanism for selecting bookkeeping nodes. this process, overall consideration should paid the efficiency and equitability the selection, with each honest node ideally given equal opportunity participate the bookkeeping process. this was achieved bitcoin and ethereum using proof work (pow), which guarantees that the node selection process sufficiently random and that the network regulations can only broken with the collusion over the network's total compute power. pow elegant solution that embodies the equitability inherent the paradigm decentralization, but also massively inefficient. another approach node selection the dpos algorithm represented graphene, which improves the throughput pow system but abandons randomness giving the ability for common nodes participate consensus, thus sacrificing decentralized equitability for efficiency. yet other consensus algorithms i.e. pbft (!(# complexity) and raft are equitable but difficult realize public blockchains large scale due high communication costs. multivac believes that bitcoin and ethereum have desirable degree equitability allowing all ordinary nodes have say the verification process. this property the bedrock blockchain's future development. ethereum has even designed custom hash function called ethash keep its network equitable and combat asic mining, returning bookkeeping power from specialized miners ordinary users. however, the pow system remains extremely wasteful and thus choose better node-selection process based verifiable random functions (vrf). the ideal node-selection algorithm integrates both equitability (randomness) and efficiency. decentralization the most basic value proposition blockchains, but the future blockchains also depends substantial efficiency improvements current systems. optimal method for resolving this contradiction the usage verifiable random functions (vrf), framework also used algorand[], dfinity's bls [], and cardano's ouroboros praos algorithm []. verifiable random functions satisfy the same time the requirements for equitability and efficiency. intro vrfs. vrfs are pseudorandom functions such that the functions' user can produce proof allowing all parties verify the function was calculated correctly without ever needing disclose the random function itself. our case, satisfactory vrf has the following desirable characteristics: can used verify that random number generator has provided rigorous level randomness. impossible predict control. non-interactive algorithm and can implemented with lower-cost and higher efficiency. definition and properties. formally, vrf consists three polynomial-time functions: vrf. verify able verify whether not the encrypted output value did indeed come from the vrf. evaluate calculation given the proof, the public key, and the value both vrf. generate and vrf. verify are probabilistic functions while vrf. evaluate deterministic. now, given any three polynomial-time functions and over integers such that {*} say vrf {generate, evaluate, verify} verifiable pseudorandom function with input length j(c), output length k(c), and security level l(c) the following three conditions are satisfied: then prob[vrf. verify(@a, true] st(=) where the left side the greater-than sign over coin tosses vrf. verify. vrf. generate;= {@a, ba}. vrf. generate generates the pair (public key) and (secret key) according security parameter vrf. evaluate(ba, {e(ba, d), f(ba, d)}. vrf. evaluate produces encrypted output value and proof according the private key and some input vrf. verify(@a, (true|false). unique provability: for any @a, such that for all @bck[vrf. verify(@a, ebfg] with original input taking total execution count less than equal l(c), and for any let (d, fm) ijopq.jrwstwuv(wx, @a) where @a, are generated through yz{. |g#gbjeg. now, define random event which takes two states with equal probability each. depending the state determine value for either randomly from e(ba, d): prob~: e(ba, d)a pwenou prob c: {,}x(=) require that prediction algorithm able accurately predict within the margin safety the actual state that generated e}: vrf {generate, evaluate, verify}. these functions perform the following operations: probabilistic correctness: the probability the following two conditions each not less than st(=) domain range correctness: for any {,}w(=), have e(ba, {,}x(=) complete provability: for any {,}w(=) (e, vrf. evaluate(ba, d), @bck cikopq.jrwstwuv(wx,*) e}, fm> e(ba, d)a (c)o that is, the number honest nodes sufficient reach consensus. also require that o)u =(o) and the number nodes within the shard; the horizontal variable the number in-shard nodes and the vertical variable the logarithm the bifurcation probability. (a) when (c)o (aeo)u ae)o](_s)u s(_s)u (ou)! o)u]! this simplified to: @,u (aeo)u ae)o](_s)u (ou)! o)u]! quantifying reliability: shard built with size the reliability >=(o) reaching consensus can expressed follows: >=(o) prob(constraint fails)] prob(constraint fails)] expand out >=(o) >=(o) uoo (r) om(u,u) (r) (_s)uoo uo?i!! @,u usau ,of which integrated only terms and ae, (c), =(o), note that ou, o)u and (c)o are all nonnegative integers and the integrals the above computation can transformed into discrete summations. note that >=(o) monotonic and thus invertible: knowing >=(o) can quickly calculate o(>=) and effectively estimate o(>=) through binary search. shown fig., when the node number increases continuously, the log the network bifurcation probability ssc_o >=(o)) almost linear, showing that that reliability improves exponentially example use case, suppose that the honest node proportion the entire network and adopt pbft asynchronous bft consensus((c) .)within the shard. assume that the proportion nodes failing respond =() and >=() for reference, totally synchronized bitcoin network with bitcoin has reliability value after six confirmation blocks, slightly lower than >=() under the above parameters. again suppose that the honest node proportion and that adopt the consensus (with more powerful (c) within the shard, maintaining the network severity parameter =() can also operate (c) which gives >=() and >=() with this comparison see that pbft asynchronous bft algorithm reaches higher reliability with fewer nodes, the cost the higher communication cost !(o required for consensus. transactions and consensuses using our reliability model pick and using vrf generate shards with random nodes, can decompose the entire blockchain network into several shards with each transaction designated specific shard for execution. however, with all sharding implementations challenging design appropriate mechanism sync all the shards' decisions and realize inter-shard coordination. sharding solution needs comprehensively consider the questions how ledger should generated from in-shard transactions, whether the consensus reached within shard adequately secure, and how handle transactions that straddle multiple shards. existing sharding technologies including elastico[] and zilliqa[] utilize unified shared ledger. these are able handle transactions sharded network but incur heavy cost synchronize the shards throughout the network, failing optimally solve the sharding problem its root. the other hand, the byzantine shard atomic commit (atomix) protocol designed omniledger[] conducts atomized processing each transaction but uses logic that complex and difficult engineer. multivac's utxo mechanism solves the synchronization problem. each transaction distributed the network into different shards according its account number, such that all the transactions any given account are executed the same shard. shown fig., the utxo transaction mechanism, confirmation the availability funds conducted only when funds are spent, not when funds are received. each utxo transaction takes one more previously confirmed transactions input and produces output that requires processing the recipient. using utxo mechanism and always processing particular user account within the same shard, guarantee that the write operation only performed data within the same shard and that all cross-shard data interactions our system are read-only, thereby preventing complicated crossshard logic that inhibits other technologies' effectiveness. our method simple, easy implement, and highly effective. analysis include the case smart contracts, which more complicated than the case transactions. considering series computational tasks {goe ,,, ... such that the corresponding runtime cost for each task |gd the required reliability level for each task >>d the size the shard that each task executed and the total communication cost ...d then the sharding plan within the entire network shall optimize: minimize: ...(o) --;od |gd ...d (od (gd subject to: >=(o) >=(od >>d then the shard size must satisfy: >=(o) >>. vms and instruction sets virtual machines provide excellent sandbox environment for executing smart contracts. for public chains that should capable general computation and unlimited scalability, the design the virtual machine's instruction set vital importance. mainstream virtual machines and instruction sets are rather unoptimized for complicated business logic smart contracts. thus create our own specialized blockchain-dedicated instruction set, the bisc (blockchain instruction set computer). this basis create our generalpurpose virtual machine, the multivac virtual machine (mvm). upon satisfying the reliability condition, also wish keep the cost reach consensus the entire network low possible. suppose every epoch the total transaction volume and the total number shards and suppose further that the communication time complexity reach consensus within shard the function ...(o) and the cost for single communication then terms the average number nodes shard, wish our sharding plan over the entire network satisfy: minimize ...(o) subject >=(o) design goals virtual machines need not stay virtual. the long term, blockchain virtual machine may implemented directly specialized hardware cpu. this would make blockchain transactions faster and immensely more powerful. for this >=(o) monotonic, the above optimization has deterministic solution. consensus for smart contracts: now extend our above happen, the blockchain instruction set used the virtual machine should mature and efficient, able support complicated toplayer contract logic with complicated and robust base-layer architecture. based this long-term vision, design the mvm and the bisc instruction set with the following features: instruction computer instructions standard risc-v set contains the basic instruction and four kinds extension packs mafd. support for general-purpose computation. blockchain vms today are rather limited handling complicated general-purpose computation. future smart contracts and dapps require vms not only turing-complete but also for their instruction sets support more complicated logic. support for compilation from multiple high level languages. multivac open-source ecosystem designed highly friendly developers, providing robust compilation environment for many high level languages support smooth migration existing programs onto our platform. effective use hardware, allowing for implementation our instruction set hardware computer present-day blockchain systems cause low-level hardware suffer large loss potential performance when compiling interpreting bytecode. mvm redesigns and upgrades mature cpu instruction set, holding the potential one day directly installed hardware computer. this makes possible for computers naturally become multivac nodes while still being computers used for desktop mobile purposes, and would allow for seamless switch between personal computer and miner. table bisc instruction pack instruction instruction extension description pack basic access, instructions computation and controlling operation integers multiplication and instructions division operations integers trans-processor atom instructions manipulation instructions such synchronous reading and writing etc. single-precision instructions floating number operation instructions instructions instructions instructions double-precision floating number operation instructions decimal integer operation instructions bit manipulation instructions instructions instructions signature and hash instructions encryption and decryption instructions bisc instructions rvg rvg brvi brvm brva brvl brvb brvh brvx the bisc instruction set framework currently supports compilation based llvm, the gdb debugger, and the glibc standard library. llvm (low level virtual machine) compiler framework whose purpose construct compiletime, link-time and run-time executor for any programming language. the llvm compilation framework with risc-v the back-end will eventually support high-level languages such java and go. its overall architecture shown fig. the bisc instruction set the mvm uses flexible and custom-made instruction set bisc. bisc based the outstanding reduced instruction set risc-v [], which has mature instruction architecture and excellent open-source compilation environment. bisc customizes risc-v for blockchain adding -bit instruction processing plus signature and hashing instructions for public blockchains. the development bisc will line with global open-source principles. bisc supports complete and tidy set instruction sequences shown table there are multiple sets instructions, named follows: instructions labeled with prefix are from the standard extensions defined risc-v, while those labeled brv are newly defined for bisc. the numbers following and brv refer the instruction bitwidth and the suffix signifies the instruction's functions. the suffix joint label that covers risc-v's base pack and the four standard extensions mafd. these instructions, especially rvg and rvg, have the strong support the risc-v community. additional risc-v extensions have suffix and whereas instructions newly defined for bisc have suffix and fig. llvm compilation framework based bisc the mvm virtual machine the mvm virtual machine blockchain designed support flexible computational models, capable providing efficient and verifiable execution environment for smart contracts sourced from high-level turing-complete programming languages. mvm provides applications with static code optimization, storage allocation, run-time inspection, and execution-time verification. prevent infinite-loop attacks, mvm adopts gas charges similar ethereum for each bisc instruction executed. because each executed instruction smart contract incurs charge, smart contracts must executed the most computationally efficient way possible, requiring code optimization. this, mvm will include for developers targeted suggestion and optimization engine its test environment that will provide breakdowns executed instructions and their gas costs, and will also provide the compilation environment suggestions for code optimization. other than completing execution limited time, smart contracts our flexible computational system must also verified honest work. the poie consensus algorithm directly embedded into the mvm platform achieves this, performing computation, gas charging, and verification concurrently upon every executed instruction. note that gas charges will only levied smart contract execution steps and not the computational steps required for the verification logic for gas charging itself. when instruction sequence with sufficient gas completed and verified, the node will issue the computational results through the consensus mechanism and will receive gas reward. facilitate processing, mvm provides bisc-compatible memory model that isolates computer's physical memory, providing flexible run-time support through our built-in stack and heap space. the stack space provides sufficient call depth support various types complicated data structures and may also provide batch stack operations. the heap space capable being freely allocated and supports random addressing and also provides monitoring mechanism recover used resources, sum guaranteeing memory allocation for general-purpose computation. mvm can operate all the network nodes, allowing the nodes providing computational services schedule tasks adding them their priority queues order their gas price and execute them order priority. that malicious nodes must incur high real-world physical cost order defraud, and that even they defrauded they would able receive reward but would still not able overturn the computation's verified correctness. from the perspective costs, malicious nodes thus have great incentive honestly execute computational tasks. the physical cost used poie follows: treat program executed base-layer instruction sequence. for modern computers, the cost executing this sequence far less than the cost storing this sequence memory, the physical constraint use ensure reliability. reality, the processing speed modern computers often equal that their cpu cache and far greater than their read/write speed memory. even though cpu cache can reach the same processing speed the cpu itself, even high-end cpus (i.e. the intel core series) the cache only -mb but consists its computational costs (in terms number transistors). many technologies the world are designed from similar insights. the physical foundations poie have some similarity with ethereum's mining mechanism ethash. ethash was made resist asic mining and avoid bitcoin-level miningpool centralization requiring miners not only perform hashing but also randomly and frequently read large amounts data from memory. this memory read requirement creates bottleneck for specialized asic miners, preventing mining from becoming highly specialized and centralized activity. similarly ethash, poie uses the physical discrepancy between computation and storage modern computers penalize malicious behavior. poie consensus existing sharding technologies such those proposed ethereum [], zilliqa[] and elastico[] require large number nodes per shard, usually the hundreds low thousands. dapps are composed smart contracts the public blockchain, and requiring all dapp code run hundreds thousands nodes clearly too expensive. system untrusted nodes such the blockchain, there way execute the computation task only tiny number nodes such that that the soundness both the execution process and that the obtained result are verifiable the network whole? the poie algorithm poie instruction set based consensus embedded into the virtual machine. its design philosophy consider the program execution string execution instructions. poie can verify this instruction sequence has been honestly executed network with untrustworthy nodes and can distribute appropriate economic rewards for honest execution. theoretical and realistic basics for poie preliminaries first, define anti-collision hash function with safety parameter (/) hjlh: {,}* {,}' proposed researchers tel aviv university and mit, zk-snarks[] can verify the execution program without first divulging the program's data, via solving the program's zeroknowledge proofs. zk-snarks create concise non-interactive zero knowledge proofs flattening the program transaction smart contract) into base expressions functioning much like logic gates circuit. encoding the program code into circuit and providing proof statement the verifier, zk-snarks can verify non-interactively whether not computation task has actually been executed. one might design shard-based internal consensus algorithm based zk-snarks. the benefit this that the number nodes within shard very small but they can still reach high degree consensus, one that easily verifiable the out-of-shard nodes. this very important quality have effective consensus system: the nodes which did not participate program execution can still verify that they were executed correctly. however, zk-snarks suffer from extremely high time complexity. for any program and time bound the time complexity execute zk-snark verification !(|p| [][][], and thus they are not practically applicable public blockchain systems. multivac introduces brand-new consensus algorithm called poie (proof instruction execution), proof the base layer instruction sequences. zk-snarks are purely mathematical algorithms for verification, but poie based physical computational constraints. the basic design principle multivac uses the merkle tree data structure perform verification. merkle tree tree-based data structure used for efficient verification contents. for data set {jd ... build binary merkle tree denoted *(b: follows: *(jd hjlh(d *(b: hjlh(d *(a) *(a $?<> *(b: hjlh(d *;b: ysoy/ $?<> *;b: ysoy/ #>) the classic application merkle trees blockchain are their uses packaging transactions bitcoin well the proof replication filecoin. poie requires computationally complete hidden verification function, scalable computational integrity and privacy (scip) [][][]. scip triad: scip (setup, prove, verify) and process zero knowledge verification that hides the execution proof poie prevent third party from copying the instruction set sequence. expound each the individual functions below. poie. generate({@a, ba}, bee {root u(u) root u(u) fee homomorphic hiding for any program decomposed into instruction set sequence poie allows the instruction executor (prover,,,) generate proof f(g) linear !(|g|) time which enables the verifier (verifier verify !;ssc(|g|)> time that the instruction set sequence has been correctly executed. simplify our presentation, combine the output (if any) the instruction set sequence into considers both instruction set sequence and its result. node owns public-secret key pair {@a, ba} addition another pair public-secret keys {@ee bee used hide information. first, conduct homomorphic hiding (hh) the instruction set sequence each executor, triad expanded below, the program code executed. poie. generate creates merkle tree root node from the instruction sequence and the hidden instruction sequence generated execution. these operations are executed simultaneously the cpu without recording the pseudo-code for poie. generate below: poie. generate inputs: key pair {@a, ba} hide key bee program outputs: root merkle tree root u(u) root merkle tree root u(u) prove fee procedure: run *(g) merkle tree synchronized: i{l, fee hh. generate({@a, ba}, bee *(l) merkle tree set: root u(u) root *(g) set: root u(u) root *(l) output: root u(u) root u(u) fee (generate, prove, verify). describe each operation follows: hh. generate({@a, ba}, bee {l, fee hh. generate generates hidden version the instruction set and proof fee provided the executor generate proof about and and need doubly generated below section ... the pseudo-code for hh. generate below: hh. generate inputs: key pair {@a, ba} hide key bee instruction list outputs: encrypted instruction list prove fee procedure: compute: e#bioe(g, ba) set: {@a, set: {ba, compute: fee scip. prove(bee ii) output: fee poie. prove defines interactive process requiring twophase commit protocol, meaning that another execution performed that generates new *(l), constructing proof for the challenge given the verifier, until the point where all challenges have been queried: u(.) poie. prove({@a, ba}, bee {fuo fuo fo'w l(e)} the pseudo-code poie. prove below: poie. prove inputs: key pair {@a, ba} hide key bee program challenge outputs: u(.) prove p(g) {fuo fuo fo'w l(e)} procedure: observe that encryption requires only verification and not reverse decryption. thus, may use easily computable oneway encryptions instead high-cost encryptions such elliptic curves rsa. hh. prove(bee fo'w run until finished m(g) merkle tree {l, fee hh. generate({@a, ba}, bee m(l) merkle tree synchronized: @ath.,u merkle path g(e) m(g) @ath.,u merkle path l(e)in m(l) u(.) fo'w hh. prove(bee l(e), using hh. prove generates for the executor proof corresponding the challenge proposed the verifier (true|false) hh. verify(@a, @ee fee fo'w hh. verify used the verifier check the authenticity fo'w hh. prove and hh. verify are both generated using scip. set: #rootu(u) set: iiiii {@ath.,u g(e)} compute: fuo scip. prove(bee iiiii) set: #root u(u) set: iiiii {@ath.,u l(e)} compute: fuo scip. prove(bee iiiii) u(.) output: fuo fuo fo'w l(e) the main algorithm now present the full poie algorithm. this also triad: poie (generate, prove, verify) finally, the verifier verifies the computation given its input using poie. verify: poie. verify c/@a, @ee rootu(u) rootu(u) fee p(g)ps (ebfg|...jsslg) system resources reach the reliability requirements. therefore, the decision +(o,) made may expressed as: arg min +(o,) [... (o) (g) |g|] (o) (|g|) subject >=(o) >>, (c) the pseudo-code for poie. verify below: poie. verify inputs: public key prover public key @ee root merkle tree root u(u) root merkle tree root u(u) prove fee challenge u(.) prove p(g) {fuo fuo fo'w l(e)} outputs: true false procedure: set: {root u(u) compute:%_ scip. verify(@ee fuo set: {rootu(u) compute:%$ scip. verify(@ee fuo u(.) compute:%& hh. verify c/@a, @ee l(e), fee fo'w output: where and are weight parameters. the task submitter would prefer set ignoring the needs the system order maximize his her self-interest. because this, the final decision-making power +(o,) remains with the multivac public blockchain. the user will able request reliability level and some economic considerations, but the final selection shard size and consensus algorithm are still decided the multivac program. storage, transmission computation and must noted that computers not only compute; they also store and transmit data. robust public blockchain system should able achieve the three desiderata security, scalability, and decentralization not only for computation but also for storage and transmission. this turn requires welldesigned incentive mechanisms encourage nodes contribute resources for all three. multivac the first scalable public blockchain that designs for all three dimensions blockchain robustness (computation, storage and transmission). this allows for interactive verification process executed the instruction set sequence. since the cost executing instructions much lower than that storing them memory, attacker will incur high cost they chose store copy construct this makes not cost-effective launch attack. also goes without saying that the cost storing and constructing *(g) and *(l) memory also extremely high. computation have already discussed computation the above sections. multivac the first system provide flexible sharding solution for blockchain computation, using poie verify the correctness each computation. poie provides both the actual sequence executed instructions well the instruction sequence after the homomorphic hide based the execution status inferred can easily design reward system similar the gas incentive ethereum. its reward function is: flexible sharding computation requirements consistency, availability and partition tolerance are difficult equally satisfy the design any distributed system. different contracts and dapps have different levels requirements for these properties, but almost all public blockchains have fixed compromise between them. multivac unique among public blockchains that its flexible computation model provides infrastructure guaranteeing that dapp designers have space decide their own the tradeoff between decentralization, scalability and security. given the vrf sharding process and the poie task verification process, multivac allows the users who submitted tasks select required reliability level based actual business demand, and based this select shard size and corresponding consensus mechanism. for computation task multivac allows the task submitter choose run their task inside shard with certain size order reach the reliability requirement >>. define the communication complexity reach consensus within the shard terms shard size function ...(o). also define the cost single communication function the proof (g). note that (g) the data volume that the poie algorithm needs interact with and has complexity !(ssc|g|). ...(*) fixed the consensus type chosen (i.e. asynchronous bft ba), given consensus algorithm denote the consensus-specific communication complexity ... (*) also denote the reward that miners are able receive (|*|) and the node count involved distributing the reward (o). the submitter the computation task aims achieve desired reliability level the minimum possible cost. multivac's public blockchain aims using minimum possible zgijbd (ld poie. verify) |ld poie. verify true poie. verify false storage multivac equipped with high-performance transaction processing that improves with the number nodes the network. the average realized throughout public blockchain tps and the average transaction size .kb, the blockchain ledger will have annual file size over tb. clearly, normal pcs are unable store such large ledgers and either require the usage supernodes shard storage. there are many distributed storage projects such storj[],maidsafe[] and siacoin[] and filecoin[]. filecoin[] takes ipfs[] its base mechanism, which complete decentralized and distributed storage system with addressable, versioned, and peer-to-peer file system. some wellknown blockchains including eos also adopt ipfs. slightly different from ipfs which based hash addressing, multivac also uses storage and search mechanism based merkle roots. merkel roots have many benefits. they not only enable search and retrieve data, they have the additional capability allowing search and retrieve only small chunk the data while still obtaining verification the full data's existence and authenticity. multivac supports file storage and retrieval based both hash and merkle roots. addition, multivac also includes vrf sharded storage mechanism, which distributed and decentralized storage system. similar bitcoin light nodes, the multivac nodes only store block header information, maintaining the full transaction input and output distributed storage. important note that multivac, the data storage mechanism only used internal base-layer service for the system, that the storage mechanism unable edit the data. all the rules for data generation, modification, deletion, well verification and consensus are delegated the platform's higher-level functions. the only thing that the base-layer does store and retrieve data for the higher-levels. multivac will provide reward for nodes performing both storage and computational services. transmission finally, blockchain network also must consider data transmission issues. systems utilizing sharded storage ledger reduce their storage costs exchange for increased transmission costs, though this issue may relieved somewhat ipfs has proven that the usage distributed storage also brings with distributed transmission capability, which may reduce bandwidth pressures centralized nodes. suppose blockchain node processes transactions before forming block. the entire network stores the ledger then there will disc time cost !(e) and network syncing cost !(e). use shard storage, there will disc time cost, network syncing cost !(e), and additional network communication cost for verification !(e). the transaction process likely takes place over fragmented network instead synchronized network, the time cost syncing will actually practice somewhat higher than that the local disc io, however principle sharding the ledger's storage does not increase the time complexity the transmission. discovering appropriate incentive mechanisms for data transmission remains open question academia and industry and fully effective solutions have been presented date. even the mechanisms ipfs and filecoin where storage nodes may receive rewards through two mechanisms porep and post, the storage nodes may still refuse transmit data when other nodes require due reasons such bandwidth cost. addition, data transmission may frequent such that impossible generate corresponding reward transaction for each data request, because the reward transaction itself will result its own data transmission costs, leading infinite recursion. well-designed incentive mechanism for data transmission would take into consideration issues such bandwidth, latency, transition volume, and request frequency, and these many variables cause the data transmission reward question remain unsolved problem the near-term. however, this mechanism not urgent objective data transmission never decoupled from the operations storage and computation which each already have their own incentive mechanisms. summary, multivac comprehensively considers the three dimensions computation, storage, and transmission modern blockchains, and design incentive mechanism for computation and storage. are the first scalable public blockchain that designs for all three dimensions. conclusions multivac designs high-performance public blockchain where nodes are randomly sharded based vrf and where reliability guaranteed with probability model. unlike all public blockchains available today, our flexible platform provides users smart contracts the ability self-select the balance between security, decentralization, and scalability. unlike bitcoin ethereum, the processing capacity the multivac network will continuously increased number nodes increases and the total computational power the network expands, making the blockchain infinitely scalable and capable being used myriad business and industrial applications. terms business support, our distributed computation platform provides revolutionary breakthrough the blockchain industry with our novel bisc instruction set, our mvm virtual machine and our poie consensus, and this allows our platform able supply ever-increasable level resources distributed applications. final sidenote: the name multivac derived from the name the supercomputer isaac asimov's the last question. multivac evolved from our present-day transistor based computers into entity existing hyperspace beyond gravity time, having merged with all the human souls the universe. the last days the universe, multivac finally discovers the answer the question, "how can the net amount entropy the universe massively decreased?," and thus makes the pronouncement, "let there light".) references []. satoshi nakamoto, bitcoin: peer-to-peer electronic cash system, october []. castro, liskov. practical byzantine fault tolerance. symposium operating systems design implementation, []. micali, rabin, and vadhan. verifiable random functions. proceedings the annual ieee symposium foundations computer science (focs), new york, ny, oct. []. yossi gilad, rotem hemo, silvio micali, georgios vlachos, nickolai zeldovich. algorand: scaling byzantine agreements for cryptocurrencies, mit csail, arxiv: []. boneh, lynn, and shacham. short signatures from the weil pairing. proceedings the international conference the theory and application cryptology and information security: advances cryptology, asiacrypt ',pages london, uk, springer-verlag. []. david, gazi, kiayias,and russell. ouroboros praos: adaptively-secure, semisynchronous proof-of-stake blockchain. international conference the theory applications cryptographic techniques, []. global bitcoin nodes distribution, website: https://bitnodes.earn.com/ []. ether nodes network number, website: https://www.ethernodes.org/network/ []. rosario gennaro, craig gentry, bryan parno, and mariana raykova. quadratic span programs and succinct nizks without pcps. annual international conference the theory and applications cryptographic techniques, pages springer, []. nir bitansky, alessandro chiesa, and yuval ishai. []. []. []. []. []. []. []. []. []. []. []. []. []. []. []. []. []. []. []. succinct non-interactive arguments via linear interactive proofs. springer, vitalik buterin, next-generation smart contract and decentralized application platform, gavin wood, ethereum: secure decentrailised generalised trasactioin ledger. the block.one. eos.io technical white paper. march eli ben-sasson, alessandro chiesa, daniel genkin, eran tromer, and madars virza. snarks for verifying program executions succinctly and zero knowledge. advances cryptology-crypto pages springer, luu, narayanan, zheng, baweja and gilbert.a secure sharding protocol for open blockchains.acm sigsac conference computer communications security. the zilliqa team, the zilliqa technical whitepaper, eleftherios kokoris-kogias, philipp jovanovic, linus gasser, nicolas gailly, ewa syta, bryan ford, omniledger: secure, scale-out, decentralized ledger via sharding, the seele team. seele tech whitepaper: innovate new era value internet. timo hanke, mahnush movahedi and dominic williams. dfinity technology overview series: consensus system. jan. vitalik buterin. ethereum mauve paper. diego ongaro and john ousterhout. search understandable consensus algorithm. usenix annual technical conference. june andrew waterman, krste asanovie, the risc-v instruction set manual, may juan benet. ipfs content addressed, versioned, file system. the filecoin team. filecoin: cryptocurrency operated file storage network. july shawn wilkinson, tome boshevski, josh brandoff, james prestwich, gordon hall, patrick gerbes, philip hutchins and chris pollard. storj: peer-to-peer cloud storage network. dec david vorick and luke champine. sia: simple decentralized storage. nov the maidsafe team. safe network premier: introductory guide's the world's first fully autonomous data network. feb joseph poon and vitalik buterin. plasma: scalable autonomous smart contracts. august isaac asimov. the last question. science fiction quarterly. nov