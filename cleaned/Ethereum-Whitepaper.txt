ethereum: secure decentralised generalised transaction ledger eip- revision dr. gavin wood founder, ethereum ethcore gavin@ethcore.io abstract. the blockchain paradigm when coupled with cryptographically-secured transactions has demonstrated its utility through number projects, not least bitcoin. each such project can seen simple application decentralised, but singleton, compute resource. can call this paradigm transactional singleton machine with shared-state. ethereum implements this paradigm generalised manner. furthermore provides plurality such resources, each with distinct state and operating code but able interact through message-passing framework with others. discuss its design, implementation issues, the opportunities provides and the future hurdles envisage. introduction information often lacking, and plain old prejudices are difficult shake. overall, wish provide system such that users can guaranteed that matter with which other individuals, systems organisations they interact, they can with absolute confidence the possible outcomes and how those outcomes might come about. with ubiquitous internet connections most places the world, global information transmission has become incredibly cheap. technology-rooted movements like bitcoin have demonstrated, through the power the default, consensus mechanisms and voluntary respect the social contract that possible use the internet make decentralised value-transfer system, shared across the world and virtually free use. this system can said very specialised version cryptographically secure, transaction-based state machine. follow-up systems such namecoin adapted this original "currency application" the technology into other applications albeit rather simplistic ones. ethereum project which attempts build the generalised technology; technology which all transactionbased state machine concepts may built. moreover aims provide the end-developer tightly integrated end-to-end system for building software hitherto unexplored compute paradigm the mainstream: trustful object messaging compute framework. previous work. buterin [a] first proposed the kernel this work late november, though now evolved many ways, the key functionality blockchain with turing-complete language and effectively unlimited inter-transaction storage capability remains unchanged. dwork and naor provided the first work into the usage cryptographic proof computational expenditure ("proof-of-work") means transmitting value signal over the internet. the value-signal was utilised here spam deterrence mechanism rather than any kind currency, but critically demonstrated the potential for basic data channel carry strong economic signal, allowing receiver make physical assertion without having rely upon trust. back later produced system similar vein. the first example utilising the proof-of-work strong economic signal secure currency was vishnumurthy al. []. this instance, the token was used keep peer-to-peer file trading check, ensuring "consumers" able make micro-payments "suppliers" for their services. the security model afforded the proof-of-work was augmented with digital signatures and ledger order ensure that the historical record couldn't corrupted and that malicious actors could not spoof payment unjustly complain about service delivery. five years later, nakamoto introduced another such proof-of-work-secured value token, somewhat wider scope. the fruits this project, bitcoin, became the first widely adopted global decentralised transaction ledger. other projects built bitcoin's success; the alt-coins introduced numerous other currencies through alteration the protocol. some the best known are litecoin and primecoin, discussed sprankel []. other projects sought take the core value content mechanism the driving factors. there are many goals this project; one key goal facilitate transactions between consenting individuals who would otherwise have means trust one another. this may due geographical separation, interfacing difficulty, perhaps the incompatibility, incompetence, unwillingness, expense, uncertainty, inconvenience corruption existing legal systems. specifying state-change system through rich and unambiguous language, and furthermore architecting system such that can reasonably expect that agreement will thus enforced autonomously, can provide means this end. dealings this proposed system would have several attributes not often found the real world. the incorruptibility judgement, often difficult find, comes naturally from disinterested algorithmic interpreter. transparency, being able see exactly how state judgement came about through the transaction log and rules instructional codes, never happens perfectly humanbased systems since natural language necessarily vague, ethereum: secure decentralised generalised transaction ledger protocol and repurpose it; aron discusses, for example, the namecoin project which aims provide decentralised name-resolution system. other projects still aim build upon the bitcoin network itself, leveraging the large amount value placed the system and the vast amount computation that goes into the consensus mechanism. the mastercoin project, first proposed willett [], aims build richer protocol involving many additional high-level features top the bitcoin protocol through utilisation number auxiliary parts the core protocol. the coloured coins project, proposed rosenfeld [], takes similar but more simplified strategy, embellishing the rules transaction order break the fungibility bitcoin's base currency and allow the creation and tracking tokens through special "chroma-wallet"-protocol-aware piece software. additional work has been done the area with discarding the decentralisation foundation; ripple, discussed boutellier and heinzen [], has sought create "federated" system for currency exchange, effectively creating new financial clearing system. has demonstrated that high efficiency gains can made the decentralisation premise discarded. early work smart contracts has been done szabo and miller []. around the became clear that algorithmic enforcement agreements could become significant force human cooperation. though specific system was proposed implement such system, was proposed that the future law would heavily affected such systems. this light, ethereum may seen general implementation such crypto-law system. the blockchain paradigm eip- revision identifier for the final state (though not store the final state itself--that would far too big). they also punctuate the transaction series with incentives for nodes mine. this incentivisation takes place state-transition function, adding value nominated account. mining the process dedicating effort (working) bolster one series transactions block) over any other potential competitor block. achieved thanks cryptographically secure proof. this scheme known proof-of-work and discussed detail section formally, expand to: p(s (..., ...)) p(s, (b, u(u(s, )...) where the block-finalisation state transition function function that rewards nominated party); this block, which includes series transactions amongst some other components; and the block-level statetransition function. this the basis the blockchain paradigm, model that forms the backbone not only ethereum, but all decentralised consensus-based transaction systems date. value. order incentivise computation within the network, there needs agreed method for transmitting value. address this issue, ethereum has intrinsic currency, ether, known also eth and sometimes referred the old english the smallest subdenomination ether, and thus the one which all integer values the currency are counted, the wei. one ether defined being wei. there exist other subdenominations ether: multiplier ethereum, taken whole, can viewed transaction-based state machine: begin with genesis state and incrementally execute transactions morph into some final state. this final state which accept the canonical "version" the world ethereum. the state can include such information account balances, reputations, trust arrangements, data pertaining information the physical world; short, anything that can currently represented computer admissible. transactions thus represent valid arc between two states; the 'valid' part important--there exist far more invalid state changes than valid state changes. invalid state changes might, e.g. things such reducing account balance without equal and opposite increase elsewhere. valid state transition one which comes about through transaction. formally: u(s where the ethereum state transition function. ethereum, together with are considerably more powerful then any existing comparable system; allows components carry out arbitrary computation, while allows components store arbitrary state between transactions. transactions are collated into blocks; blocks are chained together using cryptographic hash means reference. blocks function journal, recording series transactions together with the previous block and name wei szabo finney ether throughout the present work, any reference value, the context ether, currency, balance payment, should assumed counted wei. which history? since the system decentralised and all parties have opportunity create new block some older pre-existing block, the resultant structure necessarily tree blocks. order form consensus which path, from root (the genesis block) leaf (the block containing the most recent transactions) through this tree structure, known the blockchain, there must agreed-upon scheme. there ever disagreement between nodes which root-to-leaf path down the block tree the 'best' blockchain, then fork occurs. this would mean that past given point time (block), multiple states the system may coexist: some nodes believing one block contain the canonical transactions, other nodes believing some other block canonical, potentially containing radically different incompatible transactions. this avoided all costs the uncertainty that would ensue would likely kill all confidence the entire system. the scheme use order generate consensus simplified version the ghost protocol introduced ethereum: secure decentralised generalised transaction ledger sompolinsky and zohar []. this process described detail section conventions use number typographical conventions for the formal notation, some which are quite particular the present work: the two sets highly structured, 'top-level', state values, are denoted with bold lowercase greek letters. they fall into those world-state, which are denoted (or variant thereupon) and those machine-state, functions operating highly structured values are denoted with upper-case greek letter, e.g. the ethereum state transition function. for most functions, uppercase letter used, e.g. the general cost function. these may subscripted denote specialised variants, e.g. csstore the cost function for the sstore operation. for specialised and possibly externally defined functions, may format typewriter text, e.g. the keccak- hash function (as per the winning entry the sha- contest) denoted kec (and generally referred plain keccak). also kec referring the keccak hash function. tuples are typically denoted with upper-case letter, e.g. used denote ethereum transaction. this symbol may, accordingly defined, subscripted refer individual component, e.g. denotes the nonce said transaction. the form the subscript used denote its type; e.g. uppercase subscripts refer tuples with subscriptable components. scalars and fixed-size byte sequences (or, synonymously, arrays) are denoted with normal lower-case letter, e.g. used the document denote transaction nonce. those with particularly special meaning may greek, e.g. the number items required the stack for given operation. arbitrary-length sequences are typically denoted bold lower-case letter, e.g. used denote the bytesequence given the output data message call. for particularly important values, bold uppercase letter may used. throughout, assume scalars are positive integers and thus belong the set the set all byte sequences formally defined appendix such set sequences restricted those particular length, denoted with subscript, thus the set all byte sequences length named and the set all positive integers smaller than named this formally defined section square brackets are used index into and reference individual components subsequences sequences, e.g. denotes the first item the machine's stack. for subsequences, ellipses are used specify the intended range, include elements both limits, e.g. [..] denotes the first items the machine's memory. the case the global state which sequence accounts, themselves tuples, the square brackets are used reference individual account. when considering variants existing values, follow the rule that within given scope for definition, assume that the unmodified 'input' value denoted the placeholder then the modified and utilisable value denoted and intermediate values would eip- revision ** &c. very particular occasions, order maximise readability and only unambiguous meaning, may use alpha-numeric subscripts denote intermediate values, especially those particular note. when considering the use existing functions, given function the function denotes similar, elementwise version the function mapping instead between sequences. formally defined section define number useful functions throughout. one the more common which evaluates the last item the given sequence: `(x) x[kxk blocks, state and transactions having introduced the basic concepts behind ethereum, will discuss the meaning transaction, block and the state more detail. world state. the world state (state), mapping between addresses (-bit identifiers) and account states data structure serialised rlp, see appendix b). though not stored the blockchain, assumed that the implementation will maintain this mapping modified merkle patricia tree (trie, see appendix d). the trie requires simple database backend that maintains mapping bytearrays bytearrays; name this underlying database the state database. this has number benefits; firstly the root node this structure cryptographically dependent all internal data and such its hash can used secure identity for the entire system state. secondly, being immutable data structure, allows any previous state (whose root hash known) recalled simply altering the root hash accordingly. since store all such root hashes the blockchain, are able trivially revert old states. the account state comprises the following four fields: nonce: scalar value equal the number transactions sent from this address or, the case accounts with associated code, the number contract-creations made this account. for account address state this would formally denoted s[a]n balance: scalar value equal the number wei owned this address. formally denoted s[a]b storageroot: -bit hash the root node merkle patricia tree that encodes the storage contents the account mapping between -bit integer values), encoded into the trie mapping from the keccak -bit hash the -bit integer keys the rlp-encoded -bit integer values. the hash formally denoted s[a]s codehash: the hash the evm code this account--this the code that gets executed should this address receive message call; immutable and thus, unlike all other fields, cannot changed after construction. all such code fragments are contained the state database under their corresponding hashes for later retrieval. this hash formally denoted s[a]c and thus the code may denoted given that kec(b) s[a]c ethereum: secure decentralised generalised transaction ledger gaslimit: scalar value equal the maximum amount gas that should used executing this transaction. this paid up-front, before any computation done and may not increased later; formally to: the -bit address the message call's recipient or, for contract creation transaction, used here denote the only member formally value: scalar value equal the number wei transferred the message call's recipient or, the case contract creation, endowment the newly created account; formally values corresponding the signature the transaction and used determine the sender the transaction; formally and this expanded appendix since typically wish refer not the trie's root hash but the underlying set key/value pairs stored within, define convenient equivalence: trie (s[a]s s[a]s the collapse function for the set key/value pairs the trie, l*i defined the element-wise transformation the base function given as: (k, kec(k), rlp(v) where: shall understood that s[a]s not 'physical' member the account and does not contribute its later serialisation. the codehash field the keccak- hash the empty string, i.e. s[a]c kec then the node represents simple account, sometimes referred "noncontract" account. thus may define world-state collapse function (s) {p(a) s[a] where p(a) kec(a), rlp (s[a]n s[a]b s[a]s s[a]c this function, used alongside the trie function provide short identity (hash) the world state. assume: v(x) homestead. significant block number for compatibility with the public network the block marking the transition between the frontier and homestead phases the platform, which denote with the symbol defined thus additionally, contract creation transaction contains: init: unlimited size byte array specifying the evm-code for the account initialisation procedure, formally init evm-code fragment; returns the body, second fragment code that executes each time the account receives message call (either through transaction due the internal execution code). init executed only once account creation and gets discarded immediately thereafter. contrast, message call transaction contains: data: unlimited size byte array specifying the input data the message call, formally s[a] v(s[a])) where the account validity function: the protocol was upgraded this block, this symbol appears some equations account for the changes. the transaction. transaction (formally, single cryptographically-signed instruction constructed actor externally the scope ethereum. while assumed that the ultimate external actor will human nature, software tools will used its construction and dissemination. there are two types transactions: those which result message calls and those which result the creation new accounts with associated code (known informally 'contract creation'). both types specify number common fields: nonce: scalar value equal the number transactions sent the sender; formally gasprice: scalar value equal the number wei paid per unit gas for all computation costs incurred result the execution this transaction; formally eip- revision appendix specifies the function, which maps transactions the sender, and happens through the ecdsa the secp-k curve, using the hash the transaction (excepting the latter three signature fields) the datum sign. for the present simply assert that the sender given transaction can represented with s(t (tn (tn otherwise here, assume all components are interpreted the rlp integer values, with the exception the arbitrary length byte arrays and where (h)h the timestamp block and must fulfil the relation: (h)h this mechanism enforces homeostasis terms the time between blocks; smaller period between the last two blocks results increase the difficulty level and thus additional computation required, lengthening the likely next period. conversely, the period too large, the difficulty, and expected time the next block, reduced. the nonce, must satisfy the relations: with (n, pow(hn d). where the new block's header but without the nonce and mix-hash components, being the current dag, large data set needed compute the mix-hash, and pow the proof-of-work function (see section .): this evaluates array with the first item being the mixhash, proof that correct dag has been used, and the second item being pseudo-random number cryptographically dependent and given approximately uniform distribution the range the expected time find solution proportional the difficulty, ethereum: secure decentralised generalised transaction ledger this the foundation the security the blockchain and the fundamental reason why malicious node cannot propagate newly created blocks that would otherwise overwrite ("rewrite") history. because the nonce must satisfy this requirement, and because its satisfaction depends the contents the block and turn its composed transactions, creating new, valid, blocks difficult and, over time, requires approximately the total compute power the trustworthy portion the mining peers. thus are able define the block header validity function (h): d(h) (h)h (h)h (h)h khx otherwise gtransaction ethereum: secure decentralised generalised transaction ledger where means the series bytes the transaction's associated data and initialisation evm-code, depending whether the transaction for contractcreation message-call. gtxcreate added the transaction contract-creating, but not result evm-code before the homestead transition. fully defined appendix the up-front cost calculated as: the validity determined as: s(t s[s(t s[s(t )]n s[s(t )]b `(br note the final condition; the sum the transaction's gas limit, and the gas utilised this block prior, given `(br must greater than the block's gaslimit, the execution valid transaction begins with irrevocable change made the state: the nonce the account the sender, s(t incremented one and the balance reduced part the up-front cost, the gas available for the proceeding computation, defined the computation, whether contract creation message call, results eventual state (which may legally equivalent the current state), the change which deterministic and never invalid: there can invalid transactions from this point. define the checkpoint state [s(t )]b s[s(t )]b [s(t )]n s[s(t )]n except: evaluating from depends the transaction type; either contract creation message call; define the tuple post-execution provisional state remaining gas and substate l(s s(t s(t otherwise eip- revision from the refund counter, the sender the original rate. min{ the total refundable amount the legitimately remaining gas added with the latter component being capped maximum half (rounded down) the total amount used the ether for the gas given the miner, whose address specified the beneficiary the present block define the pre-final state terms the provisional state [s(t )]b [s(t )]b [m]b [m]b (tg )tp except the final state, reached after deleting all accounts that appear the suicide list: [i] except and finally, specify the total gas used this transaction and the logs created this transaction: (s, (s, these are used help define the transaction receipt, discussed later. contract creation there are number intrinsic parameters used when creating account: sender (s), original transactor (o), available gas (g), gas price (p), endowment (v) together with arbitrary length byte array, the initialisation evm code and finally the present depth the messagecall/contract-creation stack (e). define the creation function formally the function which evaluates from these values, together with the state the tuple containing the new state, remaining gas and accrued transaction substate a), section l(s, the address the new account defined being the rightmost bits the keccak hash the rlp encoding the structure containing only the sender and the nonce. thus define the resultant address for the new account  b.. kec rlp (s, s[s]n and the original transactor, which can differ from the sender the case message call contract creation not directly triggered transaction but coming from the execution evm-code. note use denote the fact that only the first three components the function's value are taken; the final represents the message-call's output value byte array) and unused the context transaction evaluation. after the message call contract creation processed, the state finalised determining the amount refunded, from the remaining gas, plus some allowance where kec the keccak -bit hash function, rlp the rlp encoding function, ba..b (x) evaluates binary value containing the bits indices the range [a, the binary data and s[x] the address state none exists. note use one fewer than the sender's nonce value; assert that have incremented the sender account's nonce prior this call, and the value used the sender's nonce the beginning the responsible transaction operation. the account's nonce initially defined zero, the balance the value passed, the storage empty and the code hash the keccak -bit hash the empty string; where the amount gas remaining after deducting the basic amount required pay for the existence the transaction: ethereum: secure decentralised generalised transaction ledger the sender's balance also reduced the value passed. thus the mutated state becomes eip- revision state allowed persist. thus formally, may specify the resultant state, gas and substate where: except: [a] [s]b trie(), kec s[s]b where the account's pre-existing value, the event was previously existence: s[a] s[a]b otherwise finally, the account initialised through the execution the initialising evm code according the execution model (see section code execution can effect several events that are not internal the execution state: the account's storage can altered, further accounts can created and further message calls can made. such, the code execution function evaluates tuple the resultant state available gas remaining the accrued substate and the body code the account ks(s where contains the parameters the execution environment defined section that is: evaluates the empty tuple there input data this call. has special treatment and determined from the blockchain. code execution depletes gas, and gas may not below zero, thus execution may exit before the code has come natural halting state. this (and several other) exceptional cases say out-of-gas exception has occurred: the evaluated state defined being the empty set, and the entire create operation should have effect the state, effectively leaving was immediately prior attempting the creation. the initialization code completes successfully, final contract-creation cost paid, the code-deposit cost, proportional the size the created contract's code: gcodedeposit |o| there not enough gas remaining pay this, i.e. this states that the execution exceptional halting state there insufficient gas, the instruction invalid (and therefore its subscript undefined), there are insufficient stack items, jump/jumpi destination invalid the new stack size would larger then the astute reader will realise that this implies that instruction can, through its execution, cause exceptional halt. h(u, ... jump destination validity. previously used the function determine the set valid jump destinations given the code that being run. define this any position the code occupied jumpdest instruction. all such positions must valid instruction boundaries, rather than sitting the data portion push operations and must appear within the explicitly defined portion the code (rather than the implicitly defined stop operations that trail it). formally: (a, (a, (s, o(s, o(s, z(s, otherwise where d(c) (c, ethereum: secure decentralised generalised transaction ledger where: (c, {i} (c, (i, c[i])) (c, (i, c[i])) |c| c[i] jumpdest otherwise where the next valid instruction position the code, skipping the data push instruction, any: push [push, push] (i, otherwise ... normal halting. the defined: hreturn (u) h(u, normal halting function the execution cycle. stack items are added removed from the left-most, lower-indexed portion the series; all other items remain unchanged: (s, kus kus [aw kus [x] the gas reduced the instruction's gas cost and for most instructions, the program counter increments each cycle, for the three exceptions, assume function subscripted one two instructions, which evaluates the according value: upc c(s, jjump (u) jump jjumpi (u) jumpi (upc otherwise general, assume the memory, suicide list and system state don't change: arrive the leaf. this akin existing schemes, such that employed bitcoin-derived protocols. since block header includes the difficulty, the header alone enough validate the computation done. any block contributes toward the total computation total difficulty chain. thus define the total difficulty block recursively as: (bh such given block its total difficulty, its parent block and its difficulty. block finalisation return {stop, suicide} otherwise the data-returning halt operation, return, has special function hreturn defined appendix eip- revision however, instructions typically alter one several components these values. altered components listed instruction are noted appendix alongside values for and and formal description the gas requirements. blocktree blockchain the canonical blockchain path from root leaf through the entire block tree. order have consensus over which path is, conceptually identify the path that has had the most computation done upon it, or, the heaviest path. clearly one factor that helps determine the heaviest path the block number the leaf, equivalent the number blocks, not counting the unmined genesis block, the path. the longer the path, the greater the total mining effort that must have been done order the process finalising block involves four stages: validate (or, mining, determine) ommers; validate (or, mining, determine) transactions; apply rewards; verify (or, mining, compute valid) state and nonce. ommer validation. the validation ommer headers means nothing more than verifying that each ommer header both valid header and satisfies the relation th-generation ommer the present block where calldatacopy codecopy extcodecopy log log log log log call callcode delegatecall suicide create sha jumpdest sload wzero wbase wverylow wlow wmid whigh wextcode balance blockhash upc otherwise slt signed less-than comparision. otherwise where all values are treated two's complement signed -bit integers. equality(comparision. otherwise iszero simple not operator. otherwise and bitwise and operation. [..] []i []i []i bitwise operation. [..] []i []i []i xor bitwise xor operation. [..] []i []i []i not bitwise not operation. [..] []i byte []i otherwise retrieve single byte from word. [](i+us []) kid this pertains the input data passed with the message call instruction transaction. calldatasize get size input data current environment. kid this pertains the input data passed with the message call instruction transaction. calldatacopy copy input data current environment memory. [us (h, (hp otherwise and assert the header can determined its hash the parent hash the block following it. coinbase get the block's beneficiary address. timestamp get the block's timestamp. number get the block's number. difficulty get the block's difficulty. gaslimit get the block's gas limit. ethereum: secure decentralised generalised transaction ledger eip- revision stack, memory, storage and flow operations value mnemonic description pop remove item from stack. mload load word from memory. [us (us max(ui d(us the addition the calculation not subject the modulo. mstore save word memory. [us (us max(ui d(us the addition the calculation not subject the modulo. mstore save byte memory. [us []] (us mod max(ui d(us the addition the calculation not subject the modulo. sload load word from storage. s[ia [us []] sstore save word storage. [ia [us []] gsset s[ia [us []] csstore (s, gsreset otherwise rsclear s[ia [us []] otherwise jump alter the program counter. jjump (u) this has the effect writing said value upc see section jumpi conditionally(alter the program counter. jjumpi (u) upc otherwise this has the effect writing said value upc see section get the value the program counter prior the increment corresponding this instruction. upc msize get the size active memory bytes. gas get the amount available gas, including the corresponding reduction for the cost this instruction. jumpdest mark valid destination for jumps. this operation has effect machine state during execution. ethereum: secure decentralised generalised transaction ledger eip- revision push operations value mnemonic description push place byte item stack. c(upc +() [x] (the maximum call depth limit reached) s[ia (balance the caller too low fulfil the value transfer); and otherwise a(ia s[ia the address the newly created account, otherwise. (ui [], []) thus the operand order is: value, input offset, input size. call message-call into account. [us s[ia th(s, ccallgas (u), [], [], s[ia (not enough funds) (call depth limit reached); otherwise. (ui [], []), [], []) thus the operand order is: gas, to, value, offset, size, out offset, out size. ccall (s, cgascap (s, cextra (s, cgascap (s, gcallstipend ccallgas (s, (s, otherwise gascap min{l(ug cextra (s, u)), []} cextra (s, cgascap (s, otherwise cextra (s, u)( gcall cxfer (u) cnew (s, gcallvalue cxfer (u) otherwise gnewaccount s[us mod cnew (s, otherwise callcode message-call into this account with alternative account's code. exactly equivalent call except: th(s s[ia ccallgas (u), [], [], kmk otherwise