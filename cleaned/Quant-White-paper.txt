quant overledger (r) whitepaper release (alpha), january gilbert verdian, paolo tasca, colin paterson, gaetano mondelli research@quant.network abstract the traditional internet architecture hasn't yet achieved its vision open, trusted and secure network. the technology distributed ledger technologies (dlt) and their broad range applications across finance, healthcare, supply-chain and many other sectors, opportunity for the internet adapt and honour what was originally envisaged, and reach its potential decentralised network networks. while providing broad range benefits, the fast-paced environment dlts lack seamless inter-communicability, internally among ledgers, and externally with existing networks. this limitation forces distributed applications single-ledger-dependent, i.e. limited only executed single ledger. from technology perspective, the fact that distributed decentralised applications are single ledger-dependent, makes difficult choose the appropriate dlt fit for purpose, meeting technical and business requirements when considering dlts for decentralised applications. this technical dependency slows down mass-adoption, limits scope, impedes scalability new features and reduces necessary controls required for data security and privacy. from business perspective, single-ledger dlt application increases the amount risk, complexity and effort needed adopt multiple dlt technologies, many cases even duplicating resources and investments. enterprises are forced accept financial risk, due monopolistic approach dlt fees, limiting options manage fees and transaction costs. all challenges listed limit widespread adoption and critical mass users. this paper proposes solution this problem single-ledger dependency, introducing new technology for the design, deployment and execution multi-ledger decentralised applications. this technology's called overledger. page table contents abstract introduction background information state the art purpose interoperability layer communication connection method scalability fault tolerance connection speed overledger philosophy overledger messaging layer standardization messages and information out the chain messages and security properties improve privacy specification shortcomings messages out the chain speed and throughput messages filtering and ordering layer filtering criterion overledger ordering criterion for overledger cross-ledger transactions blockchain and transaction properties acid and blockchain base and blockchain cross-ledger transaction and acid two-phase commit and cross-ledger transactions application layer overledger applications application level responsibility use cases cqrs-es and overledger conclusion bibliography page introduction the invention bitcoin achieved new technological milestone: the blockchain. although the underlying technology blockchain isn't new, the innovation results from combination existing technologies integrated original way, create blockchains. the components (i.e., merkel tree, concatenated hashes, public-key encryption) were established technologies, well before the bitcoin paper nakamoto []. the moment writing, may argue that, according the technology life cycle theory, we're the beginning the so-called phase "fermentation", characterised technological uncertainty, due the evolution blockchain into alternative technical paths. the industry promotes different model designs, favouring functional and performance aspects over others, meet specific business goals. currently, there are more than thousand digital currencies (for clarity the phrase digital currency and cryptocurrency will used interchangeably through the paper) and tokens, and thousands blockchain projects under development different sectors worldwide []. the current blockchain ecosystem too fragmented and complex, with progress being achieved silos. the variation blockchain designs and their possible configurations represent hindrance for enterprises, software architectures and developers. heterogeneous development brings lack blockchain interoperability and compatibility within blockchain networks well existing systems and networks. that is, the ability for blockchains exchange information between them and with off-chain systems. this lack interoperability threat the wide and uniform adoption blockchain applications our techno- and socio-economic systems. apart from the technical challenges existing (e.g., key management, filtering and ordering messages), the lack interoperability between ledgers, itself, also presents business risks. major concern consists decoupling different business logic from the underlying ledgers increase the communicability among them preserving privacy requirements [-]. thus, was the case with the internet, it's necessary provide off the shelf software and development tools that simplify how develop and deploy distributed ledger (dlt) applications without requiring developers build various components from scratch. addressing the above risks, decentralised applications will grow and become increasingly interoperable and widely adopted. page background information order address the problem blockchain interoperability, software reference architectures for blockchain interoperability should set up. however, the majority existing technologies trying connect dlts define standard interoperability within their platform, but not outside. the integration with legacy other dlts challenging and difficult implement. choosing the correct technology becomes crucial because it's hard foresee which will the most suitable, even the short term, without the uncertainty presented other external factors such technologies forking, becoming insecure, being abandoned altogether. the development blockchain applications, the choice the underlying blockchain technology can't easily undone. migrations aren't always possible because the transactions only have scope their blockchain address space. for example, blockstack [], open-source project create, manage and use decentralised apps blockchain, decided move from namecoin bitcoin because the first technology was considered less secure. the migration applications problem that can soon apply those running ethereum []. this endless problem and the solution can't merely designing better and smarter blockchains. front-end technologies today will become obsolete few years, due planned and unplanned obsolescence. solve these issues, overledger presents the following solutions: introduction new scripting languages, updating existing ones; scaling applications (e.g. increasing transaction speeds); communication among different dlts for cross-ledger operations; adaptable technology that can change meet newer sector-specific requirements and regulation; and mitigation tools against new security threats. overledger new blockchain operating system intending solve the problems singleledger dependency increasing communicability among dlts, allowing general purpose applications run top different blockchains. overledger abstracts single-ledger dependent technology overcome the bound different architectures regardless addresses, ledger implementation and consensus mechanisms. rather than defining specific platform with multiple connectors, accommodating the plugin the compliant dlts, our solution introduces vendor-independent wire-level protocol for message-oriented middleware. decoupling the transaction layer with shared messaging layer, overledger provides unique solution interoperability for digital ledger environments. overledger also allows the business logic decouple from the underlying ledger. increases communicability among chains with the privacy constraints decentralised applications demand. readers familiar with distributed systems, are aware the differences between blockchains and the larger family dlts. dlt generally mean database technology where records decentralised and transactional data are stored sequence (not necessarily grouped blocks), continuous ledger spread through network across multiple locations. blockchain particular kind dlt which batches transactions are held blocks, and the blocks are linked with hash pointers chain. each block contains the hash the prior block the chain, method keeping the integrity each set data the blockchain. for the sake page simplicity, here out we'll use the terms blockchain and distributed ledger technologies indistinguishably. from time time we'll refer the blocks the chain. nevertheless, overledger universal, and general-purpose operating system, among the family distributed ledger technologies. privacy constraints and data ownership applications requiring transparency challenge many projects are exploring (e.g. blockstack, digital holding asset and sidechains (section .)). the future, when decentralised blockchain applications will spread widely, it'll necessary create method for allowing applications communicate, exchange and replicate data across multiple blockchains. finally, will easier compare the performance different blockchains running the same application. all these aspects together will help boost blockchain technology, its applications, and the opportunities exploit the technology widely. the next subsection will analyse existing solutions the problem single-ledger dependency. we'll also introduce mathematical models with the order theory for blockchains, considering other technical aspects the underlying blockchain technologies required deliver such solution. state the art this section provides overview those projects that, although pursuing different final goals, propose alternative solutions the problem the lack blockchain communicability and interoperability. this rather new and evolving stream research; therefore, focused only the main projects and compared them with overledger: virtualchain blockstack sidechain blockstream interledger protocol cosmos interchain polkadot parity technologies aion- nuco decided explain the state the art communicability among blockchains using set parameters interest our project (see table purpose; interoperability; layer communication; connection method; connection speed; scalability; and fault tolerance. purpose virtualchain. blockstack introduced virtualchain build state machines top the underlying blockchains. the main idea behind virtualchains extend the blockchain's business logic and allow for the ability migrate among dlts, without changing the underlying dlt. virtualchains are overlays top page specific blockchains for building multiple state machines and allowing the migration from one blockchain another. migration requires two ledgers communicate with each other. this context, some applications run single blockchain and are represented virtual state machines. the way these state machines evolve adding new operational codes functions (op_code) the transactions' blocks. this implemented the additional data field bitcoin called op_return. this additional field the hash the new state added the state machine after this last operation executed. makes the system fork-consistent. interledger purpose interoperability layer comm. virtualchai sidechain payments across ability migrate from add new innovative different one dlt features payment systems another for fault the main crypto based dlt tolerance currencies -c- -c- transaction level over the transaction level overcome blockchain limits and transfer assets transaction level two phase connection method connection speed two phase two phase commit (two commit commit like way pegspv) notaries entity consensus ledgers scalability fault tolerance allow connectors run nodes migration time ledgers allow write metadata depends depends notaries the two institutions that validates blockchains involved transactions the migration cosmos and contest period ledger's transfer assets and solve blockchain data (smart isolation contract) problem applications protocol based (transaction (transaction (transaction level for legacy level for legacy level for legacy ledger) ledger) ledger) two phase two phase two phase commit (spv) commit commit protocol time protocol time depended depended two phase commit like proportional the validator number ibf talk with the hub should implement the polka dot security the zones para chains (user responsibility follow rules where they move coins) and consensus polkadot n-n over the transaction level protocol (flexible) time depended ledger's aion- readability compatible and/or writability consensus confined the sidechain multiledgers protocol based implement sidechain are confined layer for protocol based with two-way peg faults build messaging n-c-n should security overledger n-c-n compliance itself. aion n-c-n (tendermint) confirmation polkadot compatible blockchain aion- follow rules and protocol based consensus aion- table comparison among projects aiming increase intercommunication between dlts. the interoperability section below, explain the convention used this table. page cosmos. cosmos project with ambitious mission: the creation network distributed ledgers that will solve "long-standing problems" the cryptocurrency and blockchain communities. the cosmos project wants solve all the traditional issues blockchains like energy inefficiency (pow), limited performances regarding transactions compared conventional centralised systems, poor governance strategies, for example, when change the protocol needs implemented. polkadot. polkadot's vision build web where people have direct control their data. polkadot, like cosmos, network ledgers that allows the exchange assets and data through ledgers. interledger. the protocol for interledger payments, ripple project, wants allow secure payment transfers between different ledgers. today this service provided centralized systems, like western union, which need trusted the endpoints the transactions. interledger wants enable payments between any users holding assets separate ledgers, without the need trust third party. aion-. aion seeks solve scalability, privacy, and communication issues among digital ledgers. aims provide decentralised accountability among blockchain networks. aion claims introduce nextgeneration blockchain that enables intercommunicating blockchains. the first generation presents the distributed ledger technology, cryptographically secured like bitcoin, and the second one enhances smart contract and distributed apps, like ethereum. according the aion classification, the third generation adds the ability communication and value exchange among ledgers. sidechain. sidechain and interledger protocols are two projects aiming promote communication among blockchains and allow asset transfers. while sidechain builds ad-hoc external chains that can interact automatically with just specific blockchain (not full mesh connection), interledger needs the use external nodes (the connectors), with further consensus mechanism allow currency conversion, without the need trust third-party exchanger. the focus sidechain's allow ledgers (notably bitcoin) transfer coins particular chains that are innovative and have new cryptocurrency features. this should extend traditional cryptocurrencies like bitcoin, limited their original protocol. overledger. the projects introduced far are "single-ledger dependent". they start from the same point: blockchain protocols are not adaptive needs. i.e., they propose particular solutions solve only specific needs. differently, overledger universal and general-purpose technology. for this reason, although overledger shares common technical aspects with some the existing projects, decouples the business logic from the underlying ledger technologies. this means general-purpose applications can sit top different ledgers the same time, with the ability communicate. fact, propose "over layer" top existing blockchains which applications can run on. thus, the applications can communicate, migrate and exchange information and value, regardless the ledgers which they've been deployed. overledger enables users build decentralized multi-chain applications which aren't single-blockchain dependent. this means users can run applications, smart contracts, treaties move data across different blockchain technologies. this original approach will empower the adoption blockchain technologies across various sectors and use cases, enabling large-scale adoption the technology, without tying particular vendor chain. page interoperability one today's challenges with distributed ledgers they exist silos. different structures and working mechanisms make harder, not impossible, build common interface. moreover, general, users have different rights different ledgers. for example, only group people can append data permissioned ledger while another one can only read the data. tackle the interoperability issues positioning overledger top the ledgers, rather than struggling order and match different ledgers. our approach, distinguish ledgers with the ability read and write from ledgers that are readable only. ledger that offers write function arbitrary strings long enough host hash classified writable. this case, users can use optional fields regular transaction add the hash arbitrary messages. the ledgers that don't offer write function arbitrary strings, but offer read operation, are labelled readable. until now, the proposed solutions for blockchain interoperability depend the specific goals for which the projects were originated. interledger. the protocol for interledger payments can connect any two ledgers having connector with least one node each the ledgers. it's possible connect two ledgers, let's say and not directly joined connector, there's path between ledgers that starts from and ends virtualchain. virtualchain allows running state machine the top specific blockchain. the underlying blockchain becomes obsolete, longer suitable, virtualchain offers the ability migrate more convenient one. for this reason, the interaction between blockchains happens only between the two blockchains involved the migration. sidechain. sidechain the communication happens between two chains, the main one called the parent chain and the other one with new features called the sidechain. newer applications can use existing blockchains for which security consolidated lower parallel layer their business logic. these applications can build messages out the chain, hash them and add only their digests the blockchains. the case parallel chains, they can build these extension-chains that allow the exchange assets with the main ones. the extension chains provide benefits, allowing the development more complex applications and delegating the complexity the external layer. the sidechains project uses this approach transfer assets between existing blockchains like bitcoin, litecoin and others offering new features. these extensions should always compliant with the main blockchain protocol (e.g. the bitcoin one) without changing it, because the protocol isn't flexible. even small changes would result hard fork. cosmos. cosmos has architecture that allows zones (blockchains compliant the protocol) communicate each other through hubs, multi-asset blockchains, where coins can owned individuals zones. the hub blockchain appends transactions its ledger among individuals zones. polkadot. polkadot uses relay chains coordinate consensus among parachains. parachains gather, collect and process transactions and use the relay chain consensus for normal and cross-ledger transactions. aion-. aion provides protocol route, propagate and translate messages among blockchain networks. the root this network there's ad-hoc blockchain called aion-. page overledger. should noted that all the above solutions only allow communication between two blockchains the same time. our solution can conduct operations across multiple blockchains simultaneously. overledger can read information like transactions, scripts contracts and map them the "over layer", only that information compliant with the selected business logic. this way, overledger can connect all blockchains allowing the ability add arbitrary hash message host. most cases, the projects that encourage connectivity among blockchains create network ledgers, where the asset, the information, needs routed from the source the destination, across different hops (when applicable). not propose network approach; introduce multi-layer approach. move the information the layers above, creating common interface among ledgers. table summarise the level interoperability using the following notation: -c-: two connected blockchains per time with connector; n-c-n: many connected blockchains per time with connectors; two connected blockchain connected per time without connector; and n-n: many connected blockchains per time without connectors. layer communication our idea's build presentation layer top blockchains allow applications run them. communication among blockchains happens logical layer, which sits top the transactional one. virtualchains adopt similar approach ours. virtualchains are designed perform migration between two blockchains. the migrations are executed through messages exchanged virtual layer. this means the transaction where the fingerprint the operation added doesn't affect the underlying transaction. instead, the other projects carry out the communication the transaction level. since the protocol for interledger and sidechains focus tokens and coins, they need impose the connection happens the same level transactions. cosmos, polkadot and aion define new standards work new sharable transaction layer. limitation this approach that they can only work with token-based ledgers. connection method all the projects table propose different ways communicate across-ledgers. however, when comes interactions with different ledgers, all cases, connection methods between different ledgers require two-phase commit approach. this consists two more states. the first, where the transaction proposed, propagated and processed (committed aborted) the stakeholders. interledger. the case the protocol for interledger, particular nodes called connectors are charge communications. connector two chains entity having least one node each the two ledgers. they coordinate transfers multiple ledgers using smart contracts. smart contracts force connectors cooperate, therefore people don't need trust anyone. the escrow's implemented with the financial equivalent the two-phase commit, that first locks resources and then moves them, rolls back the transaction the previous owners. page virtualchain. virtualchain's migration uses two-step commit that locks the application the new blockchain until the migration ended. sidechains. sidechains are newer blockchains that have particular rules allowing transfers from parent chains. they proposed scheme that locks coins one chain sending them unique addresses, then simple payment verification (spv) proof used unlock them the other blockchain. spv are used lightweight clients, but rather than checking the validity all transactions the blocks, they only check transaction's member the merkle tree block appended the past. this method's described the original bitcoin whitepaper []. this much faster, users only need check the membership merkle tree and only the block header. only when the block header received the transaction that belongs the longest blockchain checked, can seen. this doesn't guarantee it's the longest valid chain. cosmos. cosmos, the zones communicate with each other through the "hub" with inter-blockchain communication (ibc) protocol defining two types messages (ibcblockcommittx, ibcpackettx). this similar the spv approach. polkadot. polkadot seeks address the unsolved questions extensibility and scalability decoupling the tied bound canonicality and validity the popular blockchain architectures, with focus security. parachains communicate among them through the relay chain. the relay chain provides the foundation (through consensus mechanism, parachain interface and routing protocol) which the polkadot network's built. aion-. aion, like cosmos and polkadot, connect blockchain networks compliant with set requirements (aion-compatible) and make them communicate through central node, this case, the aion-. overledger. also, overledger adopts two-phase commit schema, similar the one used the other projects. scalability interledger. the scalability the payments for the interledger protocol depends the connectors. connector can run node ledger, having the right transactions, then can potentially use this protocol exchange and from the particular ledger. virtualchain. the scalability for virtualchain depends the ability blockchain add metadata the blockchain. sidechain. for sidechain, the scalability parameter depends the blockchain's ability implement two-way peg scheme. must considered that the two-way peg scheme uses spv proof, that requires proof work, which means needs adjusted for blockchains using another consensus mechanism. cosmos. cosmos can scale long new blockchain can adopt the inter-blockchain communication protocol and also connect cosmos hub. page polkadot. similar cosmos, polkadot can scale new ledgers adopt the requirements connect relay chain, i.e. new ledgers must compatible the connector standard. aion-. aion- also follows similar approach both cosmos and polkadot. overledger. internet-scalability has been built into the core the overledger protocol and approach. fault tolerance interledger. for the interledger protocol there's two modes working: atomic mode and universal mode. the fault tolerance the atomic mode depends the behaviour the group notaries that approve transactions. the case universal mode, depends the institution that fills that role charge incentive. since the interledger protocol only intended for value exchanges among blockchains, blockchain error can't compromise the business logic. blockchain becomes insecure, connectors won't transfer values from that blockchain. virtualchain. fault tolerance the main reason behind virtualchain, blockchain becomes insecure, the application can migrate from one blockchain another. however, blockchain's already fully compromised, the previous state the application can't recovered. this very unlikely happen, but avoid this, virtualchain frequently publishes logs other blockchains. sidechain. with regards fault tolerance, one should consider that sidechain treats the two chains isolated. the case security fault malicious design sidechain, the damage confined the sidechain itself and doesn't compromise the main one. cosmos. cosmos' topology, the hub the critical point failure, therefore security enforced. the hub uses the tendermint consensus protocol [], considered secure, and uses only trusted validators for the transactions. the problem arises one the zones has security issue, can spread through the network. the hub doesn't validate transactions inside zones, only validates inter-zone transactions. polkadot. polkadot also has single point failure the relay chain. this the reason the project focuses more security for these entities. aion-. the aion- blockchain, the root the network, potential single point failure for this type technology. connection speed although it's very hard estimate the connection time, let's see how the different software architectures the projects table may influence it. interledger. the protocol for interledger payments operates over three phases: proposal, preparation and execution. the phasing works utilising two-phase commit protocol, and chosen group notaries act like the transaction manager. the transaction time depends the time required the blockchain add information about these three phases for all nodes involved the transactions, plus the time required the notaries check all the information needed each phase these protocols, send vote page (commit, abort). the liveness property (deadlock free and not starvation) guaranteed this process because the presence timeouts each stage. virtualchain. virtualchain logical (not physical) layer the blockchain showing the evolution the state virtual machine. this chain needs respect the consensus rule fork-consistent and, depending these rules, can give rough estimation the speed their transactions. where there communication among blockchains, i.e. migration, they require only two messages: one announce they're leaving message the old blockchain and one the new blockchain, announcing migration started that blockchain. sidechain. sidechain's two-way peg requires sending spv proof lock coins blockchain (parent side one) and then unlock them the other. this process delays specific period time before sending the spv proof (confirmation time) allow sufficient proof work created, after the spv proof's been sent (contest period), prevent double spending. according the sidechain white paper [], this period would one two days. cosmos. the connection speed cosmos depends the parameter the tendermint consensus protocol []. good trade-off with one hundred validators can allow thousands transactions per second. polkadot. polkadot the connection speed depends the protocol and the involved entities (nominators, collators, validators, and fishermen). aion-. estimate the connection speed aion need consider its architecture. considering bitcoin can manage approximately seven ten transactions per second, given the underlying speed, this will depend the transactional speed the underlying aion compatible blockchains involved, well the aion- blockchain itself. overledger. all projects that don't create presentation layer and aim achieve communication the transaction level needed route information across-ledgers from the source ledger the destination. since our solution doesn't route the information across-ledgers, the connection time proportional the latency the involved chains and only requires fixed set transactions. doesn't depend the path length, since all ledgers are directly connected our presentation layer. overledger philosophy one the challenges with digital ledgers they exist silos. different structures and working mechanisms make harder build common interface. overledger addresses this issue sitting top them rather than struggling match them up. sometimes you may have different rights different ledgers. overledger's vision build unique group transactions, put together, and then ordered distributed applications. the analysis the projects table dlt inter-communication and interoperability allows extract the connection methods adopted those cases. comparative analysis permits extract the common logical elements pertaining those methods: page build platform with new features designed address today's dlts challenges (slow transaction rates, migrations, cryptocurrency exchanges etc); build network blockchains where nodes have different roles and responsibilities (e.g. parentchain-sidechain, hub-zone, relaychain-parachain []); define standard connect blockchains the platform; build adapters make existing technologies compliant with the standard; transaction-oriented, not application oriented; connections low-levels strictly involving consensus mechanism; and tree/graph network that requires complex routing algorithms. the methods proposed far are very limited their application, they set strict rules and create standard the connection level. this approach automatically excludes some technologies and limits the evolution the new ones are bounded within the new constraints. moreover, becomes harder and harder include the current and new technologies being developed. it's indeed impossible build general meta-adapter connect all present and future blockchains, resulting platform needing build different adapters different complexity. fig. represents common scenario where there's special nodes with more responsibility than regular ones. the special node, becomes single point failure for the connected bodies. also needs able manage many nodes possible. it's designed optimised for the connection: this represented with hexagon. the hexagon the symbol for connectivity because its property cover plane (its internal angle divisor despite its design, needs connect legacy existing technologies not designed for inter-communicability (the purple and the blue polygons). therefore, must implement and maintain different adapters. the yellow node the representation brand new blockchain technology that's particularly complex, and therefore its adapter has irregular shape highlight its complexity. fig. connectivity and differences between regular and special nodes. other issue are upgrades changes. the upgrade the communication protocol, standard, adds complexity. since we're dealing with transactions, can lead unavailability the service inconsistency problems. this also affects the flexibility the communication because the resistance page changes. furthermore, one should take into account that upgrade the platforms may also require the adapters updated. the resulting architecture graph network requiring different adapters for different dlts and routing strategy that forwards information from source destination, avoiding loops. fig. shows topology for such architecture. fig. connection topology. let's suppose dlt-a wants send message dlt-g, the following issues arise: convert the message the platform format from the dlt-a format respecting the time; route the message from the node the next one. the routing strategy must efficient because the different consensus timing adds complexity. the fastest path may not the shortest one. the safest path may not the fastest one. the user may not have control the path their information; the message needs converted from the dlt-a platform format the dlt-g one; and special node (master, relay, parent, hub) are points failure well the adapters itself, this example. the overledger approach manages the connection upper layer despite the underpinning technology. the applications bind blockchains and treat them decentralised queue transactions where messages are attached transactions and are appended the different ledgers. page overledger this paper propose architecture that acts like the osi model for the internet, redistributing the tasks among four different layers, built the transport layer, since most blockchain technologies are built the internet (see fig. transaction layer. this layer stores transactions appended the ledger's technology. includes all operations needed reach the consensus different blockchain domains (in this representation, simplified this putting all those operations one layer). however, all the transactions executed specific blockchain only have scope that domain, i.e. it's not possible also make them valid other ledgers. therefore, this layer's represented different and isolated ledgers. messaging layer. this logical layer because all relevant information retrieved from the ledgers. information can transaction data, smart contract metadata (if the underlying ledgers can add arbitrary strings transactions). the particular case metadata, the added strings are typically the digest out-of-chain messages that can interpreted the payload this logical over layer. this logical layer stores all transaction information and the message's digests different applications the same way shared channel has packets different applications. filtering and ordering layer. this layer messages extracted and built from the transaction information, and those only referenced the transaction through hash, that exchanged out the chain, are filtered and ordered. this layer responsible for creating connections among different messages built the messaging layer. the case metadata, this the layer charge the validation out chain messages. the validation checks the application schema and its requirements. application requirements can set the transaction data. for example, the application may accept only transactions from/to particular address, may need certain amount coin moved. therefore, applications can only consider valid messages that move certain amount coins specific address. application layer. valid messages that respect the requested format and have the requested signatures from the list the application's messages. messages can update the state their application. different applications can share the same messages can refer messages another application. the message references are the unique hash pointer the transaction the ledger containing the digest the messages. the hash pointer basically pointer the place where some (cryptographic) hash the information stored. it's identifier that can used uniquely select transaction database and verify hasn't changed. messaging layer there are several reasons think the control logic, well the business logic, should decoupled from the transaction level. the first reason lies the consideration that, general, blockchain protocols can't accept changes without fork their chain into two different ones. for several reasons, the blockchain communities can decide split and depart from the original chain adopting different protocol rules. for example, the ethereum platform has been forked into two versions: "ethereum classic" (etc) and "ethereum" (eth). prior the fork, the token was called ethereum. after the fork, the page new tokens kept the name eth, and the old tokens were renamed etc. ethereum classic appeared result disagreement with the ethereum foundation regarding the dao hard fork []. other notable examples regard forks bitcoin. reference the implementation bitcoin core, aiming increase the transaction processing capacity (e.g., bitcoin xt, bitcoin unlimited, bitcoin cash) []. fig. overledger architecture model another fact supporting our architecture choice lies the fact that bitcoin, and other blockchain based projects, have originally been conceived and designed support cryptocurrencies and simple transfers. that's why smart contracts and distributed scripts aren't powerful today's application's demands. moreover, transactions only have scope their blockchain address space because the simple original design. finally, our architecture justified the need code language independent. indeed, the languages used build today's blockchain systems will likely substituted other languages the future. for example, the bitcoin script, the script language bitcoin takes inspirations from forth -year-old concatenative programming language. instead, many other blockchains, like ethereum, have implemented complex business logic within the blockchain layer. serpent and solidity (the two turing complete programming languages that run ethereum) are inspired python and javascript respectively, the most adopted scripting languages today, but not necessarily tomorrow. the remaining part this subsection explain the technical requirements the overledger messaging layer needs meet. standardisation the messaging layer shall abstract from all the transactions regardless the particular ledger. only the applications (living the application layer) are responsible for the design rules (according their business logic) that will specify which specific information will need extracted from the transactions, and which order they'll need sorted out. the messaging layer extracts all the information about the transactions from every single ledger the transaction layer. the messaging layer stores all the information recorded the ledger any transaction: the source, the recipient, the amount coin, the script used, the smart contract and all other types information that can recorded each ledger, laying the transaction layer. allows legacy applications work with our architecture, extending the capability across-ledgers. however, ledger technologies are very different from each other and follow different architectural standards []. this requires build unique standard naming system for the messaging layer. the standard should define how refer the different ledgers and their particular fields unique and unequivocal way. for example, should possible refer the address page bitcoin transaction using compound syntax (e.g. btc.height.transactionindex.outputindex should apply the output index "outputindex", the transaction index "transactionindex", the block the main chain, with the height equal the "height" parameter.) our proposal will give the opportunity build standard libraries for developers interact similar ways with different ledgers. messages and information out the chain most blockchains provide the ability add small amount metadata the transaction input/output. for example, bitcoin allows use the op_return field add metadata. ethereum has the field used for the script bytecode []. ripple has the 'memos' field []. therefore, external messages (converted into hexadecimal values) can used for any arbitrary logic. these messages can considered transactions, blocks external blockchain, locally stored users. only fingerprints these messages are added the blockchain. the digital asset platform uses this approach privacy enhancement tool, solve the reconciliation problem between parties. each user has its own set views and can build its view the transactions. only the hashes these transactions are stored the [public] ledger prove their validity. case conflict between two views, user can show the validity their set transactions showing the transactions containing the hash their messages, and prove their validity the counterpart. want extend this approach messages. messages are exchange information; they can simple transaction, something more complex concerning the application logic. fig. depicts example our hashing approach, applied the messaging layer. this example, there are different applications running the top the blockchains and their messages are differentiated using different colours. from the top, the first white blocks represent section the "white" blockchain, which the coloured applications (blue, green, orange) are appending messages. the "white" blockchain only hosts the hash those messages. each hash corresponds message one the applications. there could more than one message the same application, different transactions, stored the same block and there can messages different applications the same block (see block no. the white blockchain). moreover, the same application can run different blockchains the same time. this shown our example letting the blue application add some messages, both the "white" blockchain and some others the "blue" one (bottom the figure). note that the numbers the messages are monotonically increasing. page fig. messages out the chain different applications different blockchains. should pointed out that the concept blockchain "message" more generic than one blockchain "transaction". fact, messages can require more complex format and part more complicated interactions between the parts. hence, mark-up languages like xml json can good fit build messages this context. the applications could define the valid sequences messages and their format through schema validate them. moreover, these messages can exchanged over standard http machines and xml, and json, all good choices since they're already widely used internet communication. messages and security properties the security properties the messaging layer regard the solutions the problems identification, authentication, authorisation and non-repudiation the entities and actions involved the messaging. identification. identification the action claim certain entity, e.g. person, company, department with ambiguity. login system, user identifies herself through the username, usually arbitrary alphanumeric string. blockchains, the identification usually achieved through public keys, their hash. this context, public key seems the best approach, but there can also cases where users are identified with address which similarly works username. this respect, the message format should always have field which unequivocally identifies the senders and the receivers. authentication and authorisation. authentication the action that proves someone who they claim be. standard login systems, user can authenticated with password. the blockchain, authentication done with private key the process the digital signature. such context, asymmetric cryptography and digital signature are the common approaches enable message compliance with both the will and the authentication user. however, after the initial authentication phase, with username-password, it's also possible the application shares secret with the user, then starts exchange messages encrypted with symmetric cryptography. the hash these messages stored the blockchain, and the future user, with the shared secret and the complete message, will able prove they've received those messages. page non-repudiation. non-repudiation means that, the future, action can't questioned disowned have taken place. digital signatures are the most common way achieve this property computer science. this means that, someone has copy the signed message, can stated that the message was compliant with the will the entities who signed it. privacy constraints. many applications will need obfuscate data related other users order compliant with privacy requirements. the classic lower level blockchain cannot satisfy privacy constraints because the intrinsic transparency property the blockchain. other words, common blockchain transaction can't completely anonymous, otherwise would impossible check its validity. with regards this, our proposed messaging layer borrows similar approach the digital asset platform adding the hash the messages special field the regular blockchain transaction. someone holds copy valid message (e.g. signed all the stakeholders), has the opportunity show the hash the chain, hence it's valid. colored coins (bitcoin applications for digital representation and management real world assets) uses similar mechanism using the op_return field bitcoin []. thus, the proposed solution may have some drawbacks because everyone can add the hash message into blockchain transactions, creating the called "blockchain bloat" problem []. means there can irrelevant invalid messages whose hash the chain. therefore, the presence the hash the chain isn't sufficient condition treat the message valid, according the overledger logic. cover how check message validity section ... fig. depicts situation which messages are exchanged off-chain, for example, through the internet. even would sufficient save the hashes the messages separate transactions, here represent them stored different blocks the chain. user can see all the hashes the chain, but she only has details her own transactions: the blue one and the green one. she, for example, doesn't know there's transaction between user and user there's conflict between the users' views the records, each user can exhibit their complete transaction history and prove the validity their transactions sending the hash pointers the counterpart, such that they can used verify the data the blockchain. fig.: messages out the chain and user's views. page improve privacy specification enhance user privacy, conceive the introduction the multi-part message hash pointer technique. subsection show way give the proper view the application the proper entity. however, certain circumstances the applications may require messages follow hierarchical structures that may have different scope regarding privacy. since our context have arbitrary message formats, propose adding hash pointers another part the message. this way, the applications can provide each user with user-specific parts the messages, i.e., unique content addressed only specific users. thus, user has rights see some part the multi-part message, they'll only see hash pointer random piece data. fig. provide example messages out the chain, with different levels secrecy. our example, the user with only the right see the "blue" part the message, only aware there are two other branches the message: the one that starts with the "red" part and the one that starts with the "green" one. however, the user doesn't know how deep these branches are. the same time, the user that can see the "black" part the message knows about the "green" one and the "blue" one, but can't know she's aware the content the "red" part. please consider this modular approach can replaced removing the pointers from the lower part, adding reference the upper ones and treating them newer messages, adding their hashes the chain. however, this can lead business logic inconsistency the other parts the messages aren't correctly added, something happened between. the problem with the approach described above is, whoever sits given level privacy aware the other levels privacy. this something that should avoided most situations. solve this issue, can hide the level secrecy taking the fields that contain private information like hash pointers, encrypt them with the public keys the interested user and make look like random piece data other users. this means, the case there are more levels secrecy, should add random sequence data. fig. messages out the chain and different level secrecy. page one the problems with this approach the secret information can different size and means need amend the size and use padding strategy. the main issue solved the users' awareness regarding the different parts the message. since message can encrypted only with one key, want use this strategy, need replicate the different parts concerning that specific key. for instance, fig. three users can see the "green" part the message and just two them can see the "black" one. need add three "green" hash pointers the "blue" extension. one these three (the one the top the figure) has random pieces data extension field. the following ones (the one the middle and the one the bottom the figure) have hash pointer "black" messages encrypted with their own keys. extending this example, can see the lower the level secrecy the higher the number keys involved. fig.: the field extend the message contains the hash pointers the other parts the message and also contains random sequence bytes. page fig. cryptography with multi-part messages. even showed with our example fig. that it's still possible manage multi-part messages with different keys, still have the issue related the different message sizes, with the need fix the size make sure authorised users aren't aware how many branches secrecy there are that level. this section, propose extension field approach (see fig. that partially solves that problem adding only one field per message that can point message part that only contains hash pointers. this case, the "blue" message has only one extra field for the extension. the content that field can random sequence bytes the hash the "blue" dashed extension. the "blue" extension contains the pointers the "red" part and the "green" part the message. this way, users who sit lower level don't know there are other levels secrecy how many there are. however, with this solution, the users that can read the "red" part the message also know the "green" one, well those who can read the "green" part also know the "red" one. page fig. level secrecy without keys. shortcomings messages out the chain one the main issues needing overcome when building over-layer the message, whose hash added the blockchain, can't control who and which messages can appended. means there's rules limit it, there can problems like trashing and spamming. it's also possible design denial service. this what would happen the lower level, the blockchain has consensus mechanism. fact, the consensus rules how frequently blocks are added the chain. spamming. messaging system, spamming the action send unsolicited messages. this action results overwhelming the channel with valid messages. this case, the channel the space per transaction the field use add the hash the application message. one possible solution can let only third party validate messages signing them. this case, only messages with the right format, which have been signed the authority and have hashes valid chain, can considered valid. however, some business contexts, this approach could mandatory, and would still give the user the transparency, and non-repudiation property, traditional centralised applications can't guarantee without trust. without centralised authority checking message consistency and controlling its growth, replica issues replay attacks can also occur. for example, command valid message added many times, could executed arbitrary number times. also, becomes more difficult build the application logic during the scanning all messages there are messages that have the correct format and the right signatures, but they're longer valid because they're already overledger. there are techniques solve this issue, like enumerating messages using timestamps. trashing. trashing the action overwhelming channel with meaningless data regarding the business logic (not-valid messages). can the action malicious user involuntary act. fact, many applications can run the same blockchain, and messages from one application are trash data for other applications (i.e., lack communication). this means entity the application loses the pointer page the particular block transaction that hosts the hash the message, should compare this hash with all the hashes the valid messages all the applications that have run into that blockchain, until the matching one's found. also means, check message has been validated and added the chain, users have check all the messages and then store the pointer it. speed and throughput messages building new decentralised applications the blockchain layer are affected the parameters concerning the underlying layers (e.g. speed transactions, energy efficiency, scalability). fact, want act the "over-layer", must accept and respect the latency all underlying blockchain technologies involved. thus, discussion about speed and throughput messages relevant. overledger applications may require many operations single (or multiple) blockchain(s). this case, the time for each (and between each) subsequent transaction needs properly accounted for. the trivial case, want perform over-layer action that only affects one blockchain, want make sure the hash the action stored valid transaction. blockchain transaction valid when consensus achieved the distributed network, meaning correct node appends set block of) transaction(s) "m" its copy the blockchain, before appending set block of) transaction(s) "n", then other correct node will append "n" before "m" its copy the blockchain. while this concept consensus finality related the idea correctness (existence single global set recognised transactions the system), refers the ability the distributed system resilient the same correct transaction made multiple times (this also referred the problem double spending) and forks []. this respect, blockchain can follow randomised probabilistic consensus (e.g., bitcoin) deterministic one (all the blockchains based lamport byzantine fault tolerance []). for example, the case bitcoin, "sure" the commitment the transaction use the heuristic the confirmed blocks reduce the probability that someone can come with longer chain making our transaction invalid. now let's suppose have our action ready particular time, need wait for latency not deterministic before our transaction accepted and added block. after this period, also need wait probabilistic period time until consensus achieved blocks the bitcoin case). filtering and ordering layer one the benefits blockchains its capability store all transactions (one after the other) distributed, replicated (collision-free, hiding and puzzle-friendly []), hashed data structure, way that can quickly detect any changes the log data structure any manipulation data (tamper-evident property). the consensus mechanism embedded the blockchain's protocol, unequivocally decides the order valid blocks. thus, filtering and sorting blocks allows trace ownership asset, calculate the balance account, replaying all the transfers and transactions from the beginning the chain []. these transactions and transfers are secured because digital signatures giving the blockchain identification, authorisation and non-repudiation properties. the signature algorithm, the key length public and private key pairs and the hash function produce the account address from the public key are embedded the particular blockchain protocol. the order property, together with the non-repudiation property, solve the double spending problem within the blockchain. the challenge building "over-ledger" upon ledgers define criterion according which blocks can sequentially ordered and which blockchains' addresses can standardised. such criterion should intelligibly order which different blocks different blockchains must processed first and should page translate addresses, which are unique alphanumeric identifiers, different blockchains, into the same format. our reference architecture, all the information contained all the ledgers are put together the filtering and ordering layer logical, not physical layer) where set rules filtering small set messages and transactions and determines their processing order, regardless the sequential position held their respective ledger. for each transaction, can extract information regarding the sources, the receivers, the coins, the script, the contract and combine them define rules. some ledgers allow users append arbitrary data transactions (see subsection ..). users can use this space fill these fields with messages, or, there's not enough space, with their fingerprints. even these messages are meaningful the hosting transactions, can use the contained information filter and order messages and transactions different ways. considering it's straightforward find order among transactions the same ledgers, can challenging multi-ledger environment. the previous section focused how build this message and what can achieve with them. this section we'll introduce the ordering problem and focus on: how set order binary relation for blocks different blockchains; and how allow cross-ledger transactions mapping addresses the various blockchains into one address, valid the overledger domain. order the transactions within application, the application scans the ledgers involved and places transaction hashes compliant the applications blockchain programming interface (bpi) into virtual block, called verification block. hash pointer the verification block then written the blockchains forming part the application. after given interval, dependent variables, such number application transactions and block height, etc, the application then re-scans the blockchains involved back the verification block. any new bpi compliant transactions appended the blockchains that are part the application are then appended the verification block, which updated the blockchains involved. note, there order among transactions the same block amongst invalid transactions. design, the verification block keeping the order across all chains involved the application hashes appended after consensus has been reached. filtering criterion overledger the messaging layer contains potentially infinite combinations messages and information existing all the ledgers. find way bound this set introduce filtering rules drop all the messages we're not interested handling overledger. all these rules are related the transactions and their fields. however, some the fields can filled with arbitrary data used for the out chain messages. this means can set rules these messages because their fingerprints are the ledgers. we've two levels where apply these rules: transaction validation rules; and out chain messages validation rules. the first category can set rules using information the transaction. these set rules include the choice permitted ledgers produce messages. once we've picked the ledgers use, need decide which fields are selected. this difficult, because each ledger has its own transaction structure, page but need select fields build consistent messages among the ledgers. even chose the set shared fields, it's difficult create compliant messages among ledgers. for example, select two ledgers having similar transaction structure and only look the addresses (source and receiver), we'll need find way map the addresses allow for exchange among ledgers. for this reason, out band messages are useful because they provide the ability implement this map and eventually have more detailed information. fact, can map two addresses into two different transaction ledgers' external messages. these messages can contain signature user and their fingerprints the transactions. can also apply complex logic these messages, for example utilising validation schema. however, transaction information essential because they can contain low-level information about addresses and coin information. for example, application can allow some messages only they pay one its lower level (transaction ledger) addresses, certain amount coin, and then use the source that transaction send the response. possibly, can also use script-smart contract information allow legacy application work. ordering criterion for overledger order binary relations. address the order problem faced the filtering and ordering layer, resort the order theory: the branch mathematics that studies the order using binary relations. this theory provides formal tools compare two objects within set and decide which one greater than the other. consider there are objects comparable under many different ways. for example, it's possible sort the set natural numbers with their magnitude with the lexicographical order. complex objects, composed various fields, can compared using the combination their fields. therefore use the concept partially ordered set (poset) order blocks and transactions. poset formalises and generalises the intuitive concept ordering, sequencing, arrangement the elements set. poset consists set, together with binary relation, indicating for certain pairs elements the set, one the elements precedes the other the ordering (i.e., not every pair elements need comparable). given set and relation elements, then partial order iff for all can ensure these three properties: reflexivity: antisymmetry: and then and transitivity: and then these orders are also known poset. can prove only reflexivity and transitivity can call the order preorder. the relation has the antisymmetry and transitivity properties and instead the reflexivity property has the irreflexivity property: irreflexivity: not define this relation strict partial order relation. can prove the previous three properties and the following one: totality: can define the relationship total order and the set total ordered set, linear orders, chains. poset, unique elements exist, like the least element for all the set and the greatest element for all the set. partial order, there can items having elements greater/less than them and are not comparable each other. this case, these elements are called, respectively, minimal page and maximal. there are elements the set that are special, concerning subset the order. given poset binary relation <=, and one its subsets lower bound element such that, less equal all elements conversely, with the same assumptions upper bound element such that all elements are less than equal another important concept the infimum and the supremum. the infimum lower bound called inf subset poset which defined the relation inf for all lower bounds inf. hence, the supremum upper bound called sup subset poset which defined the relation <=, for all upper bounds sup the infimum contained the subset the infimum called the least element, the same way, the supremum contained the subset it's called the greatest element. ordered set has the property every subset that non-empty and has upper bound, also has the least upper bound, then has the least-upper-bound property, also known dedekind completeness []. total order has least element for all its subsets not empty, the order called well-order. important proposition the set theory which build our ordering criterion zorn's lemma zorn's lemma: given poset with the property that every chain contained has upper bound then the set has least one maximal element. moreover, also resort the principle duality [], according which, given statement valid for all partially ordered sets, then its dual statement, obtained inverting the direction all order relations and dualising all order theoretic definitions involved, also valid for all partially ordered sets. namely, every poset gives rise dual (or opposite) partially ordered set pop. this dual order pop defined the set with the inverse order, i.e. holds pop iff holds for this principle, the previous definitions the least element the minimal set can obtained the greatest element, the maximal, inverting the ordering function. starting from given order, this operation allows build new types order. representation poset. there are alternative manners graphically represent poset. the first method via hasse diagrams, now define. the hasse diagram partially ordered set the (directed) graph whose vertices are the elements and whose edges are the pairs (x, for which covers it's usually drawn elements are placed higher than the elements they cover. and covers means [x, ={x, y}. that is, elements the poset lie strictly between and (and y). according the hasse diagram, binary relation represented edge between two vertices representing two elements, such that the vertex that's below the predecessor the relation, and the one above the successor the other vertex. orders are represented bottom-up. example, fig. shows the hasse diagram the poset where the divisors and the divisibility relation that exists one element integer divisor another. for example because divided has reminder, therefore, there's edge connecting these two elements, and below because the binary relation the topmost element because the set there are elements for which divisor. this way visualise the existence maximals. it's not possible spot the existence greatest elements; it's possible there vertex with predecessor and it's not connected the presumed greatest element any its predecessor. the same way, with this representation, it's easy spot minimals, but not that easy understand there's the least element. page fig. hasse diagram all divisors ordered divisibility. another way represent poset via directed acyclic graph (dag). this case, each vertex represents element, and the edges point from the predecessor the successor. example, fig. depicts the order divisibility all the divisors dags are data structures easier implement, and can used check properties, find particular elements. this representation offers way find the set minimals and maximals o(n), where the number vertices, checking node node the list outgoing edges empty (maximals), the list ingoing edges empty (minimal). one these sets has only one element, it's sufficient way prove the existence the greatest element the least element. it's also possible check element predecessor successor another one checking path exists connecting the two elements o(v+e) with depth first search []. fig. dag all divisors ordered divisibility. blocks order popular blockchains. blockchain consensus relates the set rules and procedures allowing maintain and update the ledger and guarantee the trustworthiness the records the ledger, i.e., their reliability, authenticity and accuracy []. those rules and procedures are jointly considered when designing active network consensus validation process, because not only their individual configuration, but also their combination, determines when and how the overall blockchain agreement achieved, and the ledger's updated with new information. from business logic perspective, the correct order information critical because can establish ownership and therefore page rights and obligations []. particular, new information can added, ordered and stored the ledger under different rules consensus immutability and failure tolerance []. the most common rules include the proof-of-work (pow), the proof-of-stake (pos), hybrid solutions like "pow and pos" where pow blocks act checkpoints containing transactions, but anchor both each other and the pos chain. for example, bitcoin and ethereum use set rules respectively called hashcash and etash, based pow. the pow setup, miners connected the network perform the task validating the transactions proposed for addition the blockchain solving the inversion cryptographic function whose solution can only found brute force. pow the probability mining new block depends the instantaneous computational power devoted the task all miners connected the network under the rule "one cpu one vote". pow, miners are continuously asked brute-force one-way hash function computing new hash values based the combination the previous hash values contained the message, the new transaction block and nonce, such that the new hash value will start with given number zeros target. this way it's easy build strict binary relation among blocks. differently from pow, pos the creator new block selected deterministic way, depending its stake. block generation linked the proof ownership certain amount digital assets (e.g., digital currencies) linked the blockchain. the probability prover selected verify the next block larger, the larger the share assets this prover has within the system. the underlying assumption users with large share the system's wealth are more likely provide trustworthy information with respect the verification process, and are therefore considered trusted validator []. the case dlts where the storage data isn't based chains blocks, such ripple [], the addition new information the ledger based iterative processes. each node builds transaction set based the newer transactions knows (candidate set) and broadcasts its trusted network, proposed transaction set applied the ledger. when node receives proposed transaction set trusted nodes, implicitly votes each transaction into the set with "yes" "no" including newer proposed transaction set. certain percentage nodes the trusted network specific node votes for transaction, then that node will add its transaction set. after awhile, the percentage threshold rises making the transaction set converge into one, which added the ledger concerning specific timing scheme. blocks and transaction order overledger. among other things, have seen that consensus techniques order the blocks. it's therefore convenient represent, with hasse diagram the order blocks b(< where: the set all blocks, relation that states which block comes first. total strict order, meaning given two blocks, it's always possible choose which comes first. example, fig. represents the hasse diagram order problem with blocks. fig.: hasse diagram the order b(<, s), where the set blocks{a, a}. page two blocks have two conflicting transactions, the transaction the greatest (latest) block isn't valid because that coin's considered already spent. this how ordering partially solves double-spending. one challenge what happens the two conflicting transactions are present the same block. since transactions within the same block have the same timestamp, can model the set transactions total poset t(<= w), where the set all transactions contained the blocks, and the binary relation that compares transaction order. example, fig. represents the hasse diagram poset problem with blocks and transactions. luckily, this problem automatically solved many blockchain protocols, because blocks with conflicting invalid transactions are not eligible added, and when they're proposed the next block the ledger, they're dropped. this way, it's not possible have conflicting transactions either different blocks the same block []. fig hasse diagram the poset t(<,w), where the set transaction{t, t}. overledger block order. while the order set blocks and transactions within particular blockchain can modelled total order, the comparison the order blocks transactions across different blockchains impossible, those elements exist inside different domains. fig. blockchains and overledger representation. this problem represented fig. showing the hasse diagram the set some blocks two different blockchains: blockchain and the order the poset o(<= s), where the set{a, b}and the binary relation deciding which block comes first. there's way compare block with any other couple blocks belonging different chains. the easiest solution this problem use timestamps decide which block comes first. however, dealing with different consensus mechanisms, the timing scheme regulating the way new blocks are added the chains, can make this choice non-compliant with cross-ledger business logic. moreover, it's possible some chains don't use timestamp comparable with others. fact, timestamps define time range which the transactions are considered have occurred. timestamps are expressed windows, because distributed system there one "true" time. for example, the bitcoin blockchain block rejected contains timestamp: lower than (or equal to) the median timestamp the previous eleven blocks; and greater than (or equal to) the "network-adjusted time" hours. nevertheless, this isn't problem page overledger because there's need compare transactions moving assets existing only their blockchain domain, and therefore don't have conflicting transactions. the situation changes when we'll introduce cross-ledger transactions (in subsection .). this case, we'll explain how can compare some the blocks different chains and detect conflicting transactions. cross-ledger transaction and block poset. fig. provides example cross-ledger transaction. there are two blockchains: "purple" and "green". each block contains set transactions identified the unique field serial and composed 'coin' field indicating the asset moved the transaction, and 'public key' field, showing which user's moving the asset whom. block blockchain (#@a) the transaction indexed cross-ledger transaction that moves the asset blockchain (@a) from the user blockchain (u@a) the user blockchain (u@b). fig.: cross-ledger and overledger transaction representation. the same transaction appears according blockchain semantics into block (#@b) index for the sake simplicity, assume the blockchain semantics are the same. these two transactions represent the same transfer. therefore, it's evident the two blocks containing these two transactions happen together, concerning the business logic our example. however, since these two blocks can added with different consensus methods, it's very unlikely they're added the same time. moreover, avoid inconsistency, it's mandatory find way allow atomic cross-ledger transactions the unfortunate case when only one the two blockchains record the transaction. this overledger representation, even the transactions these two blocks happen the same time, regarding our business logic, they're added into subsequent over blocks. this choice will explained later when we'll introduce protocol achieve atomicity, the user owning the asset proposes the first transfer (see subsection .). fig there's the hasse diagram the set all blocks the different blockchains, ordered the binary relation, stating which block comes first according the overledger business logic. while fig. wasn't possible compare blocks different blockchains, the case fig. we're able compare them because the cross-ledger transaction. namely, can say that (#a #b) (#b<=#a). thus, can model the overledger chain containing blocks the different chains. block the overledger (over block) can include one more blocks different blockchains. page fig. hasse diagram poset o(<=, where are the blocks the blockchains fig. this poset has set minimal blocks for every block because zorn's lemma and duality. fig. represents overledger based the cross-ledger transactions shown fig. fig. overledger modelled blockchain block set note that the block and can grouped together. each overledger block can contain many other blocks different blockchains. therefore, includes the set all transactions those blocks. the example shown fig. can model the overledger block regular block with all the transactions, because we're sure there's conflicts. therefore, can surmise they happen the same time. fig. transactions the block overledger shown fig. page blockchain blockchains. there are more blocks the same blockchain, can't model all the transactions, since they were happening the same time this, may lead enter the same set conflicting transactions. fact, strict order relation exists between transactions different blocks the same blockchain. for this reason consider them all equal. fig. conflicting transactions the same over block. fig. hasse diagram showing the order the blocks which shows cross-ledger transaction between the blocks and #b. this case, the transaction block transfers the coin from u@b u@b; the transaction block moves the same coin from u@b u@b. now there's clear, strict order relation between these two transactions. can't ignore this order and consider these transactions happened the same moment, because the transfer that moves the coin from u@b isn't even valid, since u@b doesn't own the coin yet. hence, overledger treats the blocks, transactions set, poset rather than regular set. leads the block our model contain little piece different chains. obtain what computer science known list lists, this case, blockchain blockchains. fig. blockchain blockchains representation overledger whose hasse diagram fig.. fork issue multi-ledger applications. described blockchains list valid blocks and said there are common rules accept whether new block valid not. however, some cases, blockchain can suffer the fork problem []. fork situation which blockchain splits into two (or more) separate chains temporarily permanently. forks naturally occur when miners unintentionally solve the pow puzzle nearly the same time and generate distinct blocks that succeed the same block. this page undesirable situation which transactions the two (or more) branches are not ordered and thus could conflicting. the rule such situations the longer branch the main chain (long-chain rule). after fork forms, one branch quickly becomes longer, and extended all miners, thus the system's state agreed upon. blocks the shorter branch are pruned and their transactions are ignored, they never happened. however, forks can also occur consequence the use two distinct sets rules trying govern the same blockchain. this case, the fork permanent and can either soft hard []. regardless the reason, forks can compromise the blockchain business logic. for example, branch containing set messages and another one containing completely different set messages, with different order. this problem solved single-ledger environments with other techniques, unfortunately not applicable our context. fork situation, even the branches are conflict with each other, they're consistently alone. therefore, way solve this problem single-ledger environment have clear and universally recognised set rules (like the long-chain rule), independently allowing all users univocally pick the valid branches among the various ones. let's imagine overledger application which interacts with two distinct blockchains, and (fig. fork happens after block blockchain (#@a). the overledger application may not aware the fork and may append some transactions block (#@a). later discover the surviving branch doesn't include block (#@a), the ordering, and therefore the business logic, compromised. even single blockchain fork-resistant and can backup consistent state, can't sure the restored consistent state the one consistent with our business logic, and with the other blockchain, involved the same overledger application. fig. example fork happening one the ledgers overledger, leading inconsistency. cross-ledger transactions distributed environment, it's challenging build applications. the one hand, want our applications guarantee validity the event failures and errors. the other hand, want high availability, security and openness. becomes harder environment where nodes behave according the bar model (byzantine, altruistic rational). this context, one should develop system that's, the same time, acid compliant and byzantine fault tolerant (bft). achieving acid and bft ledger logic challenging because failures, errors and malicious behaviour all the sub chains and their page interactions. the previous section introduced cross-ledger transactions and studied their importance, build order between blocks different blockchains and order between transactions. blockchain and transaction properties computer science, the acronym acid stands for atomicity, consistency, isolation and durability []: atomicity: all changes data are performed they're single operation. that is, all changes are performed, none them are; consistency: data consistent state when transaction starts and when ends; isolation: the intermediate state transaction invisible other transactions. result, transactions that run concurrently appear serialised; and durability: after transaction successfully completes, changes data persist and aren't undone, even the event system failure. these properties guarantee the validity and compliance transactions the business logic. it's not easy satisfy all these properties and systems requiring high availability data and high scalability. it's better use the base property eventual consistency (basically available, soft state, eventually consistent). the base acronym takes its origins from the cap theorem []. the cap theorem states that distributed computer system cannot guarantee all the following three properties the same time: consistency: every time user manages read data will receive the most recent value that data, but they're not guaranteed receive answer; availability: every time user will try read data will always receive reply, but not ensured receives the most recent values; and partition tolerance: the system will work even after many messages were lost among two different partitions the system. base system gives consistency exchange for availability. basically available indicates the system does guarantee availability, terms the cap theorem. soft state indicates the state the system may change over time, even without input. this because the eventual consistency model. eventual consistency indicates the system will become consistent over time, given the system doesn't receive input during that time. base architecture used domains where there's huge demand for data, and approximate answers can tolerated well using stale data. e-commerce sites can show the last item stock many users, and can happen that many users may buy the same item. then it's not issue for the ecommerce site sell the item only one customer and apologise the others. contexts where users are dealing with asset transfers, there's need assure validity and all the acid properties. blockchains don't guarantee, deterministic way, all the acid properties, which consider the next section. acid and blockchain atomicity. each transaction not breakable into smaller operations, and its execution binary. either succeeds aborts. blockchain always guarantees atomicity since transaction can only present absent block. therefore, there are intermediate states where the operation can fail. this also the page case for smart contracts, because even it's true there's precise state those assets the contract, the constraints ruling those assets are either committed aborted. consistency. before operation executed, the system state compliant with the business logic. after the execution the operation, the system different state, still compliant with the business logic. the changes states shifts the focus assure data integrity within the system upheld. one should aware, consistency has different meaning from the consistency the cap theorem. blockchain guarantees consistency, fact, every time transactions are validated block appended. appending new block should not lead the blockchain invalid state because the consensus mechanism assures it's valid block that takes the blockchain valid newer state. isolation. each transaction must executed way that won't interfere with others having the same result system that executes all the transactions sequentially. block's strict order the blockchain guarantees the isolation property. durability. committing transaction produces changes that will persistent. blockchains with nondeterministic consensus agreement finality [], like bitcoin, don't guarantee this property deterministic way, because the probability disagree decreases over time. however, the probability incurring fork can't completely eliminated. therefore, transactions within blocks are not persistent. however, blockchains with deterministic consensus agreement finality, like all those based lamport byzantine fault tolerance [], guarantee this property, because consensus converges with certainty and transactions are immediately confirmed/rejected in/from the ledger. base and blockchain eventual consistency. according this model, different nodes can store different and conflicting states the logic. sufficiently long enough period, nodes detect conflicts and solve them. this means nodes will eventually give the most updated version data. this architecture enforces liveness because nodes don't need sure their data version the most update. they can directly answer the request with the best answer they can give. strong eventual consistency (sec). some contexts, data updates bring the state from one point the same point regardless the order transactions. other words, two nodes receive the same messages, but different order, they're considered the same state anyway. for the same logic, counter that receives the same increment operations and decrement operations will the same state (value), regardless the order these operations. this property isn't true for transactions and can lead invalid state, because the set transactions poset and can't ignore the order, shown fig. however, blocks the blockchain have the order that guarantees consistency among transactions embedded their format. node receives the same blocks, but different order, can rebuild the proper order using hash pointers. this means blockchains can considered strong eventual consistency (sec) systems, that can acid (in the case deterministic consensus), converge probability acid (in the case non-deterministic consensus). the last case, the probability can estimated proportional the number confirmed blocks succeeding the block interest. cross-ledger transaction and acid page atomicity. cross-ledger transactions need record the data all blockchains interested the exchange information. the easiest case, like the one shown fig., the transaction needs recorded both the domains blockchain and the transfer operation longer atomic, for single-ledger operations, because consists two sub-operations. consistency. for various reasons, can happen that cross-ledger transaction recorded only one the blockchains and hence breaking the consistency among blockchains. fact, for example, blockchain records the transfer asset into the domain blockchain according the asset will considered conversely, blockchain may consider that asset still that case, the two blockchains don't agree, and since asset can exist only one domain there's data integrity violation. isolation. cross-ledger transactions don't guarantee isolation. let's suppose blockchain there's transaction that moves asset from user u@b. suppose this transfer failed blockchain the user u@b can use his partial information move asset doesn't own. this example what can happen acting upon uncommitted information. durability. since cross-ledger transactions are based blockchains, the durability property only guaranteed for blockchains based deterministic consensus. instead, for blockchains based nondeterministic consensus, one could estimate probability that's the product the confirmation probabilities all blockchains. two-phase commit and cross-ledger transactions transaction processing, databases, and computer networking, the two-phase commit protocol (pc) type atomic commitment protocol that validates transactions distributed environments. it's distributed algorithm that coordinates all the processes participating distributed atomic transaction, whether commit abort (roll back) the transaction []. other terms, ensures either all the databases are updated none them, that the databases remain synchronised. the algorithm even able achieve its goal, many cases, temporary system failure (involving either process, network node, communication, etc. failures). all computer nodes the network interested the transaction (in our example fig. node and node) need express commit abort coordinator, according time scheme. the coordinator receives all commits from the nodes, will validate the transaction, otherwise will abort it. it's called two-phase commit, because commit can reached after two phases. the first one (voting phase) all nodes express their intention commit abort. the second phase (commit phase) the coordinator will commit the transaction only there's abort error messages. the problem here with cross-ledger transactions need distribute the coordinator's job. the proposed scheme (fig. the role the coordinator made the two entities (two clients, client and server) that exchange asset. they start the interaction posting "ready" message that acts like commit request all blockchains involved. when they succeed add "ready" message all the chains, they then confirm and commit the transaction the chain where the transfer started. all messages "ready" have hash pointer the proposed message prove the user's intentions. the final commit message contains all the hash pointers the "ready" messages. this simple scheme locks the coin until successful transfer. one could build more complicated models only including the ability abort some the involved blockchain (e.g. the one where the transaction has been proposed). page fig. two phase commit scheme. fig. two phase commit scheme two ledgers. rare occasions, the application may write transaction one the blockchains involved and this transaction may invalidated the consensus mechanism performing fork. the ordering solution shown fig. solves this issue appending the last known verification block, common across the blockchains involved the forked chain. the application then scans back across the blockchain reappending any transactions invalidated the fork. both the standard ordering method, and the crossledger fork issue, are shown the diagram fig. have named this solution the verification block. fig. verification block process. page application layer this section, we'll explore the application layer: the upper part our reference architecture. this domain, there are several isolated applications that have their business logic independent from the lower component. applications have the chance communicate with each other putting messages the messaging layer. these messages are compliant with the filtering rules the other application, they can page flow through the filtering and ordering layer the application layer. applications also have the chance implement communication mechanisms not using this scheme. this scheme allows anonymous users send message the application it's compliant with its business logic. overledger applications the previous sections, explored from theoretic point view, how build overledger architecture adding messages meta information different ledgers, giving them order and making them part more complex application business logic. this section we'll describe the steps perform basic transaction, i.e. append message overledger. can start providing clear and formal description what overledger is, what its building blocks are, and how can used via the blockchain programming interface (bpi). overledger definition. overledger can described sorted list messages which satisfy set unambiguous properties. set properties define the valid format message, how build the fingerprint and other requirements dependant the methods required. transaction must contain the fingerprint valid message considered part overledger application. the list these messages defines what call the messaging layer overledger. another set rules determines how sort the valid messages sorted list called the ordering and filtering layer. system using overledger reacts this sequence and can change its state. any change one these sets rules results different list messages, different permutation. more systems, with different control logic, can share the same overledger they respect the same rules. blockchain programming interface (bpi). multi-ledger applications wanting use overledger will need define two sets (mandatory and optional) rules. these rules determine how wire protocol will interact with the overledger system and with other users/applications. non-exhaustive list rules includes: accept messages that can validated specific schema; accept messages only they respect certain pattern sequences (e.g. want receive the "propose" message before the "ready" message); accept messages only their fingerprint (hash) has been appended particular set ledgers; accept messages only their fingerprint has specific source and recipe addresses; and accept messages only their fingerprint spending least certain amount cryptocurrency. application can define more complex messages, can use any combination them (e.g. different messages can have different validation schema, different rules the transactions hosting their fingerprint). the rules can also involve other information, for example, the script the contract they contain. this respect, this schema similar the one used systems which expose apis. fact, those systems, the application level, publish file and library interact with the system abstract data type (adt). likewise, our set rules describe how interact with overledger. assume the approach the same, having the api the application layer and rules the messaging layer, and are technology independent. call our approach, bpi (blockchain programming interface). bpi essentially marked-up text that defines the specific overledger rules application must follow order add messages, read the output write, the ledgers question. the bpi should automatically read the clients that implement the required methods according their technology. we're now creating overledger software development kit (sdk): set software development tools page that will allow applications define the rules (bpi) without the need address the low-level details regarding transactions and messages. through the sdk, we'll also enable additional methods, where appropriate, interface with other lower level functions the ledgers question. after the final overview overledger, and the introduction the overledger bpi, provide simple example typical transaction journey. describe the steps followed order append valid message overledger. this example, user (client) wants append specific message, should follow the following rules: the client reads the requirements for the message wants append; the client builds valid message and calculates its fingerprint the client builds valid transaction t(inserting the fingerprint) and proposes the systems charge proposing transactions; appended ledger accepted the bpi; and the client sends the complete message the application and the transaction that contains its fingerprint. note that the rules this example are interchangeable. application level responsibility sections and discussed the different roles the messaging layer and the filtering and ordering layer. explained those are logical layers, but didn't explain who's charge implementing those features. filtering messages requires deep knowledge all the different blockchains included the overledger application. for this reason, would convenient build open source libraries helping the application developer use high-level function interact with blockchains. let's take example write operation for client sending message particular application (app_id=): import import import import import bitcoin btc ethereum eth json hashlib requests message definition# jstring {'app_id'=, message'='hello world', 'client'=} msg json.dumps(jstring, sort_keys=true) hash_function hashlib.sha() hash_function.update(msg) hash_message hash_function.digest() requests.post(server_address, json=msg) page eth.add_msg_out_of_the_chain(hash_message) btc.add_msg_out_of_the_chain(hash_message) btc.add_msg_out_of_the_chain(hash_message, mode='op_return') this example, the code takes all the responsibilities for all layers. the first lines are both related messaging and filtering: the definition particular message format, the values the particular message instance, the chosen hash function and the method how the message added the ledger. the last two lines code show the bitcoin chain can allow different way add information its ledger. the last line, the optional parameter mode specifies which one must used rather than the default option. this performs the post-operation send the entire message through the network. op_return script opcode used mark bitcoin transaction output invalid. since any outputs with op_return are provably un-spendable, op_return can used for digital asset proof-ofownership and other transaction-based business logics. the server responsible for checking the message valid and, this case, the hash that message the blockchains interest, with the proper transaction parameters (addresses and coins). check the message the chain, the application needs perform scan the newer blocks and react, when finds the message. this can lead solutions that need timeout and complex protocol. the server finds the hash message, can react, because the json file there's all the information the receiver. this case, there's the field "client" the message equal one. that number can refer client address set configurations, allow the server reply with this schema, adding messages blockchains. another design solution can assign the responsibility check the hash the client, that can scan the interested ledgers, until finds the transaction and can prove providing the transaction's hash pointer (e.g. merkle tree proof) the server. this case, the server can quickly check the lowest details and doesn't need pull all the interested chains scan. this last example, introduce, the import statement, library "quant", that takes the responsibility for tasks the filtering and order layer. the application loads the configuration file that can hosted the local storage, can downloaded every time, guarantee consistency between the application upgrade and the client application. this case, the developer needs only focus the business logic the client. import quant.app_builder app new q.client_application() #in conf.txt there are all the information #about the filtering layer app.set_configuration(./conf.txt) jstring {'app_id'=, message'='hello world'} msg json.dumps(jstring) app.sendmessage(msg) page use cases there are many uses for overledger produced applications, all which are far too numerous list this paper, but example, we've included one the simplest. cqrs-es and overledger command query responsibility segregation. cqrs (command query responsibility segregation) architecture pattern introduced greg young []. this pattern uses different models for writing and reading the model. the writing model should manage the command operations that, following the cqs (command query separation) vocabulary, can update the model and must not return value. the reading operations should handle the query operations that mustn't change the system state (no side-effects). some domains this pattern can useful for breaking down the complexity system, especially where reading operations and writing operations have different time scales. fig. cqrs architecture schema for overledger. overledger can good fit for this pattern implementation (see fig. can use two more different blockchains, some for appending commands and others for querying the status. this can useful, not only because the application may have different scale for reading and writing, but because different blockchains have different levels security and different throughput. for example, could make sense use faster blockchain collect the commands, and more secure (and probably lower speed) blockchain store the valid transaction the application logic; use different blockchain show different types aggregation according the client's needs (this blockchain could only store the client state verification blocks). overledger event sourcing (oes) pattern that builds the status the system scanning all events that have changed it. when new event happens, rather than updating the state the system, events sourcing architecture appends the event stream. the state calculating replaying all the events. since appending events single operation, oes inherently atomic. the way the state calculated has page many similarities with blockchain technology. fig. events are appended one blockchain and different domains the applications retrieve those event data for different reasons. for example, one domain can interested storing data for etl, one for optimising searches, and another for processing the event and streaming the output another blockchain. fig. cqrs architecture schema for overledger. the similarities between this pattern and the mode operation the blockchain makes its integration with overledger natural. the literature cqrs and event sourcing (es) are often combined and used together (cqrs-es), noting this still applicable with overledger. communications. while email, its current state, very effective medium, does, however, have one flaw. the receiver the email can refute the delivery the communication. even where controls, such delivery/read receipts, are requested, these can ignored the recipient. now were use overledger simple messaging solution could produce the process flow figure page message send message response fig. simple overledger message flow. conclusion the above paper, propose the design new operating system able increase interoperability between different dlt technologies. the overledger operating system proposes approach both order and manage the blockchain blocks forming part the overledger application. does this eliminate double spending problems, while maintaining the ability react situations where the dlt may become subject fork, result not being part the accepted consensus. solve the above challenges introducing both the bpi (blockchain programming interface), and the verification block, described above. these solutions, when coupled with -phase-commit, can facilitate crossledger transactions, both transactional and messaging layer. finally, the paper describes that leveraging features within the underlying functionality the dlt's, these can utilised impose cqrs architecture pattern. this can then held and managed externally interface not only across dlts, but also integrate with legacy systems and external data sources. page bibliography satoshi nakamoto. bitcoin: peer-to-peer electronic cash system. tomaso aste, paolo tasca, and tiziana matteo. "blockchain technologies: the foreseeable impact society and industry." computer (): paolo tasca, digital currencies: principles, trends, opportunities, and risks (september available ssrn: https://ssrn.com/abstract= birkhoff, garrett. lattice theory. (rd revised ed.). american mathematical society. luke dashjr mark friedenbach gregory maxwell andrew miller andrew poelstra jorge timn adam back, matt corallo and pieter wuille. enabling blockchain innovations with pegged sidechains. edward felten andrew miller steven goldfeder arvind narayanan, joseph bonneau. bitcoin and cryptocurrency technologies. ryan shea michael freedman princeton university jude nelson, muneeb ali and blockstack labs. extending existing blockchains with virtualchain. jae kwon and ethan buchman. cosmos. network distributed ledgers. marshall pease leslie lamport, robert shostak. the byzantine generals problem. jude nelson muneeb ali, ryan shea and michael freedman. blockstack: new internet for decentralised applications. barbara liskov miguel castro. practical byzantine fault tolerance,laboratory for computer science, massachusetts institute technology. pierre karpman ange albertini marc stevens, elie bursztein and yarik markov. aion: the third-generation blockchain network. pierre karpman ange albertini marc stevens, elie bursztein and yarik markov. the first collision for full sha-. the digital asset platform. non-technical white paper. manny trillo. stefan thomas and evan schwartz. protocol for interledger payments. gavin wood. polkadot: vision for heterogeneous multi-chain framework. gavin wood. ethereum: secure decentralised generalised transaction ledger. yellow paper. jae kwon. tendermint: consensus without mining. matthew, spoke and nuco engineering team, aion: the third-generation blockchain network, paolo tasca, shaowen liu, and adam hayes. the evolution the bitcoin economy: extracting and analyzing the network payment relationships. forthcoming journal risk finance, aliprantis, charalambos burkinshaw, owen. principles real analysis (third ed.). academic. campbell pj. the origin "zorn's lemma". historia mathematica. feb ;():-. bitcoin wiki. op_return. [online] available https://en.bitcoin.it/wiki/op_return. [accessed january ethereum github. ethereum development tutorial. [online] available https://github.com/ ethereum/wiki/wiki/ethereum-development-tutorial. [accessed january ripple. transactions format. [online] available https://ripple.com/build/transactions/. [accessed january davey, b.a.; priestley, a., introduction lattices and order (nd ed.), cambridge university press, cqrs. welcome cqrs info. [online] available https://cqrs.wordpress.com//// welcome-to-cqrs-info/. [accessed january even, shimon, graph algorithms (nd ed.), cambridge university press, pp. paolo tasca, thayabaran thanabalasingham, claudio tessone. taxonomy blockchain technologies. principles identification and classification. forthcoming ledger journal. back, adam. hashcash-a denial service counter-measure. david schwartz, noah youngs, arthur britto. the ripple protocol consensus algorithm. page juri mattila. the blockchain phenomenon. in: the blockchain phenomenon(berkeley roundtable the international economy, edn.). peter todd. soft forks are safer than hard forks. [online] available https://petertodd.org// soft-forks-are-safer-than-hard-forks [accessed january haerder, t.; reuter, a.. principles transaction-oriented database recovery. acm computing surveys. (): doi:./.. brewer, eric towards robust distributed systems. podc. vol. bitcoin wiki. colored coins. https://en.bitcoin.it/wiki/colored_coins, [accessed january philip bernstein, vassos hadzilacos, nathan goodman.: concurrency control and recovery database systems, chapter addison wesley publishing company. rob price, digital currency ethereum cratering because million hack. business insider, jun. [online] available http://uk.businessinsider.com/dao-hacked-ethereum-crashing-in-value-tensof-millions-allegedly-stolen--?ir=t [accessed december croman, kyle, al. scaling decentralised blockchains. international conference financial cryptography and data security. springer, berlin, heidelberg, paolo tasca, and sebastian widmann. the challenges faced blockchain technologies-part journal digital banking (): paolo tasca, and sebastian widmann. the challenges faced blockchain technologies-part forthcoming journal digital banking. page