chainlink decentralized oracle network steve ellis, ari juels+ and sergey nazarov september (v.) abstract smart contracts are poised revolutionize many industries replacing the need for both traditional legal agreements and centrally automated digital agreements. both performance verification and execution rely manual actions from one the contracting parties, automated system that programmatically retrieves and updates relevant changes. unfortunately, because their underlying consensus protocols, the blockchains which smart contracts run cannot support native communication with external systems. today, the solution this problem introduce new functionality, called oracle, that provides connectivity the outside world. existing oracles are centralized services. any smart contract using such services has single point failure, making more secure than traditional, centrally run digital agreement. this paper present chainlink, decentralized oracle network. describe the on-chain components that chainlink provides for contracts gain external connectivity, and the software powering the nodes the network. present both simple on-chain contract data aggregation system, and more efficient off-chain consensus mechanism. also describe supporting reputation and security monitoring services for chainlink that help users make informed provider selections and achieve robust service even under aggressively adversarial conditions. finally, characterize the properties ideal oracle guidance for our security strategy, and lay out possible future improvements, including richly featured oracle programming, data-source infrastructure modifications, and confidential smart-contract execution. contents introduction architectural overview on-chain architecture off-chain architecture oracle security chainlink decentralization approach distributing sources distributing oracles chainlink security services validation system reputation system certification service contract-upgrade service link token usage long-term technical strategy confidentiality infrastructure changes off-chain computation existing oracle solutions conclusion off-chain aggregation oca protocol proof sketches discussion sgx trust assumptions introduction smart contracts are applications that execute decentralized infrastructure, such blockchain. they are tamperproof, the sense that party (even their creator) can alter their code interfere with their execution. historically, contracts embodied code have run centralized manner that leaves them subject alteration, termination, and even deletion privileged party. contrast, smart contracts' execution guarantees, which bind all parties agreement written, create new and powerful type trust relationship that does not rely trust any one party. because they are self-verifying and self-executing (i.e., tamperproof explained above), smart contracts thus offer superior vehicle for realizing and administering digital agreements. the powerful new trust model that smart contracts embody, though, introduces new technical challenge: connectivity. the vast majority interesting[] smart contract applications rely data about the real world that comes from key resources, specifically data feeds and apis, that are external the blockchain. because the mechanics the consensus mechanisms underpinning blockchains, blockchain cannot directly fetch such critical data. propose solution the smart contract connectivity problem the form chainlink, secure oracle network. what differentiates chainlink from other oracle solutions its ability operate fully decentralized network. this decentralized approach limits the trust any single party, enabling the tamperproof quality valued smart contracts extended the end-to-end operation between smart contracts and the apis they rely on. making smart contracts externally aware, meaning capable interacting with off-chain resources, necessary they are going replace the digital agreements use today. today, the lion's share traditional contractual agreements that have been digitally automated use external data prove contractual performance, and require data outputs pushed external systems. when smart contracts replace these older contractual mechanisms, they will require high-assurance versions the same types data inputs and outputs. examples potential next-generation smart contracts and their data requirements include: securities smart contracts such bonds, interest rate derivatives, and many others will require access apis reporting market prices and market reference data, e.g. interest rates. the main use smart contracts ethereum today management tokens, which are common functionality most smart contract networks. believe that the current focus tokens the exclusion many other possible applications due lack adequate oracle services, situation chainlink specifically aims remedy. insurance smart contracts will need data feeds about iot data related the insurable event question, e.g.: was the warehouse's magnetic door locked the time breach, was the company's firewall online, did the flight you had insurance for arrive time. trade finance smart contracts will need gps data about shipments, data from supply chain erp systems, and customs data about the goods being shipped order confirm fulfillment contractual obligations. another problem common these examples the inability for smart contracts output data into off-chain systems. such output often takes the form payment message routed traditional centralized infrastructure which users already have accounts, e.g., for bank payments, paypal, and other payment networks. chainlink's ability securely push data apis and various legacy systems behalf smart contract permits the creation externally-aware tamperproof contracts. whitepaper roadmap this whitepaper*, review the chainlink architecture (section then explain how define security for oracles (section describe the chainlink approach decentralization distribution oracles and data sources (section and follow with discussion the four security services proposed chainlink, well the role played link tokens (section then describe proposed long-term development strategy, which includes better confidentiality protections, the use trusted hardware, infrastructure changes, and general oracle programmability (section briefly review alternative oracle designs (section and conclude with short discussion the design principles and philosophy guiding chainlink development (section architectural overview chainlink's core functional objective bridge two environments: on-chain and offchain. describe the architecture each chainlink component below. chainlink will initially built ethereum [], [], but intend for support all leading smart contract networks for both off-chain and cross-chain interactions. both its and off-chain versions, chainlink has been designed with modularity mind. every piece the chainlink system upgradable, that different components can replaced better techniques and competing implementations arise. on-chain architecture oracle service, chainlink nodes return replies data requests queries made behalf user contract, which refer requesting contracts and denote user-sc. chainlink's on-chain interface requesting contracts itself on-chain contract that denote chainlink-sc. behind chainlink-sc, chainlink has on-chain component consisting three main contracts: reputation contract, order-matching contract, and aggregating contract. the reputation contract keeps track oracle-service-provider performance metrics. the order-matching smart contract takes proposed service level agreement, logs the sla parameters, and collects bids from oracle providers. then selects bids using the reputation contract and finalizes the oracle sla. the aggregating contract collects the oracle providers' responses and calculates the final collective result the chainlink query. also feeds oracle provider metrics back into the reputation contract. chainlink contracts are designed modular manner, allowing for them configured replaced users needed. the on-chain work flow has three steps: oracle selection, data reporting, result aggregation. oracle selection oracle services purchaser specifies requirements that make service level agreement (sla) proposal. the sla proposal includes details such query parameters and the number oracles needed the purchaser. additionally, the purchaser specifies the reputation and aggregating contracts used for the rest the agreement. using the reputation maintained on-chain, along with more robust set data gathered from logs past contracts, purchasers can manually sort, filter, and select oracles via off-chain listing services. our intention for chainlink maintain one such listing service, collecting all chainlink-related logs and verifying the binaries listed oracle contracts. further detail the listing service and reputation systems section the data used generate listings will pulled from the blockchain, allowing for alternative oracle-listing services built. purchasers will submit sla proposals oracles off-chain, and come agreement before finalizing the sla on-chain. manual matching not possible for all situations. for example, contract may need request oracle services dynamically response its load. automated solutions solve this problem and enhance usability. for these reasons, automated oracle matching also being proposed chainlink through the use order-matching contracts. once the purchaser has specified their sla proposal, instead contacting the oracles directly, they will submit the sla order-matching contract. the submission the proposal the order-matching contract triggers log that oracle providers can monitor and filter based their capabilities and service objectives. chainlink nodes then choose whether bid the proposal not, with the contract only accepting bids from nodes that meet the sla's requirements. when oracle service provider bids contract, they commit it, specifically attaching the penalty amount that would lost due their misbehavior, defined the sla. bids are accepted for the entirety the bidding window. once the sla has received enough qualified bids and the bidding window has ended, the requested number oracles selected from the pool bids. penalty payments that were offered during the bidding process are returned oracles who were not selected, and finalized sla record created. when the finalized sla recorded triggers log notifying the selected oracles. the oracles then perform the assignment detailed the sla. data reporting once the new oracle record has been created, the off-chain oracles execute the agreement and report back on-chain. for more detail about off-chain interactions, see sections and result aggregation once the oracles have revealed their results the oracle contract, their results will fed the aggregating contract. the aggregating contract tallies the collective results and calculates weighted answer. the validity each oracle response then reported the reputation contract. finally, the weighted answer returned the specified contract function user-sc. detecting outlying incorrect values problem that specific each type data feed and application. for instance, detecting and rejecting outlying answers before averaging may necessary for numeric data but not boolean. for this reason, there will not specific aggregating contract, but configurable contract address which specified the purchaser. chainlink will include standard set aggregating contracts, but customized contracts may also specified, provided they conform the standard calculation interface. off-chain architecture off-chain, chainlink initially consists network oracle nodes connected the ethereum network, and intend for support all leading smart contract networks. these nodes independently harvest responses off-chain requests. explain below, their individual responses are aggregated via one several possible consensus mechanisms into global response that returned requesting contract user-sc. the chainlink nodes are powered the standard open source core implementation which handles standard blockchain interactions, scheduling, and connecting with common external resources. node operators may choose add software extensions, known external adapters, that allow the operators offer additional specialized off-chain services. chainlink nodes have already been deployed alongside both public blockchains and private networks enterprise settings; enabling the nodes run decentralized manner the motivation for the chainlink network. chainlink core. the core node software responsible for interfacing with the blockchain, scheduling, and balancing work across its various external services. work done chainlink nodes formatted assignments. each assignment set smaller job specifcations, known subtasks, which are processed pipeline. each subtask has specific operation performs, before passing its result onto the next subtask, and ultimately reaching final result. chainlink's node software comes with few subtasks built in, including http requests, json parsing, and conversion various blockchain formats. external adapters. beyond the built-in subtask types, custom subtasks can defined creating adapters. adapters are external services with minimal rest api. modeling adapters service-oriented manner, programs any programming language can easily implemented simply adding small intermediate api front the program. similarly, interacting with complicated multi-step apis can simplified individual subtasks with parameters. subtask schemas. anticipate that many adapters will open sourced, that services can audited and run various community members. with many different types adapters being developed many different developers, ensuring compatibility between adapters essential. chainlink currently operates with schema system based json schema [], specify what inputs each adapter needs and how they should formatted. similarly, adapters specify output schema describe the format each subtask's output. oracle security order explain chainlink's security architecture, must first explain why security important--and what means. why must oracles secure? returning our simple examples section smart contract security gets false data feed, may payout the incorrect party, smart contract insurance data feeds can tampered with the insured party figure chainlink workflow: user-sc makes on-chain request; chainlink-sc logs event for the oracles; chainlink core picks the event and routes the assignment adapter; chainlink adapter performs request external api; chainlink adapter processes the response and passes back the core; chainlink core reports the data chainlink-sc; chainlink-sc aggregates responses and passes them back single response user-sc. there may insurance fraud, and gps data given trade finance contract can modified after leaves the data provider, payment can released for goods that haven't arrived. more generally, well-functioning blockchain, with its ledger bulletin-board abstraction, offers very strong security properties. users rely the blockchain functionality that correctly validates transactions and prevents data from being altered. they treat effect like trusted third party concept discuss length below). supporting oracle service must offer level security commensurate with that the blockchain supports. oracle too must therefore serve users effective trusted third party, providing correct and timely responses with very high probability. the security any system only strong its weakest link, highly trustworthy oracle required preserve the trustworthiness wellengineered blockchain. defining oracle security: ideal view. order reason about oracle security, must first define it. instructive, principled way reason about oracle security stems from the following thought experiment. imagine that trusted third party (ttp)--an ideal entity functionality that always carries out instructions faithfully the letter--were tasked with running oracle. we'll denote this oracle oracle (using all caps general denote entity fully trusted users), and suppose that the ttp obtains data from perfectly trustworthy data source src. given this magical service oracle, what instructions would ask carry out? achieve the property integrity, also referred the authenticity property [], would simply ask that oracle perform the following steps: figure behavior ideal oracle oracle defined steps: accept request; obtain data; return data. additionally, protect the confidentiality request, upon decrypting it, oracle never uses reveals the data contains, except query src. accept request: ingest from smart contract user-sc request req (src, that specifies target data source src, time range times and query obtain data: send query src time return data: receiving answer return the smart contract. these simple instructions, correctly carried out, define strong, meaningful, but simple notion security. intuitively, they dictate that oracle acts trustworthy bridge between src and user-sc. for example, src https://www.fountofknowledge.com, p.m., and "price for ticker intc", the integrity oracle guarantees that will provide user-sc with exactly the price intc queried p.m. https://www.fountofknowledge.com. confidentiality another desirable property for oracles. user-sc sends req oracle the clear the blockchain, req public. there are many situations which req sensitive and its publication could harmful. user-sc flight insurance contract, for example, and sends oracle query req regarding particular user's flight "ether air flight "), the result would that user's flight plans are revealed the whole world. user-sc contract for course, many details are omitted here. oracle should communicate with both user-sc and source src over secure, i.e., tamperproof, channels. (if src web server, tls required. communicate with user-sc, oracle must sure scrape the right blockchain and digitally sign appropriately.) financial trading, req could leak information about user's trades and portfolio. there are many other examples, course. protect the confidentiality req, can require that data req encrypted under (public key) belonging oracle. continuing leverage the ttp nature oracle, could then simply give oracle the information-flow constraint: upon decrypting req, never reveal use data req except query src. there are other important oracle properties, such availability, the last the classical cia (confidentiality-integrity-availability) triad. truly ideal service oracle, course, would never down. availability also encompasses more subtle properties such censorship resistance: honest oracle will not single out particular smart contracts and deny their requests. the concept trusted third party similar the notion ideal functionality used prove the security cryptographic protocols certain models. can also model blockchain similar terms, conceptualizing terms ttp that maintains ideal bulletin board. its instructions are accept transactions, validate them, serialize them, and maintain them permanently the bulletin board, append-only data structure. why the ideal oracle (oracle) hard achieve. there is, course, perfectly trustworthy data source src. data may benignly maliciously corrupted due faulty web sites, cheating service providers, honest mistakes. src isn't trustworthy, then even oracle does operate exactly like ttp instructed above, still doesn't completely meet the notion security want. given faulty source src, the integrity property defined above longer means that oracle's answer correct. the true price intel and https://www.fountofknowledge.com misreports for example, then oracle will send the incorrect value user-sc. this problem unavoidable when using single source src. oracle simply has way know whether the answers src provides its queries are correct. bigger issue, course, the fact that our ttp for oracle just abstraction. service provider unconditionally trustworthy. even the best-intentioned may buggy hacked. there way for user smart contract have absolute assurance that service oracle will carry out its instructions faithfully. chainlink reasons about its security protocols terms this ideal functionality oracle. our goal chainlink achieve real world system with properties close possible those oracle under realistic trust assumptions. now explain how. for simplicity what follows, now denote chainlink-sc the complete set chainlink contracts, i.e., its full on-chain functionality (not just its interface requesting contracts). thereby abstract away the multiple individual contracts actually used the system architecture. chainlink decentralization approach propose three basic complementary approaches ensuring against faulty nodes: distribution data sources; distribution oracles; and use trusted hardware. discuss the first two approaches, which involve decentralization, this section. discuss our long-term strategy for trusted hardware, different and complementary approach, section distributing sources simple way deal with faulty single source src obtain data from multiple sources, i.e., distribute the data source. trustworthy oracle can query collection sources src src srck obtain responses and aggregate them into single answer agg(a oracle might this any number ways. one, for example, majority voting. majority sources return the identical value the function agg returns otherwise returns error. this case, provided that majority k/) sources are functioning correctly, oracle will always return correct value many alternative functions agg can ensure robustness against erroneous data handle fluctuations data values over time (e.g, stock prices). for example, agg might discard outliers (e.g., the largest and smallest values and output the mean the remaining ones. course, faults may correlated across data sources way that weakens the assurances provided aggregation. site src echoecho.com obtains its data from src thehorsesmouth.com, error src will always imply error src more subtle correlations between data sources can also occur. chainlink also proposes pursue research into mapping and reporting the independence data sources easily digestible way that oracles and users can avoid undesired correlations. distributing oracles just sources can distributed, our ideal service oracle itself can approximated distributed system. this say that instead single monolithic oracle node can instead have collection different oracle nodes each oracle contacts its own distinct set data sources which may may not figure requests are distributed across both oracles and data sources. this figure shows example such two-level distribution. overlap with those other oracles. aggregates responses from its data sources and outputs its own distinct answer query req. some these oracles may faulty. clearly the set all oracles' answers will need aggregated trustworthy way into single, authoritative value but given the possibility faulty oracles, where and how will this aggregation happen chainlink? initial solution: in-contract aggregation. our initial proposed solution chainlink will simple one called in-contract aggregation. chainlink-sc-- which, again, denotes the on-chain part chainlink--will itself aggregate oracle responses. (alternatively, chainlink-sc may call another aggregation contract, but for conceptual simplicity assume that the two components form single contract.) other words, chainlink-sc will compute agg(a for some function agg (similar agg, described above), and send the result user-sc. this approach practical for small and has several distinct benefits: conceptual simplicity: despite the fact that the oracle distributed, single entity, chainlink-sc, performs aggregation executing agg. trustworthiness: chainlink-sc's code can publicly inspected, its correct behavior can verified. (chainlink-sc will relatively small, simple piece code.) additionally, chainlink-sc's execution fully visible on- chain. thus users, i.e., creators user-sc, can achieve high degree trust chainlink-sc. flexibility: chainlink-sc can implement most desired aggregation functions agg--the majority function, averaging, etc. simple is, this approach presents novel and interesting technical challenge, namely the problem freeloading. cheating oracle can observe the response another oracle and copy it. this way, oracle avoids the expense querying data sources, which may charge per-query fees. freeloading weakens security undermining the diversity data source queries and also disincentivizes oracles from responding quickly: responding slowly and freeloading cheaper strategy. suggest well known solution this problem, namely the use commit reveal scheme. first round, oracles send chainlink-sc cryptographic commitments their responses. after chainlink-sc has received quorum responses, initiates second round which oracles reveal their responses. algorithm shows simple sequential protocol that guarantees availability given nodes. uses commit reveal scheme prevent freeloading. oracle responses are decommitted, and thus exposed potential freeloader only after all commitments have been made, thereby excluding the freeloader from copying other oracles' responses. on-chain protocols can leverage block times support synchronous protocol designs. chainlink, however, oracle nodes obtain data from sources that may have highly variable response times, and decommitment times nodes can vary due to, e.g., use different gas prices ethereum. ensure the fastest possible protocol responsiveness, therefore, alg. designed asynchronous protocol. here, commitr (a) denotes commitment value with witness while sid denotes the set valid session ids. the protocol assumes authenticated channels among all players. easy see that alg. will terminate successfully. given nodes total, most are faulty, least will send commitments step those commitments, most come from faulty nodes, least come from honest nodes. all such commitments will eventually decommitted. additionally, easy see that will correct alg.. the decommitments the single value least one has come from honest node. in-contract aggregation via alg. will the main approach supported chainlink the short term. the proposed initial implementation will involve more sophisticated, concurrent variant the algorithm. our longer-term proposal reflected the rather more complicated protocol oca (off-chain aggregation) specified algorithms and appendix oca off-chain aggregation protocol that algorithm inchainagg({oi }ni= (code for chainlink-sc) wait until req received from user-sc. sid sid broadcast (request, sid). wait until set messages (commit, commitri (ai sid) from distinct are received. broadcast (committed, sid). wait until set distinct valid decommitments (decommit, (ri sid) are received where, for some all send (answer, sid) user-sc. minimizes on-chain transaction costs. that protocol also includes payment oracle nodes and ensures against payments freeloaders. medium-term strategy: off-chain aggregation. in-contract aggregation has key disadvantage: cost. incurs the cost transmitting and processing onchain o(n) oracle messages (commits and reveals for permissioned blockchains, this overhead may acceptable. permissionless blockchains with onchain transaction fees such ethereum, large, the costs can prohibitive. more cost-effective approach aggregate oracle responses off-chain and transmit single message chainlink-sc propose deployment this approach, called off-chain aggregation, the medium-to-long term. the problem achieving consensus value the face potentially faulty nodes much like the problem consensus that underpins blockchains themselves. given predetermined set oracles, one might consider using classical byzantine fault tolerant (bft) consensus algorithm compute classical bft protocols, however, aim ensure that the end protocol invocation, all honest nodes store the same value, e.g., blockchain, that all nodes store the same fresh block. our oracle setting, the goal slightly different. want ensure that chainlink-sc (and then user-sc) obtains aggregate answer agg(a without participating the consensus protocol and without needing receive answers from multiple oracles. the problem freeloading, moreover, still needs addressed. the chainlink system proposes the use simple protocol involving threshold signatures. such signatures can realized using any number signature schemes, but are especially simple implement using schnorr signatures []. this approach, oracles have collective public key and corresponding private key that shared among (t, n)-threshold manner []. such sharing means that every node has distinct private public keypair (ski pki can figure sigsk [a] can achieved any n/+ the oracles. generate partial signature sigski [ai that can verified with respect pki the key feature this setup that partial signatures the same value can aggregated across any set oracles yield single valid collective signature sigsk [a] answer set oracles, however, can produce valid signature any value. the single signature thus implicitly embodies the partial signatures least oracles. threshold signatures can realized naively letting consist explicitly set valid, independent signatures from individual nodes. threshold signatures have similar security properties this naive approach. but they provide significant onchain performance improvement: they reduce the size and cost verifying factor with this setup, would seem that oracles can just generate and broadcast partial signatures until such partial signatures enable the computation again, though, the problem freeloading arises. must therefore ensure that oracles genuinely obtain data from their designated sources, rather than cheating and copying from another oracle. our solution involves financial mechanism: entity provider (realizable smart contract) rewards only oracles that have sourced original data for their partial signatures. distributed setting, determining which oracles qualify for payment turns out tricky. oracles may intercommunicate off-chain and longer have single authoritative entity (chainlink-sc) receiving responses and are therefore un- able identify eligible payees directly among participating oracles. consequently, provider must obtain evidence misbehavior from the oracles themselves, some which may untrustworthy. propose the use consensus-like mechanisms our solution for chainlink ensure that provider does not pay freeloading oracles. the off-chain aggregation system propose for chainlink, with accompanying security proof sketches, may found appendix makes use distributed protocol based threshold signatures that provides resistance freeloading faulty oracles. this end, propose the use four key security services: validation system, reputation system, certification service, and contract-upgrade service. all these services may initially run one company group interested launching the chainlink network, but are designed operate strictly accordingly chainlink's philosophy decentralized design. chainlink's proposed security services cannot block oracle node participation alter oracle responses. the first three services only provide ratings guidance users, while the contract-upgrade service entirely optional for users. additionally, these services are designed support independent providers, whose participation should encouraged that users will eventually have multiple security services among which choose. validation system the chainlink validation system monitors on-chain oracle behavior, providing objective performance metric that can guide user selection oracles. will seek monitor oracles for: availability: the validation system should record failures oracle respond timely way queries. will compile ongoing uptime statistics. correctness: the validation system should record apparent erroneous responses oracle measured deviations from responses provided peers. our initial, on-chain aggregation system chainlink, such monitoring straightforward, all oracle activity visible chainlink-sc. recall, however, that the off-chain aggregation system envisaged for chainlink, it's the oracles themselves that perform aggregation. consequently, chainlink-sc does not have direct visibility into oracle responses and cannot itself monitor availability and correctness. fortunately, oracles digitally sign their responses, and thus, side effect, generate non-repudiable evidence their answers. our proposed approach will therefore realize the validation service smart contract that would reward oracles for submitting evidence deviating responses. other words, oracles would incentivized report apparently erroneous behavior. availability somewhat trickier monitor, oracles course don't sign their failures respond. instead, proposed protocol enhancement would require oracles digitally sign attestations the set responses they have received from other oracles. the validation contract would then accept (and again reward) submission sets attestations that demonstrate consistent non-responsiveness underperforming oracle its peers. both the on-chain and off-chain cases, availability and correctness statistics for oracles will visible on-chain. users developers will thus able view them real time through appropriate front end, such dapp ethereum equivalent application for permissioned blockchain. reputation system the reputation system proposed for chainlink would record and publish user ratings oracle providers and nodes, offering means for users evaluate oracle performance holistically. validator system reports are likely major factor determining oracle reputations and placing these reputations firm footing trust. factors beyond on-chain history, though, can provide essential information about oracle node "deviation" must defined data-specific manner. for simple boolean responses--for example, whether flight arrived time--deviation simply means response opposite that the majority. for, say, the temperature city, which may vary legitimately across sensors and sources, deviation may mean significant numerical deviation. course, for various reasons, e.g., broken sensors, even well-functioning oracle may deviate from the majority answer some fraction the time. security profiles. these may include users' familiarity with oracles' brands, operating entities, and architectures. envision the chainlink reputation system include basic on-chain component where users' ratings would available for other smart contracts reference. additionally, reputation metrics should easily accessible off-chain where larger amounts data can efficiently processed and more flexibly weighted. for given oracle operator, the reputation system initially proposed supporting the following metrics, both the granularity specific assignment types (see section and also general for all types supported node: total number assigned requests: the total number past requests that oracle has agreed to, both fulfilled and unfulfilled. total number completed requests: the total number past requests that oracle has fulfilled. this can averaged over number requests assigned calculate completion rate. total number accepted requests: the total number requests that have been deemed acceptable calculating contracts when compared with peer responses. this can averaged over total assigned total completed requests get insight into accuracy rates. average time respond: while may necessary give oracle responses time for confirmation, the timeliness their responses will helpful determining future timeliness. average response time calculated based completed requests. amount penalty payments: penalty payments were locked assure node operator's performance, the result would financial metric oracle provider's commitment not engage "exit scam" attack, where the provider takes users' money and doesn't provide services. this metric would involve both temporal and financial dimension. high-reputation services are strongly incentivized any market behave correctly and ensure high availability and performance. negative user feedback will pose significant risk brand value, the penalties associated with misbehavior. consequently, anticipate virtuous circle which well-functioning oracles develop good reputations and good reputations give rise incentives for continued high performance. certification service while our validation and reputation systems are intended address broad range faulty behaviors oracles and proposed way ensure system integrity the vast majority cases, chainlink may also include additional mechanism called certification service. its goal prevent and/or remediate rare but catastrophic events, specifically bloc cheating the form sybil and mirroring attacks, which now explain. sybil and mirroring attacks. both our simple and in-contract aggregation protocols seek prevent freeloading the sense dishonest nodes copying honest nodes' answers. but neither protects against sybil attacks []. such attacks involve adversary that controls multiple, ostensibly independent oracles. this adversary can attempt dominate the oracle pool, causing more than oracles participate the aggregation protocol and provide false data strategic times, e.g., order influence large transactions high-value contracts. quorums cheating oracles can also arise not just under the control single adversary, but also through collusion among multiple adversaries. attacks faults involving oracles are especially pernicious that they are undetectable from on-chain behavior alone. additionally, reduce operational costs, sybil attacker can adopt behavior called mirroring, which causes oracles send individual responses based data obtained from single data-source query. other words, misbehaving oracles may share data off-chain but pretend source data independently. mirroring benefits adversary whether not chooses send false data. poses much less serious security threat than data falsification, but does slightly degrade security that eliminates the error correction resulting from diversified queries against given source src. for example, https://www.datasource.com emits erroneous data due to, say, sporadically triggered bug, multiple queriers may still obtain correct majority result. sybil attacks resulting false data, mirroring, and collusion general may eliminated the use trusted hardware our long-term strategy (see section certification service design. the chainlink certification service would seek provide general integrity and availability assurance, detecting and helping prevent mirroring and colluding oracle quorums the short-to-medium term. the certification service would issue endorsements high-quality oracle providers. emphasize again, noted above, that the service will only rate providers for the benefit users. not meant dictate oracle node participation non-participation the system. the certification service supports endorsements based several features oracle deployment and behavior. would monitor the validation system statistics oracles and perform post-hoc spot-checking on-chain answers--particularly for high-value transactions--comparing them with answers obtained directly from reputable data sources. with sufficient demand for oracle provider's data, expect there enough economic incentive justify off-chain audits oracle providers, confirming compliance with relevant security standards, such relevant controls the cloud security alliance (csa) cloud controls matrix [], well providing useful security information that they conduct proper audits oracles' source and bytecode for their smart contracts. addition the reputation metrics, automated on-chain and automated offchain systems for fraud detection, the certification service planned means identify sybil attacks and other malfeasance that automated on-chain systems cannot. for example, all nodes agree that the moon made green cheese, they can cause user-sc ingest this false fact. moon components {green cheese} will recorded the blockchain, however, and visible post-hoc review. contract-upgrade service recent smart contract hacks have shown, coding bulletproof smart contracts extremely challenging exercise [], [], []. and even smart contract has been correctly programmed, environmental changes bugs can still result vulnerabilities, e.g., []. for this reason, propose contract-upgrade service. emphasize that use this service entirely optional and control users. the short term, vulnerabilities are discovered, the contract-upgrade service would simply make new set supporting oracle contracts available chainlink. newly created requesting smart contracts will then able migrate the new set oracle contracts. unfortunately, though, existing ones would stuck with the old, potentially vulnerable set. the longer term, therefore, chainlink-sc would support flag (migflag) oracle calls from requesting contracts indicating whether not call should forwarded new chainlink-sc should one become available. set default (i.e., the flag missing) false, migflag would enable requesting contracts benefit from automatic forwarding and thus migration the new version chainlink-sc. order activate forwarding, user will cause her requesting contract issue chainlink requests with migflag true. (users can engineer their smart contracts that they change this flag upon receiving instruction on-chain from authorized contract administrator.) migration users new oracle contracts functions kind "escape hatch," something long advocated for blockchain researchers (see, e.g., []) mechanism fix bugs and remediate hacks without resorting such cumbersome approaches whitehat hacking hard forks. migration the updated contracts will visible the blockchain, and available audit for users review before upgrading. recognize nonetheless that some users will not feel comfortable with any one group controlling escape hatch the form migration forwarding. forced migration could empower the migrating contract's controller, hacker who compromises relevant credentials, undertake malicious activity, such changing oracle responses. for this reason that requesting contracts have full control the forwarding feature and can thus opt out escape-hatch activation. additionally, accordance with chainlink's focus decentralization, expect that providers will able support multiple versions chainlink-sc developed the community. link token usage the chainlink network utilizes the link token** pay chainlink node operators for the retrieval data from off-chain data feeds, formatting data into blockchain readable formats, off-chain computation, and uptime guarantees they provide operators. order for smart contract networks like ethereum use chainlink node, they will need pay their chosen chainlink node operator using link tokens, with prices being set the node operator based demand for the off-chain resource their chainlink provides, and the supply other similar resources. the link token erc token, with the additional erc "transfer and call" functionality transfer(address,uint,bytes), allowing tokens received and processed contracts within single transaction. long-term technical strategy the long-term technical strategy for chainlink proposed this whitepaper includes three key directions: oracle confidentiality, infrastructure changes, and off-chain computation. confidentiality distributed oracle network aims offer high degree protection against faulty oracles. most deployment scenarios, seeks attain correct response the face byzantine faults (for valid decommitments are received. full signature computation: valid has yet been received chainlink-sc then aggregate partial signatures into sigsk [a]. send chainlink-sc. send provider. end algorithm rewardoracles (code for provider) wait until set commitment sets (ci from distinct oracles and are received. for every oracle and sets include commitments from then send $reward end end for proof sketches offer proof sketches the key properties oca. show that assuming most faulty nodes, the protocol always generates valid signature correct answer, and never rewards freeloading oracle nodes. claim the protocol oca will never reward freeloading node. proof. (sketch) suppose that freeloading. then can broadcast valid commitment only after time the time which the first honest decommits step alg. has received prepared messages which least come from honest nodes. let denote one these least honest nodes. will longer accept commitments after sending prepared message, the set any such honest node will longer change after time and thus will exclude commitment with correct partial signature from therefore, most sets alg. will include thus will not receive reward. unfortunately, oca cannot ensure that non-freeloading nodes are paid. cheating adversary can, after receiving decommitment, rush honest nodes step alg. generating its own partial signatures and including only one honest node's partial signature the generation that honest node's commitment may not have been included among the collected any node. could have come afterward. claim oca will always result valid signature sigsk [a] eventually being sent chainlink-sc. proof. (sketch) there are n-f honest nodes, and honest nodes, and thus least honest nodes. step alg. will complete successfully. similarly, since there are honest nodes, every oracle will eventually complete step alg. sending prepared message. honest nodes will eventually then receive least prepared messages and will decommit, permitting step completed some honest node. claim any valid signature sigsk [a] received chainlink-sc oca will valid value proof. (sketch) easy see that valid signature sigsk [a] includes correct value partial signatures are needed compute sigsk [a], and most nodes are faulty, least one partial signature was provided honest node and thus must correct. discussion oca introduces few design challenges that briefly discuss here. payment for honest nodes. unfortunately, while penalizes freeloaders with non-payment, oca not able guarantee conversely that honest nodes are paid. indeed, even the benign case where nodes are faulty, unlucky message ordering can result honest nodes that have contributed partial signatures not receiving payment. this problem could addressed part making alg. synchronous. specifically, "wait" steps could require that nodes wait period time such that receipt messages from honest nodes guaranteed. this case, all nodes with partial signatures incorporated into would guaranteed payment. side effects, however, would slower execution and the challenge setting correctly. the problem designing asynchronous protocol with strong payment guarantees open research problem that are currently exploring. redundant messages. oca aims minimize on-chain communication and ideally involves just one on-chain message, namely signed response from the set participating oracles. practice, however, because signature will not post immediately the blockchain, multiple oracles could independently send signed responses the blockchain. the best way limit such redundant messages for oracles monitor not just the blockchain, but the mempool, i.e., pending messages. key management. course, often the case, key management major challenge protocols this kind. the distribution shares can performed distributed manner and updates can made accommodate new nodes and remove departing nodes, well provide proactive security, i.e., ongoing resilience against compromise nodes' keys. additionally, nodes can organized into distinct cliques bound the size propose that chainlink employ these techniques ensure flexible, responsive, and secure distributed oracle. sgx trust assumptions intel's role providing stronger assurance correctness, sgx enhances but does not supplant other integrity protections chainlink. other words, use sgx makes the system strictly stronger. trusting sgx for confidentiality does require trust intel, but this trust circumscribed. assuming that intel does not have backdoor its cpus enabling leakage enclave data, does not have means inspecting enclave state. (such backdoor possible, but which would require the presence physical evidence every user's machine and pose serious reputational risk.) intel adversary that corrupts intel's manufacturing processes could principle falsify attestation keys (platform epid keys). such adversary could generate epid keys that are not embedded sgx-enabled servers, but instead permit attestations generated non-sgx platform. effect, this adversary could create bogus servers that generate valid-looking sgx attestations, but provide protections for enclaved code. should there more than such nodes, course, the adversary could corrupt oracle responses. more problematically, such nodes would expose sensitive data handled oracle nodes the adversary. the ability falsify epid keys, however, does not imply ability corrupt existing, valid sgx instances. also important recognize that course today, whether not like it, trust intel inescapable. the cpu the machine which you are reading this paper bears witness this fact--or, not, the cpu the server from which you downloaded this paper. course, would preferable make use trusted hardware from multiple vendors, and hoped that others will create equivalent capabilities. new, open architectures for trusted hardware, and ways weaken the trust assumptions required such hardware, are active areas research, e.g., [], []. the ability diversify across vendors architectures per would not ensure data confidentiality, however. are also interested research into techniques for confidentiality assurance distributed networks through the use cover traffic.