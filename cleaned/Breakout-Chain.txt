breakout chain white paper james stroud breakout chain white paper abstract breakout chain decentralized blockchain ledger that carries several currencies, which term multicurrency blockchain. each these currencies first class currency that each transferrable using the bitcoin-like input/output mechanism. the principal currency breakout coin, but the blockchain secured proof-of-work (pow) mining sister coin and proof-of-stake (pos) staking breakout stake. the first blockchain system where interest earning capacity has been separated from the principal. also the first blockchain system where pos and pow produce different coins. breakout chain has number other features such delegated fees, fee scavenging, nonmalleable transactions, and atomic currencies. each described herein. addition these existing features, breakout chain plans turing complete smart contract system that amenable pegged sidechains, making breakout chain fully scalable. breakout chain smart contracts will have the property directed acyclic graphs use transaction control points that regulate logical recursion. the combination existing and planned features will allow for breadth applications, some which are outlined herein. background bitcoin decentralized cash the definition decentralized cash money system that lacks central authority approve transactions. arguably the first fully viable decentralized cash bitcoin (ticker symbol btc), launched one several individuals working under the potentially pseudonymous moniker satoshi nakamoto []. the bitcoin protocol serves model for every decentralized money system currently use. for this reason, lieu saying "breakout chain", this document makes many references "bitcoin" shorthand for "the bitcoin protocol upon which breakout coin based". this usage meant not only save space, but give credit the bitcoin creators where appropriate. ethereum decentralized computing platform ethereum highly experimental decentralized computing platform invented vitalik buterin []. ethereum extends bitcoin offering turing complete scripting (scripts are simply short computer programs). turing completeness the ability simulate turing machine, which hypothetical machine consisting instruction processor and infinitely long memory tape that can seek forwards and backwards. this esoteric sounding definition can thought (perhaps imprecisely) page breakout chain white paper james stroud describing machine that can execute any logic accessible computers. turing completeness requires the ability for computer program loop one more times through the same set instructions, process known unbound recursion. turing completeness endows ethereum scripting with tremendous power execute many kinds contracts that represent fiducial relationships between people. these types contracts are often called smart contracts reflect the fact that the computer program can execute the terms the contract, presumably replacing human intelligence. even decentralized autonomous organizations (daos) that work like companies have been launched the ethereum platform. daos are also known decentralized autonomous corporations (dacs) because possible for people buy shares these organizations, with ownership being represented ethereum. with ethereum's turing complete power comes one critical burden known the halting problem, which the general inability determine advance whether computer program will complete finite amount time. other words, the only way know turing complete program will finish running the program. the halting problem means that the execution programs turing complete programming language must have controls place that terminate execution even the program itself has not completed. ethereum uses its native currency, eth, form "gas" for this control. each program supplied with gas money and once the program runs out gas, execution terminated. the program did not complete successfully, the gas money forfeited fee and, except for payment the fee, the state the ethereum computing platform remains unchanged, the computation had never happened. another challenge with ethereum that may not viable system when the frequency transactions and scripts increases beyond threshold. this problem known the scalability problem and effects all decentralized cash systems. this problem especially severe for ethereum because each script affects global state the system. this means that ethereum scripts must have strict ordering (script must finish executing before script can start) that the state the system known with certainty for the execution every script. ethereum's strict ordering precludes the ability run more than one script the same time, technique called concurrency. see how ordering precludes concurrency, consider what would happen all ethereum's activity were split into two sets and termed shards. this hypothetical example, the individuals who run shard take with them half the eth money supply used for gas while the individuals who run shard take the other half. scripts from both shards are executed concurrently long crosstalk between shards prevented such that activities from shard not require input from shard and vice versa, and eventually the two shards fuse that eth money can used payment system for the entire ethereum platform. while fairly trivial prevent crosstalk, the real (and perhaps insoluble) problem that impossible fuse shards without members each shard fully validating the other shard. the reason for validation ensure that the eth that ends the fusion has not been spent gas either shards. this need for validation destroys any benefits concurrency. page breakout chain white paper james stroud breakout chain proposes decentralized computing with concurrency proposed computing platform address the scalability and halting problems faced ethereum, breakout chain proposes turing complete scripting engine that uses different control mechanism from ethereum. instead ethereum's approach allowing each script run completion before deciding whether can modify the state the computing platform, breakout chain will divide execution contracts into segments. these segments are restricted from recursing except when users push execution through loops submitting transaction. these control points mean that scripts can filtered for length and complexity without the need execute them, allowing for greater scalability. although this mechanism may appear cumbersome first sight, will demonstrate through example crop insurance that control points are natural places which actors contract would make transactions. see this, imagine the recursion involved monthly subscription represented smart contract. each loop through the contract would initiated payment. fact, because the contract mediates benefit exchange for payment, desirable halt the execution the contract until payment made. this simple principle forms the foundation the breakout chain computing platform, and allows the platform have properties that make amenable scaling through concurrency. for this reason, the proposed breakout chain protocol permits shards through the use pegged side chains described adam back, al. []. pegged side chains are shards wherein money from the main shard (also called the main chain) locked and then apportioned separate shard (the side chain). the money can used the side chain and until destroyed while concomitantly unlocking the money the main chain. pegged side chains require both the main chain and side chains have properties that make them amenable concurrency because the side chain must run concurrently with the main chain. existing features and innovations although breakout chain will not have the turing complete scripting engine launch, already incorporates number new features that will described detail below. these features include multicurrencies multiple currencies carried single chain, each currency having full set features available it, like multi-signature transactions, locked transaction times, and sophisticated scripting multicurrency hybrid pow/pos unique security mechanism where currency rewarded secure chain using proof-of-work (pow, described below) and currency rewarded secure chain using proof-of-stake (pos, also described below) currency interrelationships proof-of-stake for currency rewarded with currency page breakout chain white paper james stroud breakout gravity wave novel difficulty algorithm derived from dark gravity wave that throttles block creation block group transactions bundled single unit data, similar ledger sheet) atomic currencies currencies that are indivisible beyond whole units, making possible represent real world fungible assets that can't divided, like frequent flyer miles loyalty points delegated fees the ability send currency but pay for the transaction currency fee scavenging the ability for transaction fee collection deferred until proof-of-work claims the fee nonmalleable transactions transactions protected against changes their transaction ids, addressing current vulnerability bitcoin colored coins currencies with only one unit that indivisible, proof concept for which has been incorporated into breakout chain the form deck cards exchange friendliness exchanges can add any currency supported breakout chain several seconds modifying only one line the configuration file several other features derived from other decentralized currencies have also been incorporated into breakout chain, including full-featured graphical wallet for several platforms, free-form transaction metadata, stealth addresses, and encrypted transactions comments that can only read sender and receiver. concepts rather than present complete history electronic money systems background, the first part this white paper reviews several essential aspects existing payment systems. knowledge these topics important for understanding novel aspects (both existing and proposed) the breakout chain protocol. decentralized ledgers the essence ledger simply table account credits and debits. ledgers have starting balances, then current balances can tallied simply adding all credits (receipts) and subtracting all debits (payments). example the following table for two accounts, alice and bob: page breakout chain white paper james stroud table example simple ledger sheet alice memo credit debit starting alice deposit bob deposit alice pays bob bob pays alice bob balance credit debit balance this example demonstrates several aspects typical ledger. first, for any internal transfer, the sum all credits equal the sum all debits. for example, when alice pays bob, the debits are and the credits are this means that internally, ledgers adhere the principle conservation money. notice that all entries are not internal transfers. one entry, alice's initial deposit, was external transfer that added money the ledger. each line ledger can have pictorial representation, where the ledger itself could considered middleman, payment processor, that mediates exchanges. figure depicts the second transaction the ledger above, where alice pays bob $.. figure alice sends bob. this transaction can imagined one where alice creates input (debit) from her account and output (credit) bob's account. the reason for placing the payment processor mediator the transaction introduce visual framework for the concept inputs and outputs. namely, the payment processor placed visually the middle establish perspective for what "in" and what "out". roughly, input can imagined debit from account while output can imagined credit. this example, alice created input that got debited from her account. transferring the money bob, she also created output that got credited bob's account. this framework, alice had perform some operations create the input and output, could say that the process she followed adhered particular input/output mechanism. this terminology communicates that some computational machine does alice's bidding, and within this machine the mechanism process the inputs and outputs. this computational machine given the name "payment processor". traditional ledgers and some distributed ledgers like ethereum, nxt [], counterparty [], and page breakout chain white paper james stroud bitshares explicitly pool all account's funds single balance every entry, similar what depicted table for the sake convenience, these type ledgers will termed herein state ledgers. state ledgers, account's funds are represented single number, which the balance. sense, account's balance change from previous transaction that used all the previous balance input. figure depicts change represented output. the context the ledger table this change output becomes alice's balance. figure state ledger implicitly makes change. this transaction, alice begins with input (her previous balance) and sends output bob, which credit his account. the transaction balanced with implicit change output that this case becomes alice's new balance. having established the concept inputs and outputs and their relation ledger entries, now possible understand the specific needs decentralized ledger, such that represented bitcoin. first, what decentralized ledger? decentralized ledger one where copies are maintained many different parties separated distance. additionally, the different parties potentially have conflicting interests. the integrity decentralized ledger depends each copy the ledger being updated exactly the same way. important requirement for decentralized ledger that updates must synchronized. that is, not only must the copies updated exactly the same way, these updates must occur close enough time such that any copy can relied upon faithfully report account's balance any moment. second requirement decentralized ledger that account holders need prove that they are authorized spend funds, more precisely, prove that they own the account which funds were sent. with centralized ledger (like bank uses), this proof might take the form signing check, using debit card with pin, presenting teller. with decentralized ledgers, different form proof, called cryptographic signature, required. the cryptographic signature produced computer program that has access the spending account's secret information that identifies the account uniquely. spend input, the input signed via the cryptographic signature. cryptographic signature can quite complicated may need provide proof multiple parts. examples might that input requires that two more parties must both sign (multi-signatures), that the spender must prove knowledge some other information aside from the account's identifying secret. the technical details signatures and multi-part proofs are quite elaborate and are beyond the scope this white paper, although helps the reader appreciates the power behind page breakout chain white paper james stroud complex spending requirements like multi-signatures. typical use multi-signatures, for example, -of- multi-signature that requires two different people approve spending funds. the combined requirement synchrony and potentially complicated proofs spending authority (the cryptographic signature) imposes constraints decentralized ledgers. these constraints mean that often not most efficient combine all account's inputs (credits) into single spendable unit that most people think balance. using multi-signatures example, obvious that two different inputs require two different sets signatures, they can not spent combined unit. other words, the first input may need multi-signature authorization and the second input may only need single-signature authorization. therefore, not sensible combine them into single balance upon receipt. instead, more efficient approach wait combine inputs until they are spent, signing only those needed the time. short, inputs are treated discrete units that are signed independently the spender. cases where all spender's inputs are smaller than given payment, the spend will combine inputs produce the payment. figure illustrates combined inputs. figure inputs are combined cover spend larger than any single input. this transaction, bob pays alice bob only has inputs and available, combines them and then makes output alice and output himself change. distinguish state ledgers from ledgers that treat inputs discrete units, this white paper will refer the latter utxo ledgers. the acryonym utxo stands for "unspent transaction output", phrase that describes transaction output before referenced input that signed and spent. state ledgers are fundamentally different from utxo ledgers that state ledgers require strict ordering transactions while utxo ledgers not. the reason state ledgers require strict ordering transactions because impossible for account have negative balance. for example, assume that alice has balance and receives deposit then spends this set transactions would leave her with but imagine that transaction processor receives the spend first, meaning her account would have balance $(), invalidating the spend. alice's account decentralized ledger, she could walk away from her negative balance without any repercussions. utxo ledgers, the other hand, are ordered the input/output mechanism. the example above, alice might receive output deposit and then spend output output points output one its inputs. network participant receives notification alice's spend with output the participant will know wait some reasonable time for output because has been referenced output page breakout chain white paper james stroud fees processing payments requires computational resources validate and maintain complete history transactions, which means that desirable for users pay fees. addition compensating the individuals who provide payment processing resources, fees ensure that users not abuse those resources creating too many transactions for the payment processor handle. although centralized payment processors like banks are able automatically deduct service fee each month from user accounts, decentralized payment processors can not deduct automatic payments. the reason that account holders must specifically sign inputs spend them and any payment transaction, like fee, spend. thus, fees paid using decentralized ledger are taken for every transaction (even though these fees are generally very small). figure shows transaction (not appearing the ledger table with fee. figure fees are paid leaving the appropriate amount their inputs unclaimed. this transaction, bob will pay alice bob only has inputs and combines them and creates output alice. left over, but bob needs pay fee, makes output himself. does not specify where the fee goes (indicated gray). instead, the payment processor will see that the unclaimed and claim fee. the output transaction for the fee, therefore, created the processor and not the spender (bob). figure illustrates that decentralized ledger conserves money that any (generally purposefully) unclaimed funds from transaction may claimed agent the payment processor. the blockchain the structure traditional ledger presented table the layout intuitive. each account has debit column, credit column, and balance column. the ledger grows one row with each new transaction. traditional ledgers are rectified upon each internal transfer ensuring that all the debits equal all the credits for the transaction. because the potential asynchrony that accompanies decentralization, bitcoin was designed with different structure from traditional ledgers. the bitcoin ledger not continuous series rows. instead, divided into sets transactions called blocks. each block can hold many transactions wherein each transaction composed inputs and outputs. the first transaction block generally includes block reward, special output that increases the money supply and rewarded the individual who processed the block transactions. the first transaction can also include fees any are claimed the processing individual. after this first transaction, called the coinbase transaction, are transfers authored account holders. these are the types transfers depicted figures above. page breakout chain white paper james stroud figure blocks contain array transactions, called vtx. the first transaction block called the coinbase transaction. every transaction holds array inputs called vin and array outputs called vout. notice that fees are paid non-coinbase transactions but collected the coinbase transaction fee output. also, the coinbase transaction creates new coins, does not have any inputs. technically speaking, the input array filled with one empty input placeholder indicate that the coinbase transaction correctly formed. each transaction has record its own identifier, called transaction id, commonly abbreviated "txid". figure illustrates couple important points. first each transaction stores record its own identifier called transaction (txid). each txid unique. second both the inputs and outputs for each transaction are numbered their index within the array (idiosyncratically beginning with because txids are unique the blockchain and outputs have unique array indices, every output can identified combination its txid and array index. addition array transactions, blocks have other information, one which very long number, called block hash, that identifies the block. block hashes are expressed almost exclusively hexadecimal numbers, meaning the number system has digits from then instead just example block hash is: dcaeeffaeaacbfbacef although this hash may not look like number, simply hexadecimal for the big number block hashes will often have several leading zeros, which simply formatting convention make them exactly characters long. each block not only identified block hash, but also contains record the hash the block that came immediately previous. this record often referred pointer the previous block. these pointers link blocks together into chain, giving motivation for the name "blockchain". page breakout chain white paper james stroud figure the blockchain series blocks transaction linked pointers the previous block hash. the strings "aaa", "bbb", "ccc", "ddd" represent block hashes. each block identified and contains record its own hash ("block hash"). each block also contains the hash the previous block ("prev block hash"), that serves link blocks into chain. inputs and outputs the heart blockchain transactions are inputs and outputs. outputs are simple data structures that have three parts: destination with spending requirements, the amount transfer the recipient. figure output data structure with records only for the destination and amount send. the destination typically simply address, but could specify other spending requirements. output referred "ctxout" the computer code. inputs are slightly more complicated because they must contain proof that the spender has the right spend the funds. this proof generally called signature. addition this proof, input must reference the previous output that being spent. this reference takes the form txid and array index. figure illustrates how input references the previous output. figure input composed signature (proof authority spend funds) and two-part reference the previous output that the input spends. this example the previous output belongs the transaction with txid starting "ceb..." (blue) and having array index (blue) vout. the full data structure the transaction not shown. for example, all transactions will have array inputs called "vin". page breakout chain white paper james stroud blockchain security the cryptographic hash central blockchain security the cryptographic hash, "hash" for short. hash produced function block computer code practice) that takes string (sequence characters) input and returns very large unpredictable number output. this context, "unpredictable" means that the only way know the hash given string pass this string the hash function and calculate the result. the cryptographic hash used extensively for decentralized ledgers known shad. get feel for what cryptographic hash functions do, consider the quote believe that banking institutions are more dangerous our liberties than standing armies" thomas jefferson, one america's founding fathers, author the declaration independence, third u.s. president, and probably america's most revered patriot. the shad hash (expressed hexadecimal number) jefferson's phrase is: eaeaebffbaecabfaccdaccffaeeac aside from unpredictability, cryptographic hash functions have two other important properties. the first property that practically impossible (within the limits all resources available humanity) find two strings that will produce the same hash. the second property that impossible ascertain the string that produced the hash with any confidence. other words, there function that could take hash and return string that would produce that hash without brute force trial and error. illustrate this latter property, imagine jefferson's quote had ended the sentence with "armies" and put period after it. the string would believe that banking institutions are more dangerous our liberties than standing armies." this means the period would into the hash function well. the shad hash this new phrase is: edabeaeccccadbdeabeebfbeeb inspection this latter hash reveals that has relation the hash the original phrase, despite the two phrases' differing only one character, the sentence-ending period. the properties cryptographic hashes mean that they make very good building blocks for designing computationally difficult problems. for example, one problem might determine string one would need append the end jefferson's quote make the first hexadecimal digit the shad hash into zero (""). because the cryptographic properties shad, the only way work this problem trial and error. for the curious, the resulting string believe that banking institutions are more dangerous our liberties than standing armies" (appending the original quote), and the shad hash is: effdeecbacbcccfaeeeafefccaa because there are possibilities for each hexadecimal digit ("" plus "a" "f"), converting each successive digit zero requires, average, times more effort than converting the previous digit. for example takes unit computational work, average, convert the first digit zero, page breakout chain white paper james stroud will take units effort, average, convert the first two digits zero. the resulting hash would with hexadecimal digits following. convert the first eight digits zero (meaning hash that starts "") would take, average units effort. that is, over million times harder find shad hash with zeros its start than with just one zero its start. although this example problem converting starting digits zeros seems pedantic, fundamentally the cryptographic "puzzle" that lies the heart blockchain security. proof-of-work what the nature "transaction processor" for decentralized ledger and what ensures that they act honestly? the activity transaction processor boils down signing blocks that all members the network accept into their copy the blockchain. transaction processors demonstrate their authority solving what essentially the problem just described. simple terms, the problem turn all the block data (transactions, time stamp, etc) into one long string, then append number (called nonce), take the cryptographic hash and see the hash has the requisite number ""s the front. not enough ""s are present, then the nonce incremented and new hash taken. the need for trial and error means that the transaction processor has proven quantifiable amount work, earning the right sign the block and claim the block reward. this process trying find block hash with enough ""s called mining. importantly, anyone can join the race find nonce that produces the requisite number zeros, making the act becoming transaction processor competitive. the work investment the eventual winner provides the incentive act honestly, meaning that winners will faithfully validate transaction that they include the block they sign. moreover, maintain the best value for the reward they claim, when they not win the mining race, miners will have incentive accept the blocks those who win the reace. this scheme blockchain security called proof-of-work (pow). the central concept pow that not the act signing block but the proven work that earns reward. from the perspective the block signer, the signature merely necessary formality prove one's identity and claim the reward. from the perspective the network, the signature serves the important function certifying the block that others accept the block into their copies the blockchain. the block shown figure pow block. proof-of-stake pow not the only way prove eligibility sign block. some systems blockchain security, the requirement for work replaced with the requirement that one holds coin. this type system, called proof-of-stake (pos) those who have greater ownership have easier time trying nonces because the number ""s inversely proportional the amount stake. prevent the largest holder from signing every block, coin considered have age, which resets when sent used stake. page breakout chain white paper james stroud used stake, coin must have minimum age. this means that the largest holder uses all their stake easily sign block, this holder must wait until their stake ages, giving others chance sign block. pos system therefore competitive, but the competition overwhelmingly dominated the amount stake one owns and not the amount work one capable producing. prove stake, the staker (one who stakes coins) effectively sends coins themselves. because sending requires signature, the signature proof the stake. the sending transaction also serves mark the time which the age the coin (coin-age) resets. pos, this staking transaction called coinstake and serves the same purpose coinbase transaction that block rewards are claimed therein. for example, alice stakes coins claim coin block reward, then alice would create stake inputs worth coins and outputs, called mint, worth coins. the result that pos blocks, the coinbase transaction still comes first but empty (marking the block pos block) and the staking transaction second. pos block similar those from the cryptocurrency peercoin shown figure figure peercoin-like proof-of-stake blocks have extra transaction known coinstake. these proof-of-stake blocks are marked with empty coinbase inputs and outputs and empty first coinstake output. spending transactions begin with the third transaction vtx. for all transactions, the input and output sets, called vin and vout, respectively, are never empty. these sets will least contain one member. these members are used markers, the members may empty. the total the mint outputs are are equal the stake inputs plus the block reward. peercion and many other proof-of-stake cryptocurrencies, stakers are not permitted claim transaction fees. this does not mean that senders not need pay fees. means that the fees are never claimed and disappear. this situation, fees are said "go the network", which means that when the fees disappear reduces the money supply, presumably making the rest the money supply just little more valuable. more often than not, this reduction the coin supply more than offset block rewards. all decentralized ledgers have challenge wherein possible for two different miners stakers produce two blocks that link the same earlier block. this situation represents loss consensus called fork, shown figure page breakout chain white paper james stroud figure fork occurs when two otherwise valid blocks are produced that both point the same previous block. both blocks ccc and ddd point back block bbb their immediate predecessor situation called fork. forks represent loss consensus until one side the fork grows into the longest chain. forks happen with regularity (and are just readily resolved through the consensus mechanism) for all decentralized ledgers. however, for pos, forks are theoretically very problematic because staker can attempt add blocks both sides fork simultaneously, further contributing the loss consensus. this possibility for exacerbated loss consensus often referred the nothing-atstake problem. because stake effectively reproduced both sides fork, requires resources attempt stake both sides. the nothing-at-stake problem given many pow proponents cardinal reason that pow superior pos. pow immune the nothing-at-stake problem because costs pow miners proportionally greater resources mine multiple sides fork simultaneously. hybrid proof-of-work/proof-of-stake address the nothing-at-stake problem, many cryptocurrencies, like peercoin, combine both proof-ofwork and proof-of-stake. the combination aims addresses several potential issues. for example, proof-of-work theoretically susceptible "majority attack" that could occur when single entity controls majority the mining capacity that secures particular coin. proof-of-stake potentially "centralized" because single entity could eventually purchase ownership greater than the money supply. hybrid system may mitigate these issues. specifically, successful majority attack hybrid pow/pos currency would require both ownership majority the money supply and control majority the mining capacity. hybrid pow/pos systems not have specialized block structures. instead, pow and pos blocks are intermingled, typically about ratio. other words, given block hybrid pow/pos system either pow pos block. typically, hybrid pow/pos block puzzles, though identical design, are independent for pow and pos. this means that workers attempt solve one problem while stakers attempt solve different problem and the two types blocks are added the chain more less independently. despite this idenpendence, all blocks are added the same chain. for example, sequence blocks from hybrid pow/pos might something like: pow-pos-pos-pow-pow-pos-pow-pos-... with real limitations the sequence except approximate equal probability the each block's being pow pos. page breakout chain white paper james stroud tokens and colored coins several cryptocurrency systems support the creation token currencies that exist along with the principal currency their block chains. the principal currency the currency which transaction fees are paid and without which the token currencies could not function. token currencies may thought unique currencies that can created users. once created, token currencies are essentially independent the principal currency, except for reliance the essential functions transaction fees and blockchain security. token currencies can created most the cryptocurrency systems that use state ledger, including ethereum, nxt, counterparty and bitshares. except for ethereum, which allows for tremendous flexibility with smart contracts, the ability stipulate spending requirements for tokens generally somewhat limited. additionally, sophisticated interaction and interconversion between tokens and the principal currency general not possible. one exception bitshares, which has smartcoins. smartcoins are currencies pegged external (non-blockchain) asset through the use price feed. smartcoins are collateralized the principal currency, fixing the peg specific quantity the external asset. smartcoins can converted the principal currency where the conversion rate determined the price feed. aside from pegged currencies bitshares, token currencies are typically used represent real-world assets like equity ownership some enterprise. different nxt token currencies (usually called "nxt assets") have been used extensively represent shares, where dividends are paid proportion one's holdings. colored coins are traceable coins that have unique identities. the concept colored coin often confused with the concept token currency, mostly because some cases they are equivalent. however the difference can understood examining the various physical representations domestic currencies. for example, each usd dollar bill has printed unique serial number, making dollar bills analogous colored coins. however, dollar that typical bank account indistinguishable from any other dollar that account because the representation any dollar the account simply the number added the account balance. one way that colored coins could implemented the use token currencies. this implementation, unit one currency converted token currency with fixed money supply. for example, imagine that one bitcoin converted token with money supply where each unit the token currency worth btc. individual units the token currency could spent whole units fractions thereof. this system problematic, least with regards using bitcoin, which does not support colored coins natively. the problem that although bitcoin could converted token destroying the bitcoin, impossible convert the token back bitcoin because once destroyed, new bitcoin can only created mining. because the colored coin not convertible bitcoin, can easily lose its value. one way solve this problem known side chains, which will discussed later. however, page breakout chain white paper james stroud cryptocurrency that natively allows the interconversion colored coins bypasses the problem altogether, interconversion would thereby fairly trivial. smart contracts the present paper, smart contract will defined "computer code that enforces agreement between two more parties". smart contracts were originally described nick szabo, using the vending machine primitive example. introduce the most essential features smart contract, this paper will use the metaphor bubblegum machine (figure the most basic vending machine conceivable. bubblegum machine accepts money and then allows the user retrieve bubblegum the correct money provided. most bubblegum machines accept money and permit the user retrieve bubblegum the same time (while turning the handle), even though this synchrony not strictly necessary. one could imagine different type machine that divided the process into two consecutive steps. figure bubblegum machine metaphor for the essential features smart contract. the three steps required the user obtain bubblegum are insert money, turn the handle, retrieve the gum. the bubblegum machine has internal mechanism that decides whether the user has met the conditions the contract (supplied enough funds this case). so, permits the user retrieve the gum opening gate, allowing the gum fall from the hopper the candy tray. image attributed http://sweetclipart.com/, modified with labels. bubblegum machine excellent metaphor for smart contract because has well defined functions that can expressed concise algorithm: hold product securely, making the product inaccessible until certain conditions are met. await payment transaction from user, this case the insertion money. await collection transaction from the user, this case turning handle retrieve the gum. permit execution the transaction conditions the sale (contract) are met. bubblegum machine has some extraordinary properties. first, allows two parties engage contract without ever interacting directly. the seller supplied the bubblegum the hopper and then locked the machine. the buyer inserts money and turns handle. second, bubblegum machine has internal mechanism that decides, upon action from the buyer, whether conditions are appropriate allow the transaction complete. third, the bubble gum machine fully passive. never executes any action relation the transaction. does not withdraw money from the buyer's account nor does send the money the seller. does dispense bubblegum, but that action initiated (and even fully executed) the user. it's most critical function measure whether the correct the amount money has been inserted and, so, permit the transaction complete. page breakout chain white paper james stroud bubblegum machine might considered archetype for what will term permissive smart contract, which means its function permit transactions rather than execute them. permissive contracts mirror traditional contracts that both are passive. for example, the contract that record company has with musician does not actually pay the musician. instead, the record company pays the musician subject the terms the contract. often, with the recording contract, traditional contracts require parties take certain actions (the musician record music and the record company compensate the musician). because the blockchain can not compel action anyone, the bindings which parties are subject must reversed for blockchain contracts, often requiring escrow upfront, then permitting the escrow withdrawn the conditions the contract are satisfied. other definitions smart contracts have been advanced elsewhere, but these definitions include smart contract behaviors that are unnecessary, even impractical. for example, implicit many definitions "smart contract" the idea that the contract protocol will execute transaction. consider modified version the hedging contract, contract for difference, described the ethereum white paper. wait for party input ether. wait for party input ether. record the usd value ether, calculated querying the data feed contract, storage, say this $x. after days, the contract expires and the protocol sends worth ether (calculated querying the data feed contract again get the new price) and the rest although most this contract taken verbatim from the ethereum white paper, the part bold new. here the smart contract has, part it's protocol, the act sending coins and practice, though, only necessary for the contract permit this transaction, not execute it. first glance, may seem authority spend must vested with the block chain, otherwise one the parties will simply send the totality the escrow himself. this necessity can eliminated using -key multisignature (one key belonging and one belonging b), and the contract respecified: wait for party send ether the multisignature address. wait for party input ether the multisignature address. record the usd value ether, calculated querying the data feed contract, storage, say this $x. after days, permit party spend worth ether from the multisignature address, and permit party spend the rest the multisignature balance. page breakout chain white paper james stroud breakout chain proposal for smart contracts permissive smart contracts notable that none the smart contracts described the ethereum white paper necessitate any capacity for the contract execute transaction, even though several contracts therein specify this behavior. for example, the crop insurance contract proposed the ethereum white paper specifies that, based the results data feed, the farmer may "automatically receive money". this implies that the smart contract protocol executes the send. however, possible have crop insurance where the farmer, and not the contract, responsible for executing the transaction. outline the contract would be: the insurer and farmer together register multisignature address with the contract. each party has private key for the public key that they contribute the multisignature address. the insurance agent sends funds covering all but the farmer's purchase price. the farmer buys crop insurance sending money the multisignature address. after set duration, the contract permits the farmer spend (proportional the size the policy and inversely proportional rainfall) from the address registered step likewise the insurer can spend the remaining balance. this contract more complicated than that found the ethereum white paper. both require the registration public keys (the payout address for the ethereum contract and the escrow address, contract address, for the permissive smart contract), purchase the insurance, and transaction that pays the farmer the case drought. permissive smart contracts not require any polling the chain's state. instead, state checked only when transaction attempted. for example, the farmer attempts spend from the registered address after his crops received plenty rain, then the transaction will invalidated when network nodes verify the transaction and check the history the weather feed. the absence polling means that the contract does not burn cpu cycles every block. polling chain state (e.g. checking whether the contract has matured) undoubtedly still happens, although the farmer the entity polling and not the miners they execute the contract. specifying permissive smart contracts: crop insurance possible fully specify crop insurance contract without the execution any transaction the protocol itself. the example crop insurance contract figure uses stack-based language called contract that models bitcon's script language. for this reason, will easy for readers familiar with script follow the protocol. also like bitcoin's script language, the contract data stack populated with byte vectors. although the native language permissive smart contracts the stack-based language contract, page breakout chain white paper james stroud higher-level languages the origination the example crop insurance smart contract, the contract data stack contains (starting the top) the contract amount, expiration time, earliest claim time, feed params, max total rain, and insured address. deeper members the contract data stack are not shown, such the insurer's address. the expiration time the time before which the insured may claim payout. the real total rain exceeds max total rain, claim possible (tested line for simplicity, feed params meant represent group contract data stack members that are taken arguments get_feed_total. the get_feed_total operator returns the sum feed observations given feed identifier, interval and sampling frequency, and others, indicated the feed params. smart contract system would have several different operations that retrieve data from feeds. examples include get_feed_total, get_feed_mean, get_feed_median, and on. these operations are finegrained minimize the complexity contracts themselves. for this simple contract, the contract amount the maximum payout, and equal the total provided escrow the insurer and payment the insured. when the insurer sets the contract, the insurer sends escrow funds the contract address. page breakout chain white paper james stroud figure crop insurance contract can specified permissive contract using stackbased language. the portion the contract executed the insured extends through line two transactions (circled letters) are represented. transaction executes through pause line transaction executes through pause line both transactions terminate with the value the top the contract data stack, causing the instruction pointers (filled arrows) move through pause, rather than back the previous instruction, described the text. the state the contract data stack upon completion the corresponding instruction (open arrows) given boxes. the stack language, called contract, modeled after bitcoin's script language, with similar instruction names having the same meanings. for example swap means switch positions the top two stack members, means push the value the stack. differences naming include (less than equal to) and other tests for inequality. other new commands (accept_payment, push_txtime, etc.) are explained the text. this crop insurance contract purposefully simple for the sake illustration. for example, makes provision the insured does not pay for the policy, etc. page breakout chain white paper james stroud the example figure introduces several new operators. for example, the operator accept_payment will invalidate transaction the transaction attempts spend from the contract address, which specified when the contract created. the transaction does not try spend from the contract address, accept_payment checks see whether the balance the contract address greater than equal the top member the contract data stack (contract amount). the balance calculated from all known transactions that execute the smart contract, including the transaction that executes accept_payment. the test succeeds, placed the top the contract data stack, otherwise. all cases, accept_payment places the input (contract amount) the second position the contract data stack that the input can available later needed. the pause instruction pops the top member the contract data stack. this member the instruction pointer moved backwards the instruction immediately prior pause, otherwise the instruction point moves forward the following instruction. all cases, execution stops pause and only resumes with new transaction. because contract will support the use subroutines, pause way achieve recursion and therefore way achieve turing completeness permissive smart contracts. one limitation that each cycle can only initiated with new transaction. single transaction can cause the contract recurse, meaning that the number operators given transaction's instruction sequence finite and easily determined. the mechanism prevent recursion single transaction simple and can envisioned using pseudocode (figure figure recursion prevented within transaction using the call stack. the pseudocode represents three subroutines a(), b(), and c(). return addresses after calling each these functions are main', b', and c', respectively. when each subroutine called, -tuple the subroutine address being called (a, and the return address pushed the call stack (boxes). before calling subroutine, the runtime searches the call stack for tuples that have the subroutine's address the first element. duplicate address found, the transaction invalidated. the image, the transaction invalidated a() when called from within c() because the bottommost member the call stack has the address the tuple's first element. the transaction chain each permissive smart contract executed chain transactions (the transaction chain) that has strict ordering. this ordering established each transaction's having pointer the txid the previous transaction the chain. each permissive smart contract has one and only one transaction chain and transaction may part more than one chain. the transaction chain therefore linked list similar the blockchain (where each block links one and only one previous block). the transaction chain does not branch, meaning that when two transactions link the same previous page breakout chain white paper james stroud transaction the chain, they cannot both valid. when miner receives two transactions that both link the same previous transaction the chain, the miner may decide which include block. therefore clients who execute contract keep track network transactions and link the newest the transaction chain. figure contracts are executed transaction chains. the transaction chains for two contracts ("contract and "contract are represented. the strings "aaa", "bbb", "ccc", "ddd" represent txids. each transaction identified and contains record its own txid. each transaction also contains the txid the previous transaction the chain. the original transaction the chain points previous transaction, represented null. the data structures permissive smart contracts permissive contracts can interact with various data structures that belong the contract itself. for example, the amount and time the current transaction can obtained using push_txamt and push_txtime, respectively. the current transaction the transaction that triggers execution segment the instruction sequence. follows that each transaction will trigger execution some segment the sequence (starting the beginning where the last transaction left off) and that execution may may not complete for particular transaction. the latter the case, the crop insurance example, transaction did not transfer enough funds advance past accept_payment instruction followed immediately pause. permissive smart contracts are created with originating transaction which, like other transactions that execute the contract, stores the state the contract. this storage consists of: the instruction sequence that specifies the contract protocol (figure for non-originating transactions, this sequence empty because the contract operations are fully specified the originating transaction. the instruction pointer that indicates the first instruction execute for the next transaction. for the originating transaction, this pointer points the first instruction. figure the solid arrows are instruction pointers. state the contract data stack. for the originating transaction, the contract data stack filled page breakout chain white paper james stroud with starting values. for non-originating transactions, the state the contract data stack, would after the transaction's execution, specified. only the changes necessary convert the state contract data stack the previous transaction that the current transaction pointer the prior transaction the contract's transaction chain. for the originating contract, this pointer null. given this pointer, possible backtrack the originating transaction determine retrieve the instruction sequence and contract address. transaction data stack. for the originating transaction, the transaction data stack will empty. for non-originating transactions, the transaction data stack will hold additional data that can transferred the contract data stack using transfer. the sole argument, transfer takes the number elements from the transaction data stack transfer. the transfer operator removes the elements from the transaction data stack. the transfer operator used other than transfer, operators contract can applied the transaction data stack. the transaction data stack allows transactions supply information the contract such cryptographic proofs ownership. state call stack. for the originating transaction, the call stack empty. for non-originating transactions the call, the changes necessary convert the state the call stack from the previous transaction that the current transaction. elements flow control permissive smart contracts one question that may arise when looking the crop insurance contract figure how the contract ensures that actors have the correct authority execute specific parts the contract. can see how this works within the block. here, the actor provides message and signature that message the transaction data stack and used checksigverify with the insured address. checksigverify fails, the transaction not valid and the contract state does not change from that specified the preceding transaction the chain. following the check lines whether the insured has claimed payout, the contract will check whether the transaction executed the insurer, again using checksigverify. this part the contract not shown for brevity. one thing note that smart contracts offer two levels control. the first that the contract may require proofs different from those required the transaction script, which could pay-to-pubkeyhash, pay-to-script-hash, and on. the second level control the transaction script, which applies all transactions, whether they are contract transaction chain not. should noted that not necessary persistently store the state if-else-endif blocks. the reason that the blocks subject and else conditionals that fail are never evaluated. consider the following block code: page breakout chain white paper james stroud false {block else {block pause {block endif here, block line skipped, then block executed. execution paused line and the next transaction, naive the if-else-endif nesting, begins executing block line put simply, whatever instruction which transaction begins facto part the execution sequence, this includes any instructions immediately following the next endif. similarly, any instruction within else block that naively encountered will not executed. this later situation can seen clearly the following block code, considering circumstances where execution begins naively after the pause line true {block pause {block else {block endif state permissive smart contracts permissive smart contracts store the contract state information the transaction itself. for this reason, the contract state known before the transaction accepted into the blockchain. also, the miner and the contract executor (the party that makes the transaction) must agree the state the contract after execution. this means that the executor can assured that the contract state will remain consistent with the executor's expectations. ultimately, the party who creates transactions responsible for determining the state the permissive smart contract and storing this state the transaction that executes the contract. this manifestly different from how state managed the ethereum blockchain, where determining state and storing the responsibility the miner. moreover, permissive smart contracts store contract state the transaction level whereas ethereum stores state the block level. sidechains permissive smart contracts the chains formed permissive smart contracts share several fundamental properties with the underlying input/output chain. first, each step the chain has precisely defined set predecessors. second, each step the chain executed deterministic number steps. third, the state the page breakout chain white paper james stroud chain completely specified members the chain and not influenced the state any other chain. fourth, the entity who executes steps the chain fully specifies the state the chain after execution. these properties combine make bitcoin amenable pegged side chains. these properties also mean that permissive smart contracts are amenable pegged side chains, making breakout chain's premissive smart contracts arbitrarily scalable. multicurrencies breakout chain offers multiple first-class currencies running single decentralized utxo ledger. each currency fully supported the breakout chain input/output mechanism. multicurrency support achieved simple extension outputs where the type currency given numerical identifier, termed color, reference colored coins. figure multicurrency outputs have currency identifier. the data structure shown multicurrency output. the currency identifier (color) currency identifiers range from ,,,, meaning that breakout chain can accommodate over billion different currencies. having multiple first class currencies single block chain allows for novel relationships between currencies. one such relationship incorporated into breakout chain that between breakout coin (brk) and breakout stake (brx). this relationship, brx staked earn block rewards brk. the reason for this relationship that first coin sale buyers (late purchased stake and the block reward coin two separate entities. enable this type relationship, the breakout chain pos block structure (figure significantly deviates from the peercoin pos block structure (figure figure breakout chain pos block places the mint output the coinbase transaction. the coinstake inputs and outputs are the second transaction, where the sum the input stake must equal the sum the output stake. all new coins are placed the coinbase transaction. the coinbase transaction marked with inputs (empty vin), and the coinstake transaction marked with empty first output. breakout chain, fees are not collected pos blocks. page breakout chain white paper james stroud the breakout chain protocol does not allow fees collected pos blocks although does require senders pay fee. these fees are not lost, however. they can collected breakout chain pow blocks (figure what known fee scavenging (figure figure breakout chain pow block allows fees different currencies collected the coinbase transaction. fees the currency the block reward are combined with the block reward the first output the coinbase transaction. fees for other currencies follow. each currency may only appear once the outputs the coinbase transaction. when payments are different currency than fees situation called delegated fees, figure the fee input (green) may larger than the required fee, meaning that the sender will write output for the fee change (green). transaction inputs and outputs are highly restricted, limited only payment currency, and, different, the fee currency. the value transaction's outputs for given currency less than the value that transaction's inputs, the difference available fees. this difference subtracted from the money supply. when pow miner claims rewards, fee scavenging allows the miner collect any money not previously claimed outputs. the available fee for given currency calculated subtracting the current money supply from the total mint (all coins that have ever been created). the miner for pow block eligible claim all available fees, restoring the money supply the total mint. fee scavenging illustrated figure the purpose fee scavenging add incentive for pow mining. page breakout chain white paper james stroud figure fee scavenging restores the available money supply currency the total mint. the end pow block the total mint for currency xyz equal its available supply xyz. the transaction block (shaded), leaves xyz unclaimed required fees, reducing the available supply xyz. the pos block does not give opportunity claim the xyz. pow block does, however. the miner block claims the xyz fee output, restoring the available supply. figure some currencies have fee delegate, which different currency which fees are paid. two currencies, abc and xyz, are represented. bob sends abc alice and takes abc change for himself. pay the fee, bob uses currency xyz, required. bob pays xyz for the fee payment and receives xyz for the fee change, leaving xyz collected the miner the next pow block, which could also the block that stores this payment alice. references https://bitcoin.org/en/bitcoin-paper https://github.com/ethereum/wiki/wiki/white-paper http://szabo.best.vwh.net/smart_contracts_idea.html https://letstalkbitcoin.com/bitcoin-and-the-three-laws-of-robotics https://blockstream.com/sidechains.pdf https://peercoin.net/whitepaper http://wiki.nxtcrypto.org/wiki/whitepaper:nxt http://counterparty.io/docs/ http://bitsharesblog.com/new-bitshares-whitepaper/ page