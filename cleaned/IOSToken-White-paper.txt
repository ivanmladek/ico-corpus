internet services: the next-generation, secure, highly scalable ecosystem for online services the internet services foundation december abstract despite the recent hype the cryptocurrency market, the underlying blockchain technology still early stage and far from mass adoption. one the well-recognized issues with current blockchain technologies scalability. without the capability processing large volumes transactions swiftly, heavy usage services like facebook, amazon, and digital asset exchanges are nearly impossible deploy onto the blockchain. this paper, propose the internet services ("ios"), innovative and secure blockchain paradigm designed provide horizontal scalability and high transaction throughput. implementing our novel sharding architecture and consensus mechanism, the ios system able process secure transactions per second. this work makes the following contributions. introduces: efficient distributed sharding (eds) innovative sharding scheme that makes shards sufficiently large and strongly bias-resistant via combination client-server randomness scavenging mechanism and leader election via cryptographic sortition. transepoch secure validators-to-shards assignment during epoch transitions while maintaining transaction operability. atomix novel two-step inter-shard atomic commit protocol that guarantees transaction atomicity byzantine setting. proof-of-believability (pob) groundbreaking byzantine consensus protocol with believable-first approach that guarantees safety and liveness the system while largely maximizes the transaction throughput size-one-shard. micro state block (msb) novel mechanism minimize the storage and bootstrapping costs for validators. note: the ios work progress. active research under way, and new versions this paper will updated http://iost.io for comments and suggestions, contact team@iost.io table contents background related work state machine replication bitcoin and proof-of-work proof-of-stake blockchain architecture distributed randomness protocol efficient distributed sharding algorithm leader election with back-up protocol analysis operability during epoch transitions node-to-shard transition assignment algorithm transepoch analysis inter-shard transactions consensus mechanism tokens and motivations proof-of-believability blockchain storage pruning algorithm msb generation protocol analysis references background excessive commission fees, privacy violations, frauds and censorship are common issues encountered during daily interactions with centralized online service providers. given these well-recognized problems with centralization, wide range blockchain technologies attempting resolve these issues have been developed since the launch bitcoin specialized projects like steemit [], bitshares [], and syscoin [], well more versatile projects like ethereum and eos [], are some many examples. however, most those attempts are either too specialized certain applications, burdened low transaction throughput. due these limitations flexibility and transaction throughput, impossible for developers and enterprises bring heavy services like facebook amazon onto the blockchain not mention something more complicated like digital asset exchanges. the heart the scalability issue lies the fundamental design these existing blockchain technologies their consensus protocols and blockchain architectures. most the existing blockchain technologies face two major challenges their way scaling up: every full node must store the entire ledger order participate; every participating node the network obligated handle every transaction. since all the participating nodes are essentially conducting the same work, the number transactions the system can process will not exceed that single node. moreover, the growing size the blockchain increases the requirements and costs storage space, bandwidth, and computational resources for node fully participate the network. the increasing mining cost will inevitably make the participation the network become privilege for the few, leading straight back the problem centralization. the ios designed fill the void. our vision, the ios next-generation blockchain technology that provides the network infrastructure support service-oriented ecosystem. the ios platform not only provides its users completely decentralized way exchange online services and digital goods, but also enables developers deploy large scale dapps with the ability support massive number users. with series groundbreaking innovations, such efficient distributed sharding ("eds") and believable-first consensus approach, are able increase the system's throughput enormously while guaranteeing security. developed eds based the sharding technique. widely adopted distributed systems and databases enable parallel transaction processing. inspired the classic "divide and conquer" principle computer science, sharding technique that partitions the entire ios network into certain numbers subspaces called shards. can consider each shard miniature network that runs its own consensus protocol parallel. instead having the entire network validating the same set transactions, subsets transactions can handled various consensus groups simultaneously. therefore, the throughput the system can significantly enhanced even the size the network and number transactions grow rapidly. moreover, order ensure the network divided homogeneously, have developed bias-resistant distributed randomness protocol order introduce unbiased and transparent randomness into the sharding process. with the eds, the ios also packed very powerful arsenal technologies that empowers deployment large scale dapps with high-performance and flexibility. allows developers build wide range products: from counterparts traditional monopolistic online service providers brand new business models that would have been considered impossible previously. admittedly, running such services could quite expensive when the size the ios network relatively small. however, with increasing number nodes and resources the network, the cost running such large scale dapps might greatly reduced. additionally, there are many benefits including: avoiding cyber attacks, high-level data security, and the immutable property. during the development the ios blockchain, thoroughly examined all currently available solutions order learn from previous attempts. related work state machine replication nutshell, blockchain technologies are state machine replication protocols. every state machine replication protocol has satisfy two important properties: safety i.e., all servers the network have the same record transactions; liveness i.e., transactions clients are submitted and documented into the log quickly. there are two fundamentally different ways achieve state machine replication: classical-style consensus and blockchain-style consensus []. classical-style consensus generally applies paxos-like algorithms and used the permissioned setting where there priori knowledge the consensus nodes known the system. example this application would the servers software companies like amazon, where their servers collectively use classical way replicate and store information, and the classical algorithm establishes the fundamentals form consensus the ordering their data. bitcoin and proof-of-work satoshi nakamoto was the first introduce bitcoin solution establish consensus the permissionless setting e.g. any node can freely join and leave the network without priori knowledge the consensus nodes. the network underlying bitcoin, blockchain improves the scale distributed systems without human involvement providing economic incentives the servers, dubbed miners bitcoin's settings. miners the bitcoin network form consensus calculating partial hash collisions with certain difficulty level. the chain with the greatest cumulative difficulty would acknowledged other nodes the consensus result. this solution named proof-of-work (pow), which essence have all the nodes the network contribute their computing power way earn incentives and thus determine the ordering transactions for the whole system. benefit pow its ability defend against sybil attack permissionless setting []. despite its advancements scale and security, bitcoin has few major drawbacks: unlike other modern cryptocurrencies, takes more than hour confirm transaction according its configuration; difficult develop various applications upon bitcoin network; the consensus mechanism wastes too much energy, i.e., costs more than two million dollars per day electricity. more importantly, earlier works show that bitcoin-style blockchain must have sufficiently large interval retain security []. therefore, bitcoin would not good replacement for the current centralized system support day-to-day applications and large transaction volume. proof-of-stake the concept proof-of-stake was first discussed online blockchain forum and was adopted few cryptocurrencies like ppcoin [], peercoins[] and nxt []. the idea pos essentially one vote per unit stake, such that for each validator, owning more stake will have higher voting power. therefore, validators have economic incentive harm the whole blockchain network. for attackers, the cost attack huge because they have own the majority the stakes. the early development, proof-of-stake consensus mechanism known for being vulnerable "nothing-at-stake" attacks, where servers are able vote multiple blocks the same time with incentive converge, damaging the security the blockchain. later work solves the problem using slasher [], which enforces punishment for violating nodes. many other work are also described the hoc application proof-of-stake [-,][][]. although pos fulfills the liveness the replicated state machine protocol, still faces challenges like centralization and security problems. for instance, validators possessing more tokens will more likely generate new blocks and get richer, leading potential centralization problem. furthermore, previous work shows that proof-of-stake protocol can only provably secure and robustly configured consensus protocol its token not being exchanged too frequently which potentially implies that there ceiling throughput for proof-of-stake order preserve security. blockchain architecture the infrastructure ioschain similar existing well-known blockchains like bitcoin and ethereum, where nodes disseminate data through gossip protocol. the system split its data and state into shards. each node responsible for one shard the system. unspent transactions (utxos) are stored the memory the nodes the corresponding shards. this raises several new challenges. how divide the system into shards. how reach consensus each shard. how perform inter-shard transactions. order solve the above challenges fair and secure manner, have perform many random operations, for example, assigning nodes into shards, electing leaders each shard. result, have first design unforgeable and unbiased (uniformly random) distributed random number generation protocol. with the random number generation protocol, the above challenges can addressed one one. the rest this paper, present the techniques and methods used address these challenges. section present distributed randomness protocol (drp), which unforgeable and unbiased when the ratio malicious nodes are below some certain predefined threshold. the random numbers generated drp used divide the system into shards, assign nodes different shards, and elect leaders each shard. section present efficient distributed sharding (eds) novel scheme form shards (subsets validators record state and process transactions) that are both sufficiently large and strongly bias-resistant using combination drp and vrf-based leader election via cryptographic sortition. section present transepoch secure validators-to-shards assignment protocol during epoch transitions while maintaining system operability. section present atomix novel two-step inter-shard atomic commit protocol that guarantees transaction atomicity byzantine setting. section present proof-of-believability (pob) novel byzantine consensus protocol with believable-first approach that guarantees safety and liveness the system while largely maximizing the transaction throughput size-one-shard. section present micro state blocks (msb) novel mechanism minimize the storage and bootstrapping costs for validators. distributed randomness protocol traditional approach generate randomness like proof-of-work based mechanism trusted beacon have computational wastes and centralization concerns. desirable use cryptographic tools generate distributed random numbers, which not only saves resources but also provably secure. there are multiple algorithms generate distributed random numbers for the purpose node-shard assignment and leader election ioschain. here present the one that, our knowledge, the best fits the requirement the ioschain scenario. ioschain, the distributed random number generator has the following requirements. has resistant dishonest participants (including clients and servers) with certain ratio. detailed, the system able make progress when the ratio dishonest participants are below the threshold, and nothing bad happens when making progress. the final random number must unforgeable and unbiased (uniformly random), except negligible probability. dishonest participant not able try multiple times generate the random number that favors the participant, even multiple dishonest participants collude. third parties are able verify the output generated faithfully running the protocol (i.e., verify that satisfies all the above requirements). order achieve these requirements, propose use client-server protocol, called distributed randomness protocol (drp) [], where client communicates with set servers generate unforgeable, uniformly random value through non-interactive zero-knowledge proof (nizk) and publicly verifiable secret sharing (pvss). certain protocol run, before the protocol finishes and the final random output revealed, entity the protocol able learn any information about the final output, which makes sure dishonest client not able try multiple runs generate the random number that favors the dishonest client. the protocol consists two phases randomness generation and randomness verification. works follows. initially, the client starts protocol run broadcasting all the servers message including randomly generated balanced grouping. the first phase, each server generates random input value and creates shares only for other members the same group using pvss. upon receiving encrypted shares with the nizk proofs from all the servers (or timeout), the client chooses subset server inputs from each group. this allows the client fix each group's secret and the output the protocol. the second phase, the servers decrypt and send their shares the client soon the client receives sign-off input values global run collective signature (cosi) []. then the client combines the recovered group secrets reveal the final random output. efficient distributed sharding with the distributed randomness protocol (drp) presented above, not difficult implement efficient distributed sharding. however, the protocol only works well without malicious failure nodes, since performed validators collectively. therefore, have design backup protocols for scenarios with malicious failure nodes. conquer this problem, propose solution that uses algorand and omniledger elect leader. algorithm leader election with back-up protocol inputs: view counter validator the private key for the current epoch the synchrony bound output: validator for each which has the minimum-value valid lottery run drp each computes lottery function with its view and the node's private key using verifiable random then for time bound the validators gossip these lotteries with each other. each validator collects the top minimum-value lottery the gossip process. after the time bound the validators fix the minimum-value valid lottery they have seen far. the validator corresponding the minimum-value valid lottery elected the leader, while the other two validators corresponding the second and third minimum-value valid lottery are used the pool for back-up leaders. the elected validator successfully runs the drp, broadcasts the output all other validators with its correctness proof. each can use compute permutation and divide the result into buckets with same size, thus the mapping from nodes shards determined. after the time bound the elected validator fails start drp, validators mark the current run failed and exclude this leader the rest the epoch this case,the back-up leader will used run drp. the two backup leaders fail continuously, the lottery will roll back step and the whole protocol will rerun. analysis the leader election mechanism provides required properties which the same those described section each validator can produce only single valid lottery per view epoch the drp design provides scalability. since the private key kept secret, the output vrf unpredictable. given our synchrony time bound the lottery will seen all other validators within malicious nodes win the lottery, cannot perform arbitrary behaviors either choose cooperate and run the drp protocol, decide fail the epoch. any the malicious/abnormal cases happens, the malicious nodes would excluded from participating the rest the epoch. operability during epoch transitions there are many shard configuration schemes, such static configuration and some different rolling schemes. ioschain uses dynamical rolling scheme swaps out and validators batches for each epoch this configuration will give ioschain idle period that only after enough validators have bootstrapped appropriately, the network can begin processing transactions. many designs the blockchain did not take the issue that how make sure the system operational during this period into consideration. key factor the issue during the transition the batch size, which highly relevant the safety the system. when the swap batch size grows, the risk increases the number remaining honest validators will not sufficient reach consensus. another disadvantage growing swap batch size that the downloading and bootstrapping information will cause network stress increases. given our threat model that there are most should less than malicious nodes, the maximum size the swap batch nodes. maintain full operability during transition/idle phases, use the method selecting subset the validators swapped out and replaced with new members [,]. this based omniledger's approach []. enables the remaining validators continue offering services while the newly joined nodes are downloading history data and bootstrapping. present the node-to-shard transition assignment protocol transepoch follows. node-to-shard transition assignment algorithm transepoch inputs: the total number nodes the size each shard the the swap-out batch size, i.e., the number validators that will swapped out given time given epoch. outputs: set for each shard generate two seeds and using the generated random output from drp. use and get the permutation and and divide nodes into buckets size this way, the node swap-batch mapping determined. used for current nodes and used for the newly joined nodes. each batch waits and then starts the swap. analysis the algorithm presented above, ensured safety byzantine fault tolerance (bft) consensus each shard transition. the reasons are two folds. firstly, made sure the size the group. there are least shard size validators running consensus. secondly, safety against adversary also guaranteed per epoch randomness used generate the permutation validators batches. inter-shard transactions the mechanism that supports inter-shard transactions critical the system, since transactions are likely happen cross shards. introduce byzantine shard atomic commit (atomix) protocol ensures the atomicity cross shards. this protocol prevents double spending and keeps the consistency transactions. our design variant the omniledger algorithm. first present atomix the utxo state model. previous work has proved that the atomix can ensure that the smart contract also supported our inter-shard transaction mechanism the utxo model supported. nutshell, when cross-shard transaction from node shard node shard happens, the algorithm does the following: create the within the shard and let all nodes validate the transaction. the approved all nodes shard the transaction logged a's blockchain. the same time, the client will gossip proof-of-acceptance endorse the transaction,lock the fund utxo, and send the rejected nodes the fund gets returned a's blockchain commits the the b's blockchain and have nodes the receiver's shard validating the tx. the rejected nodes the fund gets returned the gets approved all nodes the b's blockchain, the fund released the rejected all nodes, the fund gets returned consensus mechanism tokens and motivations the ios system, ios token, like tokens other blockchain systems, serves the medium exchange for all transactions and commission fees. more importantly, ios also plays important role calculating user's believability score. all ios tokens will generated the genesis block. the ios ecosystem, ios tokens can used for: payment: payments for services and goods provided merchants other community members. commission: payment validators compensation for running smart contracts, processing messages and transactions, and using resources shared the general ecosystem including but not limited storage space, computing power, etc. the commission fee incentivizes the validators and prevents malicious users from damaging the interests the community through excessive deployment smart contracts. believability: ios tokens will used calculate users' believability scores (will explained the following section). addition, member the ios ecosystem, each user can acquire ios tokens through validating transactions and contributing resources (e.g., running smart contracts, providing storage space, etc.). mentioned previous sections, major challenge faced traditional proof-of-stake consensus mechanism the tendency towards centralization. order mitigate this risk, introduce servi both measurement users' contribution the community and way encourage members contribute the continued development the ioschain. has the following attributes: non-tradable: since servi not designed medium exchange, servi can not traded exchanged any way. self-destructive: after validating block, the system will automatically clear the servi balance owned the validator. this way, nodes with high believability scores can take turns validating blocks, ensure fair block generation process. self-issuance: servi will generated and deposited user accounts automatically after certain contributions, such providing community services, evaluating services provided another entities, and/or making other special contributions. proof-of-believability traditional blockchain systems have inherent trade-off between safety and throughput, depending shard size. system with large number small shards delivers better performance but provides less resiliency against bad actors, and vice versa. order break the trade-off way that keeps safety and increases throughput, propose innovative proof-of-believability (pob) consensus protocol for ioschain. pob guarantees that the nodes are with negligible probability misbehave, while significantly increasing the transaction throughput size-one-shard. the proof-of-believability consensus protocol uses intra-shard believable-first approach. the protocol divides all validators into two groups, believable league and normal league. believable validators process transactions quickly the first phase. afterwards, normal validators sample and verify the transactions the second phase provide finality and ensure verifiability. the chance node being elected into the believable league determined believability score which calculated multiple factors (e.g., token balance, contributions the community, reviews, etc). one with higher believability score more likely elected into the believable league. believable validators follow the procedures decide the set committed transactions and their order, well process them order. believable validators also form smaller groups one validator per group. transactions will randomly distributed among these believable validators. consequently, they produce smaller blocks with extremely low latency. however, may introduce security problem only one node performing the verification. result, some corrupted transactions might committed misbehaved validators. order solve this security problem, specify sampling probability pthat normal validators will sample transactions and detect inconsistencies. validator detected misbehaviour, will lose all the tokens and reputation the system while the defrauded users will compensated for any loss. the believable-first approach makes processing transactions extremely fast only single (believable) validator doing the verification and unlikely misbehave. the ios system, the sharding policy file specifies the sizes the believable and normal league, respectively, and the sampling probability upon the inception epoch, all validators will assigned shards using the distributed randomness generation protocol. their states will bootstrapped from the corresponding shard's last micro state blocks (msb). depending the believability score validators will assigned either believable group (small) the normal group (large) within shard. the first phase, transactions that are processed the believable league produce optimistically validated blocks. these blocks serve input for sampling re-validation the normal league who runs concurrently. the normal league also combines inputs from multiple optimistic processing groups. this could maximize the throughput the system. transactions are validated successfully, they will included finalized block, added the shard's blockchain, and finally included the msb. however, when the normal league detects any inconsistency, the corresponding validated transaction would excluded from the blockchain and the validator who signed the invalid block would detected and held accountable. designed the punishment scheme powerfully harsh that the validator has incentive misbehave under any circumstances. validator detected misbehaving, that validator will lose all tokens and reputation the system and all its previously validated transactions will re-checked. given the minimal incentive fault and the quantifiable confidence the security validation, clients can achieve real-time processing speed with assurance. the normal league runs the byzantine consensus scheme based byzcoin [], because scales efficiently thousands consensus group members. byzcoin uses collective signature (cosi) [], scalable cryptographic primitive that uses multi-signatures [], make traditional consensus algorithms such pbft scale. byzcoin distributes blocks using multicast trees for performance, and falls back star topology for fault tolerance. ensures that all the honest members shard agree specific common sequence actions, despite some malicious nodes are the shard, while guaranteeing safety and liveness. ensure robustness, use fall-back scheme believable-first protocol. when shard doesn't have enough believable validators form the league, due either temporary downtime being the bootstrapping phase the ecosystem, two-league committees would fall back one-league. all transactions are directly processed the normal league following the pbft consensus protocol. blockchain storage pruning another issue current blockchains are facing the rapid expanding size the blockchain storage [], which puts new validators heavy workload for bootstrapping. blockchains follow the same pattern store historical data from the beginning. however, this crucial concern for the high-throughput blockchain systems the the storage will explode. minimize the storage and bootstrapping costs for validators, use blockchain storage pruning approach summarize the full state shard's blockchain. use micro state blocks (msb), which based the state block []. present the msb generation protocol below. algorithm msb generation protocol inputs: the current epoch the current shard output: the micro state block for when the epoch ends, the shard leader stores all transactions merkle tree []. the shard leader hashes the merkle tree's root, denoted and puts validators run consensus the blocks pending. while there not any regular the correctness verified, the shard leader stores the approved header the shard's blockchain. the end epoch regular blocks all the nodes drop the body and keep the analysis transactions are checked references past blockchains. since each shard ioschain stores only the past msb headers and blockchain state distributed across multiple shards, client cannot prove the existence past transaction providing check the block. mitigate this issue moving the storage responsibility from past blockchains the client. since latest epoch's blocks retained, clients can ask the validators the shard create existence proof for transactions validated epoch during the next epoch. validators are essentially creating higher level chain for msbs, that provides skips from epoch's msb another. this msb chain keeps the latest msb with its body and all the previous msb headers. this important clients that want verify past transaction need have reference point. remark that msbs may contain several multi-hop backpointers headers regular blocks order reduce the size their proofs. with msb, bootstrapping new validators and syncing crashed validators up-to-date become efficient, validators start from the last valid msb and replay only the last part the blockchain, instead replaying the full history from the first block from the time they crashed. bitcoin deployed ioschain, currently the bandwidth bootstrapping costs would two orders magnitude less. this critical when new shards come ioschain. due the random shard assignment mechanism, validators changes shards periodically and need updated frequently, which benefits lot from the blockchain storage pruning technique. references iddo bentov, ariel gabizon, and alex mizrahi. cryptocurrencies without proof work. lecture notes computer science. iddo bentov, charles lee, alex mizrahi, and meni rosenfeld. proof activity. acm sigmetrics performance evaluation review (), vitalik buterin. slasher: punitive proof stake algorithm. retrieved january from https://blog.ethereum.org////slasher-a-punitive-proof-ofstake-algorithm/ miguel oom temudo castro. practical byzantine fault tolerance. nxt community. nxt whitepaper. retrieved january from https://bravenewcoin.com/assets/whitepapers/nxtwhitepaper-v-rev.pdf george danezis and sarah meiklejohn. centrally banked cryptocurrencies. proceedings network and distributed system security symposium. doi: https://doi.org/./ndss.. kokoris-kogias, jovanovic, gailly, khoffi, gasser, and ford. enhancing bitcoin security and performance with strong consistency via collective signing. usenix conference security symposium. eleftherios kokoris-kogias, philipp jovanovic, linus gasser+, nicolas gailly, ewa syta, bryan ford. omniledger: secure, scale-out, decentralized ledger via sharding. yossi gilad, rotem hemo, silvio micali, georgios vlachos, and nickolai zeldovich. algorand: scaling byzantine agreements for cryptocurrencies. proceedings the symposium operating systems principles sosp doi: https://doi.org/./. maxwell and. stake and consensus. retrieved january from https://download.wpsoftware.net/bitcoin/pos.pdf ian grigg. eos introduction. eos.io. retrieved from https://eos.io/documents/eos_an_introduction.pdf kwon. tendermint: consensus without mining. retrieved january from http://tendermint.com/docs/tendermint.pdf loi luu, viswesh narayanan, chaodong zheng, kunal baweja, seth gilbert, and prateek saxena. secure sharding protocol for open blockchains. proceedings the acm sigsac conference computer and communications security ccs'. doi: https://doi.org/./. ralph merkle. certified digital signature. lecture notes computer science. satoshi nakamoto. bitcoin: peer-to-peer electronic cash system. bitcoin.org. retrieved from https://bitcoin.org/bitcoin.pdf rafael pass, lior seeman, and abhi shelat. analysis the blockchain protocol asynchronous networks. lecture notes computer science. rafael pass and elaine shi. the sleepy model consensus. lecture notes computer science. phil daian and rafael pass and elaine shi. snow white: provably secure proofs stake. (). phil daian rafael pass. snow white: robustly reconfigurable consensus and applications provably secure proofs stake. schnorr. efficient signature generation smart cards. cryptology (). doi: https://doi.org/./bf jagdeep sidhu. syscoin: peer-to-peer electronic cash system with blockchain-based services for e-business. international conference computer communication and networks (icccn). doi: https://doi.org/./icccn.. sunny king and. ppcoin: peer-to-peer crypto-currency with proof-of-stake. retrieved from https://peercoin.net/assets/paper/peercoin-paper.pdf scott nadal sunny king. peercoin. retrieved january from https://peercoin.net/assets/paper/peercoin-paper.pdf ewa syta, philipp jovanovic, eleftherios kokoris kogias, nicolas gailly, linus gasser, ismail khoffi, michael fischer, and bryan ford. scalable bias-resistant distributed randomness. ieee symposium security and privacy (sp). doi: https://doi.org/./sp.. ewa syta, iulia tamas, dylan visher, david isaac wolinsky, philipp jovanovic, linus gasser, nicolas gailly, ismail khoffi, and bryan ford. keeping authorities "honest bust" with decentralized witness cosigning. ieee symposium security and privacy (sp). doi: https://doi.org/./sp.. buterin and. casper. retrieved january from https://blog.ethereum.org//// introducing-casper-friendly-ghost/ wood. ethereum: secure decentralised generalised transaction ledger. ethereum project yellow paper. (). gavin wood. ethereum: secure decentralised generalised transaction ledger. ethereum.github.io/yellowpaper. retrieved from https://ethereum.github.io/yellowpaper/paper.pdf steem: incentivized, blockchain-based, public content platform. steem.io. retrieved from https://steem.io/steemwhitepaper.pdf whitepapers. bitshares.org. retrieved from http://docs.bitshares.org/bitshares/papers/ proof stake instead proof work. retrieved january from https://bitcointalk.org/index.php?topic=.