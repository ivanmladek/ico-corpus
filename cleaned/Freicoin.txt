freimarkets: extending bitcoin protocol with user-specified bearer instruments, peer-to-peer exchange, off-chain accounting, auctions, derivatives and transitive transactions version v.. mark friedenbach, jorge timon august abstract this proposal adds primitives bitcoin necessary for implementing non-currency financial constructs, such dividend-yielding bonds, asset ownership tokens, credit relationships, variety forms smart contracts, and distributed marketplaces for exchanging all the above. private accounting servers provide mechanism support unlimited volume off-chain transactions while being able interact with in-chain assets through atomic cross-chain trade and integrated peer-to-peer market. keywords: bitcoin, freicoin, user-specified bearer instruments, off-chain accounting, atomic trades, auctions, derivatives, transitive transactions contents introduction major features indivisible, unique tokens user-issued assets partial transactions private ledgers proposed changes precision, rounding, and limits indivisible tokens asset tags granular outputs granular redemption validation scripts authorizing signatories new scripting opcodes transaction expiration formal specification nversion= transactions hierarchical sub-transactions asset definition transactions example use cases with scripts general notation conventions basic uses auctions options gateways and bridges off-chain transactions introduction herein propose new transaction format, nversion= transactions, which enables hierarchies independently verified sub-transactions, additional validation scripts and introspective opcodes, strict currency controls, well relaxation the rules regarding coin generation via coinbase transactions for the purpose supporting user-defined assets the block-chain. also introduce the concept private centralized accounting servers perform transactions off-chain assets that cam interact with each other well with in-chain assets. combined with suitable extensions the peer-to-peer, json-rpc, restful, and wallet interfaces, these protocol changes complete bitcoin's repertoire low-level constructs, allowing the emulation wide variety financial instruments. together this enables the following sorts applications: issuing new assets means asset definition transactions (coinbase transactions other than the usual first transaction block). such assets are allowed specify their own interest/demurrage rate, unit granularity, display scale, and hash field referencing external resource, possibly legal ricardian contract that the chain itself does not validate. issuing unique and indivisible tokens that are transferred sets instead numeric amount, and allow fast look ups their current ownership enhance smart property use cases and manage some permissions the regular custom assets. atomic exchange assets differing types through inclusion inputs and outputs both types single transaction. signing orders (partial-transactions giving one asset exchange for another) that are binding but not completed until they get into the chain part balanced transaction, and have attached expiration dates can explicitly cancelled double-spending the signed inputs. executing arbitrary number these orders atomically creating complete valid transaction where the orders are included nested sub-transactions, thereby executing atomic trade without requiring each the parties online direct communication with each other. composing orders from separate markets into atomic trade with intermediate assets enables payments based transitive trust relationships. destruction coins, tokens, assets when longer needed special class nonspendable, prunable output script. restricting the conditions which transaction sub-transaction may selected for inclusion specifying validation scripts, which are run when the enclosing block validated. introspection the block chain from within the bitcoin scripting environment enabled the introduction new opcodes. running accounting servers private chains with centralized rather than distributed consensus, which off-chain assets can issued, transferred and traded the same way they are the public chain, with the private block chain providing audit log. execute arbitrary number trades from different accounting servers and/or the public chain atomic transaction, using either the public chain agreed upon timestamping service for the commit phase. public chains private accounting servers configured "observe" other chains enable much faster but secure cross-chain trade, compared with the existing slow, multi-phase protocols involving revelation hashed secrets. this requires the ability extract proofs from the observed chain order validate conditional transactions. restrict the usage custom asset assigning rotatable signing keys which must sign all transactions involving the restricted assets prior inclusion (support for kyc regulatory compliance). the remainder this document first overview the major features this proposal, then detail the precise modifications and formal specifications before covering handful applications. major features here describe non-normative prose the proposed changes. assume technical familiarity with the bitcoin protocol and freicoin's various extensions thereof. indivisible, unique tokens indivisible, uniquely identifiable asset tokens are useful for applications like physical ownership keys smart car, numbered seats membership tokens. since token contained within more than one unspent transaction output any given time, it's not necessary trace the ownership back "genesis transaction" one would need with colored coins approach this allows smart property clients have smaller requirements when authenticated unspent transaction output index checkpoints are included each block user-issued assets divisible currency and/or tokens representing user-issued assets may minted special coinbase transactions separate from the usual first transaction block (where freicoins are currently, and continue minted). coins created such generating transactions are not freicoins, but rather user-issued asset shares which represent fungible ownership the underlying asset type, asset tokens identified per-asset unique bitstrings. such coins tokens can included transactions containing regular freicoin currency, which this document sometimes called the host currency fee currency. the creator the new asset can define interest/demurrage rate. the quantity issued may fixed may define list issuance tokens that permit their owners issue new units the asset being defined. the creator the asset definition transaction may also specify list authorizer tokens. the signature authorizer required every time transaction involves inputs outputs that asset. this allows issuers/gateways manage closed list "authorized accounts" registered users regulatory restrictions their jurisdiction requires them they desire whitelisting participants (for example, local currencies restricted stock sales). also allows issuers charge fees when the assets are traded moved. colored coins approach custom assets the chain define genesis transaction that identifies the asset and trace the funds that transaction outside the chain treat them differently they represent more than regular bitcoins. this approach has several limitations when compared this protocol extension. there's discussion group colored coins development here: https://groups.google.com/forum/#!forum/bitcoinx having fast access utxo tree indexed each block would enhance light clients security and also important for scalability, something important for this proposal since enables new uses and bigger volume expected. mark friedenbach's work these improvements documented here: http://utxo.tumblr.com/ issuers currencies convertible fiat may have comply with know your customer regulations their jurisdiction for anti-money laundering enforcement. for example, u.s. dollar gateways based the usa need comply with fincen's normative. using unique tokens manage new issuance and authorizers allows the creator follow his own key cycling policy security protocols. utilizing multisig multiple signatures, possible for transactions remain valid even across one more key rotations. these various properties the asset, its interest/demurrage rate, unit granularity and display scale, and listings issuer and authorizer tokens are set the coinbase string the asset definition transaction. partial transactions this proposal extends the transaction format with optionally empty nested level subtransactions. sub-transactions differ from regular, block-level transactions that their inputs and outputs are not required balance and they have associated with them quantity and granularity allowing for fractional redemption. since validation sub-transactions occurs separately from each other and the higher-level enclosing transaction, pre-signed, unbalanced transactions are able act offers distributed exchange: market participants sign offers adding coins one asset type exchange for output another type. these signed offers are broadcast through side-channel and aggregated miners. when cross-over detected bid higher than ask), the miner combines the two pre-signed offers and claims the difference fee. other use cases are enabled. for example, when the underlying assets represent lines credit, the exchange mechanism allows payments based transitive trust relationships, the style the original ripplepay application ryan fugger. private ledgers private accounting servers, "accountants" use variant the freicoin/freimarkets code base that stripped the distributed consensus proof-of-work mechanism. accountants are responsible for eliminating double-spending, reserving balances for pending transfers, and authorizing transactions, sometimes conditionally external events. accountants are able prevent transactions from going through the owner has already obligated funds elsewhere, keeping track the available balance (actual balance minus funds various stages commit). accountants use various distributed consensus mechanisms for coordinating the transaction commitment with other private accounting servers public block chains. the level privacy may vary from one server another. server operators are allowed freedom choosing which parts the block chain audit log publish, with sensible default being the block headers and coinbase transactions, allowing for validation authenticated inclusion and index proofs used notify users their wallet balance, history and current activity, but not revealing other user's balances transaction history. using newly added extrospective opcodes construct scripts dependent external chains, possible for private transactions conditional public freicoin blockchain data other private accounting servers. note that the opposite relation cannot apply this time. public chains could support transactions conditional data other chains enhance cross-chain trade, but then the observing chain's validation becomes dependent the observed chain validation. this approach cross-chain has been described several times and would trivial implement with this protocol extension. least these two threads describe this cross-chain trade scheme: https://bitcointalk.org/index.php?topic=. https://bitcointalk.org/index.php?topic=. proposed changes precision, rounding, and limits all internal computation accounting quantities are performed using arbitrary precision fractions, equivalent mathematical system which does not suffer from loss precision over/underflow. max_money moneyrange limitation the maximum numerical value allowed for any output stored intermediary value any asset type kria, this about less than the maximum value representable the decimal type. transaction which violates this constraint invalid. ieee decimal floating point output amounts for nversion= transactions are positive, real decimal floating point values using stricter subset the binary integer decimal encoding specified ieee infinities and not-a-numbers are not allowed, and the normal (lowest exponent) representation must used. for nversion= and nversion= transactions, the int nvalue field interpreted according the following equation: nvalue int dvalue decimal dvalue nvalue that say, old-style minimum representable positive value kria freicoins) would encoded new-style decimal value since the smallest representable positive decimal value that gives expressive range approximately orders magnitude the exponent, plus sixteen digits precision. while not technically providing infinite divisibility, this leaves plenty room the bottom. note units throughout this document couple differing units are used for describing financial quantities the freicoin block chain. this unfortunate and confusing situation arises from the history representing bitcoin/freicoin amounts both user interface and serialization formats. when talking about the host currency speak freicoins, with freicoin frc) traditionally being specified with decimal places precision. old-style transactions the smallest non-zero representable unit freicoins kria, with kria frc. new-style transactions encode freicoin quantities decimal values, with kria and the smallest non-zero representable unit being frc. either case, expected that the user interface will configured show units freicoins, the multiplier the underlying asset. indivisible tokens new-style outputs contain the decimal continuous value combined with possibly empty list bitstrings. these bitstrings are indivisible, unique outputs. any output token must found input the enclosing transaction, and tokens cannot shared among two outputs the same transaction. the asset definition transaction, any transaction with one more asset's issuers signatory allowed violate the constraint that continuous outputs are less than equal inputs, and that output unique tokens are subset inputs for that asset. asset tags new-style outputs are tagged with bits identifying the asset from which the output drawn. this tag the -byte serialized hash (ripemd sha) the asset definition transaction. for outputs the host currency freicoin, the similarly-calculated -byte hash the genesis block used instead. granular outputs the granularity option the asset definition determines the minimum increment which may used transfer otherwise continuous value. represented positive decimal value. left unspecified, asset limited this time the minimum encodable positive decimal value but with further subdivision allowed future extensions enable it. the host currency freicoin defined maximally divisible this way. for assets with non-zero interest/demurrage, granularity checks are made the reference-height the transaction. granular redemption general, outputs are considered spent only when the full amount has been claimed. later transaction claims less than the full amount, that amount subtracted from the remaining balance. transaction may claim less than the full amount utilizing granular offer. the signed offer contains -bit integer field ngranularity which specifies the number equal-sized units the offer split into, and any transaction making use the offer may choose the number units claim, long there remains sufficient output remaining. order implement this functionality, the set unspent transaction outputs must include field recording the amount remaining (or equivalently, the amount spent far). fractional redemption outputs containing unique tokens not allowed. validation scripts new-style transactions have validation script, split into the two fields scriptvalidpubkey and scriptvalidsig, which when combined and executed must run completion without abnormal termination, and return non-zero value the stack for transaction valid. while performing signature operations any other script, the scriptvalidsig set the empty script before performing hash serialization and the scriptvalidpubkey stripped any code prior (and including) the last delegation_separator, one exists. special case, empty scriptvalidpubkey and scriptvalidsig automatically passes, and for old-style nversion= nversion= transaction, the empty script the value these fields. authorizing signatories new-style transactions have sorted list signatories. the assetid the -byte asset tag, with token bitstring taking the remaining bytes. the scriptpubkey retrieved from the current unspent transaction output containing the identified authorizing token. new scripting opcodes several new scripting language opcodes are added this proposal. their behavior are detailed here. block_height and block_time these opcodes push the height the block containing the current frame, its ntime value onto the stack. delegation_separator the delegation_separator opcode nop during execution, but does affect signature hash operations. during such serialization for any script except the one being executed, all code prior and including the delegation_separator omitted. quantity the new quantity opcode pushes the nquantity value the current frame onto the stack, the current frame block-level transaction. extrospection opcodes the following opcodes assume the maintenance discrete set observed chains each chain. public chain observes another public chain, it's validation and security become completely dependent the observed chain, and any reorg the later can trigger another reorg the former. even assuming that public chain only observes its own chain, the opcodes may require full nodes have more data than it's currently the utxo set, opening the door new dos attacks vectors. for these reasons the opcodes are only recommended used private chains, and even those cases configure them with caution, potentially limiting more strictly the standard behavior described here. for example, freicoin their behavior modified described section .... ... output_spent output_spent throws error (abnormally terminating script execution) the following condition true: the chain identified (the hash the chain's genesis block) not part the set chains observed the chain for which the script being validated. returns the following condition true: the output identified still exists the utxo block height returns otherwise. ... output_spent_in output_spent_in almost equivalent the following script: block_height frc_chain_id output_spent the difference being that during execution the unspent transaction output set the result applying all transactions the block chain prior the one being validated, including transactions the current block which precede the transaction being validated, but excluding transactions which come later. ... output_exists output_exists throws error (abnormally terminating script execution) any the following conditions are true: the chain identified (the hash the chain's genesis block) not part the set chains observed the chain for which the script being validated. not serialized, sorted, non-repeating but possibly empty list bitstrings. returns the following condition true: there's unspent output from block height block height (both included) the specified asset and contract script, with output amount greater than equal reference-height and set output tokens which are superset returns otherwise. .... output_exists_in output_exists_in almost equivalent the following script: frc_chain_id block_height block_height output_exists again this will only make nodes look for outputs that are the utxo the moment validation (see output_spent_in above for more detailed explanation). ... freicoin's treatment extrospection opcodes freicoin, the only observed chain freicoin itself. the depth the introspection restricted too. only the more limited output_spent_in and output_exists_in opcodes are available. any use the generic ones will result abnormal termination the script. transaction expiration nexpiretime works very similar way than nlocktime, mandating this case maximum time (also specified either unix time block height), after which the transaction cannot accepted into block. see nlocktime bitcoin's protocol specification for more details. formal specification the formal specifications assume familiarity with both the bitcoin protocol and various extensions it, well modifications made freicoin developers. this document makes reference but does not specify these extensions and modifications detail. nversion= transactions this specification defines new standard bitcoin transaction type, nversion= transactions (nversion= being freicoin's reference-height transactions, which this specification extends). nversion= transactions differ syntactically from nversion= transactions the following ways: possibly-empty sub-transaction list precedes the input list. outputs are prefixed with asset identifier tag, -byte serialized hash (ripemd sha) the coinbase transaction from which the output's coins are derived. each output contains coins and/or tokens from single asset/currency. for the host currency freicoin, the similarlycalculated -byte hash the entire chain's genesis block used instead; within asset definition transaction, the asset being defined identified with the hash. outputs are suffixed with optionally empty, sorted list unique token bitstrings. optionally empty sorted-list mapping signatories added immediately following vout. new script field, split into two fields scriptvalidpubkey and scriptvalidsig, added following the signatories' list. new -bit block-time field, nexpiretime, added immediately following nlocktime. the following modifications are made the validation rules for nversion= transactions: sub-transaction list present, each nested sub-transaction must independently validate, according the rules for sub-transaction validation. sub-transaction aggregate input and output balances are calculated the sub-transaction's reference-height, and then time-adjusted the enclosing transaction's reference-height, before being summed together contributors that transaction's aggregate balance. the asset tag each output must reference asset that still has unspent, unpruned transaction outputs. (coins tokens may destroyed sending them the category prunable, unspendable scriptpubkey prefixed op_return, and all unspent outputs asset are constructed, the asset itself considered destroyed.) for block-level transaction, each asset/currency must independently balance (input coin output coin, input tokens equal superset output tokens; the difference any left fee the miner). transaction which has signature from token the asset's issuers list exempted from this requirement for that particular asset, are asset definition transactions for asset being defined. each signature the signatories mapping must reference existing token, execute and run completion using that token's scriptpubkey without abnormal termination (with the other signatories removed during signature operations) else the transaction does not validate. script that does not finish execution with non-zero value the top the stack not valid signature, but otherwise does not stop transaction validation. for example, authorizer's signature required and only one such signature present and terminates with zero the top the stack, then the transaction does not validate (error: missing authorizer signature). but there are two such authorizer signatures, and least one them passes then the transaction may still validate. for each asset used the transaction, that asset has non-empty list authorizers, least one such signature must present the signatories mapping. the scriptvalidpubkey and scriptvalidsig the block-level transaction and each nested sub-transaction any depth, when separately combined and executed must run completion without abnormal termination, and return non-zero value the stack for transaction valid. special case, both scriptvalidpubkey and scriptvalidsig are empty, the check skipped for that script. the current time block height must less than equal the transaction's nexpiretime, where the single field can interpreted either block number unix timestamp the same manner nlocktime. for the purposes enumeration and indexing, the inputs and the outputs the block-level transaction are counted first, followed its sub-transactions order. this corresponds depth-first, pre-order traversal the sub-transaction tree. the transaction coinbase but not the first transaction block, then extra validation rules for asset definition transactions apply. hierarchical sub-transactions any nversion= transaction includes optionally empty nested level sub-transactions, serialized in-between the nversion and vin fields. sub-transactions differ syntactically from regular transactions the following ways: sub-transactions are prefixed varint value, nquantity, which required lie within the semi-closed interval ngranularity]. sub-transactions are suffixed with varint value, ngranularity, which required non-zero. sub-transactions are otherwise similar regular block-level bitcoin transactions, but with additional verification rules: null (coinbase) sub-transaction inputs are not allowed. inputs and outputs not need balance (aggregate input may exceed output for any asset). the reference-height sub-transaction must less than equal its enclosing transaction's (and greater than equal each its inputs and sub-transactions). during script execution, the current frame the sub-transaction. this means that input output indices are relative the sub-transaction, and signature operations evaluate the hash the sub-transaction only. when performing signature operations within the frame the sub-transaction, ngranularity included the hash serialization whereas nquantity not. asset definition transactions the coinbase transaction creating asset the asset definition genesis transaction. such transaction has single nullary input (thereby marking coinbase), and zero more ordinary inputs containing freicoins other asset tokens any type, typically used supply fee the output vector must include outputs the newly defined asset (marked all-zero asset tag), else the asset immediately considered destroyed. here are the ways which asset definition transactions differ from ordinary transaction types: asset definition transactions must not the first transaction block, which reserved for the freicoin miner coinbase. with the freicoin miner coinbase, the first input the block-level asset definition coinbase transaction must nullary txid, int_max n-index). unlike the freicoin miner coinbase, the asset definition coinbase string (the scriptsig the nullary input) allowed have length within the closed interval however the string must script-parseable and meet other criteria specified below. the coinbase string contains the asset's interest/demurrage rate, unit granularity, display scale and external contract hash. these values are decimal, decimal, signed integer and byte serialized hash (ripemd sha) respectively. other inputs besides the nullary input are allowed. asset definition generating transaction may not hash (ripemd sha) any extant asset tag unless all asset tokens for the previously defined asset have been destroyed spending provably unspendable, prunable output (scriptpubkey prefixed with op_return). the -hash asset tag refers the asset being defined, within the context the asset definition transaction only. the transaction does not require its own issuer authorizer signatures (the issuer and authorizer lists the asset being defined take effect after the asset definition transaction). this contrast regular coinbase transactions which not currently allow extra inputs. example use cases with scripts here expand the set possible bitcoin contracts using the protocol extensions. general notation conventions the following examples will use summarized notation for transactions that doesn't represent accurately the actual serialized format and may lead confusion. for example, the transaction: input: frc output: frc alice means that the payer general term for the user building the final transaction, regardless being actual payment trade execution) adds signed inputs totaling least frc and inserts change address reclaiming the remainder minus fees. for the most part, change addresses, miner fees, and reference-height details are elided from the examples order keep the presentation clear. alice, alice, alice, etc. are all addresses script hashes (psh) that alice controls. puba, pubb, pubc, etc. are custom assets issued the public chain. priva, privb, privc are all private assets managed outside the public chain, nothing said, assume that they're issued different accounting servers. needs clarified, label for the chain server will prefixed follows: frc_chain_id:frc, frc_chain_id:puba, chainb:pubb, accountantc:privc, accountantd:privd, etc. basic uses peer-to-peer exchange sub-transactions enable the creation partially valid transactions that act like open binding orders that wait outside the chain. for example, considering this offer created alice: input: puba output: pubb alice granularity: the price here pubb for each puba, and the offer can divided smaller pieces pubb for each puba, specified granularity while the puba remain the utxo set, anyone can use this sub-transaction full valid transaction. bob buys those puba broadcasting this transaction: sub-txns: input: pubb output: puba bob there are several contracts use cases already described the bitcoin wiki: https://en.bitcoin.it/wiki/contracts since the nquantity specified for offer has put pubb and can claim puba. although the sub-transaction has appeared the chain already, the puba referenced the offer hasn't been fully spent yet, puba remain the offer. carol could take more puba with this transaction: sub-txns: input: pubb, frc output: puba carol since carol has payed more than needed and claimed less than she could, the miner gets the pubb, frc and puba fee. finally, alice decides cancel the offer just spending the remaining puba which left the partially-spent transaction output: input: tx_id:output where the puba were originally contained output: puba alice since this clears out the remaining balance the output, removed from the set unspent transaction outputs, and any further attempt use offer will invalidated. although this examples the payers (bob and carol) use the orders directly and actively, miners can act exchange engines pairing matching crossover orders described section ... transitive trust relationships issuing assets representing iou debts and signing outstanding offers representing lines credit, standard marketplace mechanisms can used execute payments through networks transitive trust relationships. these payments look like the marketplace transactions involving more asset types. alice, bob, and carol issue public assets puba, pubb, and pubc representing bitcoin ious. for simplicity use public assets and bitcoins over freicoins avoid complicating the example with cross-chain trade and demurrage. baskets currencies basket currency can issued and fully managed within the block chain. the basket manager issues asset value and then offers bidirectional exchange for multiple other assets fixed rate. auctions english auction the english auction, the owner asset declares his intent sell auction, and starts collecting bids like the following examples: input: frc output: item bid input: frc output: item bid when the auction ended, the seller selects the highest bid and composes complete transaction: sub-txns: input: item output: frc seller since this higher-level transaction, the signature the seller covers the included highest bid sub-transaction, not possible for another bid substituted for the winner. dutch auction dutch auction basically the same english auction, but with the roles the buyer and seller reversed the protocol. the seller suggests price constructing signed offer like the following: input: item output: frc offer the seller then broadcasts this offer and waits some period time see anyone takes it. not, the price lowered and new offer broadcast: input: item output: frc offer the seller knows offer has been accepted and the auction closed when detects transaction the following form the network: sub-txns: input: frc output: item buyer the first buyer get combined transaction the chain using one the seller's offers wins the auction. double auction (market/exchange) this generalization the multi-item english auction, which basically regular market with the miners handling order execution. for any asset pairing, out-of-chain mechanism exists for building, sharing, and collecting signed offers. alice offers buy pubb price puba for each pubb, units pubb time: input: puba output: pubb bid granularity: bob independently offers sell pubb for puba, price puba for each pubb, units pubb time: input: pubb output: puba ask granularity: long the bid price greater than the ask price, the case here, possible for anyone combine these two offers together yield composite market transaction: sub-txns: fee: puba miner the use granularity and quantity allow fractional parts each offer claimed. note that although the crossover spread could claimed output, anyone else could take the bids and construct their own matching transaction and claim the fee for their own. assume that miners will know how this, and one way another the crossover spread will ultimately claimed them. market clearing becomes profitable source revenue addition intentional transaction fees. options options are financial instruments typically used hedge. here describe how implement the most basic types using the protocol extensions. call the long call the buyer pays premium for the right buy puba exchange pubb price before expiry exp. the seller signs the following transaction tx: input: puba output: puba script script: dup hash equalverify checksigverify hash equalverify block_height equalverify checksigverify else dup hash equalverify checksigverify https://en.wikipedia.org/wiki/option_(finance)#the_basic_trades_of_traded_stock_options. american_style. option sub-transaction sub-tx: input: script output: pubb granularity: expiry: exp the seller signs sub-tx with seller. the buyer only lacks the seller's secret able exercise the sub-transaction. pays the premium conditionally the secret being revelead before exp with the following sub-transaction sub-tx: input: pubb output: granularity: expiry: exp scriptvalidpubkey: hash equalverify finally, the seller completes the buyer's transaction receive the premium revealing the secret, allowing the buyer use the option transaction: sub-txs: input: output: pubb scriptvalidsig: now the payer could any moment before exp complete the option sub-transaction with: sub-txs: input: pubb output: puba scriptvalidsig: the nquantity must lower than the ngranularity after exp, the seller can double spend script signing any valid transaction with seller and seller. the seller the long call example taking the short call position. put the long call example the asset being traded was puba and pubb was the base currency. the premium paid puba instead pubb you can consider that pubb the asset being traded and puba the base currency. the right "buy puba for pubb" equivalent "sell pubb for puba". the previous example with the premium being paid puba, the long call buyer would the long put seller, and the long call seller the long put buyer. the buyer long put taking the short put position. gateways and bridges gateways are similar basket currencies: issuer creates asset and then distributes when funds are received out-of-protocol. this could the form fiat wire transfer, physical deposit precious metals, cross-chain transaction (atomically swapping bitcoin for freicoin, for example). assets are redeemed similar process reverse. off-chain transactions for ultimate privacy and scalability, off-chain accounting services are preferred. this proposal provides the missing pieces necessary for accounting servers implement their own private block chains with secure audit log and without the expensive distributed consensus mechanism, allowing opt-in global consensus only when necessary for "cross-chain" (multi-server, public/private) trade. support global consensus mechanisms, new suite extrospective opcodes are added, allowing transactions contain cross-chain conditional dependencies. private buy with public funds seller constructs private order privb for puba): input: privb output: granularity: validation scriptpubkey: delegation_separator dup hash equalverify checksigverify fromaltstack(refheight) dup equalverify fromaltstack(amount) dup div quantity equalverify fromaltstack(tokens) dup equalverify seller frc_chain_id puba fromaltstack(from) fromaltstack(to) output_exists and signs the partial transaction. the validation script contains delegation_separator, which nop far the script interpreter concerned, but marks the part the validation script that needs signed the accountant but not the owners the inputs the transaction sub-transaction, the rest note that there's some data being fetched from the stack. that data must set accountantb the script will return false it's not the stack. whoever appears checksigverify (in this case accountantb) must sign the full transaction with the complete validation script, including what's before delegation_separator. the payer (who just wants privb) completes the private transaction with: input: output: privb buyer the buyer also creates the public transaction: input: puba output: puba seller expiry: refheight: but doesn't sign it. sends both complete but not signed transactions the accountant who reads them and completes the private validation scriptpubkey with: toaltstack(to) toaltstack(from) toaltstack(tokens) toaltstack(amount) toaltstack(refheight) finally accountantb signs all and fills the sub-tx validation scriptsig with: before validation the scriptvalidsig and scriptvalidpubkey are combined together yield: toaltstack(to) toaltstack(from) toaltstack(tokens) toaltstack(amount) toaltstack(refheight) delegation_separator dup hash equalverify checksigverify fromaltstack(refheight) dup equalverify fromaltstack(amount) dup div quantity equalverify fromaltstack(tokens) dup equalverify seller frc_chain_id puba fromaltstack(from) fromaltstack(to) output_exists now buyer signs the public transaction and gets into the frc chain before height the private transaction will valid. until that happens height reached the transaction considered process and after height without appearance the public one, the private transaction invalid. buying public assets with private assets the seller constructs the public order: input: pubb output: accountanta:priva seller validation scriptpubkey: delegation_separator dup hash equalverify checksigverify and signs the partial transaction. the payer (who just wants pubb) completes the public transaction with: input: output: pubb buyer expiry: the buyer also creates the private transaction: input: priva output: priva seller validation scriptpubkey: buyer pubb frc_chain_id output_exists the buyer signs the private transaction and sends with the public one accountanta. the public transaction only lacks accountanta's signature valid. the public transaction gets into the chain before the private one also valid, otherwise rolled back. hybrid transitive transaction puba pubb privc privd pube usera the payer (usera) will pay puba and receive pube exchange. privcs and privds are managed accountants accc and accd respectively. opened offers: fully public: input: pubb output: puba userb private for public: input: privc output: frc:pubb userc] validation scriptpubkey: delegation_separator dup hash equalverify checksigverify fromaltstack(refheight) dup equalverify fromaltstack(amount) dup equalverify fromaltstack(tokens) dup equalverify userc frc_chain_id pubb fromaltstack(from) fromaltstack(to) output_exists private for private: input: privd output: accc:privc userd] validation scriptpubkey: delegation_separator dup hash equalverify checksigverify dup hash equalverify checksigverify public for private: input: pube output: accd:privd usere] validation scriptpubkey: dup hash equalverify checksigverify the payer (usera) who wants buy pube for puba builds the public transaction (pubtx using offers and input: puba output: pubb userc pube usera expiry: since pubb from offer are used pay puba must userb, and those are funded usera the inputs sub-tx complete and valid. but offer still requires accd sign the full transaction. usera still hasn't provided the scriptsig access those puba the inputs neither. two private transactions need created: using offer the payer also builds transaction privtx input: output: privc userd the validation scriptpubkey for must completed pushing the amount and the expiry into the stack. the validity offer and thus this whole transaction still depends accc's signature. the other private transaction (privtx built using offer input: output: privd usere validation scriptpubkey: userc pubb frc_chain_id output_exists offer doesn't require any completion for its validation scriptpubkey, but the corresponding scriptsig requires the signatures both accc and accd. now that all transactions are complete, it's time sign. first accc signs privtx and shares with usera and accd. this secure because privtx still depends pubb being sent userc. userd secure because privtx which gives privd will only valid privtx valid too, that is, pubb are sent userc before expiry the validation scriptpubkey privtx requires. accc and accd can sign offer any order make privtx almost valid. now accd signs pubtx make offer valid. only usera's signature for the puba input missing. the payer (usera) signs the full transaction and broadcasts. gets into the block before expiry, all transactions are valid, otherwise all them are invalid. any point, accc, accd even usera right before the end could stop signing and forwarding the transactions, but that would only cause all transaction expire.