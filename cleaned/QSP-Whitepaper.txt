quantstamp the protocol for securing smart contracts quantstamp the first smart contract security-auditing protocol. are extending ethereum with technology that ensures the security smart contracts. our team made software testing experts who collectively have over google scholar citations. founders founding team members richard ma, cornell ece algorithmic portfolio manager dr. vajih montaghami, phd formal methods steven stewart, mcs, phd, waterloo software verification, database implementation zulkoski, b.s. phd-candidate, waterloo sat/smt solvers leonardo passos, phd compilers and programming languages advisors dr. vijay ganesh, assistant professor, waterloo (ex-stanford, mit) evan cheng, director engineering facebook acm software system award for llvm dr. derek rayside, eng., associate professor, waterloo (ex-mit) -october- version the problem quantstamp protocol technology roadmap motivation smart contract improvements how improve smart contract infrastructure how improve the developer's process quantstamp, example technology validation protocol security audit engine design architectural view quantstamp validation smart contract for ethereum quantstamp reports computer-aided reasoning tools quantstamp network for ethereum tradecraft sat solvers model-checking static program analysis smt solvers symbolic execution and concolic testing incremental releases and the subscription model bug finders distributed and parallel sat parallel sat solvers security disclosure strategy the satisfiability problem (sat) parallel sat and consensus common vulnerabilities for ethereum/solidity financial planning research contributions our team frequently asked questions demo: locating the parity multisig vulnerability detailed bios addendum why should concerned about smart contracts recent studies the dao and others addendum off-chain tools for developers smart debugging using discriminating examples important legal disclaimer the problem blockchain networks are secure but smart contracts are not. june hacker stole ethereum coins from the dao due bug its smart contract. july another hacker stole over ether from crypto companies due one word bug the smart contract code the parity multi-sig wallet. security issues like these are serious impediment wider adoption the ethereum network because they erode trust smart contracts. current efforts validate smart contracts are inadequate. engaging security consulting companies require human experts audit smart contracts. this process expensive and error-prone. also, relying single company requires trusting that bad actors exist the company. distributed system relying consensus among many different actors far more secure. security audit processes that rely human experts cannot keep with the exploding growth rate smart contract adoption. between june and october the number smart contracts grew from within year, expect there smart contracts. this will create exponential increase the demand for auditing. there aren't enough security experts the world audit all smart contracts today, and this shortage will even more acute the future. the potential costs smart contract failures will also grow. october about $.b eth) was locked smart contracts. the number dollars locked smart contracts will grow exponentially ethereum network and smart contract adoption grows. the potential cost smart contract vulnerabilities will grow commensurately. quantstamp protocol the quantstamp protocol solves the smart contract security problem creating scalable and cost-effective system audit all smart contracts the ethereum network. over time, expect every ethereum smart contract use the quantstamp protocol perform security audit because security essential. the protocol consists two parts: automated and upgradeable software verification system that checks solidity programs. the conflict-driven distributed sat solver requires large amount https://www.wired.com///-million-hack-just-showed-dao-human/ https://www.coindesk.com/-million-ether-reported-stolen-parity-wallet-breach/ https://web.archive.org/web//https://etherscan.io/accounts/c https://etherscan.io/accounts/c computing power, but will able catch increasingly sophisticated attacks over time. automated bounty payout system that rewards human participants for finding errors smart contracts. the purpose this system bridge the gap while moving towards the goal full automation. the quantstamp protocol relies distributed network participants mitigate the effects bad actors, provide the required computing power and provide governance. each participant uses quantstamp protocol (qsp) tokens pay for, receive, improve upon verification services. below are the different types participants. contributors receive qsp tokens invoice for contributing software for verifying solidity programs. all contributed code will open source that the community can have confidence its efficacy. most contributors will security experts. contributions are voted via the governance mechanism. validators receive qsp tokens for running the quantstamp validation node, specialized node the ethereum network. verifiers only need contribute computing resources and not need security expertise. bug finders receive qsp tokens bounty for submitting bugs which break smart contracts. contract creators pay qsp tokens get their smart contract verified. the number smart contracts grows exponentially, expect demand from contract creators grow commensurately. contract users will have access results the smart contract security audits. voters the governance system core feature the protocol. the validation smart contract designed modular and upgradeable based token holder voting (time-locked multi-sig). this governance mechanism reduces the chance upgrade forks and decentralizes influence the founding team over time. technology roadmap june quantstamp founded richard and steven july solidity static analyzer prototype built days after parity wallet hack august released first version whitepaper september hired ed, krishna, vajih, leo october completed request network semi-automated audit built automated truffle test generator complete semi-automated audit with another company november complete semi-automated audit with another company qsp token launch begin university partnerships with the university waterloo december build the quantstamp validation/payment smart contract ethereum complete the semi-automated audit january build the quantstamp validation node (an augmented ethereum node) february add analysis software the validation node that returns the proof-of-audit hash and raw output complete the semi-automated audit using analysis software march begin testing phase and improvement crypto-economic incentives implement token holder governance system for the upgradeable protocol april deploy test network after testing and validating system begin academic review the system may hold first quantstamp hackathon june begin work smart contract insurance with partners july hold token holder vote for mainnet after months testing/incentive adjustment august release mainnet september begin work distributed sat consensus with bft for mainnet october add smart contract insurance alpha product mainnet smart contracts motivation our team has devoted their careers helping developers produce more reliable code, representing years combined research and experience the discipline software verification. the opportunity apply these expertise towards the next generation the digital revolution extremely exciting for everyone involved. there clear and urgent need for more secure code. vulnerabilities smart contracts threaten the adoption blockchain technology and cryptocurrencies. currently lot work being done scale ethereum, however think security equally important. without security smart contracts, it's hard for people trust them with anything other than risk capital. our vision for the future that smart contracts will mainstream applications used people make their everyday lives easier. will help bring about this vision for smart contracts extending ethereum with technology that ensures the security smart contracts. believe that automated security audits will help developers deploy code that the public can trust without having write formal specifications that contain more lines code than the program itself. our aim automate checks and property verification much possible. each these objectives should contribute healthier blockchain ecosystem. this solution addresses infrastructural-level problem. our strategy create foundational protocol that could eventually incorporated directly into the ethereum platform and create safe environment needed for the first ethereum killer app. the remainder this document details why security protocol necessary technological advancement, and provides high-level architecture the platform. smart contract improvements how improve smart contract infrastructure the protocol allows automated security checks the smart contract code, and does trustless manner. our approach offers the following two core advantages. use the word "trustless" indicate that the process transparent and not necessary trust third-party, and deters bad actors from compromising the audit. the protocol allows end-users directly submit programs for verification, without the possibility bad actor manipulating the results audit imagine bad actor security auditing company that allows multi-million dollar bug slip through, and then takes advantage the live deployed contract. the consensus required the quantstamp protocol mitigates the effects bad actors based the economically dominant strategy would too costly try manipulate the results. verified smart contracts are produced with the proof-of-audit hash, which includes the version the security library used the verifier and plain-text report released based consensus. the future, plan offer smart contract insurance partnership with parties further mitigate risks using smart contracts. incentivize miners making the verification and certification smart contracts part the validation node software ethereum blockchain architecture, "miners" are participating entities that try add transactions the chain. the quantstamp protocol, miners are called verifiers. verifier needs run the validation node software which watches for updates the quantstamp validation smart contract. the fee for performing the service makes verifiers honest. verifier that certifies contract produces proof-of-audit hash and turn, the verifier awarded token fee. case verifier finds violation security goals contract, s/he produces counterexample that witness the violation and the escrow smart contract pays bounty fee the verifier. developers are responsible address vulnerabilities when they are found, but now, they can address before real stakes are involved. how improve the developer's process well-intentioned software developers need help produce better code. pointed out luu al., there semantic gap rooted misunderstanding how code executes the blockchain; consequently, there pressing need for better tools that can assist the developer capturing vulnerabilities prior deployment. the current way developers test code manually via open source code reviews and unit tests (if they are diligent) not sufficient meet the needs blockchain technology, which ideally offers perfect security. all the above methods are very manual methods that allow for human error. there need for easy process verifying smart contracts while minimizing the chance serious vulnerabilities slipping through the cracks. the quantstamp protocol provides this easy interface while also helping protect developer reputations proving the blockchain that they have performed this auditing. luu al. describe this semantic gap their paper "making smart contracts smarter." they propose enhance the operational semantics ethereum and offer symbolic execution tool called oyente find bugs smart contracts. pragmatically believe that very few developers, practice, will ever utilize such tools, just very few the ordinary practice software engineering. quantstamp, example suppose developer plans deploy smart contract written solidity ethereum. there substantial risk when writing code that accesses monetary system, and the developer must careful ensure that funds are lost due vulnerabilities. minimize risk, the developer submits his code for security audit via the quantstamp ethereum smart contract directly from his wallet, with the source code the data field, and sending qsp tokens. depending the security needs the program, the developer can decide how much bounty send. then, the smart contract receives the request, and the next ethereum block validation nodes perform set security checks validate the smart contract. upon consensus, the proof-of-audit and the report data are added the next ethereum block along with the appropriate token payout. the report classifies issues based severity system from minor warning, major vulnerability. from that point on, serious vulnerability not immediately detected, the bounty remains until the specified time has elapsed. the end the time period, the bounty returned the developer who requested the audit. when requesting audit, the developer chooses public private security report. private reports are encrypted using the public key the smart contract and can decrypted the owner/developer. the developer and the public can access web portal called qsscan.io review any security report. the portal parses the information the data field the transactions via the quantstamp smart contract, and displays it. using the proof-of-audit hash, security reports viewed the public exactly match the audited source code prevent manipulation report results. developer can perform security audits local machine prior issuing public audit, but may find that the computational overhead too high. quantstamp validator nodes are likely have greater computational capacity terms memory and processing cores than the average developer's machine. the same way, aggregating the power human hackers with large bounty, the project able greatly surpass the coverage standard code review. once the code ready for deployment, the developer ultimately motivated produce public security report order give users the reassurance that decentralized security audit was performed. when security report identifies issues found within smart contract, the developer can publicly annotate qsscan.io with feedback. this gives developers the power flag false-positives the report, and the community can validate the annotations. quantstamp does not guarantee flawless source code, but provides much higher degree assurance that the code secure using both automated and crowdsourcing methods. the quantstamp team commits continuously engage research and development, making regular improvements the security library. when there are new releases, developers can re-audit their smart contracts, demonstrating their commitment securing code and increasing public confidence. non-developers will have more confidence projects because they can see whether smart contract developers have audited their code, well which version was audited. technology the technology that performs security audits based cutting-edge research into verification algorithms and blockchain technology. the foundation the validator node being developed quantstamp, heavily modified ethereum node containing analytical toolkit that applies techniques from formal methods. kroning strichman offer algorithmic view formal methods decision procedures (springer, these techniques include: static analysis, concolic testing and symbolic execution, and automated reasoning tools such sat and smt. our team has contributed maplesat award-winning sat solver. validation protocol the validation protocol for security audits rewards participants who provide compute resources for the purpose running checks smart contracts. these checks are run validator nodes. the protocol ensures that the certification smart contracts part the "proof-of-audit." introducing ethereum intermediary escrow/governance smart contract, the system can ensure transaction security for computation fees. the receiving smart contract not verified the validator, the escrow will hold the transaction until the verification complete. the verification fails, the tokens are either automatically returned the sender held until the security violations are fixed. the quantstamp nodes are partners the ethereum network. ethereum handles the network and transaction protocols, whereas the quantstamp nodes handles the validation protocol for security audits and adds the data fields transactions. design the validation protocol handles both the distribution computation and consensus. this protocol specifies how nodes the network perform automated software verification and the bug bounty reward mechanism. the core value proposition our protocol that trustless and deters bad actors from manipulating audit results. also upgradeable via decentralized governance through qsp tokens. this how design the protocol achieve these goals. protocol governance plan for the quantstamp protocol upgradeable protocol with governance system controlled the qsp token holders. the governance system controls the update the validation smart contract and validation node. the validation smart contract designed modular and upgradeable. the governance system itself will added the smart contract after the core features are implemented, detailed the development roadmap. time-locked multisig used govern upgrades. the proposed approach, upgrade transaction can initiated any member, and the more approvals the transaction has, the sooner can executed. member can vote against upgrade, which will mean that will cancel out one the other approved signatures. upgrade that has been approved all members can executed after hour. the amount time required doubles for every members who don't vote and quadruples they vote against. governance critical feature since validators and contributors will want upgrade the protocol. governance mechanism decreases the chance upgrade forks, allows the protocol incorporate contributor updates and ensures consistency among users. the decentralized governance feature allows the community participate and decentralizes the influence the founding team over time contributors add the community. for example: validators would want vote change how workloads are distributed increase their earning potential. users would want vote incorporate higher-throughput algorithms that make the protocol faster. crypto-economic incentives prevent bad actors from manipulating the system, construct incentive system with strategy preventing rogue validator nodes from altering the audit results making too expensive mount attack. verifiers are incentivized via transaction fee qsp tokens and handle part the computation. the proposed protocol requires byzantine fault tolerance /rds. /rds consensus not reached, tokens are not paid out. reserve the right improve this design during the testing and validation stage. the following sections will explain the fault tolerance design more detail. adversarial attack versus distributed computation single bad actor cannot manipulate the network because the other actors, driven economic incentives, prevent the attack. distribute our computation, each actor receives only component the overall verification problem. for distributed computations, are currently considering using -masking quorum system, where two quorums intersect least servers. this quorum system can handle faulty system with least nodes. since single actor has access the whole verification process, bad actor further deterred via the distribution the computational process. prisoner's dilemma game theory, the prisoner's dilemma paradox which two individuals, acting their own self-interest, choose course action that does not lead the ideal outcome. both choose benefit themselves the expense the other, and both end worse state than they had cooperated. hypothetically, verifier who finds bug could choose not take the bounty and exploit for future gains. our economic incentives, however, drive verifiers pursue the bounty instead attempting exploit bug. the verifier that attempts exploit bug instead reporting has assume that other verifier will discover the same bug, report it, and have the bug fixed. since the number un- coordinated verifiers large, very likely that some other verifier will find the bug and for the bounty. thus, verifier who pursues actions based self-interest driven claim the bounty, design. security audit engine the security audit engine takes unverified smart contract input, performs the automated security and vulnerability checks, and produces report. verification results will combined with proof-of-audit hash with version code used track the scope checks from that version the security library. the time taken run the full tests the security library scales with the complexity the smart contract code; therefore, verification rewards are proportional computation time. verifiers require incentivization motivate participation this effort, and token issued for users access its features. the increased confidence the public gains when knowing that smart contract was verified transparently consensus will motivate developers use these features. overall confidence will buoyed the efforts bounty hunters who attempt find critical flaws. furthermore, new vulnerabilities are discovered, the security library will evolve and new versions will released. users will then motivated re-verify their smart contracts using the latest version the security library, ensuring that their code not open attack due newly discovered vulnerabilities. this similar how users software can download patches fix security vulnerabilities, how users can update their antivirus application. architectural view the quantstamp protocol (qsp) scalable system audit all smart contract projects ethereum. our vision for the quantstamp security protocol that will become part the ethereum protocol. the qsp split into three conceptual categories: quantstamp validator smart contract for ethereum quantstamp network (qn) composed heavily-modified ethereum nodes quantstamp reports (data carried the smart contract transactions) the network verifier nodes that generates security reports consensus. utility, the qsp platform-agnostic there can many variations the security library, one which includes solidity (for ethereum), and variants that may cover other smart contract languages for different platforms. quantstamp validation smart contract for ethereum the following list functions are accessible the end-user. register() users can register ethereum address, which alerts the quantstamp network monitor api calls the registered address. audit() user can submit source code for security audit along with token bounty fee. upon success, the smart contract digitally signed prove that passes critical security checks. this point, encrypted security report made available. the bug bounty remains the contract incentivize bug finders until the specified time limit runs out. upgrade() upgrade existing smart contract. the new version the smart contract must pass security audit. existing bounties are rolled forward. quantstamp network for ethereum the quantstamp network (qn) specialized protocol capable monitoring transactions related registered smart contract involving calls the quantstamp validation smart contract. quantstamp reports quantstamp reports provide public view the security audits performed the qn. these reports will made visible via web-based user-interface qsscan.io reports can public private. public reports are visible everyone human-readable form. private reports are encrypted using the public key the registered user. only the registered user can read the contents the report. once smart contract deployed, the final security report the smart contract public. this allows investors and other users review the report before committing their funds. smart contract owners are encouraged annotate the security report. owners are encouraged indicate response all issued security warnings and flagged issues. the response may simple "this false positive" "we are not concerned about this issue," may highly detailed. the onus the owner provide much information possible anyone who may want read the security report order increase the level trust. "trust score" will computed for each smart contract based upon combination the findings the security report, the size the bounty, the length time the bounty has been active and feedback from the community. tradecraft real world practice, peer reviewing and unit testing are the major software verification techniques use. while peer review effective approach, still prone human error, and manual testing always limited coverage and scope. software verification using automated reasoning tools can help close the gap. although research into automated reasoning tools started several decades ago, their practical importance has progressed rapidly the last few years. the security audit engine builds upon tradecraft tools and techniques founded upon the study discrete mathematics, logic and computer science. interacts with the security library, which provides access security checks (to performed) and properties (to verified). summarize the tradecraft that supports the security audit engine below. computer-aided reasoning tools computer-aided reasoning tools, such sat/smt solvers (below), have had dramatic impact software engineering and security recent years. the key reason for the adoption solvers software engineering the continuous improvement their performance and expressive power. sat solvers sat (satisfiability) solvers support software verification tools. computer programs are modeled boolean formulas, which are passed the solver. when modeling program behaviour and testing for particular conditions, boolean formula can constructed such that the existence satisfying assignment signifies the presence bug. sat solver reports "satisfiable" can find solution or, none exists, reports "unsatisfiable." sat-solvers are important tools several areas software engineering, including software verification, program analysis, program synthesis and automatic testing. additional applications span variety problem domains that include electronic design automation, computer-aided design and others. sat-solvers are surprisingly efficient, combining decision heuristics, deductive reasoning and various experimentally validated techniques. smt solvers smt solver tool that decides satisfiability formulas combination various first-order theories. generalization sat solver and can handle richer theories than propositional logic. common first-order theories, which can model fragments computer code for vulnerability analysis, include equality, bit vectors, arrays, rationals, integers, and difference logic. this very active research area, and there are many applications: software verification, programming languages, test case generation, planning and scheduling, and more. well known smt solvers include yices (sri), (microsoft), cvc (nyu, iowa), stp (stanford), mathsat (u. trento, italy), barcelogic (catalonia, spain). model-checking model checking based abstracting the behavior code unambiguous manner, which often leads the discovery inconsistencies. this technique explores all possible system states brute-force manner. contrast model-checking, bounded model-checking (bmc) technique for verifying that given property (typically expressed assertion user) holds for program the number loop iterations and recursive calls bounded given number placing bound the size the execution path for finding bug. this problem can reduced solving the boolean satisfiability problem using sat-solvers. the utility bounded model-checking part supported the small-scope hypothesis this hypothesis states that most bugs have small counterexamples, and has proven effective idea for finding bugs software models. this hypothesis the basis for so-called lightweight formal methods. static program analysis static analysis determines properties program without actually executing the program. automated tools can assist programmers and developers carrying out static analysis. static analysis has been used find potential null pointer bugs and verify that device drivers always respect api usage requirements. symbolic execution and concolic testing concolic testing hybrid software verification technique that performs symbolic execution, classical technique that treats program variables symbolic variables along concrete execution path. symbolic execution used with automated theorem prover generate new test cases. its main focus finding bugs rather than proving correctness. incremental releases and the subscription model software releases for the security library will have critical, major and minor update version tags. when developers deploy code, they have the ability flag the contract for re-verification upon each critical/major/minor release subscription payment model. for very financially sensitive contracts, developers can choose re-verification all releases. for less sensitive contracts, they can choose re-verification only critical releases. when developers flag the contract for verification, and subsequent verification fails, they will notified the network and can take immediate action. the market price the token transaction fee essential component the platform that will balance computational resource supply and recurring demand. because the market price the token free-floating, decentralized verifier nodes are incentivized market forces dynamically bring additional resources meet demand. developer can choose not subscribe because they are confident their application and not want pay subscription fees, but have critical vulnerability the code that only uncovered later date new release. there possibility that vulnerabilities may discovered later date contracts that have already been deployed the network with earlier version the security library. bug finders open source software, developers are often unrewarded for finding bugs. recently, emin gun sirer found two critical vulnerabilities bitgo while vacation, and wrote friendly email alert them. common experience among security developers, received thankless reply and later was actually snubbed the bitgo cto. the automated bounty reward payout qsp tokens will allow skilled developers submit bugs the validator contracts and earn immediate rewards and public recognition without all the back-and-forth with companies. bounties qsp tokens are submitted when the source code sent the quantstamp validator smart contract and then held escrow. bug finders can use any means their disposal break the code, and smart contract found have major vulnerabilities, then the verifier awarded the bug bounty that was held escrow. validator nodes have run validation software that can verify the submitted bug. believe that will possible for skilled developers earn income purely via bug finding, manually searching for security flaws public smart contracts our platform. financially sensitive contracts worth millions dollars, should theory have bouty contracts worth least tens thousands dollars before being deployed live. this will increase the security our platform and also incentivize more security experts spend time the ecosystem and develop their skills. security disclosure strategy attackers might choose leverage the security library tool for finding vulnerabilities existing smart contracts. any detected vulnerabilities could then used starting point for planning attack. not our intention facilitate the efforts attackers, matter how unlikely that they would succeed. theory, this unfortunate scenario could avoided from the start all deployed smart contracts were pre-audited the qsp without ever providing attackers with access the complete security library. for this reason, will take the following actions: will implement staging period during the library release process, during which time will generate encrypted security reports that smart contract owners can access. will publish public statistics indicating the frequency with which critical issues are present smart contracts with the hope motivating smart contract owners read security reports and take appropriate actions. http://hackingdistributed.com////parity-wallet-not-alone/ avoid giving clues would-be attackers, will ensure that the existence report will not indicative the existence vulnerability, nor will characteristics the encrypted report, such its size, offer any reliable clues. whenever new version the security library released, there may window time which previously audited smart contracts have newly detectable vulnerabilities. this again, could give attacker the opportunity use the security library starting point for planning attack, even that window opportunity relatively small. this secondary purpose the independent verifier system leveraging human intelligence with bounties, can bridge the gap between inadequate automated checking and the converse sophisticated automated attacks. distributed and parallel sat software verification offers many benefits: better code, better testing, less hacks, and effective way improve software security. the sat solver important tool this effort. this section, offer cursory discussion sat and parallel sat. the quantstamp network offers fascinating and exciting opportunity for the domain sat. quantstamp building new kind distributed sat solver where consensus and redundancy are built-in, and participants are incentivized solve all varieties sat problems their quest claim tokens and certify contracts. the application this technology smart contracts particularly exciting because there much stake. the satisfiability problem (sat) problem instance sat consists boolean formula variables. sat-solver determines the existence non-existence satisfying variable assignment; other words, assignment either true false each variable such that the formula itself true most solvers require that specified conjunctive normal form (cnf), wherein the formula consists conjunction clauses, each consisting disjunction literals. the typical sat-solver engages the following three step workflow from high-level encoding the problem through the actual solving procedure. encoder encodes the problem boolean formula conjunctive normal form (cnf) such that satisfying assignment indicates property violation the conversion arbitrary boolean formula cnf can carried out linear time with respect the number formula variables using tseitin's translation draw upon norbert manthey's excellent phd dissertation, "towards next generation sequential and parallel sat solvers" found here: http://www.cs.sfu.ca/~mitchell/cmpt-/-fall/projects/parallel-manthey-phd.pdf usually polynomial time complexity requires less than total time preprocessor often performs simplification and re-encoding polynomial time complexity requires about the total time solving procedure conflict-driven clause learning (cdcl) variable ordering and other heuristics exponential time complexity the size the input requires about the total time the solving procedure the most challenging, requiring the computational effort and whose time complexity exponential the worst case. many strategies have been developed for solving sat formulas, but the most widely adopted and successful solvers are based the davis-putnam-logemann-loveland (dpll) algorithm. when combined with clause learning and clever implementation tricks, dpll- sat has enabled the practical use sat-solvers for wide-range applications, reflecting the importance sat central problem computer science. overview dpll-sat depicted below. the decide module carries out decisions, guided vsids variable-ordering heuristic). the bcp module carries out unit propagation until either new unit facts can derived, conflicting (unsat) clause identified. such clauses are handed over analyze conflict, which traces the reason for the clause becoming unsatisfied, and generates "learnt" clause that added the clause database. learnt clauses prevent the propagation assignments that lead kroning strichman offer architectural view sat ecision procedures (springer, the conflict. the backtrack module rewinds the search earlier state, undoing the assignments that lead the conflict. the formula said unsat upon identifying top-level conflict clause, sat when new decisions can made and all clauses are satisfied the current set assignments. parallel sat solvers techniques such model checking and automated theorem proving, which typically rely sat-solvers, may require anywhere from milliseconds hours computing effort commodity machines. for some the hardest problems, solving time can extend days, weeks, longer. recent advancements algorithms, heuristics, and parallel solvers are helping. solvers who share the workload can outperform those who don't. parallel sat solvers attempt use more cores overcome sequential slowdowns. typical parallel sat-solver use master-slave (or task farm) approach, splitting the search space and analyzing the subspaces parallel separate processes. prime example this approach parallel minisat (pmsat). pmsat distributed parallel sat-solver, implemented c++ using the message passing interface (mpi) for communication between nodes. pmsat novel the following ways: how partitions the search space terms variable selection and assumptions generation; how assumptions are pruned; how learnt clauses are shared; and automatic settings. master controls the scheduling the clients and distributes various tasks between them. more than one partitioning heuristic available the user, and sharing learnt clauses allowed. conflict-learning used prune the outstanding tasks and potentially stop processes whose search space irrelevant. two choices are available for variable selection: frequent variables, variables that appear bigger clauses. the task farm approach used with master and several workers. worker receives set assumptions from the master, and returns the result searching its subtree. the master partitions the workspace according configured mode operation. when worker finds unsat, may send vector learnt clauses and/or vector conflicts, the latter which used the master remove all untested assumptions that will lead unsat. after receiving unsat, the master sends another set assumptions, possibly with learnt clauses, the idle worker. upon receiving sat, the master ends execution. the vector conflicts sent directly the master the result message, with array size (multiple messages can sent, needed). typically, more assumptions are created than there are available workers, which accounts for workers that end early that they can get busy right away. another kind parallel sat-solver adopts portfolio approach; i.e. relies running multiple solvers the same sat instance parallel. this technique the state-of-the-art luis gil, paulo flores, and luis miguel silveira. pmsat: parallel version minisat journal satisfiability, boolean modeling and computation, :-, parallel sat solvers, which presently dominated manysat. with manysat, has been found that using different search heuristics, even different sat solvers, has lead large gains performance. performance gains have also been observed sharing learnt clauses among the different solver instances. aigner al. discuss plain parallel portfolio (ppp) solver that synchronizes termination, but otherwise does not share any information. their multi-core implementation uses shared memory, and asks the question: does memory shared resource become bottleneck? so, how much slowdown occurs? performance degradation due congestion the memory system seen upper bound the expected slowdown for portfolio systems. portfolio solvers like manysat and plingeling have architecture which the original formula and shared clauses are copied each solver, simplifying the design and minimizing synchronization overhead. solvers that attempt parallelize more fine-grained level not scale well. the drawback that neither the formula nor learnt clauses are physically shared and thus times more memory needed, and might expected that there would more memory system congestion causing slowdown; however, experiments demonstrate that most memory access are local (satisfied core-local caches), which keeps the slowdown low even for large number solvers running parallel. parallel sat and consensus noted previously regarding quantstamp's validation protocol, the distributed computation partitioned into components the overall verification problem. this important mechanism for inhibiting bad actors. relating this back sat the distributed setting, search space partitioning, each partition, subspace, solved sequential sat-solver. the quantstamp network, when possible, disjoint subspaces are mapped partitions nodes called zones within each zone, nodes work find satisfying assignment within discrete subspace. since the partitions are disjoint, identifying satisfying assignment one zone implies satisfying assignment for the original formula. the encoding process step one ensures that when formula satisfiable, then bug exists the original system. the final output zone requires /rds consensus the participating partition, just /rds majority required for consensus general. common vulnerabilities for ethereum/solidity the blockchain implementation nick szabo's idea smart contract computer program whose correct execution enforced without relying trusted authority. the ethereum youssef hamadi, said jabbour, and lakhdar sais. manysat: parallel sat solver journal satisfiability, boolean modeling and computation, :-, martin aigner, armin biere, christoph kirsch, aina niemetz, and mathias preiner. nalysis portfolio style parallel sat solving current multi-core architectures proceeding the fourth international workshop pragmatics sat (pos). citeseer, formalizing and securing relationships public networks: http://firstmonday.org/ojs/index.php/fm/article/view// protocol supports stateful contracts, meaning that the values state variables persist across multiple invocations. contract invoked when receives transactions from users its unique address. such transactions are accepted the blockchain, all participants the mining network execute the contract code. the network then agrees, the consensus protocol, the output and next state the contract. given that ethereum smart contracts are immutable and the effects the transactions cannot reversed, essential able reason effectively about code prior deployment. atzei al. describe taxonomy vulnerabilities and unexpected behaviours smart contracts written solidity for ethereum. although this taxonomy specific ethereum, likely that similar vulnerabilities will exist for other platforms that use contracts the future. summarize this taxonomy below based their findings. call the unknown some solidity primitives have the non-obvious side effect invoking the fallback function the recipient. this can lead unexpected behaviour and may exploitable attacker. (we discuss this the section the parity/multisig vulnerability.) exception disorder the are two different behaviours for how exceptions are handled that depend how contracts call each other. for some, side effects the whole transaction are reverted; for others, only the side effects the invocation another smart contract are reverted. these irregularities can affect the security contracts. gasless send when user sends ether contract, possible incur out gas exception. type casts the compiler can some type-checking, but there are circumstances where types are not checked which can lead unexpected behaviour. reentrancy the fallback mechanism may allow non-recursive function re-entered before its termination, which could lead loops invocations that consume all gas. (the "dao attack" infamously exploited this vulnerability.) keeping secrets declaring field private does not guarantee its secrecy because nicola atzei, massimo bartoletti, and tiziana cimoli. survey attacks ethereum smart contracts sok proceedings the international conference principles security and trust volume matteo maffei and mark ryan (eds.), vol. springer-verlag new york, inc., new york, ny, usa, doi: https://doi.org/./----_ the blockchain public and the contents transaction are inspectable. cryptographic techniques may need employed protect secrets. immutable bugs deployed contracts cannot altered, including when they have bugs, and there direct way patch it. (an exception this occurred after the dao attack when controversial hard fork the blockchain nullified the effects transactions involved the attack.) ether lost transfer ether sent orphaned addresses lost forever, and there way detect when address orphan. stack size limit the call stack bounded frames and further invocation triggers exception. hard fork the ethereum blockchain october has addressed this vulnerability.) unpredictable state the state contract upon sending transaction the network not guaranteed the state the contract when actually executes. additionally, miners are not required preserve the order transactions when grouping them into block. attackers can exploit this "transaction-order dependence" vulnerability. generating randomness malicious miner can craft his block bias the outcome pseudo-random generator number his favor. for example, this could advantageous for lotteries, games, etc. time constraints many applications use time constraints determine which actions are permitted the current state. miner holds stake contract, could gain advantage choosing suitable timestamp for block mining. below are sample checks that would implemented the security library for solidity. constant functions the compiler does not enforce that constant method not modifying state; instead, this should enforced. contracts that receive ether directly contracts that receive ether directly need implement fallback function order receive ether, otherwise the function throws exception and sends back the ether. there can alert when the fallback function not implemented, since there are situations where the programmer would want this. fallback function contract can have exactly one fallback function, and cannot spend more than gas. can automatically test that the programmer spending less than gas inside that fallback function. reentrancy exploit when calling another contract, the called contract can change state variables the calling contract via its functions. it's possible check that calls external functions happen after changes state variables the current contract that not vulnerable reentrancy exploit. https://gist.github.com/chriseth/cafcdfcddfddeaaaf implicit declaration variable declared anywhere within function will scope for the entire function, regardless where declared. also initialized default value for the entire scope the function. possible that poorly written code can access implicitly declared variable with default value. when this happens, our report would generate alert. transaction owner when checking tx.origin, gets the original address that kicked off the transaction. malicious actor can use attack wallet drain all funds the smart contract code required tx.origin owner, since this case tx.origin would the address the attack wallet. gas forwarding there extremely dangerous feature called addr.call.value(x)() that can forward gas receiving contract and opens the ability perform more expensive actions. this problem that needs explored more in-depth later. financial planning research contributions our team the following table comprises partial selection software verification projects connected our combined research efforts. when necessary, will adapt these proven techniques towards achieving our goal securing smart contracts the blockchain. name contributors (alphabetical order) description alloy and the alloy analyzer vajih montaghami derek rayside steven stewart alloy relational logic that enables developers model and reason about software abstractions. the alloy analyzer capable mechanically generating examples user's model. was originally developed mit part the software design group under the guidance dr. daniel jackson. http://alloy.mit.edu/alloy/ bordeaux derek rayside bordeaux technique and extension alloy for producing near-border examples, important capability for improving debugging for identifying partial over-constraint bugs software models. https://github.com/drayside/bordeaux clafer zulkoski clafer general-purpose lightweight modeling language developed gsd lab, university waterloo and models group university copenhagen. lightweight modeling aims improving the understanding the problem domain the early stages software development and determining the requirements with fewer defects. clafer's goal make modeling more accessible wider range users and domains. http://www.clafer.org/ margaux derek rayside vajih montaghami margaux tool for pattern-based debugging that can guide user find bug. the github page includes architectural diagram for how debugger using discriminating examples can guide developers towards correcting flaws logical reasoning. https://github.com/vmontagh/margaux maplesat vijay ganesh the award-winning maple series are family maplecomsps mapleglucose zulkoski conflict-driven clause-learning sat solvers developed the university waterloo under the supervision dr. vijay ganesh. https://sites.google.com/a/gsd.uwaterloo.ca/mapl esat/ mathcheck vijay ganesh zulkoski constraint programming system that combines sat solvers with computer-algebra systems. extended known results two conjectures related hypercubes. https://sites.google.com/site/uwmathcheck/ miramichi derek rayside steven stewart miramichi experimental parallel sat-solver that leverages gpus for performance acceleration. https://bitbucket.org/sstewart/miramichij moolloy derek rayside steven stewart moolloy extension relational logic for expressing discrete multiobjective optimization problems, with applications science, software engineering, and finance. https://github.com/teamamalgam/moolloy petitcodiac derek rayside steven stewart petitcodiac experimental solver for quantifier-free linear real arithmetic (lra) that leverages openmp and gpus. smt-solvers, such yices and microsoft's typically use variation the simplex procedure also employed petitcodiac. https://github.com/sstewart/peticodiac stp vijay ganesh stp constraint solver (or smt solver) aimed solving constraints bitvectors and arrays. these types constraints can generated program analysis tools, theorem provers, automated bug finders, cryptographic attack tools, intelligent fuzzers, model checkers, and many other applications. https://github.com/stp/stp demo: locating the parity multisig vulnerability provide demonstration generalizable technique for automatically locating vulnerabilities similar the parity multisig wallet flaw that lead million theft. this simple analyzer constructs multiple ast (abstract syntax tree) visitors and uses these extract the program variables and call structure solidity contract. the analyser finds any public method that directly indirectly exposes non-public state variable modification, and alerts the developer. using call-graphs can capture class vulnerabilities that can located solutions reachability problems. this demo, have two example solidity contracts show how the analyser identifies direct and indirect vulnerability. github code for the demo: https://github.com/quantstamp/solidity-analyzer https://en.wikipedia.org/wiki/reachability frequently asked questions what quantstamp? quantstamp security verification protocol for smart contracts that improves the security ethereum. the advantages the security protocol include automation, trust, governance, and ability compute hard problems over distributed network. what the quantstamp team going deliver? the quantstamp team will developing the following: quantstamp validation node heavily modified ethereum client) the security ibrary, containing code that performs automated checks validation smart contracts that handle bounty payment, voting mechanism and governance security library may also developed support languages other than solidity. aren't human security audits and code reviews the state-of-the-art? writing correct, bug-free software very difficult. (every seasoned developer eventually comes around this conclusion.) one member our team noted, anecdotally, that previous software company, the backlog bugs was the hundreds, and the project manager was constantly juggling list features and bugs work every -week sprint, struggling make any significant progress. spite abundance bugs, customers expressed satisfaction about the product and mainly only reacted strongly when "show-stoppers" were uncovered. unfortunately, once you give programmers access monetary system via smart contracts, just about any bug can show-stopper. improve software, most developers believe that they merely need conduct more code reviews and write more unit tests, but the cost/benefit calculation seldom favours increased testing. although reliance unit testing and code reviews may acceptable for low-risk applications, not acceptable when writing code for critical systems. instead, computer chip manufacturers, airplane and automobile manufacturers, and many others rely automated software verification complement other best-practices. for similar reasons, our approach take advantage the years research that have developed these sophisticated techniques. can really trust computer find vulnerabilities better than human can his own? while true that unit testing and code reviews long ways towards improving the quality software, has been shown that techniques based formal methods are better finding the most subtle and critical bugs that evade human inspection. this true, large part, because the ability automated reasoning tools simulate critical execution paths manner that well exceeds the limitations human cognition. another way look this consider what has transpired recent years algorithmic trading. for years, was believed that humans were better trading than computers, until eventually the computers took over. with quick online search for "computers have taken over wall street," you'll find numerous articles this phenomenon. perhaps, not surprisingly, something similar already underway with automated security audits: maybe, when start, cannot match experienced human except the cost/speed tradeoff, but with each new release the automated solution will able catch more and more security issues transparent way until eventually the algorithms will beat humans. the meantime, leverage human intelligence via automated bounty for bugs that are found independent verifiers (white hat hackers). why build security auditing protocol? instead, why not form security consulting company? scalability handle the millions smart contracts audits the ethereum platform once they have resolved the ethereum transaction scaling issues via plasma/casper/pos. empowering the first ethereum killer app. why not use why similar tool for formal verification instead? existing projects such why are too inaccessible for the typical smart contract developer use. similar argument can made about the adoption alternative programming paradigms, such functional programming (ocaml, haskell, clojure), where there ends being lot hype and promise but, upon closer inspection, not lot adoption actual developers, who still prefer java, c#, c++, and python. for all these reasons and more, quantstamp automates much the security auditing process possible embedding into the ethereum network with our client nodes, and relieving the developer from having learn specialized techniques. the quants are taking over wall street: https://www.forbes.com/sites/nathanvardi////the-quants-are-taking-over-wall-street/ detailed bios co-founders steven stewart university waterloo ece, software verification steven phd candidate the university waterloo (ece) where, under derek rayside and krzysztof czarnecki, focuses improving the performance software verification tools and solvers using distributed computing and gpus. previously, steven co-founded san francisco-based startup called many trees inc that used gpus for machine learning and big data analytics. his spare time, likes tinkering with in-memory databases accelerated using gpus. spent nearly years part canada's cryptologic agency the department national defense. dropped out phd work quantstamp. richard cornell ece, algorithmic portfolio manager algorithmic portfolio manager bitcoin hft fund. ex-tower research capital quant strategist. programmed production algorithmic trading software c++/python/r competitive us, european, and asian derivatives exchanges. wrote tens thousands unit tests and built production-grade integration and validation testing software. due richard's extreme testing and risk-management methodology, his hft trading systems had zero notable incidents nearly decade reliably handling millions dollars investor capital. founding team members dr. vajih montaghami phd formal methods vajih montaghami received his phd from the university waterloo for his work verifying and debugging lightweight formal models. focused declarative software model formal analysis, programming language static analysis, imperative code systemization, and software architecture analysis and evaluation. during his phd study, worked google and experienced dealing with large-scale data analysis systems. worked automating end-to-end testing machine learning algorithm applied massive data source. more recently, amazon, vajih helped develop highly scalable systems backend software engineer. zulkoski b.s., mathematics and computer science edward zulkoski ph.d. candidate the department computer science the university waterloo under the supervision vijay ganesh and krzysztof czarnecki. recently completed internship microsoft research under the direction dr. christopher wintersteiger. his phd research focused studying and exploiting the structural properties sat and smt formulas. his earlier work investigated combinations sat solvers with computer algebra systems, and optimization techniques for multi-objective product line optimization. was awarded ph.d. fellowship from ibm canada's centers for advanced studies research. advisors dr. vijay ganesh assistant professor, university waterloo dr. vijay ganesh assistant professor the university waterloo. prior that, was research scientist mit, and completed his phd computer science from stanford university vijay's primary area research the theory and practice automated reasoning aimed software engineering, formal methods, security, and mathematics. vijay has won numerous awards, most recently the acm test time award ccs the early researcher award outstanding paper award acsac ibm research faculty award two google research faculty awards and and ten-year most influential paper award date total, has won best paper awards/honors. dr. derek rayside eng, associate professor, university waterloo derek rayside associate professor electrical computer engineering the university waterloo. his primary research areas are lightweight formal methods and program analysis. received his doctorate computer science mit. derek advisor waterloo startup that was recently acquired microsoft. addendum why should concerned about smart contracts there increasing evidence that troubling percentage, perhaps greater than percent, ethereum smart contracts are vulnerable. would difficult conclude that the remaining smart contracts are safe because they may contain yet unidentified vulnerabilities. this not knock ethereum, reasonable assume that any platform that enables the execution arbitrary code that accesses the monetary system serious risk. the onus clearly the developer "get right." the dao and others code law. they say. june what now referred the dao has since become synonymous with perhaps one the greatest would-be heists modern times. the tune million, ether thief discovered bug smart contract that allowed repeated atm-like withdrawals. there was eject button, and once smart contract deployed, there's turning back. the attacker's delight, smart contracts are immutable and publically available for the unscrupulous study and exploit. date losses description june million the dao exploit perhaps the best-known. non-recursive function could re-entered before termination, leading loops invocations that consume all gas. the unhandled exception meant that repeated withdrawals were possible the calling function. june million vulnerability parity's multisignature wallet was exploited hackers. this case, some solidity primitives have the non-obvious side effect invoking the fallback function the recipient. this can lead unexpected behaviour and may exploitable attacker. july there was error the smart contract the rex token sale. specifically, when generating the contract bytes for deployment, mistake was made defining the constructor million https://www.multichain.com/blog///smart-contracts-the-dao-implosion/ https://www.cnbc.com////-million-worth-of-digital-currency-ether-stolen-by-hackers.html https://blog.rexmls.com/the-solution-aeddbdaad parameters. instead quoted string for address, javascript hex string was used. although this was not theft attacker, was preventable loss. course, what followed was the (in)famous and controversial ethereum hard fork, intended correct the apparent wrong-doing the attacker. perhaps, the outsider, it's surprising that the hard fork would controversial; after all, who could condone the actions the world's greatest thief? but, therein lies the problem: if, fact, code law, then should not respected for how was written? although the developer the smart contract undoubtedly did not intend offer atm service, the code itself, written, most certainly did permit this behaviour. code law, then the code and the law permitted the theft and there was wrongdoing. whatever your thoughts are the code law question, our view one thing certain: never assume that smart contract safe. long code has access monetary system, and long human beings want make money, then code ever truly safe. all can really minimize the risk, and even better when can provably eliminate certain types vulnerabilities that are well-known exploitable and damaging. while true that there does not exist any fully automated solution that can, without shadow doubt, catch all possible bugs computer program, can confidently state that the risk can greatly minimized. fact, one could argue that any bug worth finding will tend found, and those that are not will tend not matter. still, were there only one incident however damaging was then perhaps our worries would out proportion. the occasional theft could absorbed kind nuisance tax, and not necessarily perceived catastrophe. (ho hum another theft. happens.) unfortunately, there such thing bug insurance (not yet) and faulty code, when surfaces, can indeed catastrophic. beyond that, it's simply impractical for there hard fork whenever there theft. course, finding bug isn't easy. even the bug could self-identify, would difficult for automated solution absolutely certain without somehow understanding the original intentions behind the code. sometimes what looks like bug actually feature! what can do? our response: learn and keep learning. identify patterns and classes vulnerabilities. use established techniques and improve them when necessary. wrap this all and make part security library whose outputs are verified decentralized consensus. incentivize contributors, and harness both the power white and black hat hackers assist the effort. reward them when they succeed. keep developers accountable. recent studies the full extent which security vulnerabilities plague smart contracts unknown; however, recent studies make abundantly clear that there really plague below, summarize short selection research papers that characterize some the most serious vulnerabilities, some which highlight just how easy for developers unknowingly make mistakes. making smart contracts smarter loi luu, duc-hiep chu, hrishi olickel, prateek saxena, and aquinas hobor. making smart contracts smarter proceedings the acm sigsac conference computer and communications security (ccs '). acm, new york, ny, usa, doi: https://doi.org/./. both malicious miners and users can exploit certain classes vulnerabilities that the authors deem due "semantic gap" between how the developer thinks code executes versus how actually does. their study, out (%) ethereum smart contracts contained "semantic gap" vulnerabilities, involving total balance over million eth. formal verification smart contracts: short the authors translate solidity analyze paper evm bytecode. they perform checks capture whether the code undoes side effects karthikeyan bhargavan, antoine delignat-lavaud, cedric that can persist when call send() fails, fournet, anitha gollamudi, georges gonthier, nadim kobeissi, natalia kulatova, aseem rastogi, thomas and also detect the reentrancy problem sibut-pinote, nikhil swamy, and santiago zanella-beguelin. that plagued the dao. formal verification smart contracts: short paper proceedings the acm workshop programming languages and analysis for security (plas '). acm, new york, ny, usa, doi: https://doi.org/./. demystifying incentives the consensus computer loi luu, jason teutsch, raghav kulkarni, and prateek saxena. demystifying incentives the consensus computer proceedings the acm sigsac conference computer and communications security (ccs '). acm, new york, ny, usa, doi: https://doi.org/./. the limitations their tool restrict analysis only smart contracts; however, the authors state that those only handful passed their checks, suggesting that large-scale analysis published contracts would likely uncover widespread vulnerabilities." the authors show that turing-complete scripting exposes miners new class attacks: "honest miners are vulnerable attacks cryptocurrencies where verifying transactions per block requires significant computational resources." address this problem, they propose incentive structure the consensus protocol where cheating provides intrinsic advantage. survey attacks ethereum smart the authors present taxonomy security precise, the value eth -july- about billion usd. contracts nicola atzei, massimo bartoletti, and tiziana cimoli. survey attacks ethereum smart contracts proceedings the international conference principles security and trust volume matteo maffei and mark ryan (eds.), vol. springer-verlag new york, inc., new york, ny, usa, doi: https://doi.org/./----_ vulnerabilities observed across the corpus ethereum smart contracts. general, these vulnerabilities emerge due subtleties solidity that are unknown misunderstood developers. step step towards creating safe smart the authors show how even very simple contract contract for playing rock, paper, scissors can contain several logical flaws. these are delmolino al. step step towards creating safe smart characterized contracts that not contract: lessons and insights from cryptocurrency lab cryptology eprint archive, report refund lack cryptography achieve http://eprint.iacr.org/ fairness incentive misalignment safer smart contracts through type-driven three classes errors are highlighted that are common smart contracts: unexpected development pettersson and edstrom. safer smart contracts through type-driven development: using dependent and polymorphic types for safer development smart contracts masters thesis computer science, chalmers university technology gothenburg, sweden, states failure use cryptography and full call stack the authors propose using dependent and polymorphic types and functional language called idris make smart contract development safer. while the above papers are only sample, noteworthy percentage smart contracts reportedly have known vulnerabilities. our perspective that possible prevent many these performing automated checks and formally verifying expected properties. while likely that some attackers will focus their efforts high profile, opportunistic heists large magnitude, many others will content with multiple smaller grabs less likely garner much attention. everybody risk. addendum off-chain tools for developers addition the decentralized security platform, are interested developing set off-chain tools aimed simplifying the development, debugging, and deployment smart contracts. this includes the application recent work one our team members into creating smarter debugging tools. smart debugging using discriminating examples software models with mathematical logical foundations have proven valuable software engineering practice enabling software engineers focus essential abstractions, while eliding less important details their software design. like any human-created artifact, model might have imperfections certain stages the design process: might have internal inconsistencies, might not properly express the engineer's design intentions. introduce the idea smart debugger that helps non-expert developer find flaws and vulnerabilities based the proven localization, understanding, and fix strategy. this work explored depth the dissertation debugging relational declarative models with discriminating examples founding team member vajih montaghami and phd supervisor dr. derek rayside (university waterloo). the need debug arises because the expressed meaning differs from the intended meaning, but the user does not know where why. debugging can cumbersome and time-consuming task that persists throughout the software lifecycle. zeller, his seminal book debugging imperative programs, evokes inspiring image: some people are true debugging gurus they look the code and point their finger the screen and tell you: "did you try x?" you try and voila!, the failure gone. what has the debugging guru done? they have identified, localized, and corrected the bug, and they have done this first forming hypothesis. recently, tools and techniques have been developed provide some automated support for this vision the context relational logic models for software abstractions. two such tools are called bordeaux and margaux (depicted the architectural diagram below). these tools first help the user identify and understand the bug forming hypothesis about what might wrong with the model and computing discriminating example for the user accept reject. the user judges that bug has been identified, then further automated analysis helps localize zeller. why programs fail: guide systematic debugging. morgan kaufmann, ko, abraham, beckwith, blackwell, burnett, erwig, scaffidi, lawrance, lieberman, myers, rosson, rothermel, shaw, and wiedenbeck. the state the art end-user software engineering. acm computing surveys, ()::-:, apr. and krems. expert strategies debugging: experimental results and computational model. cognition and computer programming, pages ablex publishing corp., which part the model needs change, and might provide high-level conceptual description the correction (but the user still needs make the correction hand). examples, like test-cases for programs, are more valuable they reveal discrepancy between the expressed model and the engineer's design intentions. propose the idea discriminating examples for this purpose. discriminating example synthesized from combination the engineer's expressed model and machine-generated hypothesis the engineer's true intentions. discriminating example either satisfies the model but not the hypothesis, satisfies the hypothesis but not the model. shows the difference between the model and the hypothesized alternative. validating that the model true expression the engineer's intent important and difficult problem. one the key challenges that there typically other written artifact compare the model to: the engineer's intention mental object. one successful approach this challenge has been automated example-generation tools, such the alloy analyzer. these tools produce examples (satisfying valuations the model) for the engineer accept reject. these examples, along with the engineer's judgment them, serve crucial written artifacts the engineer's true intentions. smart debugging can ease the burden the developer, who often struggles recognize gaps between what intends the code versus what really does. smart debugger enables the developer, who likely lacks training formal methods, apply localization, understanding, and fixing bugs. practical smart debugger can guide the human intellect towards bridging semantic gaps with the use discriminating examples correct flaws logical reasoning and supply automatic error localization tools. important legal disclaimer quantstamp technologies inc. (the company quantstamp tokens (the tokens qsp tokens offered the quantstamp token pre-sale and the public sale (collectively, the token sale are not intended constitute securities any jurisdiction. this document (the white paper does not constitute prospectus offer document any sort and not intended constitute offer securities solicitation for investment securities any jurisdiction. this white paper does not constitute form part any opinion any advice sell any solicitation any offer quantstamp purchase any qsp tokens, nor shall any part it, nor the fact its presentation form the basis of, relied upon connection with, any contract investment decision. person bound enter into any contract binding legal commitment relation the sale and purchase the qsp tokens and cryptocurrency other form payment accepted the basis this whitepaper. any agreement between quantstamp and you purchaser relation any sale purchase qsp tokens governed separate quantstamp token sale terms and conditions document (the terms "). the event any inconsistencies between the terms and this whitepaper, the former shall prevail. you are not eligible and you are not purchase any qsp tokens the quantstamp token sale you are citizen, resident (for tax purposes otherwise) green card holder the united states america citizen the people's republic china. regulatory authority has examined approved any the information set out this whitepaper. such action has been will taken under the laws, regulatory requirements rules any jurisdiction. the publication, distribution dissemination this whitepaper does not imply that the applicable laws, regulatory requirements rules have been complied with. there are risks and uncertainties associated with quantstamp and its business and operations, the qsp tokens and the quantstamp token sale. this whitepaper, any part thereof and any copy thereof must not taken transmitted any country where distribution dissemination this whitepaper prohibited restricted. closed system utility the date publication this paper, the tokens have known potential uses outside the quantstamp ecosystem, and are not permitted sold otherwise traded third-party exchanges. this paper does not constitute advice nor recommendation quantstamp, its officers, directors, managers, employees, agents, advisors consultants, any other person any recipient this paper the merits the participation the token sale. quantstamp tokens should not acquired for speculative investment purposes with the expectation making profit immediate re-sale. promises future performance value are will made with respect quantstamp tokens. accordingly, promise inherent value, promise continuing payments, and guarantee that quantstamp tokens will hold any particular value made. unless prospective participants fully understand and accept the nature quantstamp and the potential risks inherent quantstamp tokens, they should not participate the token sale. quantstamp tokens are sold functional good and all proceeds received quantstamp may spent freely quantstamp absent any conditions, save set out herein. disclaimer liability the maximum extent permitted the applicable laws, regulations and rules, quantstamp shall not liable for any indirect, special, incidental, consequential other losses any kind, tort, contract otherwise (including but not limited loss revenue, income profits, and loss use data), arising out connection with any acceptance reliance this whitepaper any part thereof you. representations and warranties quantstamp does not make purport make, and hereby disclaims, any representation, warranty undertaking any form whatsoever any entity person, including any representation, warranty undertaking relation the truth, accuracy and completeness any the information set out this whitepaper. particular, representations warranties whatsoever are made with respect quantstamp the tokens: (a) merchantability, suitability fitness for any particular purpose; (b) that the contents this document are accurate and free from any error(s); (c) that such contents not infringe any third party rights. quantstamp shall have liability for damages any kind arising out the use, reference to, reliance the contents this document, even advised the possibility such damages; this whitepaper references third party data and industry publications. quantstamp believes that these references are accurate; however, quantstamp does not provide any assurances the accuracy completeness this data. have not independently verified the data sourced from third party sources this paper, ascertained the underlying assumptions relied upon such sources. representations and warranties you accessing and/or accepting possession any information this whitepaper such part thereof, you represent and warrant quantstamp follows: (a) you acknowledge that the qsp tokens not constitute securities any form any jurisdiction; (b) you acknowledge that this white paper does not constitute prospectus offer document any sort and not intended constitute offer securities any jurisdiction solicitation for investment securities and you are not bound enter into any contract binding legal commitment and cryptocurrency other form payment accepted the basis this whitepaper; (c) you acknowledge that regulatory authority has examined approved the information set out this whitepaper, action has been will taken under the laws, regulatory requirements rules any jurisdiction and the publication, distribution dissemination this whitepaper you does not imply that the applicable laws, regulatory requirements rules have been complied with; (d) you agree and acknowledge that this whitepaper, the undertaking and/or the completion the quantstamp token sale, future trading the qsp tokens any cryptocurrency exchange, shall not construed, interpreted deemed you indication the merits quantstamp, the qsp tokens and the quantstamp token sale; (e) the distribution dissemination this whitepaper, any part thereof any copy thereof, acceptance the same you, not prohibited restricted the applicable laws, regulations rules your jurisdiction, and where any restrictions relation possession are applicable, you have observed and complied with all such restrictions your own expense and without liability quantstamp; (f) you agree and acknowledge that the event that you wish purchase any qsp tokens, the qsp tokens are not construed, interpreted, classified treated as: (i) any kind currency other than cryptocurrency; (ii) debentures, stocks shares issued any person entity; (iii) rights, options derivatives respect such debentures, stocks shares; (iv) rights under contract for differences under any other contract the purpose pretended purpose which secure profit avoid loss; (v) units collective investment scheme; (vi) units business trust; (vii) derivatives units business trust; (viii) any other security class securities. (g) you are fully aware and understand that you are not eligible purchase any qsp tokens you are citizen, resident (tax otherwise) green card holder the united states america citizen resident the republic singapore; (h) you have basic degree understanding the operation, functionality, usage, storage, transmission mechanisms and other material characteristics cryptocurrencies, blockchain-based software systems, cryptocurrency wallets other related token storage mechanisms, blockchain technology and smart contract technology; (i) you are fully aware and understand that the case where you wish purchase any qsp tokens, there are risks associated with quantstamp and its business and operations and the tokens; (j) you agree and acknowledge that quantstamp not liable for any indirect, special, incidental, consequential other losses any kind, tort, contract otherwise (including but not limited loss revenue, income profits, and loss use data), arising out connection with any acceptance reliance this whitepaper any part thereof you; and (k) all the above representations and warranties are true, complete, accurate and nonmisleading from the time your access and/or acceptance possession this whitepaper such part thereof. cautionary note forward-looking statements all statements contained this whitepaper, statements made press releases any place accessible the public and oral statements that may made quantstamp's respective directors, executive officers, employees other representatives acting behalf quantstamp that are not statements historical fact, constitute "forward- looking statements". some these statements can identified forward-looking terms such "aim", "target", "anticipate", "believe", "could", "estimate", "expect", "if", "intend", "may", "plan", "possible", "probable", "project", "should", "would", "will" other similar terms. however, these terms are not the exclusive means identifying forward-looking statements. all statements regarding quantstamp's financial position, business strategies, plans and prospects and the future prospects the industry which quantstamp are forward-looking statements. these forward-looking statements, including but not limited statements quantstamp's revenue and profitability, prospects, future plans, other expected industry trends and other matters discussed this whitepaper regarding quantstamp are matters that are not historical facts, but only predictions. these forward-looking statements involve known and unknown risks, uncertainties and other factors that may cause the actual future results, performance achievements quantstamp materially different from any future results, performance achievements expected, expressed implied such forward-looking statements. these factors include, amongst others: (a) changes political, social, economic and stock cryptocurrency market conditions, and the regulatory environment the countries which quantstamp conducts its respective businesses and operations; (b) the risk that quantstamp may unable execute implement its business strategies and future plans; (c) changes interest rates and exchange rates fiat currencies and cryptocurrencies; (d) changes the anticipated growth strategies and expected internal growth quantstamp; (e) changes the availability and fees payable quantstamp connection with its respective businesses and operations; (f) changes the availability and salaries employees who are required quantstamp operate their respective businesses and operations; (g) changes competitive conditions under which quantstamp operates, and the ability quantstamp compete under such conditions; (h) changes the future capital needs quantstamp and the availability financing and capital fund such needs; (i) war acts international domestic terrorism; (j) occurrences catastrophic events, natural disasters and acts god that affect the business and/or operations quantstamp; (k) other factors beyond the control quantstamp; and (l) any risk uncertainties associated with quantstamp and its businesses and operations and the qsp tokens. all forward-looking statements made attributable quantstamp persons acting behalf quantstamp are expressly qualified their entirety the factors listed above. given the risks and uncertainties that may cause the actual future results, performance achievements quantstamp materially different from that expected, expressed implied the forward-looking statements this whitepaper, undue reliance must not placed these statements. these forward-looking statements are applicable only the date this whitepaper. neither quantstamp, nor any other person represents, warrants and/or undertakes that the actual future results, performance achievements quantstamp will discussed those forward-looking statements. the actual results, performance achievements quantstamp may differ materially from those anticipated these forward- looking statements. nothing contained this whitepaper may relied upon promise, representation undertaking the future performance policies quantstamp. further, quantstamp disclaims any responsibility update any those forward-looking statements publicly announce any revisions those forward-looking statements reflect future developments, events circumstances, even new information becomes available other events occur the future. market and industry information and consent other persons this whitepaper includes market and industry information and forecasts that have been obtained from internal surveys, reports and studies, where appropriate, well market research, publicly available information and industry publications. such surveys, reports, studies, market research, publicly available information and publications generally state that the information that they contain has been obtained from sources believed reliable, but there can assurance the accuracy completeness such included information. save for quantstamp and its directors, executive officers and employees, person has provided his her consent the inclusion his her name and/or other information attributed perceived attributed such person connection therewith this whitepaper and representation, warranty undertaking purported provided the accuracy completeness such information such person and such persons shall not obliged provide any updates the same. while quantstamp has taken reasonable actions ensure that the information extracted accurately and its proper context, quantstamp has not conducted any independent review the information extracted from third party sources, verified the accuracy completeness such information ascertained the underlying economic assumptions relied upon therein. consequently, neither quantstamp nor its respective directors, executive officers and employees acting their behalf make any representation warranty the accuracy completeness such information and shall not obliged provide any updates the same. terms used facilitate better understanding the qsp tokens being offered for purchase quantstamp, and the business and operations quantstamp, certain technical terms and abbreviations, well as, certain instances, their descriptions, have been used this whitepaper. these descriptions and assigned meanings should not treated being definitive their meanings and may not correspond standard industry meanings usage. words importing the singular shall, where applicable, include the plural and vice versa and words importing the masculine gender shall, where applicable, include the feminine and neuter genders and vice versa. references persons shall include corporations. advice information this whitepaper should considered business, legal, financial tax advice regarding quantstamp, the qsp tokens and the quantstamp token sale. you should consult your own legal, financial, tax other professional adviser regarding quantstamp and its business and operations and the qsp tokens. you should aware that you are bearing the financial risk any purchase qsp tokens for indefinite period time. further information update person has been authorised give any information representation not contained this whitepaper connection with quantstamp and their respective businesses and operations, the qsp tokens and, given, such information representation must not relied upon having been authorised behalf quantstamp. the quantstamp token sale shall not, under any circumstances, constitute continuing representation create any suggestion implication that there has been change, development reasonably likely involve material change the affairs, conditions and prospects quantstamp any statement fact information contained this whitepaper since the date hereof. restrictions distribution and dissemination the distribution dissemination this whitepaper any part thereof may prohibited restricted the laws, regulatory requirements and rules any jurisdiction. the case where any restriction applies, you are inform yourself about, and observe, any restrictions which are applicable your possession this whitepaper such part thereof your own expense and without liability quantstamp. persons whom copy this whitepaper has been distributed disseminated, provided access who otherwise have the whitepaper their possession shall not circulate any other persons, reproduce otherwise distribute this whitepaper any information contained herein for any purpose whatsoever nor permit cause the same occur. risks and uncertainties prospective purchasers qsp tokens should carefully consider and evaluate all risks and uncertainties associated with quantstamp, the qsp tokens, the quantstamp token sale, all information set out this whitepaper and the terms prior any purchase qsp tokens. any such risks and uncertainties develops into actual events, the business, financial condition, results operations and prospects quantstamp could materially and adversely affected. such cases, you may lose all part the value the qsp tokens. you are any doubt the action you should take, you should consult your legal, financial, tax other professional advisor(s).