the tangle serguei popov* april version abstract this paper analyze the mathematical foundations iota, cryptocurrency for the internet-of-things (iot) industry. the main feature this novel cryptocurrency the tangle, directed acyclic graph (dag) for storing transactions. the tangle naturally succeeds the blockchain its next evolutionary step, and offers features that are required establish machineto-machine micropayment system. essential contribution this paper family markov chain monte carlo (mcmc) algorithms. these algorithms select attachment sites the tangle for transaction that has just arrived. introduction and description the system the rise and success bitcoin during the last six years proved that blockchain technology has real-world value. however, this technology also has number drawbacks that prevent from being used generic platform for cryptocurrencies across the globe. one notable drawback the concept transaction fee for transactions any value. the importance micropayments will increase the rapidly developing iot industry, and paying fee that larger than the amount value being transferred not logical. furthermore, not easy get rid fees the blockchain infrastructure since they serve incentive for the creators blocks. this leads another issue with existing cryptocurrency technology, namely the heterogeneous nature the system. there are two distinct types participants the system, those who issue transactions, and those who approve transactions. the design this system creates unavoidable discrimination some participants, which turn creates a.k.a. mthcl; author's contact information: serguei.popov@iota.org conflicts that make all elements spend resources conflict resolution. the aforementioned issues justify search for solutions essentially different from blockchain technology, the basis for bitcoin and many other cryptocurrencies. this paper discuss innovative approach that does not incorporate blockchain technology. this approach currently being implemented cryptocurrency called iota [], which was designed specifically for the iot industry. the purpose this paper focus general features the tangle, and discuss problems that arise when one attempts get rid the blockchain and maintain distributed ledger. the concrete implementation the iota protocol not discussed. general, tangle-based cryptocurrency works the following way. instead the global blockchain, there dag that call the tangle. the transactions issued nodes constitute the site set the tangle graph, which the ledger for storing transactions. the edge set the tangle obtained the following way: when new transaction arrives, must approve two previous transactions. these approvals are represented directed edges, shown figure there not directed edge between transaction and transaction but there directed path length least two from say that indirectly approves there also the "genesis" transaction, which approved either directly indirectly all other transactions (figure the genesis described the following way. the beginning the tangle, there was address with balance that contained all the tokens. the genesis transaction sent these tokens several other "founder" addresses. let stress that all the tokens were created the genesis transaction. tokens will created the future, and there will mining the sense that miners receive monetary rewards "out thin air". quick note terminology: sites are transactions represented the tangle graph. the network composed nodes; that is, nodes are entities that issue and validate transactions. the main idea the tangle the following: issue transaction, users must work approve other transactions. therefore, users who issue transaction are contributing the network's security. assumed that the nodes check the approved transactions are not conflicting. node finds that transaction conflict with the tangle history, the node will not approve the conflicting transaction either direct indirect manner this the simplest approach. one may also study similar systems where transactions must approve other transactions for general have entirely different set rules. time always increases from left right each figure. node issues new transaction that approves conflicting transactions, then risks that other nodes will not approve its new transaction, which will fall into oblivion. transaction receives additional approvals, accepted the system with higher level confidence. other words, will difficult make the system accept double-spending transaction. important observe that not impose any rules for choosing which transactions node will approve. instead, argue that large number nodes follow some "reference" rule, then for any fixed node better stick rule the same kind this seems reasonable assumption, especially the context iot, where nodes are specialized chips with pre-installed firmware. order issue transaction, node does the following: the node chooses two other transactions approve according algorithm. general, these two transactions may coincide. the node checks the two transactions are not conflicting, and does not approve conflicting transactions. for node issue valid transaction, the node must solve cryptographic puzzle similar those the bitcoin blockchain. this achieved finding nonce such that the hash that nonce concatenated with some data from the approved transaction has particular form. the case the bitcoin protocol, the hash must have least predefined number leading zeros. important observe that the iota network asynchronous. general, nodes not necessarily see the same set transactions. should also noted that the tangle may contain conflicting transactions. the nodes not have achieve consensus which valid transactions have the right the ledger, meaning all them can the tangle. however, the case where there are conflicting transactions, the nodes need decide which transactions will become orphaned the main rule that the nodes use for deciding between two conflicting transactions the following: node runs the tip selection algorithm (cf. section many times, and sees which the two transactions more likely indirectly approved the selected tip. for example, transaction was selected times during runs the tip selection algorithm, say that confirmed with confidence. let also comment the following question (cf. []): what motivates the nodes propagate transactions? every node calculates some statistics, one which comment more this the end section transactions that are issued according the protocol. orphaned transactions are not indirectly approved incoming transactions anymore mentioned above, there good reason assume that other nodes would follow the same algorithm for tip selection. how many new transactions are received from neighbor. one particular node "too lazy", will dropped its neighbors. therefore, even node does not issue transactions, and hence has direct incentive share new transactions that approve its own transaction, still has incentive participate. after introducing some notation section discuss algorithms for choosing the two transactions approve, the rules for measuring the transaction's overall approval (section especially section .), and possible attack scenarios (section also, the unlikely event that the reader scared the formulas, they can jump directly the "conclusions" the end each section. should noted that the idea using dags the cryptocurrency space has been around for some time, see specifically, introduces the ghost protocol, which proposes modification the bitcoin protocol making the main ledger tree instead blockchain. shown that such modification reduces confirmation times and improves the overall security the network. the authors consider dag-based cryptocurrency model. their model different than our model for the following reasons: the sites their dag are blocks instead individual transactions; the miners their system compete for transaction fees; and new tokens may created block miners. also, observe that solution somewhat similar ours was proposed [], although does not discuss any particular tip approval strategies. after the first version this paper was published, several other works that aim create dag-based distributed ledger have appeared, e.g. []. also reference another approach that aims make bitcoin micropayments possible establishing peer-to-peer payment channels. weights and more this section define the weight transaction, and related concepts. the weight transaction proportional the amount work that the issuing node invested into it. the current implementation iota, the weight may only assume values where positive integer that belongs some nonempty interval acceptable values fact, irrelevant know how the weight was obtained practice. only important that every transaction has positive integer, its weight, attached it. general, the idea that transaction with larger weight more "important" than transaction with smaller weight. avoid spamming and other attack styles, assumed that entity can generate abundance transactions with "acceptable" weights short period time. this interval should also finite see the "large weight attack" section one the notions need the cumulative weight transaction: defined the own weight particular transaction plus the sum own weights all transactions that directly indirectly approve this transaction. the algorithm for cumulative weight calculation illustrated figure the boxes represent transactions, the small number the corner each box denotes own weight, and the bold number denotes the cumulative weight. for example, transaction directly indirectly approved transactions the cumulative weight which the sum the own weight and the own weights let define "tips" unapproved transactions the tangle graph. the top tangle snapshot figure the only tips are and when the new transaction arrives and approves and the bottom tangle snapshot, becomes the only tip. the cumulative weight all other transactions increases the own weight need introduce two additional variables for the discussion approval algorithms. first, for transaction site the tangle, introduce its height: the length the longest oriented path the genesis; depth: the length the longest reverse-oriented path some tip. for example, has height and depth figure because the reverse path while has height and depth also, let introduce the notion the score. definition, the score transaction the sum own weights all transactions approved this transaction plus the own weight the transaction itself. figure the only tips are and transaction directly indirectly approves transactions the score ++++ analogously, the score order understand the arguments presented this paper, one may safely assume that all transactions have own weight equal from now on, stick this assumption. under this assumption, the cumulative weight transaction becomes plus the number transactions that directly indirectly approve and the score becomes plus the number transactions that are directly indirectly approved let note that, among those defined this section, the cumulative weight (by far!) the most important metric, although height, depth, and score will briefly enter some discussions well. figure dag with weight assignments before and after newly issued transaction, the boxes represent transactions, the small number the corner each box denotes own weight, and the bold number denotes the cumulative weight. genesis figure dag with own weights assigned each site, and scores calculated for sites and stability the system, and cutsets let l(t) the total number tips the system time one expects that the stochastic process l(t) remains stable more precisely, one expects the process positive recurrent, see sections and for formal definitions. particular, positive recurrence implies that the limit p[l(t) should exist and positive for all intuitively, expect that l(t) should fluctuate around constant value, and not escape infinity. l(t) were escape infinity, many unapproved transactions would left behind. analyze the stability properties l(t), need make some assumptions. one assumption that transactions are issued large number roughly independent entities, the process incoming transactions can modeled poisson point process (cf. e.g. section []). let the rate that poisson process. for simplicity, let assume that this rate remains constant time. assume that all devices have approximately the same computing power, and let the average time device needs perform calculations that are required issue transaction. then, let assume that all nodes behave the following way: issue transaction, node chooses two tips random and approves them. should observed that, general, not good idea for the "honest nodes" adopt this strategy because has number practical disadvantages. particular, does not offer enough protection against "lazy" malicious nodes (see section below). the other hand, still consider this model since simple analyze, and may provide insight into the system's behavior for more complicated tip selection strategies. under additional assumption that the process time-homogeneous. next, make further simplifying assumption that any node, the moment when issues transaction, observes not the actual state the tangle, but the one exactly time units ago. this means, particular, that transaction attached the tangle time only becomes visible the network time t+h. also assume that the number tips remains roughly stationary time, and concentrated around number the following, will calculate function and observe that, given time have roughly "hidden tips" (which were attached the time interval and are not yet visible the network); also, assume that typically there are "revealed tips" (which were attached before time and remain tips time t), lh. stationarity, may then assume that time there are also around sites that were tips time but are not tips anymore. now, think about new transaction that comes this moment; then, transaction chooses approve tip with probability r/(r lh) (since there are around tips known the node that issued the transaction, and there are also around transactions which are not tips anymore, although that node thinks they are), the mean number chosen tips r/(r lh). the key observation now that, the stationary regime, this mean number chosen tips should equal since, average, newcoming transaction should not change the number tips. solving the equation r/(r lh) with respect obtain lh, and lh. also note that, the rule that new transaction references transactions instead then similar calculation gives (k) klh (k) this is, course, consistent with the fact that should tend (basically, the only tips would those still unknown the network). also (we return the case two transactions approve) the expected time for transaction approved for the first time approximately this because, our assumption, during the first units time transaction cannot approved, and after that the poisson flow approvals has rate approximately l/l (recall proposition [], which says that independently classify each event poisson process according list possible subtypes, then the processes events each subtype are independent poisson processes.) observe that any fixed time the set transactions that were tips some least the case where the nodes try approve tips. moment [t, h(l typically constitutes cutset. any path from transaction issued time the genesis must pass through this set. important that the size new cutset the tangle occasionally becomes small. one may then use the small cutsets checkpoints for possible dag pruning and other tasks. important observe that the above "purely random" approval strategy not very good practice because does not encourage approving tips. "lazy" user could always approve fixed pair very old transactions, therefore not contributing the approval more recent transactions, without being punished for such behavior also, malicious entity can artificially inflate the number tips issuing many transactions that approve fixed pair transactions. this would make possible for future transactions select these tips with very high probability, effectively abandoning the tips belonging "honest" nodes. avoid issues this sort, one has adopt strategy that biased towards the "better" tips. one example such strategy presented section below. before starting the discussion about the expected time for transaction receive its first approval, note that can distinguish two regimes (figure low load: the typical number tips small, and frequently becomes this may happen when the flow transactions small that not probable that several different transactions approve the same tip. also, the network latency very low and devices compute fast, unlikely that many tips would appear. this even holds true the case when the flow transactions reasonably large. moreover, have assume that there are attackers that try artificially inflate the number tips. high load: the typical number tips large. this may happen when the flow transactions large, and computational delays together with network latency make likely that several different transactions approve the same tip. this division rather informal, and there clear borderline between the the two regimes. nevertheless, find that may instructive consider these two different extremes. the situation the low load regime relatively simple. the first approval happens average timescale order since one the first few incoming transactions will approve given tip. let now consider the high load regime, the case where large. mentioned above, one may assume that the poisson flows approvals different tips are remind the reader that not try enforce any particular tip selection strategy. attacker can choose tips any way they find convenient. figure low load (top) and high load (bottom) regimes incoming transaction flow. white squares represent verified sites, while gray squares represent tips. independent and have approximate rate l/l therefore, the expected time for transaction receive its first approval around /(l) (recall ()). however, worth noting that for more elaborate approval strategies may not good idea passively wait long time until transaction approved the others. this due the fact that "better" tips will keep appearing and will preferred for approval. rather, the case when transaction waiting for approval over time interval much larger than /l, good strategy would promote this latent transaction with additional empty transaction other words, node can issue empty transaction that approves its previous transaction together with one the "better" tips increase the probability that the empty transaction receives approval. turns out that the approval strategies based heights and scores may vulnerable specific type attacks, see section will discuss more elaborate strategies defend against such attacks that section. the meantime, still that favor "better" quality tips future implementations iota. empty transaction transaction that does not involve any token transfer, but still has approve two other transactions. should noted that generating empty transaction contributes the network's security. fact, the author's feeling that the tip approval strategy the most important ingredient for constructing tangle-based cryptocurrency. there that many attack vectors are hiding. also, since there usually way enforce particular tip approval strategy, must such that the nodes would voluntarily choose follow knowing that least good proportion other nodes does so. worth considering the simple tip selection strategy where incoming transaction approves two random tips. this strategy the easiest analyze, and therefore may provide some insight into the qualitative and quantitative behavior the tangle. conclusions: distinguish between two regimes, low load and high load (figure there are only few tips the low load regime. tip gets approved for the first time th(l- time units, where the rate the incoming flow transactions. the high load regime the typical number tips depends the tip approval strategy employed the new transaction. transaction uses the strategy approving two random tips, the typical number tips given (). can shown that this strategy optimal with respect the typical number tips. however, not practical adopt this strategy because does not encourage approving tips. more elaborate strategies are needed handle attacks and other network issues. family such strategies discussed section the typical time for tip approved th(h) the high load regime, where the average computation/propagation time for node. however, the first approval does not occur the above time interval, good idea for the issuer and/or receiver promote that transaction with additional empty transaction. how fast does the cumulative weight typically grow? assume that the network the low load regime. after transaction gets approved several times, its cumulative weight will grow with speed because all new transactions will indirectly reference this transaction the case where the network the high load regime, old transaction with large cumulative weight will experience weight growth with speed because essentially all new transactions will indirectly reference it. moreover, when the transaction recall that assumed that the own weights all transactions are equal the cumulative weight just the number transactions that directly indirectly reference transaction plus first added the tangle may have wait for some time approved. this time interval, the transaction's cumulative weight behaves random fashion. characterize the speed with which the cumulative weight grows after the transaction receives several approvals, let define h(t) the expected cumulative weight time (for simplicity, start counting time the moment when our transaction was revealed the network, i.e., time units after was created) and k(t) the expected number tips that approve the transaction time let also abbreviate h(l make simplifying assumption that the number tips remains roughly constant value over time. work with the "approve two random tips" strategy this section. expected that the qualitative behavior will roughly the same for other reasonable strategies. recall that transaction entering the network time typically chooses two tips approve based the state the system time because the node must some calculations and verifications before actually issuing the transaction. not difficult see that (assuming, though, that k(*) the actual number tips, not just expected number) the probability the transaction approving least one k(t-h) k(t-h) analogous "our" tips the tangle k(t-h) example [], can write for small k(t k(t o(d), h(t h(t) and thus deduce the following differential equation k(t k(t dh(t) order able use (), need first calculate k(t). this not trivial task since tip time may not tip time and the overall number tips approving the original transaction increases the case where incoming transaction approves such tip. the crucial observation that the probability that tip time remains tip time approximately (to verify this, recall the discussion from section the typical number tips lh, and during the interval length new tips will substitute half old ones.) therefore, time approximately one half k(t tips remain the unconfirmed tip state, while the other half will have received least one approval. let denote the set k(t h)/ tips time that are still tips time and let denote the the expression the left-hand side minus the probability that the two approved tips are not ours. remaining set k(t h)/ tips that were already approved time let the probability that new transaction approves least transaction from and does not approve any transactions from furthermore, let the probability that both approved transactions belong other words, and are the probabilities that the current number "our" tips increases decreases upon arrival the new transaction. have k(t k(t k(t k(t obtain the first expression, observe that equals the probability that both approved tips belong plus twice the probability that the first tip belongs and the second tip does not belong analogous (), the differential equation for k(t) is: k(t k(t dk(t) difficult solve exactly, make further simplifying assumptions. first all, observe that after the time when k(t) reaches level for fixed will grow very quickly e)l now, when k(t) small with respect can drop the last factor the right-hand side obtain simplified version recalling that llh dk(t) k(t h), with boundary condition k() look for solution the form k(t) exp(c after substituting this into (), obtain exp exp therefore t k(t) exp exp approximate solution, where (*) the so-called lambert -function. taking the logarithm both sides (), find that the time when k(t) reaches would constant close the right-hand side would equivalent k(t-h) also known the omega function product logarithm; for characterized the relation (x) exp(w (x)). cumulative weight tan time adaptation period figure plot cumulative weight vs. time for the high load regime. roughly returning and dropping the last term the right-hand side, obtain that during the "adaptation period" (i.e., the attacker managed obtain nonce that gives the doublespending transaction weight least during the time interval length then the attack succeeds. the probability this event p[w and hope that the moment they find it, the total weight the legitimate branch smaller than the probability this event occurring p[lww (n) follows that are i.i.d. exponential random variables with parameter during the time even before; discuss this case later. with expected value /u. suppose that time the merchant decides accept the transaction with cumulative weight let estimate the probability that the attacker successfully double-spends. let (th) th)- the moment generating function the exponential distribution with parameter (section []). known that for holds that for recall that the expectation exponential random variable with parameter also equals the cumulative weight the legitimate transaction roughly l(t because assumed that the adaptation period over, the cumulative weight grows with speed analogous (), one finds the probability that the double-spending transaction has more cumulative weight time roughly exp l(t ))ph +l(t-t then, must true that have since the cumulative weight grows with speed less than during the adaptation period. can shown that the probability this consequence the so-called large deviation principle. see the general book [], and proposition section for simple and instructive derivation the upper bound, and section for the (not simple) derivation the lower bound. achieving successful double spend order exp max( for example, let that the attacker's power only bit less than that the rest the network. assume that the transaction has cumulative weight time then, max( and then gives the upper bound approximately one assumes that and keeps all other pa rameters intact, then max( and gives approximately quite drastic change. from the above discussion important recognize that the inequality should true for the system secure. other words, the input flow "honest" transactions should large compared the attacker's computational power. otherwise, the estimate would useless. this indicates the need for additional security measures, such checkpoints, during the early days tangle-based system. when choosing strategy for deciding which one two conflicting transactions valid, one has careful when using cumulative weight decision metric. this due the fact that cumulative weight can subject attack similar the one described section namely the attacker may prepare doublespending transaction well advance, build secret subtangle referencing it, and then broadcast that subtangle after the merchant accepts the legitimate transaction. better method for deciding between two conflicting transactions might the one described the next section: run the tip selection algorithm and see which the two transactions indirectly approved the selected tip. parasite chain attack and new tip selection algorithm consider the following attack (figure attacker secretly builds subtangle that occasionally references the main tangle gain higher score. note that the score honest tips roughly the sum all own weights the main tangle, while the score the attacker's tips also contains the sum all own weights the parasite chain. since network latency not issue for attacker who builds subtangle alone they might able give more height the parasite tips they use computer that sufficiently strong. moreover, the attacker can artificially increase their tip count the moment the attack broadcasting many new transactions this due the fact that attacker can always approve their own transactions without relying any information from the rest the network. that approve transactions that they issued earlier the parasite chain (figure this will give the attacker advantage the case where the honest nodes use some selection strategy that involves simple choice between available tips. defend against this attack style, are going use the fact that the main tangle supposed have more active hashing power than the attacker. therefore, the main tangle able produce larger increases cumulative weight for more transactions than the attacker. the idea use mcmc algorithm select the two tips reference. let the current cumulative weight site. recall that assumed all own weights are equal therefore, the cumulative weight tip always and the cumulative weight other sites least the idea place some particles, a.k.a. random walkers, sites the tangle and let them walk towards the tips random way. the tips "chosen" the walks are then the candidates for approval. the algorithm described the following way: consider all sites the interval [w, where reasonably large independently place particles sites that interval let these particles perform independent discrete-time random walks "towards the tips", meaning that transition from possible and only approves the two random walkers that reach the tip set first will sit the two tips that will approved. however, may wise modify this rule the following way: first discard those random walkers that reached the tips too fast because they may have ended one the "lazy tips". the transition probabilities the walkers are defined the following way: approves x), then the transition probability pxy proportional there not "canonical" source randomness. the nodes just use their own (pseudo)random number generators simulate the random walks. the idea place the particle "deep" into the tangle that will not arrive tip straight away. however, the particle should not placed "too deep" because needs find tip reasonable time. also, the interval [w, arbitrary. one could chose [w, etc. there are also other ways select the walkers' starting points. for example, node can simply take random transaction received between and time units the past, where some fixed time point. this choice largely arbitrary. use several particles instead just two for additional security. the idea that particle were accidentally jump the attacker's chain, which supposed long, then would spend lot time there and other tips will chosen first. lazy tips main tangle good tips parasite chain figure visual representation the tip selection algorithm for honest tips, well the parasite chain. the two red circles indicate attempted double-spend attacker. exp a(hx that - pxy exp a(hx exp a(hx z:z where parameter chosen note that this algorithm "local", meaning one does not need traverse the tangle back the genesis perform relevant calculations. particular, observe that one does not need calculate the cumulative weights for the whole tangle. most one needs calculate the cumulative weights for the sites that indirectly approve the starting point the walker. check that the algorithm works intended, first consider the "lazy tips". these tips intentionally approve some old transactions avoid doing verification work (figure even the particle site approved lazy tip, not probable that the lazy tip would selected because the difference between cumulative weights would very large and pxy would small. next, consider this alternate attack style: the attacker secretly builds chain containing transaction that empties their account balance another account under their control, indicated the leftmost red circle figure then, the attacker issues transaction the main tangle, represented the rightmost red circle, and waits for the merchant accept it. the parasite chain occasionally references the main one can start with tangle. however, the cumulative weight not very large the parasite chain. should noted that the parasite chain cannot reference the main tangle after the merchant's transaction. furthermore, the attacker might try artificially inflate the number tips their parasite chain the moment the attack (figure the attacker's idea make the nodes issuing new transactions reference the parasite chain that the honest branch the tangle will orphaned. easy see why the mcmc selection algorithm will not select one the attacker's tips with high probability. the reasoning identical the lazy tip scenario: the sites the parasite chain will have cumulative weight that much smaller than the sites that they reference the main tangle. therefore, not probable that the random walker will ever jump the parasite chain unless begins there, and this event not very probable either because the main tangle contains more sites. additional protecting measure, can first run random walk with large (so that fact "almost deterministic") choose "model tip"; then, use random walks with small for actual tip selection, but verify the (indirectly) referenced transactions are consistent with the model tip. observe also that, for random walk that always moves towards the tips very simple and rapid calculate the exit probability distribution using straightforward recursion; this something that not want the nodes do. however, possible modify our approach the following way: each step, the random walk may backtrack (i.e., step away from the tips) with probability (say) (and divide the remaining before). the walk will reach the tips very quickly anyway (because has drift towards the tips), but will not easy calculate the exit measure. let comment why the nodes would follow this algorithm. recall from section that reasonable assume that least "good" proportion the nodes will follow the reference algorithm. also, because computational and network delays, the tip selection algorithm would rather work with past snapshot the tangle with respect the moment when transaction issued. may good idea intentionally move this snapshot time point further the past the reference algorithm for the reasons that explain the sequel. imagine "selfish" node that just wants maximize the chances their transaction being approved quickly. the mcmc algorithm this section, which adopted considerable proportion nodes, defines probability distribution the set tips. clear that first the random walker finds former tip with respect that snapshot, and then continues walk towards the "actual" tips the current tangle. natural first choice for selfish node would choose the tips where the maximum that distribution attained. however, many other nodes also behave selfish way and use the same strategy, which reasonable assumption, then they all will lose. many new transactions will approve the same two tips roughly the same time, therefore generating too much competition between them for subsequent approval. should also clear that nodes will not immediately "feel" the cumulative weight increase caused this mass approval the same two tips since the nodes are using past snapshot. for this reason, even selfish node would have use some random tip approval algorithm with probability distribution for tip selection that close the default probability distribution produced the reference tip selection algorithm. not claim that this "aggregated" probability distribution would equal the default probability distribution the presence selfish nodes. however, the above argument shows that should close it. this means that the probability many nodes attempting verify the same "bad" tips would remain small. any case, there not large incentive for the nodes selfish because possible gains only amount slight decrease confirmation time. this inherently different from other decentralized constructs, such bitcoin. the important fact that nodes not have reasons abandon the mcmc tip selection algorithm. would like mention that the definition transition probabilities, given (), has not been set stone. instead the exponent, one can use different function that decreases rapidly, such (s) there also freedom for choosing and well. this point time, unclear there are any theoretical arguments that show exactly which way these parameters should chosen. sum, feel that the main contribution this section the idea using mcmc for tip selection. splitting attack aviv zohar suggested the following attack scheme against the proposed mcmc algorithm. the high-load regime, attacker can try split the tangle into two branches and maintain the balance between them. this would allow both branches continue grow. the attacker must place least two conflicting transactions noticed before, for backtracking walk there seem easy way discover which tips are better (that is, more likely selected "honest" nodes) other than running the mcmc many times. however, running mcmc many times requires time and other resources; after one spends some time it, the state the tangle will already change, one would possibly even have start anew. this explains why nodes not have reasons abandon the mcmc tips selection strategy favor something else, least they assume that considerable proportion the other nodes follow the default tips selection strategy. the beginning the split prevent honest node from effectively joining the branches referencing them both simultaneously. then, the attacker hopes that roughly half the network would contribute each branch that they would able "compensate" for random fluctuations, even with relatively small amount personal computing power. this technique works, the attacker would able spend the same funds the two branches. defend against such attack, one needs use "sharp-threshold" rule that makes too hard maintain the balance between the two branches. example such rule selecting the longest chain the bitcoin network. let translate this concept the tangle when undergoing splitting attack. assume that the first branch has total weight and the second branch has total weight honest node selects the first branch with probability very close then the attacker would probably able maintain the balance between the branches. however, honest node selects the first branch with probability much larger than then the attacker would probably unable maintain the balance. the inability maintain balance between the two branches the latter case due the fact that after inevitable random fluctuation, the network will quickly choose one the branches and abandon the other. order make the mcmc algorithm behave this way, one has choose very rapidly decaying function and initiate the random walk node with large depth that highly probable that the walk starts before the branch bifurcation. this case, the random walk would choose the "heavier" branch with high probability, even the difference cumulative weight between the competing branches small. worth noting that the attacker's task very difficult because network synchronization issues: they may not aware large number recently issued transactions another effective method for defending against splitting attack would for sufficiently powerful entity instantaneously publish large number transactions one branch, thus rapidly changing the power balance and making difficult for the attacker deal with this change. the attacker manages maintain the split, the most recent transactions will only have around confirmation confidence (section and the branches will not grow. this scenario, the "honest" nodes may decide start selectively giving their approval the transactions that occurred before the bifurcation, bypassing the opportunity approve the conflicting transactions the split branches. one may consider other versions the tip selection algorithm. for example, node sees two big subtangles, then chooses the one with larger sum own the "real" cumulative weights may quite different from what they believe. weights before performing the mcmc tip selection algorithm outlined above. the following idea may worth considering for future implementations. one could make the transition probabilities defined depend both and such way that the next step the markov chain almost deterministic when the walker deep the tangle, yet becomes more random when the walker close tips. this will help avoid entering the weaker branch while assuring sufficient randomness when choosing the two tips approve. conclusions: considered attack strategies for when attacker tries double-spend "outpacing" the system. the "large weight" attack means that, order double-spend, the attacker tries give very large weight the double-spending transaction that would outweigh the legitimate subtangle. this strategy would menace the network the case where the allowed own weight unbounded. solution, may limit the own weight transaction from above, set constant value. the situation where the maximal own weight transaction the best attack strategy generate transactions with own weight that reference the double-spending transaction. when the input flow "honest" transactions large enough compared the attacker's computational power, the probability that the double-spending transaction has larger cumulative weight can estimated using the formula (see also examples below ()). the attack method building "parasite chain" makes approval strategies based height score obsolete since the attacker's sites will have higher values for these metrics when compared the legitimate tangle. the other hand, the mcmc tip selection algorithm described section seems provide protection against this kind attack. the mcmc tip selection algorithm also offers protection against the lazy nodes bonus. resistance quantum computations known that sufficiently large quantum computer could very efficient for handling problems that rely trial and error find solution. the process finding nonce order generate bitcoin block good example such problem. today, one must check average nonces find suitable hash that allows new block tobe generated. known (see e.g. []) that quantum computer would need th( operations solve problem that analogous the bitcoin puzzle stated above. this same problem would need th(n operations classical computer. therefore, quantum computer would around billion times more efficient mining the bitcoin blockchain than classical computer. also, worth noting that blockchain does not increase its difficulty response increased hashing power, there would increased rate orphaned blocks. for the same reason, "large weight" attack would also much more efficient quantum computer. however, capping the weight from above, suggested section would effectively prevent quantum computer attack well. this evident iota because the number nonces that one needs check order find suitable hash for issuing transaction not unreasonably large. average, around the gain efficiency for "ideal" quantum computer would therefore order which already quite acceptable more importantly, the algorithm used the iota implementation structured such that the time find nonce not much larger than the time needed for other tasks that are necessary issue transaction. the latter part much more resistant against quantum computing, and therefore gives the tangle much more protection against adversary with quantum computer when compared the (bitcoin) blockchain. acknowledgements the author thanks bartosz kusmierz, cyril grunspan, olivia saa, razvan savu, samuel reid, toru kazama, rafael kallis, and rodrigo bueno who pointed out several errors earlier drafts, and james brogan for his contributions towards making this paper more readable. still hypothetical construct today. note that th( could easily mean references iota: cryptocurrency for internet-of-things. see http://www.iotatoken.com/, and https://bitcointalk.org/index.php?topic=. bitcoinj. working with micropayment channels. https://bitcoinj.github.io/working-with-micropayments people nxtforum.org dag, generalized blockchain. https://nxtforum.org/proof-of-stake-algorithm/dag-a-generalized-blockchain/ (registration nxtforum.org required) moshe babaioff, shahar dobzinski, sigal oren, aviv zohar bitcoin and red balloons. proc. acm conf. electronic commerce, richard durrett probability theory and examples. duxbury advanced series. sergio demian lerner dagcoin: cryptocurrency without blocks. https://bitslog.wordpress.com////dagcoin/ yonatan sompolinsky, aviv zohar accelerating bitcoin's transaction processing. fast money grows trees, not chains. https://eprint.iacr.org//.pdf yonatan sompolinsky, yoad lewenberg, aviv zohar spectre: serialization proof-of-work events: confirming transactions via recursive elections. https://eprint.iacr.org//.pdf yoad lewenberg, yonatan sompolinsky, aviv zohar inclusive block chain protocols. http://www.cs.huji.ac.il/~avivz/pubs//inclusive btc.pdf joseph poon, thaddeus dryja the bitcoin lightning network: scalable off-chain instant payments. https://lightning.network/lightning-network-paper.pdf sheldon ross introduction probability models. ed. david vorick getting rid blocks. slides.com/davidvorick/braids amir dembo, ofer zeitouni large deviations techniques and applications. springer. sheldon ross first course probability. ed. gilles brassard, peter hyer, alain tapp quantum cryptanalysis hash and claw-free functions. lecture notes computer science