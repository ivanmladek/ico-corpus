open protocol for decentralized exchange the ethereum blockchain will warren, amir bandeali xproject.com february abstract describe protocol that facilitates low friction peer-to-peer exchange erc tokens the ethereum blockchain. the protocol intended serve open standard and common building block, driving interoperability among decentralized applications (dapps) that incorporate exchange functionality. trades are executed system ethereum smart contracts that are publicly accessible, free use and that any dapp can hook into. dapps built top the protocol can access public liquidity pools create their own liquidity pool and charge transaction fees the resulting volume. the protocol unopinionated: does not impose costs its users arbitrarily extract value from one group users benefit another. decentralized governance used continuously and securely integrate updates into the base protocol without disrupting dapps end users. contents introduction existing work specification message format point-to-point orders broadcast orders smart contract signature authentication fills partial fills expiration time cancelling orders protocol token decentralized governance continuous integration token registry summary acknowledgements appendix erc token contract abi ethereum name service introduction blockchains have been revolutionary allowing anyone own and transfer assets across open financial network without the need for trusted third party. now that there are hundreds blockchainbased assets, and more being added every month, the need exchange these assets compounding. with the advent smart contracts, possible for two more parties exchange blockchain assets without the need for trusted third party. decentralized exchange important progression from the ecosystem centralized exchanges for few key reasons: decentralized exchanges can provide stronger security guarantees end users since there longer central party which can hacked, run away with customer funds subjected government regulations. hacks mt. gox, shapeshift and bitfinex have demonstrated that these types systemic risks are palpable. decentralized exchange will eliminate these risks allowing users transact trustlessly without middleman and placing the burden security onto individual users rather than onto single custodian. the two years that have passed since the ethereum blockchain's genesis block, numerous decentralized applications (dapps) have created ethereum smart contracts for peer-to-peer exchange. rapid iteration and lack best practices have left the blockchain scattered with proprietary and application-specific implementations. result, end users are exposed numerous smart contracts varying quality and security, with unique configuration processes and learning curves, all which implement the same functionality. this approach imposes unecessary costs the network fragmenting end users according the particular dapp each user happens using, destroying valuable network effects around liquidity. open protocol for decentralized exchange the ethereum blockchain. intended serve basic building block that may combined with other protocols drive increasingly sophisticated dapps []. uses publicly accessible system smart contracts that can act shared infrastructure for variety dapps, shown figure the long run, open technical standards tend win over closed ones, and more assets are being tokenized the blockchain each month, will see more dapps that require the use these different tokens. result, open standard for exchange critical supporting this open economy. ethereum blockchain dapp dapp shared liquidity pool(s) shared exchange protocol end users dapp figure open protocols should application-agnostic. decoupling the protocol layer from the application layer provides mutual benefits for dapp developers and end users alike. existing work decentralized exchanges implemented with ethereum smart contracts have failed generate significant volume due inefficiencies their design that impose high friction costs market makers. particular, these implementations place their order books the blockchain [-], requiring market makers spend gas each time they post, modify cancel order. while the cost single transaction small, frequently modifying orders response evolving market conditions prohibitively expensive. addition imposing high costs market makers, maintaining on-chain order book results transactions that consume network bandwidth and bloat the blockchain without necessarily resulting value transfer. automated market maker (amm) smart contracts are proposed alternative the on-chain order book. the amm smart contract replaces the order book with price-adjustment model which asset's spot price deterministically responds market forces and market participants either side the market trade with the amm rather than with each other. benefits the amm include availability (it always available act counterparty, though the spot price offers may worse than what one could get from more traditional exchange) and ease-of-integration with external smart contracts that need execute market orders. the deterministic nature price-adjustment models make them insensitive market liquidity, meaning that trades cause prices move the same amount both thick and thin markets []. other words, amms impose artificial constraints the supply curve. the price-adjustment model too sensitive, even small trades will produce large fluctuations the spot price. the price-adjustment model not sensitive enough, the amms bankroll will quickly depleted arbitrageurs. state channels are proposed means scaling the ethereum blockchain and reducing costs for variety applications including exchange moving transactions off the blockchain participants state channel pass cryptographically signed messages back and forth, accumulating intermediate state changes without publishing them the canonical chain until the channel closed. state channels are ideal for "bar tab" applications where numerous intermediate state changes may accumulated off-chain before being settled single on-chain transaction (i.e. day trading, poker, turn-based games). one the channel participants leaves the channel attempts cheat, there challenge period during which the other participant may publish the most recent message they received from the offender. follows that channel participants must always online challenge dishonest counterparty and the participants are therefore vulnerable ddos attacks. while state channels drastically reduce the number on-chain transactions for specific use cases, the numerous on-chain transactions and security deposit required open and safely close state channel make them inefficient for one-time transactions. hybrid implementation, which refer "off-chain order relay with on-chain settlement," combines the efficiency state channels with the near instant settlement on-chain order books. this approach, cryptographically signed orders are broadcast off the blockchain; interested counterparty may inject one more these orders into smart contract execute trades trustlessly, directly the blockchain friction costs are minimized for market makers because they can signal intent offchain and transactions only occur when value being transferred. extend this approach allowing anyone act the exchange and making the protocol application-agnostic. order book used publicly record the interest buyers and sellers particular financial instrument. each entry includes reference the interested party, the number shares and the price that the buyer seller are bidding/asking for the particular security. specification figure presents the general sequence steps used for off-chain order relay and on-chain settlement. for now ignore few mechanisms that will become important later. network transport layer maker taker maker account taker account dex token token ethereum blockchain figure off-chain order relay, on-chain settlement diagram. gray rectangles and circles represent ethereum smart contracts and accounts, respectively. arrows pointing ethereum smart contracts represent function calls; arrows are directed from the caller the callee. smart contracts can call functions within other smart contracts. arrows external the ethereum blockchain represent information flow. maker approves the decentralized exchange (dex) contract access their balance token maker creates order exchange token for token specifying desired exchange rate, expiration time (beyond which the order cannot filled), and signs the order with their private key. maker broadcasts the order over any arbitrary communication medium. taker intercepts the order and decides that they would like fill it. taker approves the dex contract access their balance token taker submits the makers signed order the dex contract. the dex contract authenticates makers signature, verifies that the order has not expired, verifies that the order has not already been filled, then transfers tokens between the two parties the specified exchange rate. see erc token appendix. possible provide approval once and execute unlimited number trades thereafter. alternatively, one can provide approval prior and limited the value each individual trade. message format each order data packet containing order parameters and associated signature. order parameters are concatenated and hashed bytes via the keccak sha function. the order originator signs the order hash with their private key produce ecdsa signature. point-to-point orders point-to-point orders allow two parties directly exchange tokens between each other using just about any communication medium they prefer relay messages. the packet data that makes the order few hundred bytes hex that may sent through email, facebook message, whisper any similar service. the order can only filled the specified taker address, rendering the order useless for eavesdroppers outside parties. name version maker taker tokena tokenb valuea valueb expiration table message format for point-to-point orders. data type description address the exchange smart contract. address this address will change each time the protocol updated. address address originating the order. address address permitted fill the order. address address erc token contract. address address erc token contract. uint total units tokena offered maker. uint total units tokenb requested maker. uint time which the order expires (seconds since unix epoch). uint ecdsa signature the above arguments. bytes bytes broadcast orders for liquid markets emerge, there must public locations where buyers and sellers may post orders that are subsequently aggregated into order books i.e. exchanges. building and operating exchange costly and the protocol have described far does not provide incentive for someone take such expense. broadcast orders solve this issue allowing anyone act exchange, maintain order book (public private) and charge transaction fees all resulting liquidity. refer entities that host and maintain order book relayers rather than exchanges. where exchange must build and operate proprietary infrastructure, execute trades and handle user funds, relayers merely facilitate signalling between market participants hosting and propagating order book that consists generic messages. relayers not execute trades behalf market participants this would require market participants trust the relayer. instead, takers execute their own trades. the message format for broadcast orders includes two changes the point-to-point message format facilitate public exchange and incentivize relayers. first, broadcast orders not specify taker address, allowing broadcast order filled anyone that happens intercept it. second, broadcast orders include feea, feeb, and feerecipient parameters which specify transaction fee values and address used relayer collect transaction fees. the exchange smart contract transfers these fees feerecipient and when order filled. figure presents the sequence steps makers and relayers use negotiate transaction fees trustless way. order book relayer maker takers ethereum blockchain figure relayers host and maintain off-chain order book exchange for transaction fees. this diagram illustrates off-chain order relay and the sequence steps used makers and relayers negotiate transaction fees trustless way. transaction fees are moved from the maker and/or taker the relayer upon settlement trade, extending the on-chain settlement process shown figure relayer cites fee schedule and the address they use collect transaction fees. maker creates order, setting feea and feeb values that satisfy relayer's fee schedule, setting feerecipient relayer's desired recieving address and signs the order with their private key. maker transmits the signed order relayer. relayer receives the order, checks that the order valid and that provides the required fees. the order invalid does not meet relayer's requirements, the order rejected. the order satisfactory, relayer posts the order their order book. takers recieve updated version the order book that includes maker's order. taker fills maker's order submitting the exchange contract the ethereum blockchain. name version maker tokena tokenb valuea valueb expiration feerecipient feea feeb table data type address address address address uint uint uint address uint uint uint bytes bytes message format for broadcast orders. description address the exchange smart contract. address originating the order. address erc token contract. address erc token contract. total units tokena offered maker. total units tokenb requested maker. time which the order expires (seconds since unix epoch). address relayer. receives transaction fees. total units protocol token maker pays feerecipient. total units protocol token taker pays feerecipient. ecdsa signature the above arguments. while may seem odd that the maker specifying the transaction fees, keep mind that relayers ultimately have control over which orders get posted. therefore, the maker wants their order posted specific order book, they must set feea, feeb, and feerecipient values that satisfy the relayer associated with that order book. since fees are negotiated off-chain, relayers may change fee schedule dynamically and their own discretion (for incoming orders that haven't been signed yet, not for existing orders). relayers may use information that available on-chain off-chain setting and adjusting fees, allowing for flexible fee schedules (flat fees, percentage based, volume based, tiered, subscription models, etc). however, once the relayer has accepted order onto their order book, the order's fee values cannot changed. conventional exchange services use matching engine fill market orders behalf their users and users must trust that the exchange will provide them with the best available price. generally, users can feel assured that these regulated entities will held accountable they attempt cheat the event that matching engine malfunctions. for protocol remain trustless, relayers cannot given the ability execute trades behalf makers and takers. instead, relayers can only recommend best available price takers who must then independently decide sign and send the transaction the blockchain. this means that protocol cannot support true market orders, however, well designed web application can approximate this type user experience. important recognize that the feerecipient address can point any arbitrary smart contract. this means that complex relayer incentive structures can "plugged in" protocol. for example, feerecipient contract could designed split transaction fees between multiple relayers distribute transaction fees across swarm nodes according the level contribution each node makes propagating order book within censorship-resistant network development low-latency relay protocol that supports fully distributed order book being considered for the next phase this project. smart contract the exchange protocol implemented within ethereum smart contract that publicly accessible and free use (no additional costs are imposed users beyond standard gas costs). written the solidity programming language and contains two relatively simple functions: fill and cancel. the entire contract approximately lines code and costs approximately gas fill order. signature authentication the exchange smart contract able authenticate the order originator's (maker's) signature using the ecrecover function, which takes hash and signature the hash arguments and returns the public key that produced the signature. the public key returned ecrecover equal the maker address, the signature authentic. address publickey ecrecover( hash, signature( hash publickey maker throw; fills partial fills the exchange smart contract stores reference each previously filled order prevent single order from being filled multiple times. these references are stored within mapping; data structure that, this case, maps byte chunk data bit unsigned integer. passing the parameters associated with order into the keccak sha function produces unique byte hash that may used uniquely identify that order (the odds hash collision, finding two different orders with identical hash, are practically zero). each time order filled, the mapping stores the order hash and the cumulative value filled. taker may partially fill order specifying additional argument, valuefill, when calling the exchange smart contract's fill function. multiple partial fills may executed single order long the sum the partial fills does not exceed the total value the order. table takers must provide additional argument when attempting fill order. name data type description valuefill uint total units tokena filled (valuefill valuea). expiration time order's expiration time specified the maker the time the order signed. the expiration time unsigned integer value that represents the absolute number seconds since the unix epoch. this value cannot changed once has been signed. time within the ethereum virtual machine given block timestamps that are set each time new block mined. therefore, the expiration status order does not depend upon the time which taker broadcasts their intention fill order, instead depends upon the time which the fill function being executed the evm miner. miner cannot set the block timestamp the current block earlier than the timestamp the previous block. cancelling orders unfilled and unexpired order may cancelled the associated maker via the exchange smart contract's cancel function. the cancel function maps order's hash the order's maximum value (valuea), preventing subsequent fills. cancelling order costs gas and, therefore, the cancel function only intended serve fallback mechanism. typically, makers are expected avoid on-chain transactions setting their order expiration times match the frequency with which they intend update their orders. one issue with this approach that can create situations where maker attempts cancel their order roughly the same time taker attempting fill that same order. one the two parties transactions will fail, wasting gas, depending upon the sequence which the two transactions are mined. uncertainty regarding the sequence which transactions are mined could lead undesirable outcomes times. this uncertainty could increase the ethereum blockchain were experience significant backlog pending transactions. protocol token cryptoeconomic protocols create financial incentives that drive network rational economic agents coordinate their behavior towards the completion process while fundamentally network protocol used facilitate signalling between buyers and sellers (rather than cryptoeconomic protocol), intended serve open standard for dapps that incorporate exchange functionality. establishing and maintaining open standard coordination problem that adds operational overhead for all contributing parties; coordination can especially challenging when each party has different needs and financial incentives. protocol tokens can align financial incentives and offset costs associated with organizing multiple parties around single technical standard. while aligning incentives around adoption useful, protocol tokens can used address much more challenging issue: future-proofing protocol implemented within immutable system smart contracts via decentralized governance. decentralized governance continuous integration once ethereum smart contract deployed the blockchain its internal logic can't changed. therefore, update protocol one must deploy completely new smart contract that either forks the network disrupts users and processes that depend the protocol until they "opt-in" the newest version. the context exchange, disruptive protocol update could invalidate all open orders and require each market participant approve new smart contract access their trading balances. alternatively, the protocol could fork into two versions that operate parallel, neutralizing network effects created dapp interoperability. while smart contract abstraction may used continuously integrate updates into protocol without disrupting higher-level processes, such update mechanism can also create significant security risks for end users (in the worst case, attacker could gain access user funds). protocol tokens may used drive decentralized update mechanism that allows for continuous integration updates into the protocol while also protecting the protocol's users and stakeholders. will deployed the ethereum blockchain with fixed supply protocol tokens that will issued partnering dapps and future end users. protocol tokens will have two uses: for market participants pay transaction fees relayers and for decentralized governance over updates the protocol. decentralized governance will used securely integrate updates into protocol according the process shown figure initially, simple multi-signature contract will used for decentralized governance until more sophisticated dao developed. protocol and its native token will not impose unecessary costs users, seek rent extract value from relayers. the protocol's smart contracts will publicly accessible and completely free use. mechanisms will put place benefit one group the expense another. stakeholders ethereum blockchain dao dapp dex dex token proxy end users token dapp figure protocol updates may deployed without disrupting the network through combination contract abstraction and decentralized governance. end users provide proxy contract with access the tokens they plan trading. stakeholders propose and elect protocol improvements that are implemented within entirely new smart contracts (dex via dao. the dao authorizes new smart contract(s) access user tokens adding them the proxy contract's whitelist and eventually unlists deprecated versions the protocol. token registry orders consist hexadecimal bytecode that machine-readable but that isn't necessarily easy for human visually interpret. token registry contract will used store list erc tokens with associated metadata for each token: name, symbol, contract address, and the number decimal places needed represent token's smallest unit (needed determine exchange rates). the registry will serve official on-chain reference that may used market participants independently verify token addresses and exchange rates before executing trade. since the token registry will serve trusted source information, oversight will required add, modify remove tokens from the registry. stakeholders will provide this oversight. while the token registry will make easy for users verify the integrity their orders, protocol can used trade any token that uses the erc token interface. the future, the protocol's order format can modified facilitate human-readability. tokens may identified three character symbol registered the token registry rather than the token's contract address. the ethereum name service (ens) can used identify makers, takers and relayers human-readable names, such "thedunkle.eth", rather than account contract address. https://github.com/ethereum/eips/issues/ summary off-chain order relay on-chain settlement low friction costs for market makers fast settlement. publicly accessible smart contracts that any dapp can hook into. relayers can create their own liquidity pools and charge transaction fees volume. standardization decoupling shared protocol layer provides interoperability between dapps creates network effects around liquidity that are mutually beneficial reduces barriers-to-entry, driving down costs for market participants eliminates redundancy, improves user experience and smart contract security decentralized update mechanism allows improvements continuously and safely integrated into the protocol without disrupting dapps end users. acknowledgements would like express our gratitude our mentors, advisors and the many people the ethereum community that have been welcoming and generous with their knowledge. particular, would like thank joey krug, linda xie and fred ehrsam for reviewing, editing and providing feedback this work. would also like thank the organizers and community members that we've met the silicon valley ethereum meetup including joseph chow, martin koppelmann, rebecca migirov, gustav simonsson, grant hummer, tom ding and the string labs folks and many others. appendix erc token erc establishes standard contract abi for tokens the ethereum blockchain and has become the facto representation for all types digital assets. erc tokens share the same contract interface, simplifying integration with external contracts. core erc functions include: transfer(to, value) balanceof(owner) approve(spender, value) allowance(owner, spender) transferfrom(from, to, value) eip includes proposal change ether follow the erc token standard. for now, "wrapper" smart contract may used proxy for erc ether. for reference, see the maker implementation the gnosis implementation. contract abi eip proposes extension the contract abi support structs. this would allow the community establish standard order and signature data structures, simplifying our contract interface and integrations with external contracts. ethereum name service eip ethereum name service (ens) will used resolve human-readable names, such "myname.eth," into machine-readable identifiers that may represent ethereum addresses, swarm and/or ipfs content hashes other identifiers. can also used associate metadata with names, such contract abis whois information. ens will used protocol create more intuitive message formats that optionally reference makers, takers and relayers name. references coinmarketcap. https://coinmarketcap.com/all/views/all/. accessed: --. wikipedia: mt. gox. https://en.wikipedia.org/wiki/mt.gox. accessed: --. timeline: shapeshift hacking incident. https://info.shapeshift.io/blog////timelineshapeshift-hacking-incident. accessed: --. will warren. the difference between https://medium.com/@willwarren, app coins and protocol tokens. maker market. https://mkr.market/. accessed: --. etheropt. https://etheropt.github.io/. accessed: --. augur. https://augur-dev.firebaseapp.com/. accessed: --. intrinsically tradable tokens. https://www.reddit.com/r/ethereum/... accessed: --. euler. https://www.reddit.com/r/ethereum/... accessed: --. galia benartzi guy benartzi, eyal hertzog. bancor protocol: hierarchical monetary system and the foundation global decentralized autonomous exchange. abraham othman, david pennock, daniel reeves, and tuomas sandholm. practical liquidity-sensitive automated market maker. acm transactions economics and computation, ():, raidex. http://www.raidex.io/. accessed: --. jeff coleman. state channels. http://www.jeffcoleman.ca/state-channels/. accessed: --. ledger labs: state channels wiki. https://github.com/ledgerlabs/state-channels/wiki. accessed: --. idex, decentralized capital. http://www.idex.market/. accessed: --. etherdelta. https://etherdelta.github.io/. accessed: --. fred ehrsam. app coins https://blog.coinbase.com, and the dawn the decentralized business model. fred ehrsam. how raise money blockchain with token. https://blog.gdax.com,