quantum resistant ledger (qrl) info@theqrl.org october (revised) abstract private digital monies must secure against computing advances achieve longevity. the design and issuance cryptocurrency ledger utilising hash-based digital signatures which are resistant classical and quantum computing attack presented. introduction the concept peer-to-peer internet ledger value, recorded blockchain and secured proof work was first reported []. bitcoin remains the most widely used cryptocurrency date. hundreds similar cryptocurrency ledgers have been subsequently created but with few exceptions they rely the same elliptic curve public-key cryptography (ecdsa) generate digital signatures which allow transactions verified securely. the most commonly used signature schemes today such ecdsa, dsa and rsa are theoretically vulnerable quantum computing attack. would valuable explore the design and construction quantum resistant blockchain ledger counter the potential advent sudden non-linear quantum computing advance. bitcoin transaction security currently only possible spend (unspent transaction outputs) from bitcoin address creating transaction containing valid elliptic curve (secpk) signature from the private key the general idea the winternitz one-time signature apply iterating hash function list random secret keys, (sk .., skm/w creating chains hashes length, ending with public keys, (pk |{, pkx (skx (pk .., pkm/w unlike the bitwise inspection the message digest the lamport signature, instead the message parsed bits time extract number, (usually }), computed. the number bit string elements wots+ key signature, where log log (w) log (w) keyed hash function used, pseudocode: hash(p ad(k)||p ad(m where ad(x) (x||b-|x|- for |x| defined follows: figure w-ots+ chaining function where: (x, (ck (x, figure example hash-chain generation that bitwise xor the previous iteration and the randomisation element followed the result, which then fed into the next iteration signature key create the secret key, sk, bit strings are chosen uniformly random (with prf), which the first make the secret key, (sk ..skl and the remaining bit strings become .., rw- function key, chosen uniformly random. verification key the public key is: (pk .., pkl ((r, k), cw- (sk r), cw- (sk r), .., cw- (skl r)) note that contains and signing perform signature: message, length parsed such that ..ml (creating base-w representation m). next the checksum, length, calculated and appended: such that: ..bl the signature is: .., (cbki (sk r), .., cbkl (skl r)) verification verify signature .., reconstructed from (ckw--b .., cw--b (sl then the signature valid. w-ots+ provides security level least log(lw) bits[]. typical signature where using sha- bits .kb. merkle tree signature schemes whilst one-time signatures provide satisfactory cryptographic security for signing and verifying transactions they have major drawback that they may only used once safely. ledger address based upon some transformation the public key single ots keypair then this would lead extremely restrictive blockchain ledger where all funds from sending address would need move with every single transaction performed those funds would risk theft. solution extend the signature scheme incorporate more than one valid ots signature for each ledger address allowing many signatures ots keypairs are pre-generated. binary hash tree known merkle tree logical way achieve this. binary hash tree the general idea behind merkle tree inverted tree composed parent nodes computed hashing the concatenation child sibling nodes upwards layers the root. the existence any node leaf can cryptographically proven computing the root. merkle tree formed from base leaves and has height merkle root, starting from the leaf hashes (layer and counting upwards with each layer nodes. each leaf node created our hypothetical ledger use-case hashing randomly pre-generated ots public key. from the tree below can seen that the node above each pair leaf hashes itself formed hashing concatenation the child hashes. figure merkle tree signature scheme example this continues upwards through layers the tree until confluence into the root hash the tree, known the merkle root. from the example tree the diagram, taking the merkle root the public key, four pre-computed ots keypairs can used generate four cryptographically secure valid one-time signatures. the merkle root the binary hash tree can transformed into ledger address (possibly iterative hashing with appended checksum). full signature, message, for given ots keypair includes: the signature, the ots key number, and the merkle authentication path. i.e. for ots keypair (thus public key root given the ots public key and leaf hash can deduced from and parent nodes can computed from their children fact this may shortened to: root where valid verifying the ots public key from and then checking the hashes from the merkle authentication path recreate matching merkle root (public key). state using the above merkle signature scheme (mss) securely relies upon not re-using the ots keys. therefore, dependent upon the state signatures signed transactions being recorded. ordinarily real world usage this would potentially problem, but immutable public blockchain ledger the ideal storage medium for stateful cryptographic signature scheme. newer hash-based cryptographic signature scheme called sphincs which offers practical stateless signatures with bit security was reported []. hypertrees problem with the basic mss that the number signatures possible limited and all the ots keypairs must pre-generated prior calculation the merkle tree. key generation and signature time grow exponentially with the height the tree, meaning trees larger than ots keypairs becomes temporally and computationally expensive generate. strategy defer computation during key and tree generation and also extend the number ots keypairs available use tree which itself composed merkle trees called hypertree. the general idea sign the merkle root child tree with ots key from the leaf hash parent merkle tree known certification tree. figure linking merkle trees the most simple form (height, certification tree precomputed with ots keypairs and when the first signature required new signature merkle tree (signature tree computed and signed one the certification tree ots keypairs. the signature tree composed leaf hashes with corresponding ots keypairs and these serve sign messages required. when each ots keypair the signature tree has been used then the next signature tree (signature tree signed the second ots keypair from the certification tree and the next batch signatures possible. signature, such hypertree construction becomes slightly more complicated and would include: from the signature tree: merkle path, root from each certification tree: (of child tree merkle root), merkle path, root theoretically possible nest layers trees down from the certification tree extend the original mss infinitely. signature size grows linearly for each additional tree that signed, whilst the hypertree signature capacity increases exponentially. hypertree examples demonstrate how easily the mss may extended with hypertree construction consider initial certification tree height, with leaf hashes and associated ots keypairs. the merkle root this tree transformed generate ledger address. another merkle tree, signature tree identical size leaves and ots keypairs) instantiated. signatures are possible before the next signature tree must created. the total number signatures possible which this case macbook pro .ghz ram creating ots keypairs and merkle certification tree for various sizes yielded the following results (unoptimised python code, winternitz ots): .s, .s, .s, .s. hypertree consisting initial generation two trees takes around compared with for standard mss tree for the same signature capacity. increasing the depth (or height) hypertree continues this trend. hypertree composed four chained certification trees and signature tree size capable signatures with added cost the signature size but creation time only .s. figure hypertree construction there requirement for hypertree symmetrical and composed initially two trees could later extended later signing further layers trees. signatures from ledger address would therefore start small and eventually rise the hypertree depth increased. using merkle hypertree create and sign transactions from ledger address never likely require transactions. thus, the ability sign with computational ease times securely hypertree depth more than sufficient. xmss the extended merkle signature scheme (xmss) was first reported buchmann al. and was published ietf draft last year[][]. provably forward secure and existentially unforgeable under chosen message attacks with minimal security requirements: prf and second pre-image resistant hash function. the scheme allows extension one-time signatures via merkle tree with major difference being the use bitmask xor the child nodes prior concatenation the hashes into the parent node. the use the bitmask xor allows the collision resistant hash function family replaced. figure the xmss tree construction the leaves the tree are also not ots keypair hashes but the root child l-trees which hold the ots public keys with, pieces forming the base leaves. winternitz ots+ used for the one-time signatures (though variant was first described). figure xmss construction the bit length the xmss public key ((h dlogle) )n, xmss signature has length h)n, and the length the xmss secret signature key buchmann reports performance with intel(r) ghz for xmss tree height, where and the cryptographic hash function used sha- around million signatures. with the same parameters and hardware, signing took ms, verification .ms and key generation seconds. the security level achieved with such parameters was bits for public key size .kb, private key bits and signature .kb. xmss attractive scheme with the main drawback being the extremely long key generation time. xmss tree performance using unoptimised python library constructed for qrl testnode formation leaf xmss tree (h=) with all keys and bitmasks generated from hash-based prf took the same hardware described above macbook pro .ghz ram). this included generation via prf more than bitmasks and over fragments. more efficient merkle tree traversal algorithm and the need only perform hashes per secret key chain function wots+ rather than with wots contribute the dramatic performance improvement over conventional mss. complete signature size around .kb was achieved this construction (.kb hexadecimal string encoding) including the: ots keypair signature, xmss auth route, ots public key and the xmss tree public key (including prf public key seed and the xmss tree root). for trees various signature capacities generated using prf and random seed, the following performance was obtained: (h=) .s, (h=) .s, (h=) .s. proposed signature scheme security requirements the design the qrl important that the cryptographic security the signature scheme secure against classical and quantum computing attack both present day and also future decades. xmss using sha-, where offers bit security with predicted safety against brute force computational attack until the year []. qrl signatures extensible stateful asymmetrical hypertree signature scheme composed chained xmss trees proposed. this has the dual benefit utilising validated signature scheme and allowing generation ledger addresses with the ability sign transactions avoiding lengthy pre-computation delay seen with giant xmss constructions. w-ots+ the chosen hash-based one-time signature the scheme for both security and performance reasons. hypertree construction key and signature sizes the number trees within hypertree grows, key and signature sizes grow linearly but signature capacity rises exponentially. sizes for various xmss tree derived public keys and signatures (based upon description), where tree height and sha- chosen the cryptographic hash algorithm, are: signatures: public key .kb, signature .kb (.s) signatures: public key .kb, signature .kb (.s) signatures: public key .kb, signature .kb (s) signatures: public key .kb, signature .kb (s[]) the trade-off for creating xmss hypertree trees, with eventual signature capacity less than compared with for signature .kb instead .kb may acceptable. asymmetry creating asymmetrical tree allows early signatures take place with with single xmss tree construction, which extended required for later signatures cost overall signature capacity. the rationale that this likely consequence for blockchain ledger application and the wallet can give user option signature capacity versus signature/key sizes. maximum tree depth should suffice for all circumstances. figure asymmetrical hypertree qrl hypertree specification the following default parameters are adopted for standard hypertree construction: }), }), upper bound signatures possible: minimum signature size: .kb, maximum signature size: .kb. i.e. single xmss tree, with signatures available, which may extended with further trees required. for most users additional trees are unlikely required all. example qrl signature assuming the most complicated hypertree construction where and signature for transaction message, where the ots keypair position for each xmss tree, would require: signature tree, ots signature merkle authentication proof, merkle root signature tree certification tree, ots signature merkle root from signature tree merkle authentication proof, merkle root original xmss tree, ots signature merkle root merkle authentication proof, merkle root verification involves generating the ots public key from and the signature, then confirming the supplied merkle authentication proof generates the signature tree merkle root. this becomes the message for the next ots signature and from this the next ots public key generated, the supplied merkle authentication proof used recreate the certification tree merkle root, which becomes the message for the next certification tree ots signature, and on. signature only valid the merkle root the highest tree, the original xmss tree, correctly generated. notice the ots public keys are not required for verification the xmss tree signature. fact the merkle root for each tree can also deduced and therefore omitted with hypertree signature verification the sending ledger address known (as this computed derivative the merkle root for the highest xmss certification tree within the qrl signature see accounts later). the signature scheme stateful the wallet implementation must retain and update for each xmss tree generated the hypertree for given address. prf prf from seed. hmac drbg. deterministic wallet using single seed possible generate very large xmss tree which should suffice for most users for prolonged period. secure source entropy used generate this seed which passed through secure prf function generate set pseudorandom keys which generate the tree. one drawback using the same xmss tree that the user confined single address (although public key exposure not concern with mss). bitcoin ethereum address derived from the associated public key and such single private public key may only create single address. however, xmss address derived from the public key, pk, which contains the merkle root and public seed. the seed remains constant but the number ots keypairs compute the tree varies then the merkle root will change for each variation. thus for every single addition subtraction single ots keypair the derived address will change. this feature may used wallet/node software generate numerous variations the xmss tree (extending/contracting required using the same initial seed) allowing many unique addresses required generated. record this information safe, stateful and compact manner computationally trivial. cryptocurrency design parameters the remainder the white paper will set out the proposed design parameters for the qrl ledger. the focus the ledger public blockchain which highly secure against classical and quantum computing attack vectors. this first draft and thus every aspect subject potential change. fees the larger transaction sizes compared with other ledgers necessitates transaction fee must paid with each transaction. the author the opinion that artificial fee markets (see bitcoin) are unnecessary and run counter the ideal open public blockchain ledger. each transaction pays minimum fee should valid any other. the minimum fee miners are willing accept should float and set the market. i.e. nodes/miners competitively set the lower bound fees between themselves. absolute minimum value will enforced protocol level. thus, miners will order transactions from the mempool for inclusion block their discretion. blocks block-times bitcoin has time between blocks roughly minutes, but with natural variance this can occasion lead fairly long periods before the next block mined. newer ledger designs such ethereum have improved upon this and benefit from much shorter block-times seconds) without the loss security miner centralisation from high rates orphan/stale blocks. ethereum uses modified version the greedy heaviest observed subtree protocol which allows stale/orphan blocks included the blockchain and rewarded[, the qrl plans safely use block-time seconds. block-rewards each new block created will include first 'coinbase' transaction containing mining address into which reward equal the sum the coinbase reward and the combined sum transaction fees within the block. the block-reward re-calculated the mining node every block and follows the coin emission schedule. blocksize avoid controversy out-of-the-box adaptive solution modelled upon the bitpay proposal increase the blocksize based upon multiple, the median size, the last blocks would employed[]. the use the median prevents gaming miners include either empty overstuffed blocks alter the mean blocksize. and would then hard consensus rules for the network obey. thus, maximum blocksize, could simply calculated as: currency unit and denominations the qrl will use monetary token, the quantum (plural quanta), the base currency unit. each quantum divisible smallest element follows: quantum (plural: quanta) shor thus, each transaction involving fraction quantum actually very large integer shor units. transaction fees are paid and calculated shor units. accounts qrl address designed extensible and supports wide range formats. the first three bytes any address (descriptor) encode information describe the hash function, signature scheme, address format, and additional parameters. typical account address represented follows: qdcf bceddcedf dcf eccdeabd structure qrl addresses are structured the following way: name bytes count description desc data address descriptor will depend the address format the moment, only one address format supported: sha when using sha qrl address composed bytes. this the internal format used any api module the project. for representational purposes (i.e. user interface, debugging, logs), possible that the address represented hexstring prefixed with hexadecimal characters). this appropriate for user related purposes but will rejected the api. name bits count description desc hash verh hash function sha (desc+pk) sha (desc+hash) (only last bytes) pythonic pseudocode this represented follows: desc[: hash[: erh[: descriptor name bits count description sig hash function signature scheme parameters (ie. height, etc.) address format parameters the case using ss, the parameters are used follows: name bits count description sig sha-, shake, shake xmss xmss height address format not used sig signature type value description xmss reserved future expansion value description sha shake shake reserved future expansion value description sha reserved future expansion hash function address format coin issuance issuance the qrl initial issuance will the following: initial supply: quanta allocated for foundation: quanta initial total supply: quanta eventual total supply: quanta distributed via exponential decay emission schedule over approximately years) coin emission schedule defining feature bitcoin the scarcity and fixed upper limit issuance the underlying monetary token. qrl will follow bitcoin this regard with fixed upper limit the coin supply quanta. smoothly exponential decay the block-reward favoured the hard ceiling coin supply. this will eliminate the volatility associated with the bitcoin 'halving' phenomenon. the total coin supply, minus coins created the genesis block, will exponentially reduce from downwards forever. the decay curve assumes the distribution rewards for approximately years (until ad, blocks generated approximate rate block every seconds). the remaining coin supply block may calculated with: e-lt the coefficient, calculated from: lnz where the total number blocks the emission schedule until the final quanta. the block reward, calculated for each block with: zt- references http://oxt.me/charts. bernstein. sphincs: practical stateless hash-based signatures. buchmann. the security the winternitz one-time signature scheme. buchmann. xmss practical forward secure signature scheme based minimal security assumptions. buterin. ethereum whitepaper. hulsing. w-ots+ shorter signatures for hash-based signature schemes. hulsing. xmss: extended hash-based signatures. karina. efficient software implementation the hash-based signature scheme mss and its variants. lenstra. selecting cryptographic key sizes. merkle. certified digital signature. crypto, nakamoto. bitcoin: peer-to-peer electronic cash system. pair. simple, adaptive blocksize limit. yonatan sompolinsky. accelerating bitcoin's transaction processing fast money grows trees, not chains. toshi. the birthday paradox.