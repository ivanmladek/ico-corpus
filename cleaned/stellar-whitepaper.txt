the stellar consensus protocol: federated model for internet-level consensus david mazieres, stellar development foundation this paper introduces new model for consensus called federated byzantine agreement (fba). fba achieves robustness through quorum slices--individual trust decisions made each node that together determine system-level quorums. slices bind the system together much the way individual networks' peering and transit decisions now unify the internet. also present the stellar consensus protocol (scp), construction for fba. like all byzantine agreement protocols, scp makes assumptions about the rational behavior attackers. unlike prior byzantine agreement models, which presuppose unanimously accepted membership list, scp enjoys open membership that promotes organic network growth. compared decentralized proof of-work and proof-of-stake schemes, scp has modest computing and financial requirements, lowering the barrier entry and potentially opening financial systems new participants. ccs concepts: *security and privacy distributed systems security; security protocols; additional key words and phrases: byzantine fault tolerance, asynchronous systems introduction financial infrastructure currently mess closed systems. gaps between these systems mean that transaction costs are high [provost and money moves slowly across political and geographic boundaries [banning-lover cgap this friction has curtailed the growth financial services, leaving billions people underserved financially [demirguc-kunt al. solve these problems, need financial infrastructure that supports the kind organic growth and innovation we've seen from the internet, yet still ensures the integrity financial transactions. historically, have relied high barriers entry ensure integrity. trust established financial institutions and our best regulate them. but this exclusivity conflicts with the goal organic growth. growth demands new, innovative participants, who may possess only modest financial and computing resources. need worldwide financial network open anyone, that new organizations can join and extend financial access unserved communities. the challenge for such network ensuring participants record transactions correctly. with low barrier entry, users won't trust providers police themselves. with worldwide reach, providers won't all trust single entity operate the network. compelling alternative decentralized system which participants together ensure integrity agreeing the validity one another's transactions. such agreement hinges mechanism for worldwide consensus. this paper presents federated byzantine agreement (fba), model suitable for worldwide consensus. fba, each participant knows others considers important. waits for the vast majority those others agree any transaction before considering the transaction settled. turn, those important participants not agree the transaction until the participants they consider important agree well, and on. eventually, enough the network accepts transaction that becomes infeasible for attacker roll back. only then any participants consider the transaction settled. fba's consensus can ensure the integrity financial network. its decentralized control can spur organic growth. this paper further presents the stellar consensus protocol (scp), construction for fba. prove that scp's safety optimal for asynchronous protocol, that guarantees agreement under any node-failure scenario that admits such guarantee. draft february mazieres also show that scp free from blocked states--in which consensus longer possible--unless participant failures make impossible satisfy trust dependencies. scp the first provably safe consensus mechanism enjoy four key properties simultaneously: decentralized control. anyone able participate and central authority dictates whose approval required for consensus. low latency. practice, nodes can reach consensus timescales humans expect for web payment transactions--i.e., few seconds most. flexible trust. users have the freedom trust any combination parties they see fit. for example, small non-profit may play key role keeping much larger institutions honest. asymptotic security. safety rests digital signatures and hash families whose parameters can realistically tuned protect against adversaries with unimaginably vast computing power. scp has applications beyond financial markets for ensuring organizations perform important functions honestly. example certificate authorities (cas), who literally hold the keys the web. experience shows that cas sign incorrect certificates that get used the wild [microsoft langley several proposals address this problem through certificate transparency [kim al. laurie al. basin al. melara al. certificate transparency allows users examine the history certificates issued for any given entity and detect attempts cas change entity's public key without the endorsement the previous key. scp holds the potential strengthen the indelible certificate history the core certificate transparency. demanding global consensus certificate history among decentralized group auditors would make harder backpedal and override previously issued certificates. the next section discusses previous approaches consensus. section defines federated byzantine agreement (fba) and lays out notions safety and liveness applicable the fba model. section discusses optimal failure resilience fba system, thereby establishing the security goals for scp. section develops federated voting, key building block the scp protocol. section presents scp itself, proving safety and freedom from blocked states. section discusses limitations scp. finally, section summarizes results. for readers less familiar with mathematical notation, appendix defines some symbols used throughout the paper. related work figure summarizes how scp differs from previous consensus mechanisms. the most famous decentralized consensus mechanism the proof-of-work scheme advanced bitcoin [nakamoto bitcoin takes two-pronged approach consensus. first, provides incentives for rational actors behave well. second, settles transactions through proof-of-work [dwork and naor algorithm designed protect against ill-behaved actors who not possess the majority the system's computing power. bitcoin has overwhelmingly demonstrated the appeal decentralized consensus [bonneau al. proof work has limitations, however. first, wastes resources: one estimate from bitcoin might consume much electric power the entire country ireland [o'dwyer and malone second, secure transaction settlement suffers from expected latencies the minutes tens minutes [karame al. finally, contrast traditional cryptographic protocols, proof work offers asymptotic security. given non-rational attackers--or ones with extrinsic incentives sabotage the stellar consensus protocol mechanism proof work proof stake byzantine agreement tendermint scp (this work) decentralized control low latency maybe flexible trust asymptotic security maybe fig. properties different consensus mechanisms consensus--small computational advantages can invalidate the security assumption, allowing history re-written so-called attacks." worse, attackers initially controlling less than computation can game the system provide disproportionate rewards for those who join them [eyal and sirer thereby potentially gaining majority control. the leading digital currency backed the most computational power, bitcoin enjoys measure protection against attacks. smaller systems have fallen victim [crazyearner bradbury however, posing problem for any proof-of-work system not built the bitcoin block chain. alternative proof work proof stake [king and nadal which consensus depends parties that have posted collateral. like proof work, rewards encourage rational participants obey the protocol; some designs additionally penalize bad behavior [buterin davarpanah al. proof stake opens the possibility so-called "nothing stake" attacks, which parties that previously posted collateral but later cashed and spent the money can back and rewrite history from point where they still had stake. mitigate such attacks, systems effectively combine proof stake with proof work--scaling down the required work proportion stake--or delay refunding collateral long enough for some other (sometimes informal) consensus mechanism establish irreversible checkpoint. still another approach consensus byzantine agreement [pease al. lamport al. the best known variant which pbft [castro and liskov byzantine agreement ensures consensus despite arbitrary (including non-rational) behavior the part some fraction participants. this approach has two appealing properties. first, consensus can fast and efficient. second, trust entirely decoupled from resource ownership, which makes possible for small non-profit help keep more powerful organizations, such banks cas, honest. complicating matters, however, all parties must agree the the exact list participants. moreover, attackers must prevented from joining multiple times and exceeding the system's failure tolerance, so-called sybil attack [douceur bft-cup [alchieri al. accommodates unknown participants, but still presupposes sybil-proof centralized admission-control mechanism. generally, membership byzantine agreement systems set central authority closed negotiation. prior attempts decentralize admission have given some the benefits. one approach, taken ripple, publish "starter" membership list that participants can edit for themselves, hoping people's edits are either inconsequential reproduced overwhelming fraction participants. unfortunately, because divergent lists invalidate safety guarantees [schwartz al. users are reluctant edit the list practice and great deal power ends concentrated the maintainer the starter list. another approach, taken tendermint [kwon base membership proof stake. however, doing once again ties trust resource mazieres ownership. scp the first byzantine agreement protocol give each participant maximum freedom chosing which combinations other participants trust. federated byzantine agreement systems this section introduces the federated byzantine agreement (fba) model. like nonfederated byzantine agreement, fba addresses the problem updating replicated state, such transaction ledger certificate tree. agreeing what updates apply, nodes avoid contradictory, irreconcilable states. identify each update unique slot from which inter-update dependencies can inferred. for instance, slots may consecutively numbered positions sequentially applied log. fba system runs consensus protocol that ensures nodes agree slot contents. node can safely apply update slot when has safely applied updates all slots upon which depends and, additionally, believes all correctly functioning nodes will eventually agree for slot this point, say has externalized for slot the outside world may react externalized values irreversible ways, node cannot later change its mind about them. challenge for fba that malicious parties can join many times and outnumber honest nodes. hence, traditional majority-based quorums not work. instead, fba determines quorums decentralized way, each node selecting what call quorum slices. the next subsection defines quorums based slices. the following subsection provides some examples and discussion. finally, define the key properties safety and liveness that consensus protocol should hope achieve. quorum slices consensus protocol, nodes exchange messages asserting statements about slots. assume such assertions cannot forged, which can guaranteed nodes are named public key and they digitally sign messages. when node hears sufficient set nodes assert statement, assumes functioning node will ever contradict that statement. call such sufficient set quorum slice, or, more concisely, just slice. permit progress the face node failures, node may have multiple slices, any one which sufficient convince statement. high level, then, fba system consists loose confederation nodes each which has chosen one more slices. more formally: definition (fbas). federated byzantine agreement system, fbas, pair comprising set nodes and quorum function specifying one more quorum slices for each node, where node belongs all its own quorum slices--i.e., q(v), (note denotes the powerset x.) definition (quorum). set nodes fbas quorum iff and contains slice for each member--i.e., q(v) such that quorum set nodes sufficient reach agreement. quorum slice the subset quorum convincing one particular node agreement. quorum slice may smaller than quorum. consider the four-node system figure where each node has single slice and arrows point the other members that slice. node slice sufficient convince statement. but and slices include meaning neither nor can assert statement without agreement. hence, agreement possible without participation, and the only quorum including the set all nodes traditional, non-federated byzantine agreement requires all nodes accept the same slices, meaning q(v q(v because every member accepts every slice, traditional systems not distinguish between slices and quorums. the downside the stellar consensus protocol q(v {{v q(v q(v q(v {{v fig. quorum slice not quorum without top tier: slice out including self middle tier: slice self any top tier nodes leaf tier: slice self any middle tier nodes fig. tiered quorum structure example that membership and quorums must somehow pre-ordained, precluding open membership and decentralized control. traditional system, such pbft [castro and liskov typically has nodes, any which constitute quorum. here the maximum number byzantine failures--meaning nodes acting arbitrarily-- the system can survive. fba, introduced this paper, generalizes byzantine agreement accommodate greater range settings. fba's key innovation enabling each node chose its own quorum slice set q(v). system-wide quorums thus arise from individual decisions made each node. nodes may select slices based arbitrary criteria such reputation financial arrangements. some settings, individual node may have complete knowledge all nodes the system, yet consensus should still possible. examples and discussion figure shows example tiered system which different nodes have different slice sets, something possible only with fba. top tier, comprising ... structured like pbft system with meaning can tolerate one byzantine failure long the other three nodes are reachable and well-behaved. nodes ... constitute middle tier and depend not each other, but rather the top tier. only two top tier nodes are required form slice for middle tier node. (the top tier assumes most one byzantine failure, two top tier nodes cannot both fail unless the whole system has failed.) nodes and are leaf tier for which slice consists any mazieres q(vi {vi v(i mod fig. cyclic quorum structure example two middle tier nodes. note that and may pick disjoint slices such and nonetheless, both will indirectly depend the top tier. practice, the top tier could consist anywhere from four dozens widely known and trusted financial institutions. the size the top tier grows, there may not exact agreement its membership, but there will significant overlap between most parties' notions top tier. additionally, one can imagine multiple middle tiers, for instance one for each country geographic region. this tiered structure resembles inter-domain network routing. the internet today held together individual peering and transit relationships between pairs networks. central authority dictates arbitrates these arrangements. yet these pairwise relationships have sufficed create notion facto tier one isps [norton though internet reachability does suffer from firewalls, transitive reachability nearly complete--e.g., firewall might block the new york times, but allows google, and google can reach the new york times, then the new york times transitively reachable. transitive reachability may limited utility for web sites, but crucial for consensus; the equivalent example would google accepting statements only the new york times does. think quorum slices analogous network reachability and quorums analogous transitive reachability, then the internet's near complete transitive reachability suggests can likewise ensure worldwide consensus with fba. many ways, consensus easier problem than inter-domain routing. while transit consumes resources and costs money, slice inclusion merely requires checking digital signatures. hence, fba nodes can err the side inclusiveness, constructing conservative slices with greater interdependence and redundancy than typically seen peering and transit arrangements. another example not possible with centralized consensus cyclic dependency structures, such the one depicted figure such cycle unlikely arise intentionally, but when individual nodes choose their own slices, possible for the overall system end embedding dependency cycles. the bigger point that, compared traditional byzantine agreement, fba protocol must cope with far wider variety quorum structures. safety and liveness categorize nodes either well-behaved ill-behaved. well-behaved node chooses sensible quorum slices (discussed further section and obeys the protocol, including eventually responding all requests. ill-behaved node does not. ill-behaved nodes suffer byzantine failure, meaning they behave arbitrarily. for instance, ill- the stellar consensus protocol ill-behaved well-behaved failed byzantine, including crashed blocked divergent correct correct fig. venn diagram node failures behaved node may compromised, its owner may have maliciously modified the software, may have crashed. the goal byzantine agreement ensure that well-behaved nodes externalize the same values despite the presence such ill-behaved nodes. there are two parts this goal. first, would like prevent nodes from diverging and externalizing different values for the same slot. second, would like ensure nodes can actually externalize values, opposed getting blocked some dead-end state from which consensus longer possible. introduce the following two terms for these properties: definition (safety). set nodes fbas enjoy safety two them ever externalize different values for the same slot. definition (liveness). node fbas enjoys liveness can externalize new values without the participation any failed (including ill-behaved) nodes. call well-behaved nodes that enjoy both safety and liveness correct. nodes that are not correct have failed. all ill-behaved nodes have failed, but well-behaved node can fail, too, waiting indefinitely for messages from ill-behaved nodes, or, worse, having its state poisoned incorrect messages from ill-behaved nodes. figure illustrates the possible kinds node failure. the left are byzantine failures, meaning the ill-behaved nodes. the right are two kinds well-behaved but failed nodes. nodes that lack liveness are termed blocked, while those that lack safety are termed divergent. attack violating safety strictly more powerful than one violating only liveness, classify divergent nodes subset blocked ones. our definition liveness weak that says node can externalize new values, not that will. hence, admits state perpetual preemption which consensus remains forever possible, yet the network continually thwarts delaying reordering critical messages just the wrong way. perpetual preemption inevitable purely asynchronous, deterministic system that survives node failure [fischer al. fortunately, preemption transient. does not indicate node failure, because the system can recover any time. protocols can mitigate the problem through randomness [ben-or bracha and toueg through realistic assumptions about message latency [dwork al. latency assumptions are more practical when one would like limit execution time avoid the trusted dealers often required more efficient randomized algorithms [?]. course, only termination and not safety should depend upon message timing. optimal resilience whether not nodes enjoy safety and liveness depends several factors: what quorum slices they have chosen, which nodes are ill-behaved, and course the concrete consensus protocol and network behavior. common for asynchronous systems, assume the network eventually delivers messages between well-behaved nodes, but can otherwise arbitrarily delay reorder messages. mazieres q(v q(v q(v {{v q(v q(v q(v {{v q(v q(v q(v {{v fig. fbas lacking quorum intersection q(v {{v q(v q(v q(v {{v fig. ill-behaved node can undermine quorum intersection. this section answers the following question: given specific and particular subset that ill-behaved, what are the best safety and liveness that any federated byzantine agreement protocol can guarantee regardless the network? first discuss quorum intersection, property without which safety impossible guarantee. then introduce notion dispensable sets--sets failed nodes spite which possible guarantee both safety and liveness. quorum intersection protocol can guarantee agreement only the quorum slices represented function satisfy validity property call quorum intersection. definition (quorum intersection). fbas enjoys quorum intersection iff any two its quorums share node--i.e., for all quorums and figure illustrates system lacking quorum intersection, where permits two quorums, and that not intersect. disjoint quorums can independently agree contradictory statements, undermining system-wide agreement. when many quorums exist, quorum intersection fails any two not intersect. for example, the set all nodes ... figure quorum that intersects the other two, but the system still lacks quorum intersection because the other two not intersect each other. protocol can guarantee safety the absence quorum intersection, since such configuration can operate two different fbas systems that not exchange any messages. however, even with quorum intersection, safety may impossible guarantee the presence ill-behaved nodes. compare figure which there are two disjoint quorums, figure which two quorums intersect single node and ill-behaved. makes inconsistent statements the left and right quorums, the effect equivalent disjoint quorums. fact, since ill-behaved nodes contribute nothing safety, protocol can guarantee safety without the well-behaved nodes enjoying quorum intersection their own. after all, worst-case scenario for safety, ill-behaved nodes can just always make any possible (contradictory) statement that completes quorum. two quorums overlapping only ill-behaved nodes will again able operate like two different fbas the stellar consensus protocol systems thanks the duplicity the ill-behaved nodes. short, fbas can survive byzantine failure set nodes iff enjoys quorum intersection after deleting the nodes from and from all slices more formally: definition (delete). fbas and set nodes, then delete from written means compute the modified fbas where (v) q(v) the responsibility each node ensure q(v) does not violate quorum intersection. one way pick conservative slices that lead large quorums. course, malicious may intentionally pick q(v) violate quorum intersection. but malicious can also lie about the value q(v) ignore q(v) make arbitrary assertions. short, q(v)'s value not meaningful when ill-behaved. this why the necessary property for safety--quorum intersection well-behaved nodes after deleting ill-behaved nodes--is unaffected the slices ill-behaved nodes. suppose figure evolved from three-node fbas with quorum intersection six-node fbas without. when join, they maliciously choose slices that violate quorum intersection and protocol can guarantee safety for fortunately, deleting the bad nodes yield restores quorum intersection, meaning least can enjoy safety. note that deletion conceptual, for the sake describing optimal safety. protocol should guarantee safety for without their needing know that are ill-behaved. dispensable sets (dsets) capture the fault tolerance nodes' slice selections through the notion dispensible set dset. informally, the safety and liveness nodes outside dset can guaranteed regardless the behavior nodes inside the dset. put another way, optimally resilient fbas, single dset encompasses every ill-behaved node, also contains every failed node, and conversely all nodes outside the dset are correct. example, centralized pbft system with nodes and quorum size any fewer nodes constitute dset. since pbft fact survives byzantine failures, its robustness optimal. the less regular example figure dset, since one top tier node can fail without affecting the rest the system. also dset because other node depends for correctness. ... dset, because neither nor the top tier depend any those five nodes. not dset, slice for and and hence, entirely malicious, can lie and and convince them assertions inconsistent with each other the rest the system. prevent misbehaving dset from affecting the correctness other nodes, two properties must hold. for safety, deleting the dset cannot undermine quorum intersection. for liveness, the dset cannot deny other nodes functioning quorum. this leads the following definition: definition (dset). let fbas and set nodes. say dispensible set, dset, iff: (quorum intersection despite enjoys quorum intersection, and (quorum availability despite either quorum quorum availability despite protects against nodes refusing answer requests and blocking other nodes' progress. quorum intersection despite protects against the opposite--nodes making contradictory assertions that enable other nodes externalize inconsistent values for the same slot. nodes must balance the two threats slice selection. all else equal, bigger slices lead bigger quorums with mazieres well-behaved ill-behaved local property nodes, independent other nodes (except for the validity slice selection). intact befouled property nodes given their quorum slices and particular set ill-behaved nodes. befouled nodes are ill-behaved depend, possibly indirectly, too many ill-behaved nodes. correct failed property nodes given their quorum slices, concrete protocol, and actual network behavior. the goal consensus protocol guarantee correctness for all intact nodes. fig. key properties fbas nodes greater overlap, meaning fewer failed node sets will undermine quorum intersection when deleted. the other hand, bigger slices are more likely contain failed nodes, endangering quorum availability. the smallest dset containing all ill-behaved nodes may encompass well-behaved nodes well, reflecting the fact that sufficiently large set ill-behaved nodes can cause well-behaved nodes fail. for instance, figure the smallest dset containing and the set all nodes, always dset, fbas vacuously enjoys quorum intersection despite and, special case, also enjoys quorum availability despite the motivation for the special case that given sufficiently many ill-behaved nodes, may the smallest dset contain all ill-behaved ones, indicating scenario under which protocol can guarantee anything better than complete system failure. the dsets fbas are determined priori the quorum function which nodes are well- and ill-behaved depends runtime behavior, such machines getting compromised. the dsets care about are those that encompass all ill-behaved nodes, they help distinguish nodes that should guaranteed correct from ones for which such guarantee impossible. this end, introduce the following terms: definition (intact). node fbas intact iff there exists dset containing all ill-behaved nodes and such that definition (befouled). node fbas befouled iff not intact. befouled node surrounded enough failed nodes block its progress poison its state, even itself well-behaved. fbas can guarantee the correctness befouled node. however, optimal fbas guarantees that every intact node remains correct. figure summarizes the key properties nodes. the following theorems facilitate analysis showing that the set befouled nodes always dset fbas with quorum intersection. heorem let quorum fbas let set nodes, and let then quorum roof. because quorum, every node has q(v) such that since follows that every has q(v) such that rewriting with deletion notation yields (v) such that which, because means that quorum heorem and are dsets fbas enjoying quorum intersection, then dset, too. roof. let and then and dset), are done. similarly, then and are done. otherwise, note the stellar consensus protocol that quorum availability despite dsets and and are quorums follows from the definition that the union two quorums also quorum. hence quorum and have quorum availability despite must now show quorum intersection despite let and any two quorums let quorum intersection but then theorem must quorum now consider that and cannot both empty, else would be. hence, theorem either quorum quorum both. the former case, note that quorum then quorum intersection (ua since (ua (ua follows that making quorum similar argument, must quorum but then quorum intersection despite tells that (ua (ub which only possible heorem fbas with quorum intersection, the set befouled nodes dset. roof. let bmin the intersection every dset that contains all ill-behaved nodes. follows from the definition intact that node intact iff bmin thus, bmin precisely the set befouled nodes. theorem dsets are closed under intersection, bmin also dset. federated voting this section develops federated voting technique that fbas nodes can use agree statement. high level, the process for agreeing some statement involves nodes exchanging two sets messages. first, nodes vote for then, the vote was successful, nodes confirm effectively holding second vote the fact that the first vote succeeded. from each node's perspective, the two rounds messages divide agreement statement into three phases: unknown, accepted, and confirmed. (this pattern dates back three-phase commit [skeen and stonebraker ].) initially, a's status completely unknown node v--a could end true, false, even stuck permanently indeterminate state. the first vote succeeds, may come accept two intact nodes ever accept contradictory statements, intact and accepts then cannot false. for two reasons, however, accepting does not suffice for act first, the fact that accepted does not mean all intact nodes can; could stuck for other nodes. second, befouled, then accepting means nothing--a may false intact nodes. yet even befouled--which does not know--the system may still enjoy quorum intersection well-behaved nodes, which case, for optimal safety, needs greater assurance holding second vote addresses both problems. the second vote succeeds, moves the confirmed phase which can finally deem true and act it. the next few subsections detail the federated voting process. because voting does not rule out the possibility stuck statements, section discusses how cope with them. section will turn federated voting into consensus protocol that avoids the possibility stuck slots for intact nodes. mazieres voting with open membership correct node byzantine agreement system acts statement only when knows that other correct nodes will never agree statements contradicting most protocols employ voting for this purpose. well-behaved nodes vote for statement only valid. well-behaved nodes also never change their votes. hence, centralized byzantine agreement, safe accept quorum comprising majority well-behaved nodes has voted for it. say statement ratified once has received the necessary votes. federated setting, must adapt voting accommodate open membership. one difference that quorum longer corresponds majority well-behaved nodes. however, the majority requirement primarily serves ensure quorum intersection well-behaved nodes, which section already adapted fba. another implication open membership that nodes must discover what constitutes quorum part the voting process. implement quorum discovery, protocol should specify q(v) all messages from definition (vote). node votes for (abstract) statement iff asserts valid and consistent with all statements has accepted, and asserts has never voted against a--i.e., voted for statement that contradicts a--and promises never vote against the future. definition (ratify). quorum ratifies statement iff every member votes for node ratifies iff member quorum that ratifies heorem two contradictory statements and cannot both ratified fbas that enjoys quorum intersection and contains ill-behaved nodes. roof. contradiction. suppose quorum ratifies and quorum ratifies quorum intersection, such must have illegally voted for both and violating the assumption ill-behaved nodes. heorem let fbas enjoying quorum intersection despite and suppose contains all ill-behaved nodes. let and two nodes not let and contradictory statements. ratifies then cannot ratify roof. contradiction. suppose ratifies and ratifies definition, there must exist quorum containing that ratified and quorum containing that ratified theorem since and both must quorums meaning they ratified and respectively but enjoys quorum intersection and has ill-behaved nodes, theorem tell and cannot both ratified. heorem two intact nodes fbas with quorum intersection cannot ratify contradictory statements. roof. let the set befouled nodes. theorem dset. the definition dset, enjoys quorum intersection despite theorem two nodes not cannot ratify contradictory statements. blocking sets centralized consensus, liveness all-or-nothing property the system. either unanimously well-behaved quorum exists, else ill-behaved nodes can prevent the rest the system from accepting new statements. fba, contrast, liveness may differ across nodes. for instance, the tiered quorum example figure middle the stellar consensus protocol vote accept vote accept slice nodes, including self vote accept vote fig. voted for which contradicts ratified statement tier nodes crash, the leaf tier will blocked while the top tier and node will continue enjoy liveness. fba protocol can guarantee liveness node only q(v) contains least one quorum slice comprising only correct nodes. set failed nodes can violate this property contains least one member each v's slices. term such set v-blocking, because has the power block progress definition (v-blocking). let node fbas set v-blocking iff overlaps every one v's slices--i.e., q(v), heorem let set nodes fbas enjoys quorum availability despite iff not v-blocking for any roof. not v-blocking" equivalent q(v) such that b." the definition quorum, the latter holds iff quorum the exact definition quorum availability despite corollary, the dset befouled nodes not v-blocking for any intact accepting statements when intact node learns that has ratified statement, theorem tells that other intact nodes will not ratify contradictory statements. this condition sufficient for accept but cannot make necessary. ratifying statement requires voting for it, and some nodes may have voted for contradictory statements. figure for example, votes for before learning that the other three nodes ratified the contradictory statement though cannot now vote for would still like accept consistent with the other nodes. key insight that node intact, then v-blocking set can consist entirely befouled nodes. now suppose v-blocking set and every member claims accept statement intact, least one member must be, too. the intact member will not lie about accepting hence, true and can accept it. course, befouled, then might not true. but befouled node can accept anything and vacuously not affect the correctness intact nodes. definition (accept). fbas node accepts statement iff has never accepted statement contradicting and determines that either there exists quorum such that and each member either voted for claims accept each member v-blocking set claims accept though well-behaved node cannot vote for contradictory statements, condition above allows node vote for one statement and later accept contradictory one. mazieres vote accept vote slice nodes, including self vote vote vote vote vote vote accept vote fig. scenarios indistinguishable when does not see bold messages heorem two intact nodes fbas that enjoys quorum intersection cannot accept contradictory statements. roof. let fbas with quorum intersection and let its dset befouled nodes (which exists theorem suppose intact node accepts statement let the first intact node accept the point accepts only befouled nodes can claim accept it. since the corollary theorem cannot v-blocking, must that accepted through condition thus, identified quorum such that every node claimed vote for accept and since the first intact node accept must mean all nodes voted for other words, ratified generalizing, any statement accepted intact node must ratified because dset, enjoys quorum intersection. because additionally contains all ill-behaved nodes, theorem rules out ratification contradictory statements. accepting not enough unfortunately, for nodes assume the truth accepted statements would yield suboptimal safety and liveness guarantees federated consensus protocol. discuss the issues with safety and liveness turn. provide some context, then explain why these issues are thornier fba than centralized byzantine agreement. ... safety. consider fbas which the only quorum unanimous consent--i.e., q(v) {v}. this ought conservative choice for safety--don't anything unless everyone agrees. yet since every node v-blocking for every any node can single-handedly convince any other node accept arbitrary statements. the problem that accepted statements are only safe among intact nodes. but discussed section the only condition necessary guarantee safety quorum intersection well-behaved nodes, which might hold even the case that some wellbehaved nodes are befouled. particular, when q(v) {v}, the only dsets are and meaning any node failure befouls the whole system. contrast, quorum intersection holds despite every ... liveness. another limitation accepted statements that other intact nodes may unable accept them. this possibility makes reliance accepted statements the stellar consensus protocol problematic for liveness. node proceeds act statement because accepted the statement, other nodes could unable proceed similar fashion. consider figure which node crashes after helping ratify and accept statement though accepts and cannot. particular, from perspective, the situation depicted indistinguishable from figure which voted for and well-behaved but slow respond, while ill-behaved and sent vote for (thereby causing accept while illegally also sending vote for support protocol-level notion liveness cases like figure needs way ensure every other intact node can eventually accept before acts once this the case, makes sense say the system agrees definition (agree). fbas agrees statement iff, regardless what subsequently transpires, once sufficient messages are delivered and processed, every intact node will accept ... comparison centralized voting. understand why the above issues arise federated voting, consider centralized byzantine agreement system nodes with quorum size such system enjoys quorum availability with fewer node failures. since any two quorums share least nodes, quorum intersection well-behaved nodes holds byzantine failures. centralized byzantine agreement systems typically set and yield the equilibrium point which safety and liveness have the same fault tolerance. safety more important than liveness, some protocols increase that [li and mazieres fba, because quorums arise organically, systems are unlikely find themselves equilibrium, making far more important protect safety the absence liveness. now consider centralized system which, because node failure and contradictory votes, some node cannot ratify statement that was ratified other nodes. hears nodes claim was ratified, knows that either one them wellbehaved all safety guarantees have collapsed. either way, can act with loss safety. the fba equivalent would hear from set where deleted, undermines quorum intersection well-behaved nodes. identifying such hard for three reasons: one, quorums are discovered dynamically; two, ill-behaved nodes may lie about slices; and three, does not know which nodes are well-behaved. instead, defined federated voting accept when v-blocking set does. the v-blocking property has the advantage being easily checkable, but equivalent hearing from nodes centralized system when really want guarantee agreement among all well-behaved nodes centralized system, one merely needs nodes acknowledge that statement was ratified. more than them fail, not expect liveness anyway. fewer fail, then know nodes remain willing attest ratification, which will turn convince all other well-behaved nodes. the reliance has easy analogue the fba model. interestingly, however, the quorum size, suggesting similar approach might work with more complex justification. put another way, some point nodes need believe statement strongly enough depend its truth for safety. centralized system offers two ways reach this point for statement ratify first-hand, reason backwards from nodes claiming was ratified, figuring safety hopeless they have all lied. fba lacks the latter approach; the only tool has for safety among well-behaved nodes first-hand ratification. since nodes still need way overcome votes against ratified statements, introduced notion accepting, but provides weaker consistency guarantee limited intact nodes. mazieres statement confirmation both limitations accepted statements stem from complications when set intact nodes votes against statement that nonetheless ratified. particularly light fba's non-uniform quorums, may prevent some intact node from ever ratifying provide means accepting despite votes against it, the definition accept has second criterion based v-blocking sets. but the second criterion weaker than ratification, offering guarantees befouled nodes that enjoy quorum intersection. now suppose statement has the property that intact node ever votes against it. then have need accept and can instead insist that nodes directly ratify before acting it. call such statements irrefutable. definition (irrefutable). statement irrefutable fbas intact node can ever vote against it. theorem tells that two intact nodes cannot accept contradictory statements. thus, while some intact nodes may vote against statement that was accepted intact node, the statement "an intact node accepted irrefutable. this suggests holding second vote ratify the fact that intact node accepted definition (confirm). quorum fbas confirms statement iff claims accept node confirms iff such quorum. nodes express that they have accepted statement stating "accept (a)," abbreviation the statement, "an intact node accepted a." confirm means ratify accept (a). well-behaved node can vote for accept (a) only after accepting cannot assume any particular other nodes are intact. itself befouled, accept (a) might false, which case voting for may cost liveness, but befouled node has guarantee liveness anyway. the next theorem shows that nodes can rely confirmed statements without losing optimal safety. theorem then shows that confirmed statements meet the definition agreement from section .., meaning nodes can rely confirmed statements without endangering the liveness intact nodes. heorem let fbas enjoying quorum intersection despite and suppose contains all ill-behaved nodes. let and two nodes not let and contradictory statements. confirms then cannot confirm roof. first note that accept (a) contradicts accept (a)--no well-behaved node can vote for both. note further that must ratify accept (a) confirm theorem cannot ratify accept (a) and hence cannot confirm heorem let the set befouled nodes fbas with quorum intersection. let quorum containing intact node b), and let any set such that let the set intact nodes and let (vs)b the set intact nodes not either such that v-blocking. roof. v-blocking for some then are done. otherwise, must show not v-blocking for any then, theorem either quorum the former case are done, while the latter get contradiction: theorem quorum since dset (by theorem must enjoy quorum intersection, meaning this impossible, since and heorem intact node fbas with quorum intersection confirms statement then, whatever subsequently transpires, once sufficient messages are delivered and processed, every intact node will accept and confirm the stellar consensus protocol quorum satisfying each votes accepts valid voted uncommitted quorum satisfying confirms accepted confirmed v-blocking set accepts voted fig. possible states accepted statement single node a-valent agreed bivalent stuck a-valent agreed fig. possible system-wide status statement roof. let the dset befouled nodes and let the quorum through which intact node confirmed let nodes broadcast accept (a). definition, any node regardless how has voted, accepts after receiving accept (a) from v-blocking set. hence, these messages may convince additional nodes accept let these additional nodes turn broadcast accept (a) until point reached which, regardless future communication, further intact nodes can ever accept this point let the set nodes that claim accept (where s), let the set intact nodes and let the set intact nodes not cannot v-blocking for any node else more nodes could come accept theorem then, meaning every intact node has accepted figure summarizes the paths intact node can take confirm given knowledge, might vote for either the contradictory votes for cannot later vote for but can nonetheless accept v-blocking set accepts it. subsequent quorum confirmation messages allows confirm which theorem means the system agrees liveness and neutralization the main challenge distributed consensus, whether centralized not, that statement can get stuck permanently indeterminate state before the system reaches agreement it. hence, protocol must not attempt ratify externalized values directly. should the statement "the value slot get stuck, the system will forever unable agree slot losing liveness. the solution craft the statements votes carefully. must possible break stuck statement's hold the question really care about, namely slot contents. call the process obsoleting stuck statement neutralization. mazieres local state system-wide status uncommitted voted voted accepted confirmed unknown (any) unknown (any) unknown (any) stuck, a-valent, agreed agreed fig. what intact node knows about the status statement more concretely, figure depicts the potential status statement can have system-wide. initially, the system bivalent, which mean there one sequence possible events through which all intact nodes will accept and another sequence through which all intact nodes will reject (i.e., accept statement contradicting a). some point, one these two outcomes may cease possible. intact node can ever reject say the system a-valent; conversely, intact node can ever accept say the system a-valent. the time fbas transitions from bivalent a-valent, there possible outcome which all intact nodes accept however, this might not remain the case. consider pbft-like four-node system ... which any three nodes constitute quorum. and vote for the system becomes a-valent; three nodes can ratify contradictory statement. however, and subsequently vote for contradicting also becomes impossible ratify this case, a's state permanently indeterminate, stuck. seen figure even once intact node accepts the system may still fail reach system-wide agreement however, theorem once intact node confirms all intact nodes can eventually come accept it; hence the system has agreed upon figure summarizes what intact nodes know about the global state statement from their own local state. preserve the possibility consensus, protocol must ensure that every statement either irrefutable, and hence cannot get stuck, neutralizable, and hence cannot block progress stuck. there are two popular approaches crafting neutralizable statements: the view-based approach, pioneered viewstamped replication [oki and liskov and favored pbft [castro and liskov and the ballot-based approach, invented paxos [lamport the ballot-based approach may harder understand [ongaro and ousterhout compounding confusion, people often call viewstamped replication "paxos" assert that the two algorithms are the same when they are not [van renesse al. view-based protocols associate the slots votes with monotonically increasing view numbers. should consensus get stuck the ith slot view nodes recover agreeing that view had fewer than meaningful slots and moving higher view number. ballot-based protocols associate the values votes with monotonically increasing ballot numbers. should ballot get stuck, nodes retry the same slot with higher ballot, taking care never select values that would contradict prior stuck ballots. this work takes ballot-based approach, doing makes easier away with the notion distinguished primary node leader. for example, leader behavior can emulated [lamport b]. scp: federated byzantine agreement protocol this section presents the stellar consensus protocol, scp. high level, scp consists two sub-protocols: nomination protocol and ballot protocol. the nomination the stellar consensus protocol protocol produces candidate values for slot. run long enough, eventually produces the same set candidate values every intact node, which means nodes can combine the candidate values deterministic way produce single composite value for the slot. there are two huge caveats, however. first, nodes have way knowing when the nomination protocol has reached the point convergence. second, even after convergence, ill-behaved nodes may able reset the nomination process finite number times. when nodes guess that the nomination protocol has converged, they execute the ballot protocol, which employs federated voting commit and abort ballots associated with composite values. when intact nodes agree commit ballot, the value associated with the ballot will externalized for the slot question. when they agree abort ballot, the ballot's value becomes irrelevant. ballot gets stuck state where one more intact nodes cannot commit abort it, then nodes try again with higher ballot; they associate the new ballot with the same value the stuck one case any node believes the stuck ballot was committed. intuitively, safety results from ensuring that all stuck and committed ballots are associated with the same value. liveness follows from the fact that stuck ballot can neutralized moving higher ballot. the remainder this section presents the nomination and ballot protocols. each described first terms conceptual statements, then concrete protocol with messages representing sets conceptual statements. finally, section shows the correctness the protocol. scp treats each slot completely independently and can viewed many separate instances single-slot consensus protocol (akin the "single-decree synod" paxos [lamport ]). concepts such candidate values and ballots must always interpreted the context particular slot even much the discussion leaves the slot implicit. nomination protocol because slots need only partially ordered, some applications scp will have only one plausible ballot per slot. for example, certificate transparency, each may have its own series slots and sign exactly one certificate tree per slot. however, other applications admit many plausible values per slot, which case helpful narrow down the possible input values. our strategy begin with synchronous nomination protocol that achieves consensus under certain timing assumptions, and feed the output the nomination protocol into asynchronous ballot protocol whose safety does not depend timing [lamport a]. such initial synchronous phase sometimes called conciliator [aspnes the nomination protocol works converging set candidate values for slot. nodes then deterministically combine these candidates into single composite value for the slot. exactly how combine values depends the application. way example, the stellar network uses scp choose set transactions and ledger timestamp for each slot. combine candidate values, stellar takes the union their transaction sets and the maximum their timestamps. (values with invalid timestamps will not receive enough nominations become candidates.) other possible approaches include combining sets intersection simply picking the candidate value with the highest hash. nodes produce candidate value through federated voting the statement nominate definition (candidate). node considers value candidate when has confirmed the statement nominate x--i.e., has ratified accept (nominate x). mazieres long node has candidate values, may vote favor nominate for any value that passes application-level validity checks (such timestamps not being the future). fact, should generally re-nominate any values that sees other nodes nominate, with some rate-limiting discussed below avoid explosion candidates. soon has candidate value, however, must cease voting nominate for any new values should still continue accept nominate statements for new values (when accepted v-blocking set) and confirm new nominate statements prescribed the federated voting procedure. the nomination protocol enjoys several properties when system has intact nodes (meaning has avoided complete failure). specifically, for each slot: intact nodes can produce least one candidate value. some point, the set possible candidate values stops growing. any intact node considers candidate value, then eventually every intact node will consider candidate value. now consider how the nomination protocol achieves its three properties. property achieved because nominate statements are irrefutable. nodes never vote against nominating particular value, and until the first candidate value confirmed, intact nodes can vote nominate any value. long any value passes application-level validity checks, intact nodes can vote for and confirm nominate property ensured because once each intact node confirms least one candidate value--which will happen finite amount time--no intact nodes will vote nominate any new values. hence, the only values that can become candidates are those that already have votes from intact nodes. property direct consequence theorem the nomination process will more efficient fewer combinations values are play. hence, assign nodes temporary priority and have each node, when possible, nominate the same values higher-priority node. more concretely, let cryptographic hash function whose range can interpreted set integers ... hmax might sha- [national institute standards and technology which case hmax let (m) h(i, xi- slot-specific hash function for slot where xi- the value chosen for the slot preceding (or the sorted set values all immediate dependencies slot when slots are governed partial order). given slot and round number each node computes set neighbors and priority for each neighbor follows: q(v) weight (v, |q(v)| neighbors(v, (n, where value and referendum externalizing for the slot question. the value counter ensure higher ballot numbers are always available. use c-like notation b.n and b.x denote the counter and value fields ballot that ballots are totally ordered, with b.n more significant than b.x. for convenience, special invalid null ballot less than all other ballots, and special counter value greater than all other counters. speak committing and aborting ballot shorthand for using federated voting agree the statements commit and abort respectively. for given ballot, commit and abort are contradictory, well-behaved node may vote for most one them. the notation section the opposite commit would commit b," but abort more intuitive notation. because most one value can chosen for given slot, all committed and stuck ballots must contain the same value. roughly speaking, this means commit statements are invalid they conflict with lower-numbered unaborted ballots. definition (compatible). two ballots and are compatible, written iff and incompatible, written iff .x. also write iff and similarly, means and definition (prepared). ballot prepared iff every statement the following set true: abort bold bold more precisely, then, commit valid vote for only confirmed prepared, which nodes ensure through federated voting the corresponding abort statements. convenient vote these statements masse, wherever write prepared," the surrounding context applies the whole set abort statements. particular, node votes, accepts, confirms that prepared iff votes for, accepts, confirms, respectively, all these aborts. commit ballot and externalize its value b.x, scp nodes first accept and confirm prepared, then accept and confirm commit before the first intact node votes for commit the prepare step, through federated voting, ensures all intact nodes can eventually confirm prepared. when intact node accepts commit means b.x will eventually chosen. however, discussed section .., must confirm commit before acting case befouled. ... concrete ballot protocol. figure illustrates the per-slot state maintained each node. node stores: its current phase its current ballot the two most recent incompatible ballots has prepared (p, the lowest (c) and highest (h) ballot, any, has voted commit and for which has not subsequently accepted abort (or for which has accepted confirmed commit later phases); next value try the current ballot fails; and the latest message received from each node (m). ballots and are non-decreasing within phase. addition, --meaning may the stellar consensus protocol variable meaning current phase: one prepare, confirm, externalize current ballot that node attempting prepare and commit the two highest ballots accepted prepared such that where there are such ballots prepare: the highest ballot confirmed prepared, none; then lowest and the highest ballot for which has voted commit and not accepted abort. confirm: lowest, highest ballot for which accepted commit externalize: lowest, highest ballot for which confirmed commit invariant: then value use next ballot. then the composite value (see section .); otherwise, h.x. set the latest ballot message seen from each node fig. ballot state maintained each node for each slot c.n h.n this message from node about slot specifies q(v). the other fields reflect v's state. values c.x and h.x are elided c.x h.x b.x when c.n this concrete message encodes host conceptual statements, follows: prepare abort accept (abort accept (abort vote prepare vote confirm prepared) accept (abort vote confirm prepared) commit c.n vote commit ... p.n c.n h.n sent try externalize b.x for slot after accepting commit. implies p.x c.x h.x b.x v's state. for convenience, also say (p' irrelevant after accepting commit). specifies q(v) above. encodes: confirm everything implied prepare c.n accept (commit vote confirm commit ... c.n h.n after confirms commit for slot and externalizes value this message helps other nodes externalize implies and for convenience, also say and encodes: externalize everything implied confirm c.n everything implied confirm c.n h.n {{v}} fig. messages scp's ballot protocol have participated ratifying commit c--code must ensure this invariant guarantees node can always legally vote prepare its current ballot figure shows the three ballot protocol messages, with determining which one the three node can send. ballot messages may overlap with nomination messages, that, when node may update response nominate message. note mazieres that accept (a)" what each node must assert for quorum accept under condition the definition accept. for convenience, when comparing state across nodes, will identify fields belonging particular nodes with subscripts. node, then write p'v ... denote the values ... node v's state described figure similarly, let denote message m's sender, and p'm ... denote the corresponding values ... state implied each node initializes its ballot state for slot setting prepare, and all other fields (p, the invalid ballot while node can receive but not send ballot messages. once b.n node reinitializes start sending messages. nodes then repeatedly exchange messages with peers, sending whichever ballot message indicated upon adding newly received message node updates its state follows: prepare and lets accept new ballots prepared, update and afterwards, either then set prepare and lets confirm new higher ballots prepared, then raise the highest such ballot and set h.x. prepare, then set and, necessary, raise the lowest ballot such that accepts all commit confirm and confirms commit for any set and the lowest and highest such ballots, set externalize, externalize c.x, and terminate. {prepare, confirm} and .n, then set where the lowest counter for which such exists. repeat the previous steps after updating while the above protocol implements federated voting confirm prepared. once the protocol implements federated voting commit for every for the confirm phase, once well-behaved node accepts commit the node never accepts, and hence never attempts confirm, commit for any once commit confirmed, the value its ballot safe externalize assuming quorum intersection. all messages sent particular node are totally ordered with the most significant and the least significant field. the values these fields can determined from messages, described figure all prepare messages precede all confirm messages, which turn precede the single externalize message for given slot. the ordering makes possible ensure contains only the latest ballot the stellar consensus protocol from each node without relying timing order the messages, since the network may re-order messages. few details the protocol merit explanation. the statements implied prepare the form "abort accept (abort not specify whether voting for confirming abort the distinction unimportant for the definition accept. glossing over the distinction allows forget about old ballots voted commit (and hence cannot vote abort), long accepted abort message for them. indeed, the only time modifies when set back after accepting abort for every ballot voting commit step the preceding page. conversely, the only time modifies when set value step because nodes never vote abort for any past abort votes can conflict with commit theorem requires that nodes rebroadcast what they have accepted. follows from the definition prepare that the two highest incompatible ballots node has accepted prepared subsume all ballots the node has accepted prepared. hence, including and every message ensures that nodes converge h--a confirmed prepared ballot. note further that the ballots node accepts prepared must superset the ballots the node confirms prepared; hence, step can never set such that step will set the new incompatible with the old the time sends externalize message, has accepted commit more importantly, however, has confirmed commit can assert its acceptance confirmed statements without regard q(v), because has already checked that one its slices unanimously agrees; this explains the appearance {{v}} place for the second implicit confirm message the description externalize eliminating allows single static externalize message help other nodes catch arbitrarily far the future, even quorum slices have changed significantly the meantime. only one rpc needed exchange ballot messages. the argument the sender's latest message and the return value the receiver's latest message. with nomi nate the values ballots are cryptographic hashes, then separate rpc needed retrieve uncached hash preimages. ... timeouts and ballot updates. all intact nodes start with the same ballot then steps the previous page are sufficient confirm commit and externalize value b.x. unfortunately, the ballot protocol starts before the nomination protocol has converged, nodes may start off with different values for ballot fails, takes long enough that may fail because unresponsive nodes, then nodes must time out and try again with higher ballot. for this reason, nodes employ timer follows: (a) node with externalize arms timer whenever such that the set senders quorum, and .n. (b) the timer fires, updates its ballot setting different nodes may start ballots different times. however, condition (a) delays setting timer node that has gotten ahead quorum. conversely, step the preceding page allows nodes that have fallen too far behind catch without waiting for timers. taken together, these rules ensure that given long enough timers, intact nodes will spend time together the same ballot; moreover, this time will grow proportionally the timer duration. ensure timeouts are long enough without predicting latencies, implementation can increase the timeout function b.n. correctness scp node cannot vote confirm commit until has voted confirm abort for all lower-numbered incompatible ballots. because well-behaved node cannot accept (and mazieres hence vote confirm) contradictory statements, this means that for given theorem ensures set well-behaved nodes cannot externalize contradictory values long enjoys quorum intersection despite this safety holds and change only between slots, but what they change mid-slot (for instance, reaction node crashes)? reason about safety under reconfiguration, join all old and new quorum slice sets, reflecting the fact that nodes may make decisions based combination messages from different configuration eras. very conservative, might require quorum intersection the aggregation the present configuration with every past configuration. however, can relax this slightly separating nodes that have sent illegal messages from those that have merely crashed. heorem let ... the set configurations fbas has experienced during agreement single slot. let and q(v) such that (v) let set such that contains all illbehaved nodes that have sent illegal messages, though may still contain crashed (unresponsive) nodes. suppose nodes and are well-behaved, externalizes for the slot, and externalizes enjoys quorum intersection, then roof. for externalize must have ratified accept (commit collaboration with pseudo-quorum say pseudo-quorum because might not quorum for any particular ratification may have involved messages spanning multiple configurations. nonetheless, for ratification succeed (v) such that follows from the construction that q(v). hence quorum similar argument pseudo-quorum must have ratified accept (commit and must quorum quorum intersection there must exist some such that assumption, such could not claim accept incompatible ballots. since confirmed accepting commit for ballots with both and must that for liveness node care about several things when fbas has undergone series reconfigurations ... within single slot. first, the safety prerequisites theorem must hold for and the set nodes cares about, since violating safety undermines liveness and theorem requires quorum intersection. second, the set ill-behaved nodes the latest state, must not v-blocking, this could deny quorum and prevent from ratifying statements. finally, v's state must never have been poisoned v-blocking set falsely claiming accept statement. summarize, then, the set nodes that have sent illegal messages, consider node cumulatively intact when the following conditions hold: intact the latest configuration the aggregation the present and all past configurations has quorum intersection despite (i.e., the prerequisite for theorem holds), and not v-blocking for any arms its timer described section .., then, given sufficient communication, every intact node can set before any timer fires. the stellar consensus protocol roof. let the set nodes with counters least assumption, contains intact node. furthermore, because that intact node armed its timer, must also encompass quorum. let the intact subset and the set intact nodes not theorem either (in which case the theorem trivial), v-blocking for some step page will adjust its ballot this point, repeat the argument with {v} until such point heorem firm phase with given long enough timeouts, intact node has reached the con b.x then eventually all intact nodes will terminate. roof. intact node has reached the externalize phase, has confirmed commit for some ballot theorem all intact nodes will confirm commit after which they will terminate step page otherwise, intact node the confirm phase has accepted commit where beforehand, intact node confirmed was prepared. theorem all intact nodes will eventually have moreover, theorem intact node can accept abort intact node can accept prepared any ballot such that hence, after sufficient communication, every intact node will permanently have the intact node nodes with the lowest will, theorem raise their ballots until such point all intact nodes with armed timers have the same ballot counter. since they also have identical h.x they will all have the same ballot. they cannot complete the protocol because one more intact nodes have higher ballots, the nodes with higher numbered ballots will not have timers set. hence, the nodes with lowernumbered ballots will after timeout set set until eventually all intact nodes are the same ballot and can complete the protocol heorem regardless past ill-behavior, given long enough timeouts and periods which ill-behaved nodes not send new messages, intact nodes running scp will terminate. roof. theorem all intact nodes will eventually have identical sets candidate values. assume this point has passed and every intact node has the same composite value combine(z). intact node ever confirms any ballot prepared without b.x then after most one timeout, all new ballots intact nodes will have value and, given sufficient timeout, complete the protocol. theorem nodes will also complete any intact node has progressed beyond the prepare phase. the remaining case that intact node has and all intact nodes have prepare theorem when the intact node nodes with the highest b.n arm their timers, timers are long enough, other nodes will catch up. moreover, theorem timers are long enough, nodes will converge the value (the highest confirmed prepared ballot) before the next timeout, which point all intact nodes will raise the same value and complete the protocol. theorem assures there are dead-end states scp. however, set illbehaved nodes with very good timing could perpetually preempt scp system delaying messages that some fraction intact nodes update right before timers fire and the remaining update after, preventing intact nodes from converging the next ballot. nodes can recover from such attack removing ill-behaved nodes from their slices. alternative would add randomness the protocol, for instance changing step page update with probability (or even with probability proportional the fraction the timer remaining). such approach would terminate with mazieres probability but worse expected running time for the common case that most all nodes are well-behaved fail-stop. limitations scp can only guarantee safety when nodes choose adequate quorum slices. section discusses why can reasonably expect them so. nonetheless, when security depends upon user-configurable parameter, there always the possibility people will set wrong. even when people set quorum slices correctly and scp guarantees safety, safety alone does not rule out other security issues that may arise federated system. for example, financial market, widely trusted nodes could leverage their position the network gain information with which engage front running other unethical activities. byzantine nodes may attempt filter transactions the input side scp while otherwise producing the correct output. well-behaved nodes accept all transactions, the combine function takes the union transactions, and there are intact nodes, then such filtering will eventually fail block victim transactions with probability but may nonetheless impose delays. though scp's safety optimal, its performance and communication latency are not. the common case that nodes have not previously voted commit ballots incompatible with the current one, possible reduce the number communication rounds one. earlier version scp did so, but the protocol description was more complex. first, required nodes cache and retransmit signed messages previously sent failed nodes. second, was longer possible gloss over the distinction between votes and confirmations abort statements prepare messages, nodes had send around potentially unbounded lists exceptions their abort votes. scp can suffer perpetual preemption discussed section open question whether, without randomness, different protocol could guarantee termination assuming bounded communication latency but tolerating byzantine nodes that continuously inject bad messages exactly the point where timeouts fire. such protocol not ruled out the flp impossibility result [fischer al. however, the two main techniques guarantee termination assuming synchrony not directly apply the fba model: pbft [castro and liskov chooses leader round-robin fashion, which not directly applicable when nodes not agree membership. (possibly something along the lines priority section could adapted.) the byzantine generals protocol [lamport al. relays messages compensate for ill-behaved nodes saying different things different honest nodes, approach that cannot help when nodes depend distinct ill-behaved nodes their slices. still another possibility might leverage both randomness and synchrony terminate with probability but shorter expected time than ben or-style randomized protocols [ben-or that make synchrony assumptions. public coin techniques [?] that speed randomized centralized byzantine agreement protocols appear difficult adapt the federated model, barring some cryptographic breakthrough federated threshold signatures. unfortunately, changing slices mid-slot accommodate failed nodes problematic for liveness well-behaved node has ever experienced wholly malicious and colluding v-blocking set. the good news that theorem guarantees safety any set well-behaved nodes enjoying quorum intersection despite even when has befouled members. the bad news that updating may insufficient unblock nodes well-behaved nodes were tricked into voting confirm bad commit message. such situation, nodes must disavow past votes, which they can only rejoining the system under new node names. there may exist way automate such the stellar consensus protocol recovery, such having other nodes recognize reincarnated nodes and automatically update their slices. the fba model requires continuity participants over time. should all nodes simultaneously and permanently leave, restarting consensus would require central coordination human-level agreement. contrast, proof-of-work system such bitcoin could undergo sudden complete turnover yet continue operate with little human intervention. the other hand, nodes return, fbas can recover from arbitrarily long outage, while proof-of-work scheme would face the possibility attacker working fork during the outage. intriguing possibility leverage scp mediate tussles [clark al. voting changes configuration parameters upgrades application protocol. one way this nominate special messages that update parameters. candidate values could then consist both set values and set parameter updates. big limitation this approach that set malicious nodes large enough deny the system quorum but not large enough undermine safety could nonetheless trigger configuration changes lying and putting configuration changes that were never ratified. remains open question how vote parameter changes way that requires the consent full quorum but also never jeopardizes liveness. summary byzantine agreement has long enabled distributed systems achieve consensus with efficiency, standard cryptographic security, and flexibility designating trusted participants. more recently, bitcoin introduced the revolutionary notion decentralized consensus, leading many new systems and research challenges. this paper introduces federated byzantine agreement (fba), model for achieving decentralized consensus while preserving the traditional benefits byzantine agreement. the key distinction between fba and prior byzantine agreement systems that fba forms quorums from participants' individual trust decisions, allowing organic growth model similar that the internet. the stellar consensus protocol (scp) construction for fba that achieves optimal safety against ill-behaved participants. acknowledgments jed mccaleb inspired this work and provided feedback, terminology suggestions, and help thinking through numerous conjectures. jessica collier collaborated writing the paper. stan polu created the first implementation scp and provided invaluable corrections, suggestions, simplifications, and feedback the process. jelle van den hooff provided the key idea restructure the paper around quorum intersection and federated voting, well other crucial suggestions for terminology, organization, and presentation. nicolas barry found several bugs the paper implemented the protocol, well identifying necessary clarifications. ken birman, bekki bolthouse, joseph bonneau, mike hamburg, graydon hoare, joyce kim, tim makarios, mark moir, robert morris, lucas ryan, and katherine tom slogged through drafts the paper, identifying errors and sources confusion well providing helpful suggestions. eva gantz provided helpful motivation and references. winnie lim provided guidance figures. the reddit community and tahoe-lafs group pointed out censorship weakness earlier version scp, leading the improved nomination protocol. finally, the author would like thank the whole stellar team for their support, feedback, and encouragement. disclaimer professor mazieres's contribution this publication was paid consultant, and was not part his stanford university duties responsibilities. mazieres references eduardo alchieri, alysson neves bessani, joni silva fraga, and fabiola greve. byzantine consensus with unknown participants. proceedings the international conference principles distributed systems. james aspnes. modular approach shared-memory consensus, with applications the probabilistic-write model. proceedings the symposium principles distributed computing. rachel banning-lover. boatfuls cash: how you get money into fragile states? (february http://www.theguardian.com/global-development-professionals-network//feb//boatfulsof-cash-how-do-you-get-money-into-fragile-states. david basin, cas cremers, tiffany hyun-jin kim, adrian perrig, ralf sasse, and pawel szalachowski. arpki: attack resilient public-key infrastructure. proceedings the acm sigsac conference computer and communications security. michael ben-or. another advantage free choice (extended abstract): completely asynchronous agreement protocols. proceedings the symposium principles distributed computing. joseph bonneau, andrew miller, jeremy clark, arvind narayanan, joshua kroll, and edward felten. research perspectives and challenges for bitcoin and cryptocurrencies. proceedings the ieee symposium security and privacy. gabriel bracha and sam toueg. asynchronous consensus and broadcast protocols. journal the acm (oct. danny bradbury. feathercoin hit massive attack. (june http://www.coindesk.com/feathercoin-hit-by-massive-attack/. vitalik buterin. slasher: punitive proof-of-stake algorithm. (january https://blog.ethereum.org////slasher-a-punitive-proof-of-stake-algorithm/. miguel castro and barbara liskov. practical byzantine fault tolerance. proceedings the symposium operating systems design and implementation. cgap. making money transfers work for microfinance institutions. (march http://www.cgap.org/sites/default/files/cgap-technical-guide-making-money-transfers-workfor-microfinance-institutions-a-technical-guide-to-developing-and-delivering-moneytransfers-mar-.pdf. david clark, john wroclawski, karen sollins, and robert braden. tussle cyberspace: defining tomorrow's internet. ieee/acm transactions networking (june crazyearner. terracoin attack over .th attack confirmd [sic]. (july https://bitcointalk.org/index.php?topic=.. kourosh davarpanah, dan kaufman, and ophelie pubellier. neucoin: the first secure, cost-efficient and decentralized cryptocurrency. (march http://www.neucoin.org/en/whitepaper/download. asli demirguc-kunt, leora klapper, dorothe singer, and peter van oudheusden. the global findex database measuring financial inclusion around the world. policy research working paper world bank. http://www-wds.worldbank.org/external/default/wdscontentserver/wdsp/ib// //bdcaaa/_/rendered/pdf/theglobalfinionaroundtheworld.pdf. john douceur. the sybil attack. revised papers from the first international workshop peer-to-peer systems. cynthia dwork, nancy lynch, and larry stockmeyer. consensus the presence partial synchrony. journal the acm (april cynthia dwork and moni naor. pricing via processing combatting junk mail. proceedings the annual international cryptology conference advances cryptology. ittay eyal and emin gun sirer. majority not enough: bitcoin mining vulnerable. (november http://arxiv.org/abs/.. michael fischer, nancy lynch, and michael paterson. impossibility distributed consensus with one faulty process. journal the acm (april ghassan karame, elli androulaki, and srdjan capkun. double-spending fast payments bitcoin. proceedings the acm conference computer and communications security. tiffany hyun-jin kim, lin-shung huang, adrian perring, collin jackson, and virgil gligor. accountable key infrastructure (aki): proposal for public-key validation infrastructure. proceedings the international conference world wide web. the stellar consensus protocol sunny king and scott nadal. ppcoin: peer-to-peer crypto-currency with proof-of-stake. (august http://peercoin.net/assets/paper/peercoin-paper.pdf. jae kwon. tendermint: consensus without mining. (). http://tendermint.com/docs/tendermint.pdf. leslie lamport. the part-time parliament. (may leslie lamport. brief announcement: leaderless byzantine paxos. proceedings the international conference distributed computing. leslie lamport. byzantizing paxos refinement. proceedings the international conference distributed computing. leslie lamport, robert shostak, and marshall pease. the byzantine generals problem. acm transactions programing languages and systems (july adam langley. maintaining digital certificate security. (march http: //googleonlinesecurity.blogspot.com///maintaining-digital-certificate-security.html. ben laurie, adam langley, and emilia kasper. certificate transparency. rfc internet engineering task force (ietf). http://tools.ietf.org/html/rfc. jinyuan and david mazieres. beyond one-third faulty replicas byzantine fault tolerant systems. proceedings the symposium networked systems design and implementation. marcela melara, aaron blankstein, joseph bonneau, michael freedman, and edward felten. coniks: privacy-preserving consistent key service for secure end-to-end communication. cryptology eprint archive, report (december http://eprint.iacr.org//. microsoft. fraudulent digital certificates could allow spoofing. microsoft security advisory (january https://technet.microsoft.com/en-us/library/security/.aspx. satoshi nakamoto. bitcoin: peer-to-peer electronic cash system. (). http://bitcoin.org/bitcoin.pdf. national institute standards and technology. secure hash standard (shs). federal information processing standards publication http://csrc.nist.gov/publications/fips/fips-/fips--.pdf. william norton. the art peering: the peering playbook. (august http://drpeering.net/white-papers/art-of-peering-the-peering-playbook.html. karl o'dwyer and david malone. bitcoin mining and its energy footprint. irish signals and systems conference. limerick, ireland, brian oki and barbara liskov. viewstamped replication: new primary copy method support highly-available distributed systems. proceedings the symposium principles distributed computing. diego ongaro and john ousterhout. search understandable consensus algorithm. usenix annual technical conference. marshall pease, robert shostak, and leslie lamport. reaching agreement the presence faults. journal the acm (april claire provost. why africans pay the most send money home? (january http://www.theguardian.com/global-development//jan//africans-pay-most-send-money. david schwartz, noah youngs, and arthur britto. the ripple protocol consensus algorithm. (). https://ripple.com/files/ripple_consensus_whitepaper.pdf. dale skeen and michael stonebraker. formal model crash recovery distributed system. ieee transactions software engineering (may robbert van renesse, nicolas schiper, and fred schneider. vive difference: paxos vs. viewstamped replication vs. zab. ieee transactions dependable and secure computing (september mazieres glossary notation notation name iff definition abbreviation "if and only :a-b function function maps each element set result set (x) application the result calculating function argument complement overbar connotes the opposite, i.e., the opposite tuple structure (compound value) with field values ... logical and both and are true. logical least one, possibly both, and are true. c(e) there exists there least one value for which condition c(e) true. c(e) for all c(e) true every value {a, ...} set set containing the listed elements (a, ...) c(e) set-builder the set all elements for which c(e) true empty set the set containing elements |s| cardinality the number elements set element element member set subset every member set also member set strict subset and powerset the set sets containing every possible combination members i.e., union the set containing all elements that are members members i.e., intersection the set containing all elements that are members both and i.e., set difference the set containing every element that not member i.e., not negates symbol's meaning. e.g., means false, while c(e) means exists such that c(e) true.