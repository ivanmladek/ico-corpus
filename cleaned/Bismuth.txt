whitepaper bismuth crypto-currency written the bismuth core dev team version date: august contents abstract introduction bismuth features use cases coin supply and reward model cryptography multiple address schemes mining algorithm chain security tail removal block validation operation and data field private contracts hypernodes and sidechain hyperblock compression penalty system mirror blocks testnet regnet education and research future prospectives summary disclaimer abstract this document contains the whitepaper the bismuth crypto-currency. the whitepaper begins with presentation the bismuth philosophy and description the three pillars stands followed presentation some the core features, which are: plugins, use cases, coin supply and reward model, cryptography, mining algorithm, tail removal block validation, operation and data fields, private contracts, hypernodes and sidechain, testnet and regnet, education and research. introduction the crypto-currency bismuth's initial goal was build chain that was simple possible, from brand new fresh python codebase. started personal project one developer, learn about the technology, but soon evolved into feature packed crypto-currency and platform with multiple developers, technical support persons, pool operators, exchanges and social media influencers involved. bismuth pillars bismuth stands three pillars that differentiate from other crypto-currencies. the real world principle some chains live idealist world where everything can made perfect, where code fixes everything and users are experts able understand complex algorithms, their bug free implementation, compile from source, then make error using the tool. the solutions designed that spirit are bound fail because they ignore the real world, real users, and use case the tool. the interfaces with the real world (users, oracles, network) are not perfect, and bismuth has account for that. there need design super complex algorithm which ensures consensus reach immutability when what secures not fail free. the complexity the code should reflect the real world use case. example, you not need supersonic reactors run your car. your usual engine enough and gives enough guarantee for everyday use. example, bismuth does not use transaction hashes. the block hash verifies all the transactions contained using the following code: block_hash hashlib.sha((str(transaction_list_converted) db_block_hash_prev).encode("utf-")).hexdigest() that the bismuth spirit, simple, easy understand, yet effective and considered good enough. the goal achieve the mass adoption cryptocurrencies, then need move away from them being seen something only for developers and experts cryptography. the way this making them simple understand and not over engineering them. there still work that respect, but this the way bismuth moves on: not trying design perfect abstract system, then find matching use cases, but starting from real world use cases instead and searching for the simplest possible way achieve with sufficient guarantees. need store because the real world principle, some data needs stored the chain. users not need use tricks that like they with btc eth. some things just have stored chain, let's not try hide that, and ease the user's job. bismuth supports default two abstract fields operation and data users can leverage build any protocol, however complex, top, while keeping good level performance. however, storing everything chain because, have chain, kind the hammer problem: all you have hammer, you see every problem nail. that why some crypto-currencies are focused scalability issues: they want store everything chain, and just too much. bismuth's philosophy store only what needs stored the main chain, and more. still, following the real world principle, chain storage not strongly discouraged. scalability application design issue. ensuring you store only what needs be, you avoid from the start many scalability and long term issues. why store full documents for proof when you can store only their hash? store proofs instead data. use checkpoints, signatures, fingerprints. bismuth also aims provide practical framework store more aside the chain, while still benefiting from the chain safety (see hypernodes-like side chains, hyperlane). clear line trust crypto-currencies often define themselves "trustless". this ignoring the real world principle. what stored chain not necessarily "true". just supposed immutable once stored, and requires some hidden trust anyway: the code, the bootstrapped data, the underlying algorithm, majority other peers, service providers. on-chain contracts are not magical, they are not perfect. they can have bugs, the virtual machine (vm) can change, they rely oracles, you still have trust but you not always know what who you trust. bismuth does not try hide the fact that you sometimes have trust, and try make that clear. when you use private bis contract like zircodice dragginator for instance, you trust its operator. you still can have history the transactions and verify that the operator did what was supposed to. the bismuth execution model and abstract protocols also that direction. not only you know what you have trust, but you can choose who you trust. the case protocol, you can freely choose the implementation you trust the more, the certifier that suits you, and on. not some magical immutable contract stored chain, with possible bugs, proxies, backdoors and way fixing when goes wrong. other words "clear line trust" means that when you have trust something someone, you know what/who you have trust. bismuth not presented trustless, whereas you implicitly trust several layers and people. bismuth value proposal the bismuth value proposition can summarized follows: lightweight: the node lightweight and does not require powerful cpu and lot ram. perfect fit for developers, scholars and academics. the codebase quick handle and develop upon. allows for fast prototyping use cases. easy tweak and experiment multiple access layers and clients api several languages are available. bismuth for developers along its development, bismuth always tries to: simple: does not copy every complex feature other chains, but strip down and simplify the core understandable. innovative: the bismuth protocol belongs core team, which allows for great flexibility and new features tested and added quickly. extremely extensible and tweakable. bismuth tailored for developers: use python means largely accessible ever growing base developers. python currently the language choice for universities, students, academics, data and machine learning scientists. python does not need time consuming compilation steps. tweak and test. bismuth allows for interaction many levels its infrastructure, from direct access pure sql api clients several languages. bismuth node comes with hooks and filters, allowing for easy write plugins, pure python code new language learn. bismuth wallet also comes with pluggable crystals, dapps can seemlessly integrated the wallet. bismuth abstract transaction model and protocols allow for virtually any application run top bismuth. example feedback from dev the core team: with python's simplicity, with few hours you can get some poc apps done. the main hassle trying bring talent blockchain all the research that needed. most the time when were going afternoon workshops with eth-solidity just got too complex. hack with bis repository the place start learn the basis and get started. bismuth core concepts for developers, see: this github link bismuth execution model the current bismuth model very different from the ethereum one. you simply can not transpose what done with smart contracts and solidity. bismuth does not need public "smart" contracts the moment, and does not have where every node executes the same code. although could seen limitation, fact quite strength, and some exploits that have taken place with eth smart contracts could not have been successful bismuth like architecture. "smart" contracts "smart" protocols nutshell eth like smart contracts are written specific language, stored chain, and run every node. bismuth like smart protocols are implemented top the bismuth chain and only run concerned dapps. ethereum you have learn new language, solidity. there are some specific pitfalls (underflow, visibility, access rights). flawed contract code can give infinity coins user. several hacks and horror stories already ethereum smart contracts history. smart contracts can "own" funds smart contracts live the chain forever and can not stopped nor upgraded unless the author provided kill switch. there kill switch, the owner can get all the funds contract. every contract invocation processed every single eth node virtual machine and consumes gas. contracts can not directly access outside resources. eth model has some strengths and some use cases that you could simply not replicate with bis, but bis has other uses. bismuth new language learn. you can write contracts and protocols almost any language, python being the native language. more pitfalls than with your usual code. contracts can not overspend. vm, "on chain" code, public contracts. users can run private contracts. owners then have full control including fix and upgrade over the contract. the contract, its inner working published, fully auditable and verifiable. contract invocation only run the clients that have interest that specific contract. private contracts can anything, including accessing outside data without the need for chain oracles. bismuth tokens things that are widely used, like tokens, are not handled via generic and user code. use case wanted enough, can integrated bismuth core. the bismuth dev team does not have the weight bitcoin eth, and can move forward very very fast. that's the case with tokens. native tokens. optimized, resource savy tokens, indexed tokens. still can overloaded with extra features. code tested, public, the same for everyone: potential bugs are identified and can fixed globally. match eth terminology, current bismuth tokens are partially erc compliant. they not allow delegation: you can not have someone else spend your tokens and approve. more feature packed tokens types may added soon. the bismuth tokens make use the operation and data fields for creation and transfer. the two main operations are token:issue and token:transfer. for more information about bismuth tokens, see this link bismuth "smart" protocols rather than having immutable chain code, that has all power the funds and can have them destroyed locked up, plus run every single node, bismuth favors the concept "smart" protocols. quotes are used, because contract protocol blockchain world really "smart". just code that smart dumb the developer who wrote it. protocol based upon the bismuth transactions, that can considered abstract data. agreement between two more parties what that data means, and what when event occurs. only clients that are involved protocol need read the data and run the code. not every node. code not chain. can updated, fixed, does not clobber the chain, does not consume node resources. they are "contract" between agreeing parties, with the logic ideally being public. anyone can run the logic over the chain data and verify that everyone acted they should. protocols can evolve, overloaded, serve basis for more evolved protocols. protocols can use protocols... for instance, protocol could define valid implementations (with chain hash) itself. for list existing bismuth protocols, see: this github link bismuth features this section contains presentation and description some the core features the bismuth crypto-currency. python and plugins developers who plan build dapps top the bismuth node, are encouraged make use the bismuth feature called "plugin". plugins reside the directory~/bismuth/plugins. the bismuth plugin system, although very lightweight, allows for action and filter hooks critical events, for easy feature addition. for example, plugin wanting implement "block" action hook only has declare simple function: plugins/_test/__init__.py: def action_block(block): print(block) for more information about bismuth plugins, see this link activate new plugin, the bismuth node (node.py) must restarted. use cases lab use case very easy for student set his/her own private network using virtual machines and then changing the default mainnet port number something else. using local network addresses (for example ..x.x ..x.x) and whitelisting these bismuth configuration file (config.txt), possible isolate the lab network from the outside world. with such network, student, researcher developer could test out new features dapps without the need for hardfork the regular main testnet. child chain use cases the child chain use cases can deal with scalability and flexibility. chain with specific properties (block time, entry barrier not needed and not limited the existing mainnet, proof-of-work (pow) chain. hypernode-like pos chain can run top the pow chain. uses the same technology, and developer could have unique chain for his/her app only, with unique chain settings, and define unique transactions types (be currency non currency data both). event sourcing event sourcing object/data model that stores the events leading the current state objects, rather than the current state itself. proof-of-concept (poc) for event sourcing with sample dapps using bismuth available this link. event sourcing would work well combination with private child chain. for example, network customers/providers/partners, agreeing operating shared database. could tracking goods, shipments, invoicing, etc. child chain could operated, with every actor running node (hypernode-like, with private registration) then the event sourcing poc could used. this means that the actors would share distributed and replicated database, where every change the data event, with immutable timestamp and source event, plus rights and on, fully auditable. file fingerprinting the legacy wallet contains feature for fingerprinting one more files using the following code: def fingerprint(): root.filename filedialog.askopenfilename(multiple=true, initialdir="", title="select files for fingerprinting") dict for file root.filename: with open(file, 'rb') fp: data hashlib.blakeb(fp.read()).hexdigest() dict[os.path.split(file)[-]] data openfield.insert(insert, dict) the hash the file(s) then inserted into the "data" field and can sent yourself someone else. the recipient could then use the received message validate the authenticity these files. below list some implemented use cases and games the time writing: anon.py, private contract anonymizer service. dragginator, collectible game based the bismuth blockchain. pokapoka, poker game site using bismuth tokens. zircodice, dice game private contract. autogame, probabilistic multiplayer game implemented private contract. coin supply and reward model the plot below shows the coin supply and rewards for the bismuth blockchain. block height (in year assuming blocks per day) the total coin supply will million bis. from this amount million will miners rewards, million bis will rewards hypernodes and million bis will developer rewards (%) the miner rewards). any change this distribution would require future hard fork which, the time writing, not planned. the bismuth blockchain started may and the inflation rates during the following years are shown the table below: year inflation seen from this table, the inflation quite high initially while rapidly drops year one reason for the relatively high initial inflation the fact that bismuth had pre-mine ico: the total coin supply started zero the genesis block (block height naturally, the inflation will initially large with such distribution model. some motivations behind this coin supply and rewards model ensure fair distribution model bismuth the early phase, while the same time attract miners secure the chain with their hash rates. the project matures, holding bismuth for the long-term encouraged the rapidly falling inflation rates while the miners will continue get rewarded collecting transaction fees. for comparison bismuth's coin supply and reward model with some other blockchain projects, see https://hypernodes.bismuth.live/?p= cryptography most today's crypto currencies use elliptic curve cryptography ecc along with ecdsa signature algorithm. while ecc keys and signature are short and potentially secure with less bits than previous cryptographic keys and signature algorithms, they are relatively new family and always possible that completely new class flaw found, effectively rendering all ecc based chains insecure. bismuth paradoxically innovates using older but very well known asymmetric cryptographic algorithm, rsa, which studied since its publication and relies core properties large prime numbers. widely used secure ssh and ssl certificates all over the web since decades. key lengths: rsa key length bits sufficient for many medium-security purposes such web site logins. for high-security applications for data that needs remain confidential for more than few years, -bit key recommended and should safe until keep data confidential for more than the next two decades, rsa recommends key size larger than bits. bits are recommended for usage post bismuth relies bits rsa keys, not take any risk. private key the private key only known the wallet owner. currently stored under pem base format. example: -begin rsa private key- miibgjacbgoqhkigwbdaedmaeckzesfwlqoidagidascawbuizmnv puro/mdt+yceywxiccenrbmvatsvbwtgb/xydycqklrhcnjgp/ ... -end rsa private key- public key the public key also stored and transmitted pem format example: -begin public key- miicijanbgkqhkigwbaqefaaocagamiiccgkcageanzgeotdlzlpfmsvkno fomgpmrguvfz/ewzbtuujyvperbldsasgbycuzuppzm/vytqkhyjjy ... klygwgdqc+mrskwcwwgqtxecaweaaq== -end public key- address the address matching key the sha hash the public key pem, under hex format. example: ebaddaaecacdaeafcacbde signatures bismuth uses pkcs signature algorithm. both public key and signature are sent with every transaction, and validated upon reception. multiple address schemes order expand bismuth's capabilities and footprint, the bismuth foundation had planned support several alternative cryptographic primitives. this was the roadmap since while and reality since july bismuth nodes now also support new ecdsa cryptographic primitive well new addresses scheme, while retaining rsa for coinbase operations and keeping full compatibility between the two schemes. ecdsa used most existing crypto-platforms, and has allowed for more effi- cient and swift operations, such rapid signing times and smaller signatures. while integrating with bismuth, the core developers took care follow much possible the current bip standard guarantee optimum compatibility, which enables bis integrate seamlessly with the existing architecture built around the bitcoin ecosystem. will introduce new address format beginning with the "bis" prefix, allowing for consistent and nicer-looking bismuth addresses. with ecdsa, bismuth becomes paper wallet compatible, well seed-word compatible. integration with existing hardware wallet solutions such "trezor" and "ledger" become simplified, and last but not least, efficient mobile wallet applications for bismuth become reality. it's the user the bismuth foundation wants give users the choice which scheme use, whether the older rsa newer ecdsa. both algorithms have their respective strengths and weaknesses, and should the preference the users and application developers which one they prefer use. both will coexist within the bismuth protocol, and compatible but this additional facet modularity should appeal everyone. bismuth the only platform offer this level choice, and offers high level security- one point the future backdoor was found for ecdsa, bismuth would the most unaffected uses rsa for all coinbase operations, and users could immediately fallback for all activity, without complicated chain swap process. the same cannot said for most other existing crypto-platforms, which ecdsa used for all operations. future proof the introduction multi-scheme addresses will help advancing bismuth many aspects, whether expanding its footprint and presence hardware devices, boosting its capabilities regards address generation and formats. step forward both scheme modernization and establishing new standard multi-scheme addresses. some point, options can even extended beyond rsa and ecdsa. the code handling the signatures and addresses modular and extendable. although undocumented, the cryptographic primitive also supported current nodes for instance. more schemes could added later on, address the possible threats quantum computing could pose any the existing ones. mining algorithm the mainnet the bismuth crypto-currency project was launched may st, the mining algorithm was based sha and briefly described here http://dx.doi.org/./mic.... the beginning there were only cpu miners, but after less than months the first gpu miners appeared and shortly afterwards the first gpu mining pools. bismuth was listed the cryptopia exchange during october and that led large increase new accounts the network. january the number bismuth accounts had quadrupled compared before the exchange listing. since bismuth had relatively simple mining algorithm requiring very little memory the gpus, the network was vulnerable attack large fpga asic mining operation. the core development team was well aware this threat, but decided work other issues instead, such general network stability improvements, addition new functions and features. the introduction hypernodes and the side-chain was one example. during august and september became increasingly evident that fpga miner had been developed, and that this mining operation was approaching portion the overall mining power the network. the figure below shows the hashrate distribution the different pools that time: the presence large fpga miner was identified several independent channels: bismuth network monitoring pages, pools, miners themselves reporting anomalies, regular exchange dumps, internal core team research fpga capabilities well work with fpga developers. the fpga operation was alternating between mining his own account and using pool the figure above. after the hypernodes had been successfully launched, the core dev team had act swiftly, and evolution the mining algorithm moved the top the priority list, even though this had not been placed the roadmap which was published few months earlier. the modi- fied mining algorithm was developed and tested private testnet record time during september took less than weeks from the first conceptual ideas until launch the new mining algorithm. even with this rapid pace development, the exchanges and the pools were given week's notice and time update their nodes. what made the fpga mining efficient was the fact that the legacy bismuth mining algorithm required only processing power, but memory. after careful research and tests, one the core developers, eggdrasyl, came with slight change the current mining algorithm that: memory hard. would block penalize the specific fpga miner lot. still fast verify nodes. needs only minimal change current gpu miners, can implemented quickly pools. the "bismuth heavy mining algorithm was born, and would used after the fork. october block height the new and novel heavy mining algorithm was introduced the bismuth mainnet. previously the bismuth mining algorithm was computationally expensive, but required little memory. order make the new mining algorithm more resistant fpgas and asics, requirement hold random binary file memory was introduced, illustrated with the yellow boxes the chart below: bismuth heavy the idea behind the "heavy" algorithm designed eggdrasyl both simple and effective: requires read from random offset fixed lookup table, for each tested nonce. this concept can applied any other mining algorithm additional layer protect against similar attack. the matching algorithm uses hashcash not bismuth does not irrelevant. the final hash state that tested vector bits words. since hash result, can considered random vector, can contain anything, and you can not reverse the process this hash core property the lookup table also contains random data. for each nonce, the extra step applying xor transform the hash output, given random vector from the lookup table, with the index begin determined the hash itself, therefore random, non predictable, location. the result xor'd hash state considered the input vector the difficulty matching function. this transformation does not affect the probability finding good candidate. does not change the hashing algorithm itself. does not change the difficulty matching algorithm either. requires reading about words from random index for every tried nonce. the miner has keep copy the whole lookup table memory all time. this then generic tweak that can applied instantly any other crypto. mid and long term considerations the core team still favor fpgas and why not dedicated asics hardware for bismuth. this the only way pow coin can protect its network. pure gpu coins always are the mercy nicehash similarly rented hash attack. hash/watt fpgas and asics way better than gpus, you have better efficiency and more hash, more secure network with more resources needed take over. this only true the mining equipment largely available. not when single operation has thousands custom proprietary hardware. next step could the introducing several mining channels, that everyone has fair chance mine, reach profitability, and contribute the network safety (cpus, gpus, fpgas, asics). this would also allow for faster algorithm changes should similar situation arise again. average block time (sec) controller output (difficulty) chain security the bismuth blockchain uses feedback control strategy calculate the difficulty adjustment the mining process, see doi:./mic... the mic journal for more details. combination with this feedback controller bismuth uses the longest chain rule determine consensus. how does such approach compare with the alternative approach deciding consensus based total hashwork (ie. selecting the chain which has the most hashwork it)? answer this question, the simulink model shown figure the mic paper used. consider the following scenario: the difficulty level stable diff= and the hour average blocktime stable seconds. block number large pool with the total hashpower decides break off it's own chain try mine longer chain than the rest the network. there will now two competing chains: the chain breaking off with the original hashpower and the main network which will this case get reduced the original hashpower block number block number block number the figure above shows how the feedback controller and the difficulty adjustment react for the hashpower chain. the difficulty drops from down while the average blocktime increases almost seconds, before comes back down again and settles seconds. the total accumulated time generate blocks this example days. average block time (sec) controller output (difficulty) block number block number the figure above shows how the feedback controller and the difficulty adjustment react for the other chain with the hashpower. the difficulty drops from down while the average blocktime increases about seconds, before comes back down again and settles seconds. the total accumulated time generate blocks this example days. the reason why the chain generates blocks faster than the chain, because the overshoot blocktime seconds seconds) smaller for the chain with the largest hashpower behind it. since the hashpower chain produces blocks this example faster than the chain with the hashpower, the chain will also the longest and the consensus rule currently implemented bismuth will select the chain with the most hashwork the winner. can seen from this simulation, the chain with the largest amount remaining hashpower will produce the longest chain case network fork. other words, bismuth's implementation feedback control algorithm for the difficulty adjustment combined with the longest chain rule achieves the same result selecting consensus based the largest total amount hashwork, method which used other blockchain implementations. bismuth's unique implementation difficulty adjustment and longest chain rule can therefore considered secure other consensus implementations based total hashwork. tail removal block validation the probability density function (pdf) describing the distribution blocktimes many crypto-currencies, such bitcoin for example, has long tail, meaning that there small, but nonzero, probability that can take very long time generate new block, even when the computational power the miners constant increasing. such long blocktimes problem for two reasons: long processing times transactions undesirable. processing times which are many factors larger than the desired average blocktime are seen negative, blockchain feedback control algorithm can typically not distinguish between long tail blocktime and the situation where the computational power the miners has dropped. hence, long tail blocktime will normally cause fast- responding controller lower the difficulty when should not so, and this behavior can cause unwanted oscillations instability the process. bismuth solution for removing long tail blocks has been implemented and the results are shown the figures above. the figure the left shows the pdf without the tail removal code activated (solid red curve) and with tail removal activated (blue bars). the figure the right shows the same, but zoomed blocktimes larger than seconds. seen from these figures, the probability long tail blocktimes (larger than seconds) has been significantly reduced bismuth, ensuring timely execution transactions. for more information about the actual implementation, see the journal article: kucera and hovland, "tail removal block validation: implementation and analysis", http://dx.doi.org/./mic... operation and data field bismuth has two fields which can used dapp developers: the operation and data fields. these fields are marked with red rectangles the light wallet the figure below: the two fields are also available the tornado wallet, see figure below: the operation and data fields can also used programmatically, for example using the examples this link. code example from this repository is: from bismuthclient.bismuthclient import bismuthclient __name__ "__main__": client bismuthclient(wallet_file='wallet.der') not client.address: client.new_wallet() client.load_wallet() print(f"my address {client.address}") txid client.send(recipient=client.address, amount=) tries send self print(f"txid {txid}") this example code sends bis yourself. send bis another account, replace client.address with the account address string, for example: recipient="bafcaabbaffffdffadaf" utilize the operation and datafield, the following example command could used: txid client.send(recipient= "bafcaabbaffffdffadaf", operation='dragg:transfer', data='draggon_adn') the use operation and datafield, major difference from other cryptocurrencies. because the real world principle, the bismuth project acknowledges the need store data the chain, and does not make hard for the user. instead, bismuth uses that meta data that can serve for higher level operations. this the pure bismuth spirit: abstract data, easy read/write, the node handles without having know what operation/datafield means and process, but that participating apps can interpret and act upon. the operation/datafield also allow the separation between the node (base layer, transport/authenticity/immutability/abstract data) and the dapp (use the data, interprets, acts upon, higher level operations). private contracts described the section above, bismuth has two fields which can leveraged extra protocols: the "data" and "operation" fields. these fields can utilized different ways create private contracts: private private data, ie. encrypted messages. private non public contract code. private private, untraceable recipient using abstract transactions and encrypted messages. abstract transactions one bis strengths allow abstract transactions. these are transactions with bis involved, and data that only understandable the dapps which participate that protocol. the "operation" field used kind "command" operator. the convention use strings formated "class:operation" allow for easy classification, like kind namespace. the openfield then holds the associated (short) data. developers can define their own operations, but have make sure that their protocol does not use already used namespaces, see this link for up-to-date list existing protocols. bis transaction fees are fixed and depend only the openfield length byte. fee len(openfield/). on-chain storage not encouraged and could restricted the future. developers should limit the payload the minimum and use side chains dapp dapp channels store real data. hypernodes and sidechain when many different masternode coins are released, can useful give few hints what makes the bismuth hypernodes innovative. bismuth hypernodes tech lab and bismuth abilities proof bismuth grows and the team gathers more and more experience, some weaknesses the nodes are more visible. not always possible test change the design running blockchain, used many people and organizations, but easy use the hypernodes lab field test new technologies, libraries and algorithms. the bismuth hypernodes will include several new technology layers that could used later on, the core code. hypernodes also demonstrate the ease integration and leverage bismuth abstract transactions. the hypernodes are good example what can done with the openness and abstraction layer that bismuth provides. network value the goal the bismuth hypernodes provide added value the network. some basic masternodes implementations are merely staking check for "ping" answer. the bismuth hypernodes operate entire different layer. they use chain their own, with currency but metrics key performance indicators (kpis) instead. both chains are loosely coupled and operate almost independent manner, with very different rules. the hypernodes operate proof stake (pos) chain, with mining and competition between the hypernodes. they observe and store their kpis the pos chain. since the hypernodes are not part the pow chain, they not add extra attack vectors. eligible hypernodes are derived from immutable info stored the pow chain. quality index and bad behavior from both pos and pow nodes recorded, immutable also, the pos chain for later action. the independence the two chains ensures: way harder manipulate the network, since requires forge both chains very different ways. bad actors and cheating attempts are recorded independent and immutable way. you cannot cheat unnoticed. bismuth may the first crypto-currency come with integrated but independent kpis dedicated side chain that monitors the network and ensures actors fair play. bismuth hybrid pow/pos the protocol used bismuth pow/pos hybrid, two-layers approach. uses strength from both pow and pos and tries avoid the pitfalls other hybrid approaches. rather than being integral part the main consensus, the pos layer acts impartial observer the pow chain, and its metrics can then used act upon the core cause the issues the bad actors. pos watches over the pow actors, pow decides who can pos actor. like ourobouros, each chain having some control over the other one. terms security, big improvement, since both chains would have attacked the same time and coherent manner gain some advantage. since the mechanisms each chain are different, this epic task. future use such side chains the loosely coupled two layer approach the hypernodes has several advantages, well many future uses. potential ones are: there incentive, the contrary, forging more blocks blocking others from forging theirs take their turn. for now, there only single pos chain, the hypernodes with their metrics. but any number pos chains can added the bismuth network, without overloading the main pow chain. you can see them side chains, and they give lot flexibility. since the chains are loosely coupled, the very same protocol can used other currencies. almost any currency that pow only could add bismuth-like hypernode layer and benefit from the security this hybrid approach, well flexible side child chains. so, bismuth continues explore new territories, with practical and field tested code. the goal for the hypernodes code become framework for easy run side chains. every such chain can have its own rules, block time, fees (or fees), storage, and still secured the main bis chain some peeks into the technology from simple proof concept, the bismuth code grew into full featured node and client code base. some new technology had left over order keep some compatibility with the current network. the hypernodes are not constrained that, and can use more modern approach from the start. async async await, use co-routines, big strength modern python. this allows write efficient and easy read async code. more need spawn hundreds threads processes, handle locks and hard debug race conditions. need fight with several concurrent access single database file. more infamous global interpreter lock (gil) limitations. within the hypernodes, async used its full extent. the core hypernode tornado server and client, with callbacks using async calls themselves. this both big plus for the performance the node itself (it barely uses any resource under load) well from safety point view. protobuf google protobuf serialization protocol that both fast and efficient. also has available bindings for almost any language, was chosen the low level exchange format. instead verbose text encoding the structures, the hypernodes will use protobuf. pros: fast, low overhead. small size the packets. more validity controls. cross and language compatible. cryptographic primitives hash the hypernodes make use modern blake cryptographic primitives. they are fast, safe, and have variable output length. keys and signature hypernodes addresses use classic ecdsa cryptographic curves. chain coupling how the two layers interact how does pos (hypernodes) use pow (nodes)? each hypernode runs along with classic bismuth (pow) node. has read access the pow ledger and node status, like peers, consensus, block height. this read only access. the hypernode just observer. from this data, the hypernode able to: get safe, immutable, shared list valid hypernodes. each round start, the hypernodes need common list theirs decide the round jurors. this list extracted from the pow chain, from checkpoint the past with enough confirmations stable. composed the valid registrations the hypernodes owners. this start list cannot manipulated the pos layer. collect metrics over the pow peers. each time peer connects the pow node, leaks much info: version, block height, ip, ping time, consensus state, connectivity status ... the same for specific actions like rollbacks. even failed connection attempt something worth recording. those are metrics the hypernode can collect and just write the pos chain. once aggregated over round all the hypernodes, these metrics can used evaluate the state the pow participants, and then compile lists and peers for instance. how does pow (nodes) use pos (hypernode)? the same way, the pow layer can use data provided the hypernodes: dynamic list bad and good peers. more reliable info about the current net height. this will allow the nodes avoid bad rep peers swarms fake nodes the cloud fake nodes targeting miner nodes well old nodes that are stuck bad block, not maintained old version. so, instead being integral part the pow process that would only add complexity well attack vectors the pos chain rather gives access impartial extra data that used qualify the pow and pos actors. the metrics kpis many metrics are available here act upon. the role the hypernodes precisely collect them all, the team can analyze and decide which one used, and how. the metrics themselves can evolve with time. can the active metrics and their corresponding trigger. the bismuth developers believe this will hand crafted start, then evolve into governance parameters. hypernodes and/or nodes owner will likely able vote upon various triggers and levels order mitigate observed bad behavior. the precise metrics and how they can used will detailed another evolving document. hypernodes payouts with usual masternodes mechanism, the forging masternode gets reward for each block forges. this means there incentive cheat, since you get more blocks deny other blocks, you can hope for higher reward. with the bismuth hypernodes, such attempt would play against you, since the reward not directly related the blocks you forge, and everyone would see you cheat and record the pos ledger, forever. also, with the bismuth scheme, every hypernode owner paid regular basis. randomness involved. every finished round leads payout for every active hypernode. hypernode payouts can handled several means. the first steps, they will handled private contract can tuned and the team makes sure safe. the process something like this: there given reward amount for the period (can fixed governance parameter). the hypernodes for the period share the reward. active means the hypernode was the list valid hypernodes, has collected and sent metrics, has interacted with peers, may have forged some blocks was juror. the rewards should proportional the collateral amount. you have one hypernode with twice the collateral another one, will get twice its reward. the private contract computes every reward and pays them. the details all computation inputs are public and stored the pos chain for everyone verify. the algorithm public too. governance since kpis and levels will likely used trigger bans actions against some actors, natural ask for governance process. launch, given the experimental nature the project however, this will not possible. the team will manually handle the analysis process, order have good overview the meaningful kpis and their usage. later on, the filters could become autonomous and various parameters could voted upon hypernodes owners. hyperblock compression bismuth uses dual database system for both redundancy and speed. besides the standard full ledger database, hyperblocks are compressed version the same data, which contain only the last blocks and only sums outstanding balances greater than zero for all preceding transactions. some scenarios, hyperblock balances are compared ledger data for discrepancy detection. also, the hyperblock database loaded into the memory node startup, limiting hard drive access minimize system load and increase database reaction speed and availability. penalty system every node the bismuth consensus system tracks the behaviour all connected clients. penalties are applied all nodes that enforce chain switching through single block rollback, one half the penalty removed for being honest and delivering the agnostically longest chain block. nodes that are too far the future for local consensus are banned automatically. this set rules requires attacker not only own more than half the computing power, also requires him connected all nodes the system, attack them all the same time and setup majority nodes. even then, the attack becomes progressively harder with every attacked block. mirror blocks mirror block technology enables easy implementation hardcoded contracts like hypernode rewards, offline staking and development rewards. mirror block storage on-chain but outside traditional blocks, denominated minus symbol not interfere with the synchronization process. the mirror blocks are never shared between nodes, instead they are created from the contract execution, optionally dependent the blockchain data. this approach makes integral part the standard transaction database, streamlining operations like account balance evaluation. testnet the bismuth testnet consists network nodes with different addresses, much like the bismuth mainnet, but with fewer nodes. setup testnet node, the following parameters must defined the file config.txt: port= version=testnet version_allow=testnet testnet=true the difficulty level for the mining algorithm testnet low purpose. hence, developers can easily set local pool and miner generate bis coins testnet. for this, optipoolware recommended. regnet setup regnet node, the following parameters must defined the file config.txt: version=regnet version_allow=regnet test that testnet regnet are running the following command can used: python commands.py statusget the output from regnet should something like this: number arguments: arguments. argument list: ['commands.py', 'statusget'] regtest mode {"protocolversion": "regnet", "address": "abafadfcbbbcabedaaf", "walletversion": "..", "testnet": false, "blocks": "timeoffset": "connections": "connections_list": {}, "difficulty": "threads": "uptime": "consensus": null, "consensus_percent": "server_timestamp": ".", "regnet": true} for regnet, there need set miner. the "generate" command instamines blocks with current wallet address miner. for example, you can "generate" blocks, then you have bis you can test send your regnet. after that, "generate" block, and your mempool transactions are instamined. regnet useful because starts from block height= and does not require sync the blockchain with networked peers. many features new dapp can tested the early stage regnet. only when distributed networked features need tested, does the developer need switch from regnet testnet. education and research bismuth ideal platform for education and research. examples research done using bismuth mainnet and testnet are the following journal articles: kucera and hovland, "tail removal block validation: implementation and analysis", http://dx.doi.org/./mic... hovland and kucera, nonlinear feedback control and stability analysis proof-of-work blockchain", http://dx.doi.org/./mic... regnet would particularly useful educational setting, each student could run local regnet his/her computer, without the need participate distributed network. many the basic concepts blockchain technology could taught using the bismuth regnet. researchers and students who develop novel functions and features using bismuth, are encouraged contact the bismuth core development team discord, https://discord.gg/tbpyj. new functions and features could potentially make into the bismuth node code, after period additional testing the core team. future prospectives the goal the bismuth project make the core node well documented and streamlined and efficient possible, and then encourage future extensions and applications building top bismuth use the plugin system and separate repositories. the bismuth developers have focus supporting "crypto standard compliance" and "ecosystem", allow for easier interaction with existing tools, protocols and platforms, and therefore removing "friction". new address formats (such ecdsa), bitcoin like json-rpc server, docker images bismuth services fall this category. another example the packaged and easy use "bismuthclient" python module which has proven valuable, with several team and third party devs building upon it, and attracting new devs. bismuth already feature-rich crypto-currency, and this whitepaper has focused parts which are already implemented, tested and working. more features are developed the future, they will documented and included updated versions this whitepaper. the core team has development roadmap, which available this github link. summary this whitepaper provides outline the philosophy, pillars and features the bismuth crypto-currency. the three pillars bismuth are: the real world principle, meaning that the core developer team takes pragmatic approach when introducing new features and functions, the "need store" meaning that you only store chain what needs stored on-chain, and nothing more. still, following the real world principle, chain storage not strongly discouraged and clear line trust, meaning that when you have trust something someone, you know what/who you have trust. bismuth not presented trustless, whereas you implicitly trust several layers and people. some the core features bismuth have been presented and discussed some detail. links and references have been provided for readers seeking more detailed information about the bismuth crypto-currency and its implementation. disclaimer the information this whitepaper for informational purposes only and does not contain any investment financial advice. please your own research before making any investment decisions. none the information this document constitutes, should relied as, suggestion, offer, other solicitation engage in, refrain from engaging in, any purchase, sale, any other any investment-related activity with respect any crypto-currency. cryptocurrency investments are volatile and high risk nature. not invest more than what you can afford lose. document revision history august v., multiple address schemes, tokens, formatting, updated future prospectives may v., added sections about mirror blocks, chain security, updated coin supply and rewards april whitepaper released