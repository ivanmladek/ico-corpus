filecoin: decentralized storage network protocol labs july abstract the internet the middle revolution: centralized proprietary services are being replaced with decentralized open ones; trusted parties replaced with verifiable computation; brittle location addresses replaced with resilient content addresses; inefficient monolithic services replaced with peer-to-peer algorithmic markets. bitcoin, ethereum, and other blockchain networks have proven the utility decentralized transaction ledgers. these public ledgers process sophisticated smart contract applications and transact crypto-assets worth tens billions dollars. these systems are the first instances internetwide open services, where participants form decentralized network providing useful services for pay, with central management trusted parties. ipfs has proven the utility content-addressing decentralizing the web itself, serving billions files used across global peer-to-peer network. liberates data from silos, survives network partitions, works offline, routes around censorship, and gives permanence digital information. filecoin decentralized storage network that turns cloud storage into algorithmic market. the market runs blockchain with native protocol token (also called "filecoin"), which miners earn providing storage clients. conversely, clients spend filecoin hiring miners store distribute data. with bitcoin, filecoin miners compete mine blocks with sizable rewards, but filecoin mining power proportional active storage, which directly provides useful service clients (unlike bitcoin mining, whose usefulness limited maintaining blockchain consensus). this creates powerful incentive for miners amass much storage they can, and rent out clients. the protocol weaves these amassed resources into self-healing storage network that anybody the world can rely on. the network achieves robustness replicating and dispersing content, while automatically detecting and repairing replica failures. clients can select replication parameters protect against different threat models. the protocol's cloud storage network also provides security, content encrypted end-to-end the client, while storage providers not have access decryption keys. filecoin works incentive layer top ipfs [], which can provide storage infrastructure for any data. especially useful for decentralizing data, building and running distributed applications, and implementing smart contracts. this work: (a) introduces the filecoin network, gives overview the protocol, and walks through several components detail. (b) formalizes decentralized storage network (dsn) schemes and their properties, then constructs filecoin dsn. (c) introduces novel class proof-of-storage schemes called proof-of-replication, which allows proving that any replica data stored physically independent storage. (d) introduces novel useful-work consensus based sequential proofs-of-replication and storage measure power. (e) formalizes verifiable markets and constructs two markets, storage market and retrieval market, which govern how data written and read from filecoin, respectively. (f) discusses use cases, connections other systems, and how use the protocol. note: filecoin work progress. active research under way, and new versions this paper will appear https://filecoin.io. for comments and suggestions, contact research@filecoin.io. contents introduction elementary components protocol overview paper organization definition decentralized storage network fault tolerance properties proof-of-replication and proof-of-spacetime motivation proof-of-replication proof-of-spacetime practical porep and post usage filecoin filecoin: dsn construction setting data structures protocol guarantees and requirements filecoin storage and retrieval verifiable markets storage market retrieval market markets useful work consensus motivation filecoin consensus smart contracts contracts filecoin integration with other systems future work on-going work open questions proofs and formal verification list figures sketch the filecoin protocol. illustration the filecoin protocol illustration the underlying mechanism post.prove proof-of-replication and proof-of-spacetime protocol sketches data structures dsn scheme example execution the filecoin dsn description the put and get protocols the filecoin dsn description the manage protocol the filecoin dsn generic protocol for verifiable markets orders data structures for the retrieval and storage markets detailed storage market protocol detailed retrieval market protocol leader election the expected consensus protocol introduction filecoin protocol token whose blockchain runs novel proof, called proof-of-spacetime, where blocks are created miners that are storing data. filecoin protocol provides data storage and retrieval service via network independent storage providers that does not rely single coordinator, where: clients pay store and retrieve data, storage miners earn tokens offering storage retrieval miners earn tokens serving data. elementary components the filecoin protocol builds upon four novel components. decentralized storage network (dsn): provide abstraction for network independent storage providers offer storage and retrieval services (in section later, present the filecoin protocol incentivized, auditable and verifiable dsn construction (in section novel proofs-of-storage: present two novel proofs-of-storage (in section proof-ofreplication allows storage providers prove that data has been replicated its own uniquely dedicated physical storage. enforcing unique physical copies enables verifier check that prover not deduplicating multiple copies the data into the same storage space; proof-of-spacetime allows storage providers prove they have stored some data throughout specified amount time. verifiable markets: model storage requests and retrieval requests orders two decentralized verifiable markets operated the filecoin network (in section verifiable markets ensure that payments are performed when service has been correctly provided. present the storage market and the retrieval market where miners and clients can respectively submit storage and retrieval orders. useful proof-of-work show how construct useful proof-of-work based proof-ofspacetime that can used consensus protocols. miners not need spend wasteful computation mine blocks, but instead must store data the network. protocol overview the filecoin protocol decentralized storage network construction built blockchain and with native token. clients spend tokens for storing and retrieving data and miners earn tokens storing and serving data. the filecoin dsn handle storage and retrieval requests respectively via two verifiable markets: the storage market and the retrieval market. clients and miners set the prices for the services requested and offered and submit their orders the markets. the markets are operated the filecoin network which employs proof-of-spacetime and proof-ofreplication guarantee that miners have correctly stored the data they committed store. finally, miners can participate the creations new blocks for the underlining blockchain. the influence miner over the next block proportional the amount their storage currently use the network. sketch the filecoin protocol, using nomenclature defined later within the paper, shown figure accompanied with illustration figure paper organization the remainder this paper organized follows. present our definition and requirements for theoretical dsnscheme section section motivate, define, and present our proof-of-replication and proof-of-spacetime protocols, used within filecoin cryptographically verify that data continuously stored accordance with deals made. section describes the concrete instantiation the filecoin dsn, describing data structures, protocols, and the interactions between participants. section defines and describes the concept verifiable markets, well their implementations, the storage market and retrieval market. section motivates and describes the use the proof-of-spacetime protocol for demonstrating and evaluating miner's contribution the network, which necessary extend the blockchain and assign the block reward. section provides brief description smart contracts within the filecoin conclude with discussion future work section filecoin protocol sketch network each epoch the ledger storage mine any time: for each new block: (a) check the block the valid format (b) check all transactions are valid (c) check all orders are valid (d) check all proofs are valid (e) check all pledges are valid (f) discard block, any the above fails for each new order introduced (a) add the storage market's orderbook. (b) bid lock o.funds (c) ask lock o.space (d) deal run put.assignorders for each the storage market's orderbook: (a) check has expired (or canceled): remove from the orderbook return unspent o.funds free o.space from alloctable (b) deal, check the expected proofs exist running manage.repairorders: one missing, penalize the m's pledge collateral proofs are missing for more than fault epochs, cancel order and re-introduce the market the piece cannot retrieved and reconstructed from the network, cancel order and re-fund the client renew expired pledges via manage.pledgesector pledge new storage via manage.pledgesector submit new ask order via put.addorder each epoch for each oask the orderbook: (a) find matched orders via put.matchorders (b) start new deal contacting the matching client for each sector pledged: (a) generate proof storage via manage.provesector (b) time post the proof (every proof epochs), submit the blockchain receiving piece from client check the piece the size specified the order obid create odeal and sign and send store the piece sector the sector full, run manage.sealsector retrieval mine any time: gossip ask orders the network listen bid orders from the network retrieval request from client any time: start payment channel with split data multiple parts only send parts payments are received submit new storage orders via put.addorders (a) find matching orders via put.matchorders (b) send file the matched miner submit new retrieval orders via get.addorders (a) find matching orders via get.matchorders (b) create payment channel with receiving odeal from storage miners sign odeal submit the signed odeal the blockchain via put.addorders receiving from retrieval miners verify that valid and was requested send micropayment figure sketch the filecoin protocol. order matching settlement bid storage market (on chain) deal ask challenge deal deal response payment orderbook filecoin blockchain transactions allocation table incremental micropayments bid retrieval market deal ask (off chain) deal data sent parts orders gossiped off-chain lock storage miner client ... claim micropayments signed transfer filecoin send piece data query order figure illustration the filecoin protocol, showing overview the client-miner interactions. the storage and retrieval markets shown above and below the blockchain, respectively, with time advancing from the order matching phase the left the settlement phase the right. note that before micropayments can made for retrieval, the client must lock the funds for the microtransaction. definition decentralized storage network introduce the notion decentralized storage network (dsn) scheme. dsns aggregate storage offered multiple independent storage providers and self-coordinate provide data storage and data retrieval clients. coordination decentralized and does not require trusted parties: the secure operation theses systems achieved through protocols that coordinate and verify operations carried out individual parties. dsns can employ different strategies for coordination, including byzantine agreement, gossip protocols, crdts, depending the requirements the system. later, section provide construction for the filecoin dsn. definition dsn scheme tuple protocols run storage providers and clients: (put, get, manage) put(data) key: clients execute the put protocol store data under unique identifier key. get(key) data: clients execute the get protocol retrieve data that currently stored using key. manage(): the network participants coordinates via the manage protocol to: control the available storage, audit the service offered providers and repair possible faults. the manage protocol run storage providers often conjunction with clients network auditors dsn scheme must guarantee data integrity and retrievability well tolerate management and storage faults defined the following sections. fault tolerance management faults define management faults byzantine faults caused participants the manage protocol. dsn scheme relies the fault tolerance its underlining manage protocol. violations the faults tolerance assumptions for management faults can compromise liveness and safety the system. for example, consider dsn scheme where the manage protocol requires byzantine agreement (ba) audit storage providers. such protocol, the network receives proofs storage from storage providers and runs agree the validity these proofs. the tolerates faults out total nodes, then our dsn can tolerate .price bid order: check ask order ii) check .price .price iii) check .size .size output matched orders ...on exchange sendpiece inputs: ask order oask bid order obid piece outputs: deal order odeal signed create odeal set odeal .ask oask set odeal .bid odeal get identity from obid signature setup micropayment channel with for each block data set merkle path from h(p) send (odeal ,pj receive odeal ici output odeal exchange sendpiece inputs: ask order oask bid order obid piece outputs: deal order odeal signed get identity from oask signature send (oask ,obid ,p) receive odeal signed check odeal valid according definition output odeal receivepiece inputs: signing key for current orderbook orderbook ask order oask bid order obid piece outputs: deal order odeal signed and check obid valid: check obid orderbook check obid not referenced other active odeal check obid .size equal |p| check signed store locally set odeal oask odeal h(p) imi get identity from obid send odeal output odeal receivepiece inputs: client's key ask order oask bid order obid merkle tree hash the orders outputs: piece create odeal set odeal .ask oask set odeal .bid obid get identity from oask signature set micropayment channel with (or re-using existing one) when receiving (odeal from check odeal valid and matches oask and obid check valid merkle-path with root hash send odeal ici output figure description the put and get protocols the filecoin dsn manage protocol network assignorders inputs: ..o deal orders odeal deal allocation table alloctable outputs: updated allocation table alloctable copy alloctable alloctable for each order odeal check odeal valid according definition get from odeal signature alloctable add details from odeal output alloctable miner pledgesector inputs: current allocation table alloctable pledge request pledge outputs: alloctable copy alloctable alloctable set txpledge (pledge) submit txpledge wait for txpledge included add new sector size pledge.size alloctable output alloctable repairorders inputs: current time current ledger table storage allocations alloctable ..o updated alloca* outputs: orders repair odeal deal tion table alloctable for each allocentry alloctable: fault then set all the orders from the current sector failed orders ..o output failed orders odeal deal and alloctable sealsector inputs: miner public/private key pair sector index allocation table alloctable outputs: proof pseal root hash find all the pieces ..pn sector the alloctable set |..|pn compute (r, rt, pseal post.setup(m, pkseal output pseal provesector inputs: miner public/private key pair sector index challenge outputs: proof ppos find for sector compute ppost post.prove(pkpost proof output ppost figure description the manage protocol the filecoin dsn filecoin storage and retrieval markets filecoin has two markets: the storage market and the retrieval market. the two markets have the same structure but different design. the storage market allows clients pay storage miners store data. the retrieval market allows clients retrieve data paying retrieval miners deliver the data. both cases, clients and miners can set their offer and demand prices accept current offers. the exchanges are run the network personification the network full nodes filecoin. the network guarantees that miners are rewarded the clients when providing the service. verifiable markets exchange markets are protocols that facilitate exchange specific good service. they this enabling buyers and sellers conduct transactions. for our purposes, require exchanges verifiable: decentralized network participants must able verify the exchange between buyers and sellers. present the notion verifiable markets, where single entity governs exchange, transactions are transparent, and anybody can participate pseudonymously. verifiable market protocols operate the exchange goods/services decentralized fashion: consistency the orderbooks, orders settlements and correct execution services are independently verified via the participants miners and full nodes the case filecoin. simplify verifiable markets have the following construction: definition verifiable market protocol with two phases: order matching and settlement. orders are statements intent buy sell security, good service and the orderbook the list all the available orders. verifiable market protocol order matching: participants add buy orders and sell orders the orderbook. when two orders match, involved parties jointly create deal order that commits the two parties the exchange, and propagate the network adding the orderbook. settlement: the network ensures that the transfer goods services has been executed correctly, requiring sellers generate cryptographic proofs for their exchange/service. success, the network processes the payments and clears the orders from the orderbook. figure generic protocol for verifiable markets storage market the storage market verifiable market which allows clients (i.e. buyers) request storage for their data and storage miners (i.e. sellers) offer their storage. requirements design the storage market protocol accordingly the following requirements: in-chain orderbook: important that: storage miners orders are public, that the lowest price always known the network and clients can make informed decision their orders, client orders must always submitted the orderbook, even when they accept the lowest price, this way the market can react the new offer. hence, require orders added clear the filecoin blockchain order added the orderbook. participants committing their resources: require both parties commit their resources way avoid disservice: avoid storage miners not providing the service and avoid clients not having available funds. order participate the storage market, storage miners must pledge, depositing collateral proportional their amount storage dsn (see section for more details). this way, the network can penalize storage miners that not provide proofs storage for the pieces they committed store. similarly, clients must deposit the funds specified the order, guaranteeing this way commitment and availability funds during settlement. self-organization handle faults: orders are only settled storage miners have repeatedly proved that they have stored the pieces for the duration the agreed-upon time period. the network must able verify the existence and the correctness these proofs and act according the rules outlined the repair portion subsection ... datastructures put orders. there are three types orders: bid orders, ask orders and deal orders. storage miners create ask orders add storage, clients create bid orders request storage, when both parties agree price, they jointly create deal order. the data structures the orders are shown detail figure and the parameters the orders are explicitly defined. put orderbook. the orderbook the storage market the set currently valid and open ask, bid and deal orders. users can interact with the orderbook via the methods defined the put protocol: addorders, matchorders described figure the orderbook public and every honest user has the same view the orderbook. every epoch, new orders are added the orderbook new order transactions (txorder appear new blockchain blocks; orders are removed they are cancelled, expired settled. orders are added blockchain blocks, hence the orderbook, they are valid: definition define the validity bid, ask, deal orders: (valid bid order): bid order from client obid hsize, funds[, price, time, coll, coding]ici valid if: has least the amount funds available their account. time not set the past the order must guarantee least minimum amount epochs storage. (valid ask order): ask order from storage miner oask hspace, priceimi valid if: has pledged miner and the pledge will not expire before time epochs. space must less than available storage: pledged storage minus the storage committed the orderbook (in ask and deal orders). (valid deal order): deal order odeal hask, bid, tsici ,mj valid ask references order oask such that: the storage market orderbook, other deal orders the storage market orderbook mention it, signed bid references order obid such that: the storage market orderbook, other deal orders the storage market orderbook mention it, signed not set the future too far the past. remark. malicious client receives signed deal from storage miner, but never adds the orderbook, then the storage miner cannot re-use the storage committed the deal. the field prevents this attack because, after ts, the order becomes invalid and cannot submitted the orderbook. this will parameter the system. storage market orders retrieval market orders bid order obid piece, price ici bid order obid hsize, funds[, price, time, coll, coding]ici piece, the index the piece requesteda price, the price which paying for one retrieval size, the size the piece stored funds, the total amount that client depositing time, the maximum epoch time for which the file should storeda price, the spacetime price filecoinb coll, the collateral specific this piece that the miner required deposit coding, the erasure coding scheme for this piece ask order oask piece, price imi piece, the index the piece requested price, the price which serving the piece for ask order oask space, price imi deal order odeal ask, order ici ,mj space, amount space storage miner providing the order price, the spacetime price filecoin ask, cryptographic reference oask from order, cryptographic reference oask from deal order odeal ask, bid, ts, hash ici ,mj ask, cryptographic reference oask from order, cryptographic reference obid from ts, timestamp epoch which the order has been signed hash cryptographic hash the piece that will store only pieces stored filecoin can requested not specified, the piece will stored until expiration funds. not specified, when storage miner faulty, the network can re-introduce the order the current best price. figure orders data structures for the retrieval and storage markets the storage market protocol brief, the storage market protocol divided two phases: order matching and settlement: order matching: clients and storage miners submit their orders the orderbook submitting transaction the blockchain (step when orders are matched, the client sends the piece the storage miner and both parties sign deal order and submit the orderbook (step settlement: storage miners seal their sectors (step a), generate proofs storage for the sector containing the piece and submit them the blockchain regularly (step b); meanwhile, the rest the network must verify the proofs generated the miners and repair possible faults (step c). the storage market protocol explained detail figure retrieval market the retrieval market allows clients request retrieval specific piece and retrieval miners serve it. unlike storage miners, retrieval miners are not required store pieces through time generate proofs storage. any user the network can become retrieval miner serving pieces exchange for filecoin tokens. retrieval miners can obtain pieces receiving them directly from clients, acquiring them from the retrieval market, storing them from being storage miner. requirements design the retrieval market protocol accordingly the following requirements: off-chain orderbook: clients must able find retrieval miners that are serving the required pieces and directly exchange the pieces, after settling the pricing. this means that the orderbook cannot run via the blockchain since this would the bottleneck for fast retrieval requests instead participant will have only partial view the orderbook. hence, require both parties gossip their orders. retrieval without trusted parties: the impossibility results fair exchange remind that impossible for two parties perform exchange without trusted parties. the storage market, the blockchain network acts (decentralized) trusted party that verifies the storage provided the storage miners. the retrieval market, retrieval miners and clients exchange data without the network witnessing the exchange file. around this result requiring the retrieval miner split their data multiple parts and for each part sent the client, they receive payment. this way, the client stops paying, the miner stops sending data, either party can halt the exchange. note that for this work, must assume that there always one honest retrieval miner. payments channels: clients are interested retrieving the pieces soon they submit their payments, retrieval miners are interested only serving the pieces they are sure receiving payment. validating payments via public ledger can the bottleneck retrieval request, hence must rely efficient off-chain payments. the filecoin blockchain must support payment channels which enable rapid, optimistic transactions and use the blockchain only case disputes. this way, retrieval miners and clients can quickly send the small payments required our protocol. future work includes the creation network payment channels previously seen data structures get orders. there are three types orders the retrieval market: clients create bid orders obid retrieval miners create ask orders oask and deal orders odeal are created jointly when storage miner and client agree deal. the datastructures the orders shown detail figure get orderbook. the orderbook the retrieval market the set valid and open ask, bid and deal orders. unlike the storage market, every user has different view the orderbook, since the orders are gossiped the network and each miner and client only keep track the orders they are interested in. storage market protocol order matching storage miner and client add orders the orderbook: (a) creates oask oask and creates obid obid ... (b) orders are submitted the blockchain via put.addorders(o ..) (c) success, the orders are added the orderbook, the funds from are deposited and the space from reserved. when orders match, involved parties jointly create odeal and add the orderbook: (a) and independently query the orderbook via put.matchorders(o). (b) and have matching orders sends the piece via put.sendpiece(obid oask receives the piece from via put.receivepiece(obid oask p). signs odeal and sends (c) signs odeal and adds the orderbook via put.addorders(odeal settlement the network checks the storage miners are correctly storing the pieces: (a) when storage miner fills sector, they seal (they create unique replica) via manage.sealsector and submit the proof pseal and the blockchain. (b) storage miners generate new proofs every epoch and add them the filecoin blockchain every proof epochs via manage.provesectors. (c) the network runs manage.repairorders every epoch. proofs are missing invalid, the network tries repair the following ways: any proofs are missing invalid, penalizes the storage miners taking part their collateral, large amount proofs are missing invalid for more than fault epochs, considers the storage miner faulty, settles the order failed and reintroduces new order for the same piece into the the market, every storage miner storing this piece faulty, then the piece lost and the client gets refunded. when the time the order expired funds run out, the service was correctly provided, the network processes the payments, and removes the orders. figure detailed storage market protocol the retrieval market protocol brief, the retrieval market protocol divided two phases: order matching and settlement: order matching: clients and retrieval miners submit their orders the orderbook gossiping their orders (step when orders are matched, the client and the retrieval miners establish micropayment channel (step settlement: retrieval miners send small parts the piece the client and for each piece the client sends the miner signed receipt (step the retrieval miner presents the delivery receipts the blockchain get their rewards (step the protocol explained details figure retrieval market protocol order matching: retrieval miners and clients add orders the get.orderbook: (a) retrieval miners creates ask orders (oask oask ..) and client creates bid orders (obid obid ..). (b) both and gossip their orders the filecoin network via get.addorders (c) since there commonly shared orderbook, when users receive orders, they add them their own orderbook's view. differently from the storage market, these orders are not binding and resource committed (e.g. clients don't any deposit). when orders match, involved parties jointly create odeal and add the get.orderbook: (a) retrieval miner and client independently run get.matchorders that queries their own current get.orderbook view. (b) both and sign odeal and add their get.orderbook via get.addorders (as described before) (c) and setup micropayment channel for odeal settlement: both parties check whether the piece has been delivered: (a) sends the piece parts via get.sendpiece (b) receives the parts and for each part, acknowledges delivery sending micropayment via get.receivepiece when the has been received can present the micropayments the network and retrieve the payment, both parties remove their orders from the orderbooks. figure detailed retrieval market protocol useful work consensus the filecoin dsn protocol can implemented top any consensus protocol that allows for verification the filecoin's proofs. this section, present how can bootstrap consensus protocol based useful work. instead wasteful proof-of-work computation, the work filecoin miners generating proofof-spacetime what allows them participate the consensus. useful work. consider the work done the miners consensus protocol useful, the outcome the computation valuable the network, beyond securing the blockchain. motivation while securing the blockchain fundamental importance, proof-of-work schemes often require solving puzzles whose solutions are not reusable require substantial amount wasteful computation find. non-reusable work: most permissionless blockchains require miners solve hard computational puzzle, such inverting hash function. often the solutions these puzzles are useless and not have any inherent value beyond securing the network. can re-purpose this work for something useful? attempts re-use work: there have been several attempts re-use mining power for useful computation. some efforts require miners perform special computation alongside the standard proofof-work. other efforts replace proof-of-work with useful problems that are still hard solve. for example, primecoin re-uses miners' computational power find new prime numbers, ethereum requires miners execute small programs alongside with proof-of-work, and permacoin offers archival services requiring miners invert hash function while proving that some data being archived. although most these attempts perform useful work, the amount wasteful work still prevalent factor these computations. wasteful work: solving hard puzzles can really expensive terms cost machinery and energy consumed, especially these puzzles solely rely computational power. when the mining algorithm embarrassingly parallel, then the prevalent factor solve the puzzle computational power. can reduce the amount wasteful work? attempts reduce waste: ideally, the majority network's resources should spent useful work. some efforts require miners use more energy-efficient solutions. for example, spacemint requires miners dedicate disk space rather than computation; while more energy efficient, theses disks are still "wasted", since they are filled with random data. other efforts replace hard solve puzzles with traditional byzantine agreement based proof-of-stake, where stakeholders vote the next block proportional their share currency the system. set out design consensus protocol with useful work based storing users' data. filecoin consensus propose useful work consensus protocol, where the probability that the network elects miner create new block (we refer this the voting power the miner) proportional their storage currently use relation the rest the network. design the filecoin protocol such that miners would rather invest storage than computing power parallelize the mining computation. miners offer storage and re-use the computation for proof that data being stored participate the consensus. modeling mining power power fault tolerance. our technical report [], present power fault tolerance, abstraction that re-frames byzantine faults terms participants' influence over the outcome the protocol. every participant controls some power which the total power the network, and the fraction power controlled faulty adversarial participants. power filecoin. filecoin, the power pti miner time the sum the storage assignments. the influence iit the fraction power over the total power the network. filecoin, power has the following properties: public: the total amount storage currently use the network public. reading the blockchain, anyone can calculate the storage assignments each miner hence anyone can calculate the power each miner and the total amount power any point time. publicly verifiable: for each storage assignment, miners are required generate proofs-of-spacetime, proving that the service being provided. reading the blockchain, anyone can verify the power claimed miner correct. variable: any point time, miners can add new storage the network pledging with new sector and filling the sector. this way, miners can change their amount power they have through time. accounting for power with proof-of-spacetime every proof blocks miners are required submit proofs-of-spacetime the network, which are only successfully added the blockchain the majority power the network considers them valid. every block, every full node updates the alloctable, adding new storage assignments, removing expiring ones and marking missing proofs. the power miner can calculated and verified summing the entries the alloctable, which can done two ways: full node verification: node has the full blockchain log, run the networkprotocol from the genesis block the current block and read the alloctable for miner this process verifies every proof-of-spacetime for the storage currently assigned simple storage verification: assume light client has access trusted source that broadcasts the latest block. light client can request from nodes the network: the current alloctable entry for miner merkle path that proves that the entry was included the state tree the last block, the headers from the genesis block until the current block. this way, the light client can delegate the verification the proof-of-spacetime the network. the security the power calculation comes from the security proof-of-spacetime. this setting, post guarantees that the miner cannot lie about the amount assigned storage they have. indeed, they cannot claim store more than the data they are storing, since this would require spending time fetching and running the slow post.setup, and they cannot generate proofs faster parallelizing the computation, since post.prove sequential computation. using power achieve consensus foresee multiple strategies for implementing the filecoin consensus extending existing (and future) proof-of-stake consensus protocols, where stake replaced with assigned storage. while foresee improvements proof-of-stake protocols, propose construction based our previous work called expected consensus []. our strategy elect every round one (or more) miners, such that the probability winning election proportional each miner's assigned storage. expected consensus. the basic intuition expected consensus deterministically, unpredictably, and secretly elect small set leaders each epoch. expectation, the number elected leaders per proof system parameter. epoch but some epochs may have zero many leaders. leaders extend the chain creating block and propagating the network. each epoch, the chain extended with one multiple blocks. case leaderless epoch, empty block added the chain. although the blocks chain can linearly ordered, its data structure direct acyclic graph. probabilistic consensus, where each epoch introduces more certainty over previous blocks, eventually reaching enough certainty that the likelihood different history sufficiently small. block committed the majority the participants add their weight the chain where the block belongs to, extending the chain signing blocks. electing miners. every epoch, each miner checks they are elected leader, this done similarly previous protocols: coa [], snow white [], and algorand []. definition (ec election filecoin) miner leader time the following condition met: t||rand(t) pti ptj check pit valid signature from user and check pti the power from time success, output pit ht, rii otherwise output test elected leader h(pit )/l otherwise output figure leader election the expected consensus protocol pti ptj smart contracts filecoin provides two basic primitives the end users: get and put. these primitives allow clients store data and retrieve data from the markets their preferred price. while the primitives cover the default use cases for filecoin, enable for more complex operations designed top get and put supporting deployment smart contracts. users can program new fine-grained storage/retrieval requests that classify file contracts well generic smart contracts. integrate contracts system (based []) and bridge system bring filecoin storage other blockchain, and viceversa, bring other blockchains' functionalities filecoin. expect plethora smart contracts exist the filecoin ecosystem and look forward community smart-contract developers. contracts filecoin smart contracts enable users filecoin write stateful programs that can spend tokens, request storage/retrieval data the markets and validate storage proofs. users can interact with the smart contracts sending transactions the ledger that trigger function calls the contract. extend the smart contract system support filecoin specific operations (e.g. market operations, proof verification). filecoin supports contracts specific data storage, well more generic smart contracts: file contracts: allow users program the conditions for which they are offering providing storage services. there are several examples worth mentioning: contracting miners: clients can specify advance the miners offering the service without participating the market, payment strategies: clients can design different reward strategies for the miners, for example contract can pay the miner incresignly higher through time, another contract can set the price storage informed trusted oracle, ticketing services: contract could allow miner deposit tokens and pay for storage/retrieval behalf their users, more complex operations: clients can create contracts that allow for data update. smart contracts: users can associate programs their transactions like other systems (as ethereum []) which not directly depend the use storage. foresee applications such as: decentralized naming systems, asset tracking and crowdsale platforms. integration with other systems bridges are tools that aim connecting different blockchains; while still work progress, plan support cross chain interaction order bring the filecoin storage other blockchain-based platforms well bringing functionalities from other platforms into filecoin. filecoin other platforms: other blockchain systems such bitcoin [], zcash and particular ethereum and tezos, allow developers write smart contracts; however, these platforms provide very little storage capability and very high cost. plan provide bridge bring storage and retrieval support these platforms. note that ipfs already use several smart contracts (and protocol tokens) way reference and distribute content. adding support filecoin would allow these systems guarantee storage ipfs content exchange filecoin tokens. other platforms filecoin: plan provide bridges connect other blockchain services with filecoin. for example, integration with zcash would allow support for sending requests for storing data privacy. future work this work presents clear and cohesive path toward the construction the filecoin network; however, also consider this work starting point for future research decentralized storage systems. this section identify and populate three categories future work. this includes work that has been completed and merely awaits description and publication, open questions for improving the current protocols, and formalization the protocol. on-going work the following topics represent ongoing work. specification the filecoin state tree every block. detailed performance estimates and benchmarks for filecoin and its components. full implementable filecoin protocol specification. sponsored-retrieval ticketing model where any client can sponsor the download another client issuing per-piece bearer-spendable tokens. hierarchical consensus protocol where filecoin subnets can partition and continue processing transactions during temporary permanent partitions. incremental blockchain snapshotting using snark/stark filecoin-in-ethereum interface contracts and protocols. blockchain archives and inter-blockchain stamping with braid. only post proofs-of-spacetime the blockchain for conflict resolution. formally prove the realizations the filecoin dsn and the novel proofs-of-storage. open questions there are number open questions whose answers have the potential substantially improve the network whole, despite the fact that none them have solved before launch. better primitive for the proof-of-replication seal function, which ideally o(n) decode (not o(nm)) and publicly-verifiable without requiring snark/stark. better primitive for the proof-of-replication prove function, which publicly-verifiable and transparent without snark/stark. transparent, publicly-verifiable proof-of-retrievability other proof-of-storage. new strategies for retrieval the retrieval market (e.g. based probabilistic payments, zero knowledge contingent payments) better secret leader election for the expected consensus, which gives exactly one elected leader per epoch. better trusted setup scheme for snarks that allows incremental expansion public parameters (schemes where sequence mpcs can run, where each additional mpc strictly lowers probability faults and where the output each mpc usable for system). proofs and formal verification because the clear value proofs and formal verification, plan prove many properties the filecoin network and develop formally verified protocol specifications the coming months and years. few proofs are progress and more mind. but will hard, long-term work prove many properties filecoin (such scaling, offline). proofs correctness for expected consensus and variants. proof correctness for power fault tolerance asynchronous impossibility result side-step. formulate the filecoin dsn the universal composability framework, describing get, put and manage ideal functionalities and prove our realizations. formal model and proofs for automatic self-healing guarantees. formally verify protocol descriptions (e.g. tla+ verdi). formally verify implementations (e.g. verdi). game theoretical analysis filecoin's incentives. acknowledgements this work the cumulative effort multiple individuals within the protocol labs team, and would not have been possible without the help, comments, and review the collaborators and advisors protocol labs. juan benet wrote the original filecoin whitepaper laying the groundwork for this work. and nicola greco developed the new protocol and wrote this whitepaper collaboration with the rest the team, who provided useful contributions, comments, review and conversations. particular david "davidad" dalrymple suggested the orderbook paradigm and other ideas, matt zumwalt improved the structure the paper, evan miyazono created the illustrations and finalized the paper, jeromy johnson provided insights while designing the protocol, and steven allen contributed insightful questions and clarifications. also thank all our collaborators and advisor for useful conversations; particular andrew miller and eli ben-sasson. previous version: qmycfxygkisovseapqygxckwmigfzccdxjzwrq references juan benet. ipfs content addressed, versioned, file system. giuseppe ateniese, randal burns, reza curtmola, joseph herring, lea kissner, zachary peterson, and dawn song. provable data possession untrusted stores. proceedings the acm conference computer and communications security, pages acm, ari juels and burton kaliski jr. pors: proofs retrievability for large files. proceedings the acm conference computer and communications security, pages acm, hovav shacham and brent waters. compact proofs retrievability. international conference the theory and application cryptology and information security, pages springer, protocol labs. technical report: proof-of-replication. rosario gennaro, craig gentry, bryan parno, and mariana raykova. quadratic span programs and succinct nizks without pcps. annual international conference the theory and applications cryptographic techniques, pages springer, nir bitansky, alessandro chiesa, and yuval ishai. succinct non-interactive arguments via linear interactive proofs. springer, eli ben-sasson, alessandro chiesa, daniel genkin, eran tromer, and madars virza. snarks for verifying program executions succinctly and zero knowledge. advances cryptology-crypto pages springer, eli ben-sasson, iddo bentov, alessandro chiesa, ariel gabizon, daniel genkin, matan hamilis, evgenya pergament, michael riabzev, mark silberstein, eran tromer, al. computational integrity with public random string from quasi-linear pcps. annual international conference the theory and applications cryptographic techniques, pages springer, henning pagnia and felix gartner. the impossibility fair exchange without trusted third party. technical report, technical report tud-bs--, darmstadt university technology, department computer science, darmstadt, germany, joseph poon and thaddeus dryja. the bitcoin lightning network: scalable off-chain instant payments. andrew miller, iddo bentov, ranjit kumaresan, and patrick mccorry. sprites: payment channels that faster than lightning. arxiv preprint arxiv:., protocol labs. technical report: power fault tolerance. protocol labs. technical report: expected consensus. iddo bentov, charles lee, alex mizrahi, and meni rosenfeld. proof activity: extending bitcoin's proof work via proof stake [extended abstract] acm sigmetrics performance evaluation review, ():-, iddo bentov, rafael pass, and elaine shi. snow white: provably secure proofs stake. silvio micali. algorand: the efficient and democratic ledger. arxiv preprint arxiv:., vitalik buterin. ethereum april url https://ethereum.org/. satoshi nakamoto. bitcoin: peer-to-peer electronic cash system, eli ben sasson, alessandro chiesa, christina garman, matthew green, ian miers, eran tromer, and madars virza. zerocash: decentralized anonymous payments from bitcoin. security and privacy (sp), ieee symposium on, pages ieee,