opera: reasoning about continuous common knowledge asynchronous distributed systems sang-min choia jiho parka quan nguyena kiyoung jangb hyunjoon cheonb yo-sub hanb byung-ik ahna fantom lab, fantom foundation department computer science, yonsei university abstract this paper introduces new family consensus protocols, namely lachesisclass denoted for distributed networks with guaranteed byzantine fault tolerance. each lachesis protocol has complete asynchrony, leaderless, has round robin, proof-of-work, and has eventual consensus. the core concept our technology the opera chain, generated the lachesis protocol. the most general form, each node lachesis has set neighbours most preference. when receiving transactions node creates and shares event block with all neighbours. each event block signed the hashes the creating node and its peers. the opera chain the event blocks directed acyclic graph (dag); guarantees practical byzantine fault tolerance (pbft). our framework then presented using lamport timestamps and concurrent common knowledge. further, present example lachesis consensus protocol our framework. our protocol can reach consensus upon all participants' agreement event block without any additional communication overhead. protocol relies cost function identify peers and generate the dag-based opera chain. creating binary flag table that stores connection information and share information between blocks, lachesis achieves consensus fewer steps than pbft protocol for consensus. keywords: consensus algorithm, byzantine fault tolerance, lachesis protocol, lamport timestamp, root, clotho, atropos, main chain preprint submitted fantom technical report october contents introduction motivation generic framework lachesis protocol contributions protocols generic framework lachesis protocols opera chain main-chain lachesis consensus algorithm (lca) node structure event block creation topological ordering events using lamport timestamps topological consensus ordering peer selection algorithm related work lamport timestamps concurrent common knowledge consensus algorithms dag-based approaches lachesis consensus protocol root selection clotho selection atropos selection peer selection algorithm via cost function discussions lamport timestamps semantics lachesis protocols conclusion future work appendix proof lachesis consensus algorithm preliminaries proof byzantine fault tolerance sensus algorithm response attacks transaction flooding parasite chain attack double spending long-range attack bribery attack denial service sybil reference for lachesis con. introduction beyond the success cryptocurrencies, blockchain has recently emerged technology platform that offers secure decentralized consistent transaction ledgers and has powered innovations across domains including financial systems, supply chains and health care. despite the high demand distributed ledger technology [], commercialization opportunities have been obstructed long processing time for consensus, and high power consumption. these issues have been addressed consensus algorithms such distributed database systems often address byzantine fault tolerance which just under one-third the participant nodes may compromised. consensus algorithms ensures the integrity transactions between participants over distributed network and equivalent the proof byzantine fault tolerance distributed database systems byzantine consensus not guaranteed for deterministic, completely asynchronous system with unbounded delays []. but achieving consensus feasible for nondeterministic system with probability one. there are several approaches consensus distributed system. the original nakamoto consensus protocol bitcoin uses proof work (pow), which requires large amounts computational work generate the blocks participants []. alternative schemes such proof stake (pos) have been proposed. pos uses participants' stakes generate the blocks respectively. another approach utilizes directed acyclic graphs (dag) facilitate consensus. examples dag-based consensus algorithms include tangle [], byteball [], and hashgraph []. tangle selects the blocks connect the network utilizing accumulated weight nonce and monte carlo markov chain (mcmc). byteball generates main chain from the dag and reaches consensus through index information the chain. hashgraph connects each block from node another random node. hashgraph searches whether members can reach each block and provides proof byzantine fault tolerance via graph search. motivation practical byzantine fault tolerance (pbft) allows all nodes successfully reach agreement for block (information) when byzantine node exists []. pbft, consensus reached once created block shared with other participants and the share information shared with others again after consensus achieved, the block added the participants' chains currently, takes o(n for pbft. hashgraph proposes "gossip about gossip" and virtual voting reach consensus. there are several limitations with hashgraph. first, the algorithm operates known network, which needs full awareness all authoritative participants. second, gossip propagation slow and latency increases o(n) with participants. third, remains unclear whether virtual voting faster than chain weight aka longest chain/proof work concept. these issues are gossip problems and not consensus problems. are interested new approach address the aforementioned issues pbft approaches and hashgraph []. specifically, propose new consensus algorithm that addresses the following questions: can reach local consensus k-cluster faster for some k?, can make gossips faster such using broadcast based gossip subset?, can continuous common knowledge used for consensus decisions with high probability? can complex decisions reduced binary value consensus? this paper, propose new approach that can quickly search for byzantine nodes within the block dag. particular, introduce new class consensus protocols, namely lachesis protocol denoted the core idea lachesis use new dag structure, the opera chain, which allows faster path search for consensus. then propose example the lachesis protocol class, which called the lachesis protocol generic framework protocols introduce generic framework lachesis protocols, called the basic idea lachesis protocol dag-based asynchronous non-deterministic protocol that guarantees pbft. propose opera chain new dag structure for faster consensus. lachesis protocol generates each block asynchronously and the lachesis algorithm achieves consensus confirming how many nodes know the blocks using the opera chain. figure shows example opera chain constructed through lachesis protocol. the main concepts lachesis are given follows: event block all nodes can create event blocks time the structure event block includes the signature, generation time, transaction history, and hash information references. the information the referenced event blocks can copied each node. the first event block each node called leaf event. ''' '''' figure example opera chain lachesis protocol lachesis protocol the rule-set communicate between nodes. when each node creates event blocks, determines which nodes choose other nodes broadcast to. node selection can random via some cost function. happened-before happened-before the relationship between nodes which have event blocks. there path from event block then happened-before happened-before means that the node creating knows event block root event block called root either the first generated event block node, can reach more than two-thirds other roots. every root can candidate for clotho. root set root set (rs the set all roots the frame. the cardinality the set then c.is clotho yes time computed, clotho nominated atropos and each node stores the hash value atropos and atropos consensus time main-chain. the main-chain used for time order between event blocks. the proof atropos consensus time selection shown the section algorithm atropos consensus time selection procedure atropos consensus time selection input: c.clotho frame c.consensus time nil the index the last frame for [..m] the root set rsi+d frame fi+d for then confirms clotho then r.time(c) r.lamport time else then the set root fj- that can share reselection(s, the number root having mod then then c.consensus time r.time(c) else r.time(c) else r.time(c) the minimum value algorithm and show pseudo code atropos consensus time selection and consensus time reselection. algorithm line denotes the deference relationship between root set and thus, line means that one the elements root set the frame fi+ where the frame includes line each root the frame selects own lamport timestamp candidate time when they confirm root cltoho. line and and save the set root that can share the result reselect ion function, and the number root having line checking whether there difference much between and where constant value for minimum selection frame. line checking whether more than two-thirds root the frame fj- nominate the same candidate time. two-thirds root the frame fj- nominate the same candidate time, the root assigned consensus time line minimum selection frame. minimum selection frame, minimum value candidate time selected reach byzantine agreement. algorithm operates the middle algorithm algorithm input root set and output reselected candidate time. line computes the frequencies each candidate time from all the roots line candidate time which smallest time that the most nomitated. the time complexity algorithm o(n) where the number nodes. since algorithm includes algorithm the time complexity algorithm o(n where the number nodes. algorithm consensus time reselection function reselection input: root set and clotho output: candidate time set all r.time(c) for all set tuples (ti computed from where count(ti max count max(ci inf inite for tuple (ti max count have generated fewer event blocks than the nodes that have low then can judge that those kind nodes are lazy. can detect whether node lazy based cost function, can change the lazy nodes other participants remove them. figure shows example the node selection based the cost function after the creation leaf events all nodes. this example, there are five nodes and each node created leaf events. all nodes know other leaf events. node creates event block and calculates the cost functions. step figure shows the results cost functions based the height cost function: leaf events signature stamp node #$%&'()*+, height vector in-degree vector (b)=. (c)= (d)= (e)= figure example cost function and in-degree vectors node the initial step, each value the vectors are same because all nodes have only leaf events. node randomly selects nodes and connects the leaf events selected nodes. this example, set and assume that node selects node and figure shows example the node selection after few steps the simulation figure figure the recent event block created node node calculates the cost function and selects the other two nodes that have the lowest results the cost function. this example, node has the result and other nodes have the same values. because this, node first selects node and randomly selects other nodes among nodes and the height node the current opera chain the example (leaf event and event block the other hand, the height node node structure node still not aware the presence the event block means that there path from the event blocks created node the event block thus, node has the height node algorithm shows the selecting algorithm for selecting reference nodes. the algorithm operates for each node select communication partner from other nodes. line and set min cost and sref initial state. line calculates the cost function for each node. line and find the minimum value the cost function and set min cost and sref and the each node respectively. line and append the each node sref min cost equals finally, line selects randomly node ids from sref communication partners. the time complexity algorithm o(n), where the number nodes. algorithm k-neighbor node selection procedure k-node selection input: height vector in-degree vector output: reference node ref min cost sref none for ode set hikk min cost then min cost sref else min cost equal then sref sref ref random select sref after the reference node selected, each node communicates and shares information that all event blocks known them. node creates event block referring the top event block the reference node. the lachesis protocol works and communicates asynchronously. this allows node create event block asynchronously even when another node creates event block. the communication between nodes does not allow simultaneous communication with the same node. figure shows example the node selection lachesis protocol. this example, there are five nodes (a, and and each node generates the first event blocks, called leaf events. all nodes share other leaf events with each other. the first step, node generates new event block (blue). then node calculates the cost function connect other nodes. this initial situation, all nodes have one event block called leaf event, thus the height vector and the in-degree vector node has same values. other words, the heights each node are and in-degrees are because this reason, node randomly select other two nodes and connect leaf events leaf events leaf events leaf events step step step step figure example node selection the top two event blocks other two nodes. the step shows the situation after connections. this example, node select node and connect and the event block connected the top event blocks node and node only knows the situation the step after that, the example, node generates new event block (green) and also calculates the cost function. randomly select the other two nodes; and since only has information the leaf events. node requests and connect then nodes and send information for their top event blocks node response. the top event block node and node the leaf event. the event block connected and leaf event from node step shows these connections. discussions this section presents several discussions our lachesis protocol. lamport timestamps this section discusses topological order event blocks dag-based lachesis protocols using lamport timestamps []. our lachesis protocols relies lamport timestamps define topological ordering event blocks opera chain. the "happened before" relation, denoted gives partial ordering events from distributed system nodes. given nodes, they are represented processes pn- for pair event blocks and the relation "-" satisfies: and are events process and comes before then the send(m) one process and the receive(m) another process, then and then two distinct events and are said concurrent and for arbitrary total ordering the processes, relation defined follows: event process and event process then and only either (i) (a) definition (frame). frame natural number that separates root sets. definition (clotho). root the frame fa+ can nominate root clotho more than roots the frame fa+ happened-before and happened-before the roots the frame fa+ definition (atropos). the consensus time clotho validated, the clotho become atropos. proposition least roots the frame happened-before least roots the frame fi+ proof. the number roots each root set more than n/. since root the frame fi+ happened-before more than roots the frame when the cardinalities the root sets the frames and fi+ are and respectively, the number paths from root set the frame fi+ root set the frame least (n/) the average and the maximum the number paths from root set the frame fi+ root the frame are (n/) and (n/) respectively. thus, least roots the frame happened-before least root the frame fi+ proposition root the frame happened-before from more than roots the frame fi+ the root happened-before all roots the frame fi+ proof. based the definition root, each root can reach more than other roots the previous frame. means that root the frame fi+ should have number paths more than roots the frame fi+ thus, root the frame happened-before more than roots the frame fi+ all roots the frame fi+ have path the root lemma (sharing). root the frame fa+ created, the root the frame fa+ knows that more than roots the frame become known more than nodes. proof. based propositions and the root the frame fa+ knows that more than roots the frame become known more than nodes. lemma (fork). the pair event blocks (x, fork, roots happenedbefore least one fork opera chain. therefore, they can know fork before becoming clotho. proof. suppose that node creates two event blocks (x, and the event blocks are fork. create two clotho that can reach each event block the pair, the event blocks should shared more than nodes. therefore, there exist fork event blocks, the opera chain can structurally detect the fork before roots become clotho. theorem all node grows into same shape opera chain. proof. suppose that each node and will have different shape (or structure). for any two nodes and there two event blocks and which are both era(a) and era(b). also, their path between and era(a) not equal that era(b). for any two event blocks, each node has different paths, can consider that the difference fork attacks. based lemma attacker forks event block, the opera chain can detect and remove before the clotho generated. contradicts our assumptions. for this reason, two nodes have consistent opera chain. lemma for any root set all nodes nominate same root into clotho. proof. based theorem each node nominates root into clotho via the flag table. all nodes have opera chain with same shape, the values flag table should equal each other opera chain. thus, all nodes nominate the same root into clotho since the opera chain all nodes has same shape. lemma the reselection algorithm, for any clotho, root opera chain selects the same consensus time candidate. proof. based theorem all nodes have opera chain with the same partial shape, root opera chain selects the same consensus time candidate the reselection algorithm. theorem lachesis consensus algorithm guarantees reach agreement for the consensus time. proof. for any root set the frame time consensus algorithm checks whether more than roots the frame fi- selects the same value. however, each node selects one the values collected from the root set the previous frame the time consensus algorithm and reselection process. based the reselection process, the time consensus algorithm can reach agreement. however, there possibility that consensus time candidate does not reach agreement []. solve this problem, time consensus algorithm includes minimal selection frame per next frame. minimal value selection algorithm, each root selects minimum value among values collected from previous root set. thus, the consensus time reaches consensus time consensus algorithm. theorem the number reliable nodes more than n/, event blocks created reliable nodes must assigned consensus order. proof. opera chain, since reliable nodes try create event blocks communicating with every other nodes continuously, reliable nodes will share the event block with each other. based proposition root the frame happened-before event block and more than roots the frame fi+ happened-before the root the root will nominated clotho and atropos. thus, event block and root will assigned consensus time for event block, assigning consensus time means that the validated event block shared more than nodes. therefore, malicious node cannot try attack after the event blocks are assigned consensus time. when the event block has consensus time cannot occur discover new event blocks with earlier consensus time than there are two conditions assigned consensus time earlier than for new event blocks. first, root the frame should able share new event blocks. second, the more than roots the frame fi+ should able share even the first condition satisfied malicious nodes (e.g., parasite chain), the second condition cannot satisfied since least roots the frame fi+ are already created and cannot changed. therefore, after event block validated, new event blocks should not participate earlier consensus time opera chain. response attacks like all other decentralized blockchain technologies, opera chain will likely subject attacks attackers which aim gain financial profit damage the system. here describe several possible attack scenarios and how the opera chain intends take preventive measures. ... transaction flooding malicious participant may run large number valid transactions from their account under their control with the purpose overloading the network. order prevent such case, the chain intends impose minimal transaction fee. since there transaction fee, the malicious user cannot continue perform such attacks. participants who participate nodes are rewarded, and those who contribute the ecosystem, such running transactions, are continuously rewarded. such rewards are expected adequate running transactions for appropriate purposes. however, since would require tremendous cost perform abnormal attacks, would difficult for malicious attacker create transaction flooding. ... parasite chain attack dag-based protocol, parasite chain can made with malicious purpose, attempting connection making look like legitimate event block. when the main chain created, verification for each event block performed. the verification process, any event block that not connected the main chain deemed invalid and ignored, the case double spending. suppose that less than one-third nodes are malicious. the malicious nodes create parasite chain. the root definition, roots are nominated node awareness. parasite chain only shared with malicious nodes that are less than one-third participating nodes. parasite chain unable generate roots and have shared consensus time. ... double spending double spend attack when malicious entity attempts spend their funds twice. entity has tokens, they send tokens via node and tokens via node both node and node agree that the transaction valid, since has the funds send (according and (according consensus mechanism whereby multiple distributed parties can reach agreement the order and state sequence events. let's consider the following transactions: txa (starting balance transfers txb (starting balance transfers txc (starting balance transfers consider node received the order txa txb txc the state node now, consider node that receives the order txc txb txa the state node consensus ordering gives sequence events. the pair event blocks (x, has double spending transaction, the chain can structurally detect the double spend and delay action for the event blocks until the event blocks assign time ordering. suppose that the pair event blocks (x, has same frame then, all nodes must detect two event blocks before frame the root definition, each root happened-before more than previous roots. for this reason, when two roots are selected, they must have happenedbefore the roots which are more than one-thirds roots this means that more than roots share both two roots which include the pair respectively. with the root definition and previous explanation, all roots share both the pairs. thus, all nodes detect the double spending event blocks earlier. ... long-range attack blockchains adversary can create another chain. this chain longer than the original, the network will accept the longer chain. this mechanism exists identify which chain has had more work (or stake) involved its creation. participating nodes are required create new chain. accomplish long-range attack you would first need create participating malicious nodes create the new chain. ... bribery attack adversary could bribe nodes validate conflicting transactions. since participating nodes are required, this would require the adversary bribe all nodes begin bribery attack. ... denial service lca leaderless system requiring participation. adversary would have deny participants able successfully mount ddos attack. ... sybil each participating node must stake minimum amount ftm participate the network. being able stake total stake would prohibitively expensive. reference aspnes. randomized protocols for asynchronous consensus. distributed computing, (-):-, baird. hashgraph consensus: fair, fast, byzantine fault tolerance. technical report, castro and liskov. practical byzantine fault tolerance. proceedings the third symposium operating systems design and implementation, osdi pages berkeley, ca, usa, usenix association. chen and micali. algorand. arxiv preprint arxiv:., churyumov. byteball: decentralized system for storage and transfer value, danezis and hrycyszyn. blockmania: from block dags consensus, fischer, lynch, and paterson. impossibility distributed consensus with one faulty process. acm, ():-, fischer, lynch, and paterson. impossibility distributed consensus with one faulty process. journal the acm (jacm), ():-, gilad, hemo, micali, vlachos, and zeldovich. algorand: scaling byzantine agreements for cryptocurrencies. proceedings the symposium operating systems principles, pages acm, kotla, alvisi, dahlin, clement, and wong. zyzzyva: speculative byzantine fault tolerance. acm sigops operating systems review, ():-, lamport. time, clocks, and the ordering events distributed system. communications the acm, ():-, lamport al. paxos made simple. acm sigact news, ():-, lamport, shostak, and pease. the byzantine generals problem. acm trans. program. lang. syst., ():-, july larimer. delegated proof-of-stake (dpos), lemahieu. raiblocks: feeless distributed cryptocurrency network, lerner. dagcoin, li, li, xu, long, and c.-c. yao. scaling nakamoto consensus thousands transactions per second. arxiv preprint arxiv:., miller, xia, croman, shi, and song. the honey badger bft protocols. proceedings the acm sigsac conference computer and communications security, pages acm, nakamoto. bitcoin: peer-to-peer electronic cash system, panangaden and taylor. concurrent common knowledge: defining agreement for asynchronous systems. distributed computing, ():- pierre chevalier, bartomiej kamin ski. protocol for asynchronous, reliable, secure and efficient consensus (parsec), popov. the tangle, sompolinsky, lewenberg, and zohar. spectre: fast and scalable cryptocurrency protocol. iacr cryptology eprint archive, sompolinsky and zohar. blockdag protocols, phantom, ghostdag: two scalable sunny king. ppcoin: peer-to-peer crypto-currency with proof-ofstake, swan. blockchain: blueprint for new economy. o'reilly media,