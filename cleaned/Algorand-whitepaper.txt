arxiv:.v [cs.cr] may algorand* silvio micali csail mit cambridge, usa silvio@csail.mit.edu jing chen computer science department stony brook university stony brook, usa jingchen@cs.stonybrook.edu abstract public ledger tamperproof sequence data that can read and augmented everyone. public ledgers have innumerable and compelling uses. they can secure, plain sight, all kinds transactions --such titles, sales, and payments-- the exact order which they occur. public ledgers not only curb corruption, but also enable very sophisticated applications --such cryptocurrencies and smart contracts. they stand revolutionize the way democratic society operates. currently implemented, however, they scale poorly and cannot achieve their potential. algorand truly democratic and efficient way implement public ledger. unlike prior implementations based proof work, requires negligible amount computation, and generates transaction history that will not "fork" with overwhelmingly high probability. algorand based novel and super fast) message-passing byzantine agreement. for concreteness, shall describe algorand only money platform. introduction money becoming increasingly virtual. has been estimated that about united states dollars today only exist ledger entries []. other financial instruments are following suit. ideal world, which could count universally trusted central entity, immune all possible cyber attacks, money and other financial transactions could solely electronic. unfortunately, not live such world. accordingly, decentralized cryptocurrencies, such bitcoin [], and "smart contract" systems, such ethereum, have been proposed []. the heart these systems shared ledger that reliably records sequence transactions, this the more formal (and asynchronous) version the arxiv paper the second author [], paper itself based that gorbunov and micali []. algorand's technologies are the object the following patent applications: us/, us/, us/, us/, us/, pct/us/ us/, us/, us/, us/, us/, us/, us/, us/, us/, us/, us/, us/, us/, us/, us/, us/, us/, us/, us/, us/, us/, us/, us/, varied payments and contracts, tamperproof way. the technology choice guarantee such tamperproofness the blockchain. blockchains are behind applications such cryptocurrencies [], financial applications [], and the internet things []. several techniques manage blockchain-based ledgers have been proposed: proof work [], proof stake [], practical byzantine fault-tolerance [], some combination. currently, however, ledgers can inefficient manage. for example, bitcoin's proof-of-work approach (based the original concept []) requires vast amount computation, wasteful and scales poorly []. addition, facto concentrates power very few hands. therefore wish put forward new method implement public ledger that offers the convenience and efficiency centralized system run trusted and inviolable authority, without the inefficiencies and weaknesses current decentralized implementations. call our approach algorand, because use algorithmic randomness select, based the ledger constructed far, set verifiers who are charge constructing the next block valid transactions. naturally, ensure that such selections are provably immune from manipulations and unpredictable until the last minute, but also that they ultimately are universally clear. algorand's approach quite democratic, the sense that neither principle nor facto creates different classes users (as "miners" and "ordinary users" bitcoin). algorand "all power resides with the set all users". one notable property algorand that its transaction history may fork only with very small probability (e.g., one trillion, that is, even algorand can also address some legal and political concerns. the algorand approach applies blockchains and, more generally, any method generating tamperproof sequence blocks. actually put forward new method --alternative to, and more efficient than, blockchains-- that may independent interest. bitcoin's assumption and technical problems bitcoin very ingenious system and has inspired great amount subsequent research. yet, also problematic. let summarize its underlying assumption and technical problems --which are actually shared essentially all cryptocurrencies that, like bitcoin, are based proof-of-work. for this summary, suffices recall that, bitcoin, user may own multiple public keys digital signature scheme, that money associated with public keys, and that payment digital signature that transfers some amount money from one public key another. essentially, bitcoin organizes all processed payments chain blocks, each consisting multiple payments, such that, all payments taken any order, followed those any order, etc., constitute sequence valid payments. each block generated, average, every minutes. this sequence blocks chain, because structured ensure that any change, even single block, percolates into all subsequent blocks, making easier spot any alteration the payment history. (as shall see, this achieved including each block cryptographic hash the previous one.) such block structure referred blockchain. assumption: honest majority computational power bitcoin assumes that malicious entity (nor coalition coordinated malicious entities) controls the majority the computational power devoted block generation. such entity, fact, would able modify the blockchain, and thus re-write the payment history, pleases. particular, could make payment obtain the benefits paid for, and then "erase" any trace technical problem computational waste bitcoin's proof-of-work approach block generation requires extraordinary amount computation. currently, with just few hundred thousands public keys the system, the top most powerful supercomputers can only muster mere percent the total computational power required from the bitcoin players. this amount computation would greatly increase, should significantly more users join the system. technical problem concentration power today, due the exorbitant amount computation required, user, trying generate new block using ordinary desktop (let alone cell phone), expects lose money. indeed, for computing new block with ordinary computer, the expected cost the necessary electricity power the computation exceeds the expected reward. only using pools specially built computers (that nothing other than "mine new blocks"), one might expect make profit generating new blocks. accordingly, today there are, facto, two disjoint classes users: ordinary users, who only make payments, and specialized mining pools, that only search for new blocks. should therefore not surprise that, recently, the total computing power for block generation lies within just five pools. such conditions, the assumption that majority the computational power honest becomes less credible. technical problem ambiguity bitcoin, the blockchain not necessarily unique. indeed according bk+ its latest portion often forks: the blockchain may --say-- bk+ one user, and bk+ bk+ bk+ according another user. only after several blocks have been added the chain, can one reasonably sure that the first blocks will the same for all users. thus, one cannot rely right away the payments contained the last block the chain. more prudent wait and see whether the block becomes sufficiently deep the blockchain and thus sufficiently stable. separately, law-enforcement and monetary-policy concerns have also been raised about bitcoin. algorand, nutshell setting algorand works very tough setting. briefly, (a) permissionless and permissioned environments. algorand works efficiently and securely even totally permissionless environment, where arbitrarily many users are allowed join the system any time, without any vetting permission any kind. course, algorand works even better permissioned environment. the (pseudo) anonymity offered bitcoin payments may misused for money laundering and/or the financing criminal individuals terrorist organizations. traditional banknotes gold bars, that principle offer perfect anonymity, should pose the same challenge, but the physicality these currencies substantially slows down money transfers, permit some degree monitoring law-enforcement agencies. the ability "print money" one the very basic powers nation state. principle, therefore, the massive adoption independently floating currency may curtail this power. currently, however, bitcoin far from being threat governmental monetary policies, and, due its scalability problems, may never be. (b) very adversarial environments. algorand withstands very powerful adversary, who can instantaneously corrupt any user wants, any time wants, provided that, permissionless environment, the money the system belongs honest user. (in permissioned environment, irrespective money, suffices that the users are honest.) totally control and perfectly coordinate all corrupted users; and schedule the delivery all messages, provided that each message sent honest user reaches the honest users within time which solely depends the size main properties despite the presence our powerful adversary, algorand the amount computation required minimal. essentially, matter how many users are present the system, each fifteen hundred users must perform most few seconds computation. new block generated less than minutes, and will facto never leave the blockchain. for instance, expectation, the time generate block the first embodiment less than .l, where the time necessary propagate block, peer-to-peer gossip fashion, matter what block size one may choose, and the time propagate blong messages. (since truly decentralized system, essentially intrinsic latency, algorand the limiting factor block generation network speed.) the second embodiment has actually been tested experimentally ?), indicating that block generated less than seconds. addition, algorand's blockchain may fork only with negligible probability (i.e., less than one trillion), and thus users can relay the payments contained new block soon the block appears. all power resides with the users themselves. algorand truy distributed system. particular, there are exogenous entities (as the "miners" bitcoin), who can control which transactions are recognized. algorand's techniques. new and fast byzantine agreement protocol. algorand generates new block via new cryptographic, message-passing, binary byzantine agreement (ba) protocol, protocol not only satisfies some additional properties (that shall soon discuss), but also very fast. roughly said, its binary-input version consists -step loop, which player sends single message all other players. executed complete and synchronous network, with more than the players being honest, with probability after each loop the protocol ends agreement. (we stress that protocol satisfies the original definition byzantine agreement pease, shostak, and lamport [], without any weakenings.) algorand leverages this binary protocol reach agreement, our different communication model, each new block. the agreed upon block then certified, via prescribed number digital signature the proper verifiers, and propagated through the network. cryptographic sortition. although very fast, protocol would benefit from further speed when played millions users. accordingly, algorand chooses the players much smaller subset the set all users. avoid different kind concentration-of-power problem, each new block will constructed and agreed upon, via new execution separate set selected verifiers, principle, selecting such set might hard selecting directly. traverse this potential problem approach that term, embracing the insightful suggestion maurice herlihy, cryptographic sortition. sortition the practice selecting officials random from large set eligible individuals []. (sortition was practiced across centuries: for instance, the republics athens, florence, and venice. modern judicial systems, random selection often used choose juries. random sampling has also been recently advocated for elections david chaum [].) decentralized system, course, choosing the random coins necessary randomly select the members each verifier set problematic. thus resort cryptography order select each verifier set, from the population all users, way that guaranteed automatic (i.e., requiring message exchange) and random. essence, use cryptographic function automatically determine, from the previous block user, the leader, charge proposing the new block and the verifier set charge reach agreement the block proposed the leader. since malicious users can affect the composition (e.g., choosing some its payments), specially construct and use additional inputs prove that the leader for the rth block and the verifier set are indeed randomly chosen. the quantity (seed) use the the last block the blockchain order automatically determine the next verifier set and leader charge constructing the new block the challenge with this approach that, just choosing slightly different payment the previous round, our powerful adversary gains tremendous control over the next leader. even only controlled only the players/money the system, could ensure that all leaders are malicious. (see the intuition section ..) this challenge central all proof-of-stake approaches, and, the best our knowledge, has not, now, been satisfactorily solved. meet this challenge, purposely construct, and continually update, separate and carefully defined quantity, which provably is, not only unpredictable, but also not influentiable, our powerful adversary. may refer the rth seed, from that algorand selects, via secret cryptographic sortition, all the users that will play special role the generation the rth block. secret crytographic sortition and secret credentials. randomly and unambiguously using the current last block, order choose the verifier set and the leader charge constructing the new block, not enough. since must known before generating the last non-influentiable quantity qr- contained must known too. accordingly, are the verifiers and the leader charge compute the block thus, our powerful adversary might immediately corrupt all them, before they engage any discussion about get full control over the block they certify. prevent this problem, leaders (and actually verifiers too) secretly learn their role, but can compute proper credential, capable proving everyone that indeed have that role. when user privately realizes that the leader for the next block, first secretly assembles his own proposed new block, and then disseminates (so that can certified) together with his own credential. this way, though the adversary will immediately realize who the leader the next block is, and although can corrupt him right away, will too late for the adversary influence the choice new block. indeed, cannot "call back" the leader's message more than powerful government can put back into the bottle message virally spread wikileaks. shall see, cannot guarantee leader uniqueness, nor that everyone sure who the leader is, including the leader himself! but, algorand, unambiguous progress will guaranteed. player replaceability. after proposes new block, the leader might well "die" (or corrupted the adversary), because his job done. but, for the verifiers things are less simple. indeed, being charge certifying the new block with sufficiently many signatures, they must first run byzantine agreement the block proposed the leader. the problem that, matter how efficient is, requires multiple steps and the honesty its players. this problem, because, for efficiency reasons, the player set consists the small set randomly selected among the set all users. thus, our powerful adversary, although unable corrupt all the users, can certainly corrupt all members fortunately we'll prove that protocol executed propagating messages peer-topeer fashion, player-replaceable. this novel requirement means that the protocol correctly and efficiently reaches consensus even each its step executed totally new, and randomly and independently selected, set players. thus, with millions users, each small set players associated step most probably has empty intersection with the next set. addition, the sets players different steps will probably have totally different cardinalities. furthermore, the members each set not know who the next set players will be, and not secretly pass any internal state. the replaceable-player property actually crucial defeat the dynamic and very powerful adversary envisage. believe that replaceable-player protocols will prove crucial lots contexts and applications. particular, they will crucial execute securely small sub-protocols embedded larger universe players with dynamic adversary, who, being able corrupt even small fraction the total players, has difficulty corrupting all the players the smaller sub-protocol. additional property/technique: lazy honesty honest user follows his prescribed instructions, which include being online and run the protocol. since, algorand has only modest computation and communication requirement, being online and running the protocol "in the background" not major sacrifice. course, few "absences" among honest players, those due sudden loss connectivity the need rebooting, are automatically tolerated (because can always consider such few players temporarily malicious). let point out, however, that algorand can simply adapted work new model, which honest users offline most the time. our new model can informally introduced follows. lazy honesty. roughly speaking, user lazy-but-honest follows all his prescribed instructions, when asked participate the protocol, and asked participate the protocol only rarely, and with suitable advance notice. with such relaxed notion honesty, may even more confident that honest people will hand when need them, and algorand guarantee that, when this the case, the system operates securely even if, given point time, the majority the participating players are malicious. closely related work proof-of-work approaches (like the cited and []) are quite orthogonal our ours. are the approaches based message-passing byzantine agreement practical byzantine fault tolerance (like the cited []). indeed, these protocols cannot run among the set all users and cannot, our model, restricted suitably small set users. fact, our powerful adversary immediately corrupt all the users involved small set charged actually running protocol. our approach could considered related proof stake [], the sense that users' "power" block building proportional the money they own the system (as opposed --say-- the money they have put "escrow"). the paper closest ours the sleepy consensus model pass and shi []. avoid the heavy computation required the proof-of-work approach, their paper relies upon (and kindly credits) algorand's secret cryptographic sortition. with this crucial aspect common, several significant differences exist between our papers. particular, their setting only permissioned. contrast, algorand also permissionless system. they use nakamoto-style protocol, and thus their blockchain forks frequently. although dispensing with proof-of-work, their protocol secretly selected leader asked elongate the longest valid (in richer sense) blockchain. thus, forks are unavoidable and one has wait that the block sufficiently "deep" the chain. indeed, achieve their goals with adversary capable adaptive corruptions, they require block poly(n deep, where represents the total number users the system. notice that, even assuming that block could produced minute, there were users, then one would have wait for about years for block become -deep, and for about years for block become -deep. contrast, algorand's blockchain forks only with negligible probability, even though the adversary corrupt users immediately and adaptively, and its new blocks can immediately relied upon. they not handle individual byzantine agreements. sense, they only guarantee "eventual consensus growing sequence values". theirs state replication protocol, rather than one, and cannot used reach byzantine agreement individual value interest. contrast, algorand can also used only once, wanted, enable millions users quickly reach byzantine agreement specific value interest. they require weakly synchronized clocks. that is, all users' clocks are offset small time contrast, algorand, clocks need only have (essentially) the same "speed". their protocol works with lazy-but-honest users with honest majority online users. they kindly credit algorand for raising the issue honest users going offline masse, and for putting forward the lazy honesty model response. their protocol not only works the lazy honesty model, but also their adversarial sleepy model, where adversary chooses which users are online and which are offline, provided that, all times, the majority online users are honest. the original version their paper actually considered only security their adversarial sleepy model. the original version algorand, which precedes theirs, also explicitly envisaged assuming that given majority the online players always honest, but explicitly excluded from consideration, favor the lazy honesty model. (for instance, some point time half the honest users choose off-line, then the majority the users on-line may very well malicious. thus, prevent this from happening, the adversary should force most his corrupted players off-line too, which clearly against his own interest.) notice that protocol with majority lazy-but-honest players works just fine the majority the users on-line are always malicious. this so, because sufficient number honest players, knowing that they are going crucial some rare point time, will elect not off-line those moments, nor can they forced off-line the adversary, since does not know who the crucial honest players might be. they require simple honest majority. contrast, the current version algorand requires honest majority. another paper close ouroboros: provably secure proof-of-stake blockchain protocol, kiayias, russell, david, and oliynykov []. also their system appeared after ours. also uses crytpographic sortition dispense with proof work provable manner. however, their system is, again, nakamoto-style protocol, which forks are both unavoidable and frequent. (however, their model, blocks need not deep the sleepy-consensus model.) moreover, their system relies the following assumptions: the words the authors themselves, "() the network highly synchronous, the majority the selected stakeholders available needed participate each epoch, the stakeholders not remain offline for long periods time, the adaptivity corruptions subject small delay that measured rounds linear the security parameter." contrast, algorand is, with overwhelming probability, fork-free, and does not rely any these assumptions. particular, algorand, the adversary able instantaneously corrupt the users wants control. preliminaries cryptographic primitives ideal hashing. shall rely efficiently computable cryptographic hash function, that maps arbitrarily long strings binary strings fixed length. following long tradition, model random oracle, essentially function mapping each possible string randomly and independently selected (and then fixed) binary string, h(s), the chosen length. this paper, has -bit long outputs. indeed, such length short enough make the system efficient and long enough make the system secure. for instance, want collisionresilient. that is, should hard find two different strings and such that h(x) h(y). when random oracle with -bit long outputs, finding any such pair strings indeed difficult. (trying random, and relying the birthday paradox, would require trials.) digital signing. digital signatures allow users authenticate information each other without sharing any sharing any secret keys. digital signature scheme consists three fast algorithms: probabilistic key generator signing algorithm and verification algorithm given security parameter sufficiently high integer, user uses produce pair k-bit keys (i.e., strings): "public" key pki and matching "secret" signing key ski crucially, public key does not "betray" its corresponding secret key. that is, even given knowledge pki one other than able compute ski less than astronomical time. user uses ski digitally sign messages. for each possible message (binary string) first hashes and then runs algorithm inputs h(m) and ski produce the k-bit string sigpki (m) s(h(m), ski since collision-resilient practically impossible that, signing one "accidentally signs" different message the binary string sigpki (m) referred i's digital signature (relative pki and can more simply denoted sigi (m), when the public key pki clear from context. everyone knowing pki can use verify the digital signatures produced specifically, inputs (a) the public key pki player (b) message and (c) string that is, i's alleged digital signature the message the verification algorithm outputs either yes no. the properties require from digital signature scheme are: legitimate signatures are always verified: sigi (m), then (pki es; and digital signatures are hard forge: without knowledge ski the time find string such that (pki es, for message never signed astronomically long. (following the strong security requirement goldwasser, micali, and rivest [], this true even one can obtain the signature any other message.) accordingly, prevent anyone else from signing messages his behalf, player must keep his signing key ski secret (hence the term "secret key"), and enable anyone verify the messages does sign, has interest publicizing his key pki (hence the term "public key"). general, message not retrievable from its signature sigi (m). order virtually deal with digital signatures that satisfy the conceptually convenient "retrievability" property (i.e., guarantee that the signer and the message are easily computable from signature, define sigpki (m) (i, sigpki (m)) and sigi (m) (i, sigi (m)), pki clear. unique digital signing. also consider digital signature schemes (g, satisfying the following additional property. uniqueness. hard find strings and such that and (pk (pk' (note that the uniqueness property holds also for strings that are not legitimately generated public keys. particular, however, the uniqueness property implies that, one used the specified key generator compute public key together with matching secret key sk, and thus knew sk, would essentially impossible also for him find two different digital signatures same message relative pk.) remarks from unique signatures verifiable random functions. relative digital signature scheme with the uniqueness property, the mapping h(sigi (m)) associates each possible string unique, randomly selected, -bit string, and the correctness this mapping can proved given the signature sigi (m). that is, ideal hashing and digital signature scheme satisfying the uniqueness property essentially provide elementary implementation verifiable random function, introduced and micali, rabin, and vadhan []. (their original implementation was necessarily more complex, since they did not rely ideal hashing.) three different needs for digital signatures. algorand, user relies digital signatures for authenticating i's own payments. this application, keys can "long-term" (i.e., used sign many messages over long period time) and come from ordinary signature scheme. generating credentials proving that entitled act some step round here, keys can long-term, but must come from scheme satisfying the uniqueness property. authenticating the message sends each step which acts. here, keys must ephemeral (i.e., destroyed after their first use), but can come from ordinary signature scheme. small-cost simplification. for simplicity, envision each user have single longterm key. accordingly, such key must come from signature scheme with the uniqueness property. such simplicity has small computational cost. typically, fact, unique digital signatures are slightly more expensive produce and verify than ordinary signatures. the idealized public ledger algorand tries mimic the following payment system, based idealized public ledger. the initial status. money associated with individual public keys (privately generated and owned users). letting pkj the initial public keys and their respective initial amounts money units, then the initial status (pk (pkj which assumed common knowledge the system. payments. let public key currently having money units, pk' another public key, and non-negative number greater than then, (valid) payment digital signature, relative pk, specifying the transfer monetary units from pk' together with some additional information. symbols, sigpk (pk, pk' h(i)), where represents any additional information deemed useful but not sensitive (e.g., time information and payment identifier), and any additional information deemed sensitive (e.g., the reason for the payment, possibly the identities the owners and the and on). refer (or its owner) the payer, each (or its owner) payee, and the amount the payment free joining via payments. note that users may join the system whenever they want generating their own public/secret key pairs. accordingly, the public key that appears the payment above may newly generated public key that had never "owned" any money before. the magic ledger. the idealized system, all payments are valid and appear tamper-proof list sets payments "posted the sky" for everyone see: each block consists the set all payments made since the appearance block the ideal system, new block appears after fixed (or finite) amount time. discussion. more general payments and unspent transaction output. more generally, public key owns amount then valid payment may transfer the amounts respectively the keys long a'j the set all public keys and the system status (r) (r) where the amount money available the public key note that deducible from and that may also specify other components for each public key for round the set initial public keys, and the initial status. both and are assumed common knowledge the system. for simplicity, the start round are and round the system status transitions from symbolically, round payments algorand, the users continually make payments (and disseminate them the way described subsection .). payment user has the same format and semantics the ideal system. namely, sigi (i, h(i)) payment individually valid round (is round-r payment, for short) its amount (r) less than equal and does not appear any official payset for hhmk the honest users every round owned fraction greater than all money the system round discussion. assuming that all malicious users perfectly coordinate their actions (as controlled single entity, the adversary) rather pessimistic hypothesis. perfect coordination among too many individuals difficult achieve. perhaps coordination only occurs within separate groups malicious players. but, since one cannot sure about the level coordination malicious users may enjoy, we'd better safe than sorry. assuming that the adversary can secretly, dynamically, and immediately corrupt users also pessimistic. after all, realistically, taking full control user's operations should take some time. the assumption implies, for instance, that, round (on average) implemented one minute, then, the majority the money given round will remain honest hands for least two hours, and least one week, note that the hmm assumptions and the previous honest majority computing power assumptions are related the sense that, since computing power can bought with money, malicious users own most the money, then they can obtain most the computing power. the communication model envisage message propagation --i.e., "peer-to-peer gossip" the only means communication. temporary assumption: timely delivery messages the entire network. for most part this paper assume that every propagated message reaches almost all honest users timely fashion. shall remove this assumption section where deal with network partitions, either naturally occurring adversarially induced. (as shall see, only assume timely delivery messages within each connected component the network.) one concrete way capture timely delivery propagated messages (in the entire network) the following: for all reachability and message size there exists lr,u such that, honest user propagates u-byte message time then reaches, time lr,u least fraction the honest users. essentially, bitcoin, when user propagates message every active user receiving for the first time, randomly and independently selects suitably small number active users, his "neighbors", whom forwards possibly until receives acknowledgement from them. the propagation terminates when user receives for the first time. the above property, however, cannot support our algorand protocol, without explicitly and separately envisaging mechanism obtain the latest blockchain --by another user/depository/etc. fact, construct new block not only should proper set verifiers timely receive round-r messages, but also the messages previous rounds, know and all other previous blocks, which necessary determine whether the payments are valid. the following assumption instead suffices. message propagation (mp) assumption: for all and there exists lr,u such that, for all times and all u-byte messages propagated honest user before lr,u received, time least fraction the honest users. protocol algorand actually instructs each small number users (i.e., the verifiers given step round algorand propagate separate message (small) prescribed size, and need bound the time required fulfill these instructions. enriching the assumption follows. for all and there exists ln,r,u such that, for all times and all u-byte messages each propagated honest user before ln,r,u are received, time least fraction the honest users. note the above assumption deliberately simple, but also stronger than needed our paper. for simplicity, assume and thus drop mentioning pessimistically assume that, provided does not violate the assumption, the adversary totally controls the delivery all messages. particular, without being noticed the honest users, the adversary can arbitrarily decide which honest player receives which message when, and arbitrarily accelerate the delivery any message wants. the protocol traditional setting already emphasized, byzantine agreement key ingredient algorand. indeed, through the use such protocol that algorand unaffected forks. however, secure against our powerful adversary, algorand must rely protocol that satisfies the new player-replaceability constraint. addition, for algorand efficient, such protocol must very efficient. protocols were first defined for idealized communication model, synchronous complete networks (sc networks). such model allows for simpler design and analysis protocols. given the honest percentage and the acceptable failure probability algorand computes upperbound, the maximum number member verifiers step. thus, the assumption need only hold for say that arbitrary-value (respectively, binary) (n, t)-byzantine agreement protocol with soundness if, for every set values not containing the special symbol (respectively, for }), execution which most the players are malicious and which every player starts with initial value every honest player halts with probability outputting value outi satisfy, with probability least the following two conditions: agreement: there exists out such that outi out for all honest players consistency: if, for some value for all honest players, then out refer out p's output, and each outi player i's output. the notation our protocols, player required count how many players sent him given message given step. accordingly, for each possible value that might sent, #si (v) (or just (v) when clear) the number players from which has received step recalling that player receives one message from each player the number exactly players then, for all and (v) the binary protocol bba this section present new binary protocol, bba which relies the honesty more than two thirds the players and very fast: matter what the malicious players might do, each execution its main loop brings the players into agreement with probability each player has his own public key digital signature scheme satisfying the unique-signature property. since this protocol intended run synchronous complete network, there need for player sign each his messages. digital signatures are used generate sufficiently common random bit step (in algorand, digital signatures are used authenticate all other messages well.) the protocol requires minimal set-up: common random string independent the players' keys. (in algorand, actually replaced the quantity protocol bba -step loop, where the players repeatedly exchange boolean values, and different players may exit this loop different times. player exits this loop propagating, some step, either special value special value thereby instructing all players "pretend" they respectively receive and from all future steps. (alternatively said: assume that the last message received player from another player was bit then, any step which does not receive any message from acts sent him the bit b.) the protocol uses counter representing how many times its -step loop has been executed. the start bba (one may think global counter, but actually increased each individual player every time that the loop executed.) there are where the maximum possible number malicious players. binary string identified with the integer whose binary representation (with possible leadings and lsb(x) denotes the least significant bit protocol bba (communication) step [coin-fixed-to- step] each player sends then sets sends outputs outi and halts. then, then sets else, sets (communication) step [coin-fixed-to- step] each player sends then sets sends outputs outi and halts. then set else, sets (communication) step [coin-genuinely-flipped step] each player sends and sigi (r, g). then sets then sets else, letting who have sent proper message this step sets lsb(minjsi h(sigi (r, g))); increases and returns step theorem whenever bba binary (n, t)-ba protocol with soundness proof theorem given []. its adaptation our setting, and its player-replaceability property are novel. historical remark probabilistic binary protocols were first proposed ben-or asynchronous settings []. protocol bba novel adaptation, our public-key setting, the binary protocol feldman and micali []. their protocol was the first work expected constant number steps. worked having the players themselves implement common coin, notion proposed rabin, who implemented via external trusted party []. graded consensus and the protocol let recall, for arbitrary values, notion consensus much weaker than byzantine agreement. definition let protocol which the set all players common knowledge, and each player privately knows arbitrary initial value vi' say that (n, t)-graded consensus protocol if, every execution with players, most which are malicious, every honest player halts outputting value-grade pair (vi where satisfy the following three conditions: for all honest players and |gi vn' for some value then and for all honest players historical note the notion graded consensus simply derived from that graded broadcast, put forward feldman and micali [], strengthening the notion crusader agreement, introduced dolev [], and refined turpin and coan []. [], the authors also provided -step (n, t)-graded broadcasting protocol, gradecast, for more complex (n, t)-graded-broadcasting protocol for has later been found katz and koo []. the following two-step protocol consists the last two steps gradecast, expressed our notation. emphasize this fact, and match the steps protocol algorand section respectively name and the steps gc. protocol step each player sends vi' all players. step each player sends all players the string and only (x) output determination. each player outputs the pair (vi computed follows: if, for some (x) then and if, for some (x) then and else, and theorem then (n, t)-graded broadcast protocol. the proof immediately follows from that the protocol gradecast [], and thus omitted. essence, graded-broadcasting protocol, (a) the input every player the identity distinguished player, the sender, who has arbitrary value additional private input, and (b) the outputs must satisfy the same properties and graded consensus, plus the following property the sender honest, then and for all honest player indeed, their protocol, step the sender sends his own private value all players, and each player lets vi' consist the value has actually received from the sender step the protocol now describe the arbitrary-value protocol via the binary protocol bba and the graded-consensus protocol gc. below, the initial value each player vi' protocol steps and each player executes gc, input vi' compute pair (vi step each player executes bba --with initial input and otherwise-- compute the bit outi output determination. each player outputs outi and otherwise. theorem whenever (n, t)-ba protocol with soundness proof. first prove consistency, and then agreement. proof consistency. assume that, for some value vi' then, property graded consensus, after the execution gc, all honest players output (v, accordingly, the initial bit all honest players the end the execution bba thus, the agreement property binary byzantine agreement, the end the execution outi for all honest players. this implies that the output each honest player proof agreement. since bba binary protocol, either (a) outi for all honest player (b) outi for all honest player case all honest players output and thus agreement holds. consider now case this case, the execution bba the initial bit least one honest player (indeed, initial bit all honest players were then, the consistency property bba would have outj for all honest j.) accordingly, after the execution gc, outputs the pair (v, for some value thus, property graded consensus, for all honest players accordingly, property graded consensus, for all honest players this implies that, the end every honest player outputs thus, agreement holds also case since both consistency and agreement hold, arbitrary-value protocol. historical note turpin and coan were the first show that, for t+, any binary (n, t)-ba protocol can converted arbitrary-value (n, t)-ba protocol. the reduction arbitrary-value byzantine agreement binary byzantine agreement via graded consensus more modular and cleaner, and simplifies the analysis our algorand protocol algorand generalizing for use algorand algorand works even when all communication via gossiping. however, although presented traditional and familiar communication network, enable better comparison with the prior art and easier understanding, protocol works also gossiping networks. fact, our detailed embodiments algorand, shall present directly for gossiping networks. shall also point out that satisfies the player replaceability property that crucial for algorand secure the envisaged very adversarial model. any player-replaceable protocol working gossiping communication network can securely employed within the inventive algorand system. particular, micali and vaikunthanatan have extended work very efficiently also with simple majority honest players. that protocol too could used algorand. two embodiments algorand discussed, very high level, round algorand ideally proceeds follows. first, randomly selected user, the leader, proposes and circulates new block. (this process includes initially selecting few potential leaders and then ensuring that, least good fraction the time, single common leader emerges.) second, randomly selected committee users selected, and reaches byzantine agreement the block proposed the leader. (this process includes that each step the protocol run separately selected committee.) the agreed upon block then digitally signed given threshold (th committee members. these digital signatures are circulated that everyone assured which the new block. (this includes circulating the credential the signers, and authenticating just the hash the new block, ensuring that everyone guaranteed learn the block, once its hash made clear.) the next two sections, present two embodiments algorand, algorand and algorand that work under majority-of-honest-users assumption. section show how adopts these embodiments work under honest-majority-of-money assumption. algorand only envisages that the committee members are honest. addition, algorand the number steps for reaching byzantine agreement capped suitably high number, that agreement guaranteed reached with overwhelming probability within fixed number steps (but potentially requiring longer time than the steps algorand the remote case which agreement not yet reached the last step, the committee agrees the empty block, which always valid. algorand envisages that the number honest members committee always greater than equal fixed threshold (which guarantees that, with overwhelming probability, least the committee members are honest). addition, algorand allows byzantine agreement reached arbitrary number steps (but potentially shorter time than algorand easy derive many variants these basic embodiments. particular, easy, given algorand modify algorand enable reach byzantine agreement arbitrary number steps. both embodiments share the following common core, notations, notions, and parameters. common core objectives ideally, for each round algorand would satisfy the following properties: perfect correctness. all honest users agree the same block completeness with probability the payset maximal. because paysets are defined contain valid payments, and honest users make only valid payments, maximal contains the "currently outstanding" payments all honest users. course, guaranteeing perfect correctness alone trivial: everyone always chooses the official payset empty. but this case, the system would have completeness unfortunately, guaranteeing both perfect correctness and completeness not easy the presence malicious users. algorand thus adopts more realistic objective. informally, letting denote the percentage users who are honest, the goal algorand guaranteeing, with overwhelming probability, perfect correctness and completeness close privileging correctness over completeness seems reasonable choice: payments not processed one round can processed the next, but one should avoid forks, possible. led byzantine agreement perfect correctness could guaranteed follows. the start round each user constructs his own candidate block bir and then all users reach byzantine agreement one candidate block. per our introduction, the protocol employed requires honest majority and player replaceable. each its step can executed small and randomly selected set verifiers, who not share any inner variables. unfortunately, this approach has completeness guarantees. this so, because the candidate blocks the honest users are most likely totally different from each other. thus, the ultimately agreed upon block might always one with non-maximal payset. fact, may always the empty block, that is, the block whose payset empty. well the default, empty one. algorand avoids this completeness problem follows. first, leader for round selected. then, propagates his own candidate block, blrr finally, the users reach agreement the block they actually receive from because, whenever honest, perfect correctness and completeness both hold, algorand ensures that honest with probability close (when the leader malicious, not care whether the agreed upon block one with empty payset. after all, malicious leader might always maliciously choose blrr the empty block, and then honestly propagate it, thus forcing the honest users agree the empty block.) leader selection algorand's, the rth block the form (r, h(b already mentioned the introduction, the quantity qr- carefully constructed essentially non-manipulatable our very powerful adversary. (later this section, shall provide some intuition about why this the case.) the start round all users know the blockchain far, from which they deduce the set users every prior round: that is, potential leader round user such that sigi qr- round executed small set verifiers, r,s again, each verifier r,s randomly selected among the users already the system rounds before and again via the special quantity qr- specifically, r-k verifier r,s sigi qr- #bad and #good #bad and #good #bad for instance, then having identified the leader the round (which they correctly when the leader honest), the task the step- verifiers start executing the using initial values what they believe the block the leader. actually, order minimize the amount communication required, verifier does not use, his input value vj' the byzantine protocol, the block that has actually received from (the user believes the leader), but the the leader, but the hash that block, that is, vj' h(bi thus, upon termination the protocol, the verifiers the last step not compute the desired round-r block but compute (authenticate and propagate) h(b accordingly, since h(b digitally signed sufficiently many verifiers the last step the protocol, the users the system will realize that h(b the hash the new block. however, they must also retrieve (or wait for, since the execution quite asynchronous) the block itself, which the protocol ensures that indeed available, matter what the adversary might do. asynchrony and timing algorand and algorand have significant degree asynchrony. this because the adversary has large latitude scheduling the delivery the messages being propagated. addition, whether the total number steps round capped not, there the variance contribute the number steps actually taken. soon learns the certificates user computes qr- and starts working round checking whether potential leader, verifier some step round assuming that must act step light the discussed asynchrony, relies various strategies ensure that has sufficient information before acts. for instance, might wait receive least given number messages from the verifiers the previous step, wait for sufficient time ensure that receives the messages sufficiently many verifiers the previous step. the seed and the look-back parameter recall that, ideally, the quantities should random and independent, although will suffice for them sufficiently non-manipulatable the adversary. first glance, could choose qr- coincide with and thus avoid specify qr- explicitly elementary analysis reveals, however, that malicious users may take advantage this selection mechanism. some additional effort shows that myriads other are the start round thus, qr- publicly known, and the adversary privately knows who are the potential leaders controls. assume that the adversary controls the users, and that, with very high probability, malicious user the potential leader round that is, assume that sigw qr- small that highly improbable honest potential leader will actually the leader round (recall that, since choose potential leaders via secret cryptographic sortition mechanism, the adversary does not know who the honest potential leaders are.) the adversary, therefore, the enviable position choosing the payset wants, and have become the official payset round however, can more. can also ensure that, with high probability, (*) one his malicious users will the leader also round that can freely select what will be. (and on. least for long while, that is, long these high-probability events really occur.) guarantee (*), the adversary acts follows. let the payset the adversary prefers for round then, computes h(p and checks whether, for some already malicious player sigz (r, h(p particularly small, that is, small enough that with very high probability will the leader round this the case, then instructs choose his candidate block alternatives, based traditional block quantities are easily exploitable the adversary ensure that malicious leaders are very frequent. instead specifically and inductively define our brand new quantity able prove that non-manipulatable the adversary. namely, h(siglr (qr- r), not the empty block, and h(qr- otherwise. the intuition why this construction works follows. assume for moment that qr- truly randomly and independently selected. then, will when honest the answer (roughly speaking) yes. this because h(siglr (*), random function. when malicious, however, longer univocally defined from qr- and there are least two separate values for one continues h(siglr (qr- r), and the other h(qr- r). let first argue that, while the second choice somewhat arbitrary, second choice absolutely mandatory. the reason for this that malicious can always cause totally different candidate blocks received the honest verifiers the second step. once this the case, easy ensure that the block ultimately agreed upon via the protocol round will the default one, and thus will not contain anyone's digital signature qr- but the system must continue, and for this, needs leader for round this leader automatically and openly selected, then the adversary will trivially corrupt him. selected the previous qr- via the same process, than will again the leader round r+. specifically propose use the same secret cryptographic sortition mechanism, but applied new q-quantity: namely, h(qr- r). having this quantity the output guarantees that the output random, and including the second input while all other uses have one inputs, "guarantees" that such independently selected. again, our specific choice alternative does not matter, what matter that has two choice for and thus can double his chances have another malicious user the next leader. the options for may even more numerous for the adversary who controls malicious for instance, let and three malicious potential leaders round such that sxr, the current round number. the current step number round the block generated round the set public keys the end round and the beginning round the system status the end round and the beginning round the payset contained round-r leader. chooses the payset round (and determines the next the seed round quantity (i.e., binary string) that generated the end round and used choose verifiers for round independent the paysets the blocks and cannot manipulated consider corrupting the news anchor major network, and producing and broadcasting today newsreel showing secretary clinton winning the last presidential election. most would recognize hoax. but someone getting out coma might fooled. system that not synchronous, the notion "the end round and "the beginning round need carefully defined. mathematically, and are computed from the initial status and the blocks r,s the set verifiers chosen for step round the set verifiers chosen for round s>= r,s r,s and hsv r,s respectively, the set malicious verifiers and the set honest verifiers r,s r,s hsv r,s r,s and r,s hsv r,s and respectively, the expected numbers potential leaders each and the expected numbers verifiers each r,s for notice that constant greater than the honesty ratio the system. that is, the fraction honest users honest money, depending the assumption used, each least cryptographic hash function, modelled random oracle. special string the same length the output the parameter specifying the allowed error probability. probability considered "overwhelming". the probability that the leader round honest. ideally with the existence the adversary, the value will determined the analysis. the look-back parameter. that is, round where the verifiers for round are chosen from --namely, r-k for the first step round user round chosen with probability knr-k for each step round user round chosen r,s with probability knr-k cert the certificate for set signatures h(b from proper verifiers round cert proven block. user knows possesses (and successfully verifies) both parts the proven block. note that the cert seen different users may different. tir the (local) time which user knows the algorand protocol each user has his own clock. different users' clocks need not synchronized, but must have the same speed. only for the purpose the analysis, consider reference clock and measure the players' related times with respect it. r,s ar,s and respectively the (local) time user starts and ends his execution step round and essentially, the upper-bounds to, respectively, the time needed execute step and the time needed for any other step the algorand protocol. parameter upper-bounds the time propagate single block. (in our notation, lr,m recalling our notation, that set for simplicity, and that blocks are chosen most mb-long, have l,,m strictly speaking, should "max{, k}". parameter upperbounds the time propagate one small message per verifier step (using, bitcoin, elliptic curve signatures with keys, verifier message long. thus, our notation, ln,r,b assume that o(l). notions verifier selection. for each round and step r,s r-k .h(sigi (r, qr- round chosen that, with overwhelming probability, |hsv r,s r,s and |hsv r,s r,s used the analysis. let the time when the first honest user knows let the interval l]. note that the initialization the protocol. for each and r,s recall that r,s ar,s and are respectively the starting time and the ending time player i's step moreover, recall that for each all honest users agree the same block when the leader honest, the block generated contains maximal payset may be. when the leader malicious, property implies that the expected time generate upperbounded again matter the precise value however, the expected time generate depends the precise value indeed, property and the leader honest with probability least thus e[t the same expected number verifiers can used whether the number users this because solely depends and sum, therefore, barring sudden need increase secret key length, the value should remain the same matter how large the number users may the foreseeable future. contrast, for any transaction rate, the number transactions grows with the number users. therefore, process all new transactions timely fashion, the size block should also grow with the number users, causing grow too. thus, the long run, should have round and each honest verifier hsv r,s have that (a) ar,s (b) player has waited amount time then bir,s for and bir,s for and (c) player has waited amount time then time bir,s has received all messages sent all honest verifiers hsv r,s for all steps have that (d) there not exist two different players r,s and two different values the same length, such that both players have waited amount time more than all the valid messages mjr,s- player receives have signed for and more than all the valid messages mjr,s- player receives have signed for proof. property (a) follows directly from the inductive hypothesis, player knows the time interval and starts his own step right away. property (b) follows directly from (a): since r,s player has waited amount time before acting, bir,s ar,s note that for now prove property (c). then property (b), for all verifiers hsv have bir,s ar,s since each verifier hsv sends his message time bjr, and the message reaches all honest users most time, time bir,s player has received the messages sent all verifiers hsv desired. then ts- property (b), for all steps ts- ts' ts' since each verifier hsv r,s sends his message time bjr,s and the message reaches all honest users most time, time bir,s player has received all messages sent all honest verifiers hsv r,s for all that why the statement the lemma require that and have the same length: many verifiers may have signed both hash value and bit thus both pass the threshold. assume for the sake contradiction that there exist the desired verifiers and values note that some malicious verifiers r,s- may have signed both and but each honest verifier hsv r,s- has signed most one them. property (c), both and have received all messages sent all honest verifiers hsv r,s- let hsv r,s- (v) the set honest (r, )-verifiers who have signed svir,s- the set malicious (r, )-verifiers from whom has received valid message, and svir,s- (v) the subset svir,s- from whom has received valid message signing the requirements for and have |hsv r,s- (v)| svir,s- (v)| ratio r,s- r,s- |hsv svi first show svir,s- (v)| r,s- svir,s- thus ratio |hsv r,s- similarly, the requirements for and have |hsv r,s- |hsv r,s- since honest verifier hsv r,s- destroys his ephemeral secret key skjr,s- before propagating his message, the adversary cannot forge j's signature for value that did not sign, after learning that verifier. thus, the two inequalities above imply |hsv r,s- |hsv r,s- (v)| |hsv r,s- |hsv r,s- contradiction. accordingly, the desired not exist, and property (d) holds. the completeness lemma lemma [completeness lemma, restated] assuming properties hold for round when the leader honest, with overwhelming probability, all honest users agree the same block which generated and contains maximal payset received time ar, and moreover, honest verifier would sign contradicting messages, and the adversary cannot forge signature honest verifier after the latter has destroyed his corresponding ephemeral secret key. thus more than all the valid (r, )-messages has received are from honest verifiers and the form mr, (esigj (h(blr )), with contradiction. accordingly, time bir, player propagates mr, (esigi where h(blr step arbitrarily fix honest verifier hsv lemma player has received all messages sent verifiers hsv when done waiting time bir, ar, similar step more than all the valid (r, )-messages has received are from honest verifiers and the form mr, (esigj (h(blr )), accordingly, player sets h(blrr and time bir, ar, propagates (esigi (), esigi (h(blr )), step arbitrarily fix honest verifier hsv lemma player would have received all messages sent the verifiers hsv has waited till time ar, note that |hsv also note that all verifiers hsv have signed for h(blrr blr, and time player has also received the message mlr the construction the protocol, player stops time bir, without propagating anything; sets blrr and sets his own cert the set (r, )-messages for and h(blrr that has received. step similarly, for any step and any verifier hsv r,s player would have received all messages sent the verifiers hsv has waited till time ar,s the same analysis, player stops without propagating anything, setting blr (and setting his own cert properly). course, the malicious verifiers may not stop and may propagate arbitrary messages, but because r,s with probability this event does not occur, then the protocol will continue for another steps. the probability that this does not occur two steps negligible, the protocol will finish step expectation, then, the number steps needed almost player were the first player propagate them. moreover, following the analysis above have accordingly, blr, thus all honest users have received mlr time all honest users know the time interval l]. finally, for actually have for all hsv there exists value such that for all hsv and such that h(b there exists valid message mr, from some verifier indeed, since player honest and sets more than all the valid messages mr, has received are for the same value and has set property (d) lemma for any other honest (r, )-verifier cannot that more than all the valid messages mr, that has received are for the same value accordingly, sets must that has seen majority for well and set desired. now consider arbitrary verifier hsv with majority for more than |hsv honest (r, )-verifiers have signed because has received all messages honest (r, )-verifiers messages from them time bir, ar, has particular received more than |hsv for because |hsv has seen majority for accordingly, player sets and property holds. does player necessarily set assume there exists different value such that player has also seen majority for some those messages may from malicious verifiers, but least one them from some honest verifier hsv indeed, because |hsv and has received all messages from hsv the set malicious verifiers from whom has received valid (r, )-message counts for majority for among all the valid (r, )-messages has received. however, already have that some other honest (r, )-verifiers have seen majority for (because they signed property (d) lemma this cannot happen and such value does not exist. thus player must have set desired, and property holds. finally, given that some honest (r, )-verifiers have seen majority for some (actually, more than half of) honest (r, )-verifiers have signed for and propagated their messages. the construction the protocol, those honest (r, )-verifiers must have received valid with h(b thus property holds. message mr, from some player bba again distinguish two cases. case all verifiers hsv have this happens following case gc. majority for and sets step which coin-fixed-to- step, although satisfies mod there not exist valid (r, )-messages for bit thus verifier hsv would stop because knows non-empty block however, with mod and there exist |hsv valid (r, )-messages for bit from hsv for every verifier hsv following lemma before time ar, player has received all messages from hsv thus stops without propagating anything and sets bor his cert the set valid (r, )-messages mr, (esigj (), esigj (vj received him when stops. next, let player either honest verifier step generic honest user (i.e., non-verifier). similar the proof lemma player sets bor and sets his own cert the set valid (r, )-messages mr, (esigj (), esigj (vj has received. finally, similar lemma such that, for the first time the binary ba, some player r,s (whether malicious honest) should stop without propagating anything. use "should stop" emphasize the fact that, player malicious, then may pretend that should not stop according the protocol and propagate messages the adversary's choice. moreover, the construction the protocol, either (esigj (), esigj (v), (e.a) able collect generate least valid messages mr,s sjr,s for the same and with r,s- for each induction have that player has set h(blr the same holds for every honest verifier hsv r,s who does not stop without propagating anything. now consider step and distinguish four subcases. case ..a. event e.a happens and there exists honest verifier hsv r,s who should also stop without propagating anything. this case, have mod and step coin-fixed-to- step. definition, player has received least valid (r, )-messages the form (esigj (), esigj (v), sjr,s since all verifiers hsv r,s have signed h(blr and r,s the (r, )-messages received for and are sent verifiers hsv r,s after time ts* blr, player has received mr, the time receives those (r, )-messages. thus player stops without propagating anything; sets and sets his own cert the set valid (r, )-messages for and that has received. next, show that, any other verifier hsv r,s has either stopped with blr has set and propagated (esigi (), esigi (h(blr )), sir,s indeed, because step the first time some verifier should stop without propagating anything, there does not exist step majority for then has seen more than (th r,s valid (r, )-messages for with more than r,s them from honest (r, )-verifiers. however, this implies |hsv r,s -|m r,s |+th -|m r,s n-|m r,s contradicting the fact that |hsv r,s r,s majority for and sets because step coin-fixed-to- step. have seen, h(blr thus propagates (esigi (), esigi (h(blr )), sir,s wanted show. for step since* player has helped propagating the messages his cert before time ar,s ts* all honest verifiers hsv r,s have received least valid (r, )-messages for bit and value h(blr before they are done waiting. furthermore, verifiers hsv r,s will not stop before receiving those (r, -)messages, because there not exist any other valid (r, )-messages for bit with mod and then the analysis goes through without any change: the end step all honest users would have received mr, the size the block becomes enormous and majority for bit again because |hsv r,s r,s majority, because |hsv r,s r,s thus all the verifiers hsv r,s propagate their messages for and h(blr accordingly. note that the verifiers hsv r,s not stop with blr because step not coin-fixed-to- step. now consider the honest verifiers step (which coin-genuinely-flipped step). the adversary sends the messages certir* some them and causes them stop, then again all honest users know blr within the time interval and majority. thus all them propagate their messages for and h(blr accordingly: that they not "flip coin" this case. again, note that they not stop without propagating, because step not coin-fixed-to- step. finally, for the honest verifiers step (which another coin-fixed-to- step), all them would have received least valid messages for and h(blr from hsv they really wait time ts* thus, whether not the adversary sends the messages certir* any them, all verifiers hsv r,s stop with blr without propagating anything. depending how the adversary acts, some them may have their own cert consisting those (r, )-messages certir* and the others have their own cert consisting those (r, )-messages. any case, all honest users know blr within the time interval and majority for (esigi (), esigi (vi thus, every verifier hsv r,s sets and propagates mr,s r,s* r,s* time similar case ..a, most more steps (i.e., the protocol reaches step which another coin-fixed-to- step), all honest users know bor within the time interval moreover, may majority for the same bit }), then sets lsb(h(slr,s )). there exists another honest r,s who has seen majority for bit then property verifier hsv (d) lemma honest verifier hsv r,s would have seen majority for bit since lsb(h(slr,s with probability all honest verifiers hsv r,s reach agreement with probability course, such verifier does not exist, then all honest verifiers hsv r,s agree the bit lsb(h(slr,s with probability combining the probability for hsv r,s have that the honest verifiers hsv r,s reach agreement bit with probability least (+h-h moreover, r,s have their set induction the majority vote before, all honest verifiers hsv h(bl thus, once agreement reached step either then useless, because the honest verifiers have already reached agreement step sure, this case would again depending whether however, this actually cases ..a and ..b, and the resulting exactly the same that case. more precisely, majority for the same bit therefore have the probability that the first users the permutation are all malicious but the )st honest h)x honest, then h(siglg (qg- g). the adversary cannot forge the signature distributed uniformly random from the adversary's point view and, except with exponentially small probability, was not queried round since each qg+ qg+ qr- respectively the output with qg+ qr- one the inputs, they all look random the adversary and the adversary could not have queried qr- round accordingly, the only case where the adversary can predict qr- with good probability round r-k when all the leaders lr-k lr- are malicious. again consider round {r-k r-} and the random permutation over g-k induced the corresponding hash values. for some the first users the permutation are all malicious and the x-th honest, then the adversary has possible choices for either the form h(sigi (qg- g)), where one small integer, without loss generality one can assume that the first rounds the protocol are run under safe environment and the inductive hypothesis holds for those rounds. that is, exponential the length the output note that this probability way smaller than the first malicious users, making player the actually leader round h(qg- g), forcing bog otherwise, the leader round will the first honest user the permutation and qr- becomes unpredictable the adversary. which the above options should the adversary pursue? help the adversary answer this question, the mental game actually make him more powerful than actually is, follows. first all, reality, the adversary cannot compute the hash honest user's signature, thus cannot decide, for each the number x(qg malicious users the beginning the random permutation round induced the mental game, give him the numbers x(qg for free. second all, reality, having the first users the permutation all being malicious does not necessarily mean they can all made into the leader, because the hash values their signatures must also less than have ignored this constraint the mental game, giving the adversary even more advantages. easy see that the mental game, the optimal option for the adversary, denoted the one that produces the longest sequence malicious users the beginning the random permutation round indeed, given specific the protocol does not depend qg- anymore and the adversary can solely focus the new permutation round which has the same distribution for the number malicious users the beginning. accordingly, each round the above mentioned gives him the largest number options for qg+ and thus maximizes the probability that the consecutive leaders are all malicious. therefore, the mental game the adversary following markov chain from round round with the state space being state represents the fact that the first user the random permutation the current round honest, thus the adversary fails the game for predicting qr- and each state represents the fact that the first users the permutation are malicious and the x-th honest, thus the adversary has options for the transition probabilities (x, are follows. and for any that is, the adversary fails the game once the first user the permutation becomes honest. (x, for any that is, with probability all the random permutations have their first users being honest, thus the adversary fails the game the next round. for any and (x, the probability that, among the random permutations induced the options the longest sequence malicious users the beginning some them thus the adversary has options for qg+ the next round. that is, h)y h)y- (x, note that state the unique absorbing state the transition matrix and every other state has positive probability going are interested upper-bounding the number rounds needed for the markov chain converge with overwhelming probability: that is, matter which state the chain starts at, with overwhelming probability the adversary loses the game and fails predict qr- round consider the transition matrix after two rounds. easy see that and for any for any and have (x, (x, (x, z)p (z, (x, z)p (z, y). z>= z>= letting have and (x, (x, hy- hz- ][( hy- z>= (x,y) goes --that is, goes note that the highest below compute the limit (x,y) order (x, with coefficient accordingly, (x, (x, (x, lim lim (x, (x, xhy- o(hy o(hz )][z hy- o(hy xhy o(hy+ z>= [xh lim lim xhy- o(hy xhy- o(hy xhy lim lim xhy- lim when sufficiently close have (x, and induction, for any (k) such that (k) (k) for any and for any and (k) (x, (k-) (x, (k-) (x, z)p (z, z>= (z, (x, (x, negligible, starting with any state although there are many such states easy see that (x, hy- hy- lim lim y-+ (x, y-+ hy+ y-+ hy+ lim therefore each row the transition matrix decreases geometric sequence with rate (k) when large enough, and the same holds for accordingly, when large enough but still the order log/ y>= (k) (x, that is, with overwhelming probability the adversary loses the game and fails predict qr- round for (/, more complex analysis shows that there exists constant slightly larger than such that suffices take o(logc thus lemma holds. lemma (restated) given properties for each round before for and the leader honest with probability least for example, suggested the specific choices parameters. proof. following lemma the adversary cannot predict qr- back round except with negligible probability. note that this does not mean the probability honest leader for each round. indeed, given qr- depending how many malicious users are the beginning the random permutation r-k the adversary may have more than one options for and thus can increase the probability malicious leader round --again are giving him some unrealistic advantages lemma simplify the analysis. however, for each qr- that was not queried the adversary back round for any with probability h)x- the first honest user occurs position the resulting random permutation r-k when the probability honest leader round indeed while when the adversary has two options for and the resulting probability only considering these two cases, have that the probability honest leader round least h)h desired. note that the above probability only considers the randomness the protocol from round round when all the randomness from round round taken into consideration, qr- even less predictable the adversary and the probability honest leader round least replacing with and shifts everything back one round, the leader honest with probability least desired. similarly, each coin-genuinely-flipped step the "leader" that step --that the verifier r,s whose credential has the smallest hash value, honest with probability least thus for and lemma holds. algorand this section, construct version algorand working under the following assumption. honest majority users assumption: more than the users each are honest. section show how replace the above assumption with the desired honest majority money assumption. additional notations and parameters for algorand notations pragmatic upper-bound the number steps that, with overwhelming probability, will actually taken one round. (as shall see, parameter controls how many ephemeral keys user prepares advance for each round.) random variable representing the number bernoulli trials needed see when each trial with probability will used upper-bound the time needed generate block lower-bound for the number honest verifiers step round such that with overwhelming probability (given and p), there are honest verifiers r,s parameters relationships among various parameters. for each step round chosen that, with overwhelming probability, |hsv r,s and |hsv r,s r,s r,s that is, there honest majority among selected verifiers. the closer the value is, the smaller needs be. particular, use (variants of) chernoff bounds ensure the desired conditions hold with overwhelming probability. example choices important parameters. .n, implementing ephemeral keys algorand recall that verifier r,s digitally signs his message mr,s step round relative r,s ephemeral public key pki using ephemeral secrete key skir,s that promptly destroys after using. when the number possible steps that round may take capped given integer have already seen how practically handle ephemeral keys. for example, have explained algorand (where handle all his possible ephemeral keys, from round round generates pair k), where public master key identity based signature scheme, and its corresponding secret master key. user publicizes and uses generate the secret key each possible ephemeral public key (and destroys after having done so). the set i's ephemeral public keys for the relevant rounds {i} u}. (as discussed, the round approaches, "refreshes" his pair k).) practice, large enough, round algorand will not take more than steps. principle, however, there the remote possibility that, for some round the number steps actually taken will exceed when this happens, would unable sign his message mr,s for any step because has prepared advance only secret keys for round moreover, could not prepare and publicize new stash ephemeral keys, discussed before. fact, so, would need insert new public master key new block. but, should round take more and more steps, new blocks would generated. however, solutions exist. for instance, may use the last ephemeral key round pkir,u follows. generates another stash key-pairs for round --e.g., generating another master key pair k); using this pair generate another, say, ephemeral keys, r,u+ r,u+ corresponding steps ..., round using skir,u digitally sign (and any (r, u)-message r,u relative pkir,u and erasing and skir,u should become verifier step with then digitally signs his (r, s)r,u+s (i, s). course, verify this signature message mr,u+s relative his new key others need certain that this public key corresponds i's new public master key thus, addition this signature, transmits his digital signature relative pkir,u course, this approach can repeated, many times necessary, should round continue for more and more steps! the last ephemeral secret key used authenticate new master public key, and thus another stash ephemeral keys for round and on. the actual protocol algorand recall again that, each step round verifier r,s uses his long-term public-secret r,s case key pair produce his credential, sigi (r, well sigi verifier uses his ephemeral key pair, (pkir,s skir,s sign any other message that may required. for simplicity, write esigi (m), rather than sigpkir,s (m), denote i's proper ephemeral signature this step, and write esigi (m) instead sigpkir,s (m) (i, esigi (m)). step block proposal instructions for every user r-k user starts his own step round soon has cert which allows unambiguously compute h(b and qr- user uses qr- check whether not. does nothing for step that is, potential leader, then does the following. (a) has seen himself (any boj can easily derived from its hash value cert and thus assumed "seen"), then collects the round-r payments that have been propagated him far and computes maximal payset ayir from them. (b) hasn't seen all yet, then sets ayir (c) next, computes his "candidate block" bir (r, ayir sigi (qr- h(b )). (c) finally, computes the message mr, (bi esigi (h(bi )), destroys his ephemeral secret key ski and then propagates two messages, and (sigi (qr- sir, separately but simultaneously.a when the leader, sigi (qr- allows others compute h(sigi (qr- r). selective propagation shorten the global execution step and the whole round, important that the (r, )messages are selectively propagated. that is, for every user the system, for the first (r, )-message that ever receives and successfully verifies,a whether contains block just credential and signature qr- player propagates usual. for all the other (r, )-messages that player receives and successfully verifies, propagates only the hash value the credential contains the smallest among the hash values the credentials contained all (r, )-messages has received and successfully verified far. however, receives two different messages the form mr, from the same player i,b discards the second one matter what the hash value i's credential is. note that, under selective propagation useful that each potential leader propagates his those small messages travel faster than blocks, ensure credential sir, separately from mr, timely propagation the mr, where the contained credentials have small hash values, while make those with large hash values disappear quickly. that is, all the signatures are correct and, the form mr, both the block and its hash are valid --although does not check whether the included payset maximal for not. which means malicious. thank georgios vlachos for suggesting this. step the first step the graded consensus protocol instructions for every user r-k user starts his own step round soon has cert user waits maximum amount time while waiting, acts follows. after waiting for time finds the user such that h(slr, has exhausted his stash pre-generated ephemeral keys and has authenticate his (r, s)-message mr,s "cascade" ephemeral keys. thus i's message becomes bit longer and transmitting these longer messages will take bit more time. accordingly, after many steps given round, the value the parameter will automatically increase slightly. (but reverts the original once new block produced and new round starts.) reconstruction the round-r block non-verifiers instructions for every user the system: user starts his own round soon has cert follows the instructions each step the protocol, participates the propagation all messages, but does not initiate any propagation step not verifier it. ends his own round entering either ending condition ending condition some step, with the corresponding cert from there on, starts his round while waiting receive the actual block (unless has already received it), whose hash h(b has been pinned down cert again, cert indicates that bor the knows the moment has cert analysis algorand the analysis algorand easily derived from that algorand essentially, algorand with overwhelming probability, (a) all honest users agree the same block the leader new block honest with probability least handling offline honest users said, honest user follows all his prescribed instructions, which include that being online and running the protocol. this not major burden algorand, since the computation and bandwidth required from honest user are quite modest. yet, let point out that algorand can easily modified work two models, which honest users are allowed offline great numbers. before discussing these two models, let point out that, the percentage honest players were algorand could still run setting all parameters assuming instead that accordingly, algorand would continue work properly even most half the honest players chose offline (indeed, major case of"absenteeism"). fact, any point time, least the players online would honest. from continual participation lazy honesty saw, algorand and algorand choose the look-back parameter let now show that choosing properly large enables one remove the continual participation requirement. this requirement ensures crucial property: namely, that the underlying protocol bba has proper honest majority. let now explain how lazy honesty provides alternative and attractive way satisfy this property. recall that user lazy-but-honest follows all his prescribed instructions, when asked participate the protocol, and asked participate the protocol only very rarely --e.g., once week-- with suitable advance notice, and potentially receiving significant rewards when participates. allow algorand work with such players, just suffices "choose the verifiers the current round among the users already the system much earlier round." indeed, recall that the verifiers for round are chosen from users round and the selections are made based the quantity qr- note that week consists roughly minutes, and assume that round takes roughly (e.g., average) minutes, week has roughly rounds. assume that, some point time, user wishes plan his time and know whether going verifier the coming week. the protocol now chooses the verifiers for round from users round and the selections are based qr-, round player already knows the values qr-, qr- since they are actually part the blockchain. then, for each between and verifier step round and only sigi qr+m with non-negligible probability, e.g., then the r,s r,s probability that |hsv-i sv-i very low, e.g., when this case, may well treat the smaller part going offline, because there will not enough verifiers this part generate signatures certify block. let consider the larger part, say part without loss generality. although |hsv r,s the system has enough signatures certify however, since the malicious verifiers withheld their signatures, the users enter step which coin-fixed-to step. because |hsvr,s the system has enough signatures certify bor the adversary then creates fork releasing the signatures svr,s for and h(b accordingly, there will two 's, defined the corresponding blocks round however, the fork will not continue and only one the two branches may grow round additional instructions for algorand when seeing non-empty block and the empty block bor follow the non-empty one (and the defined it). indeed, instructing the users with the non-empty block the protocol, large amount honest users r+-k realize there fork the beginning round then the empty block will not have enough followers and will not grow. assume the adversary manages partition the honest users that some honest users see (and perhaps bor and some only see bor because the adversary cannot tell which one them will verifier following and which will verifier following bor the honest users are randomly partitioned and each one them still becomes verifier (either with respect with respect bor step with probability for the malicious users, each one them may have two chances become verifier, one with and the other with bor each with probability independently. r+,s let hsv;b the set honest verifiers step round following other notations r+,s r+,s r+,s such hsv;b and sv;b are similarly defined. chernoff bound, easy sv;b having fork with two non-empty blocks not possible with without partitions, except with negligible probability. see that with overwhelming probability, r+,s r+,s r+,s r+,s |hsv;b |hsv;b sv;b sv;b small for each part following similar analysis, even the adversary manages create fork with some non-negligible probability each part for round most one the four branches may grow round adversarial partition second all, the partition may caused the adversary, that the messages propagated the honest users one part will not reach the honest users the other part directly, but the adversary able forward messages between the two parts. still, once message from one part reaches honest user the other part, will propagated the latter usual. the adversary willing spend lot money, conceivable that may able hack the internet and partition like this for while. the analysis similar that for the larger part the physical partition above (the smaller part can considered having population the adversary may able create fork and each honest user only sees one the branches, but most one branch may grow. network partitions sum although network partitions can happen and fork one round may occur under partitions, there lingering ambiguity: fork very short-lived, and fact lasts for most single round. all parts the partition except for most one, the users cannot generate new block and thus (a) realize there partition the network and (b) never rely blocks that will "vanish". acknowledgements would like first acknowledge sergey gorbunov, coauthor the cited democoin system. most sincere thanks maurice herlihy, for many enlightening discussions, for pointing out that pipelining will improve algorand's throughput performance, and for greatly improving the note that user finishes step without waiting for time only has seen least signatures for the same message. when there are not enough signatures, each step will last for time. exposition earlier version this paper. many thanks sergio rajsbaum, for his comments earlier version this paper. many thanks vinod vaikuntanathan, for several deep discussions and insights. many thanks yossi gilad, rotem hamo, georgios vlachos, and nickolai zeldovich for starting test these ideas, and for many helpful comments and discussions. silvio micali would like personally thank ron rivest for innumerable discussions and guidance cryptographic research over more than decades, for coauthoring the cited micropayment system that has inspired one the verifier selection mechanisms algorand. hope bring this technology the next level. meanwhile the travel and companionship are great fun, for which are very grateful. references bitcoin computation waste, http://gizmodo.com/the-worlds-most-powerful-computer-network-is-being-was- bitcoinwiki. proof stake. http://www.blockchaintechnologies.com/blockchain-applications june coindesk.com. bitcoin: peer-to-peer electronic cash system http://www.coindesk.com/ibm-reveals-proof-concept-blockchain-powered-internet-things/ june ethereum. ethereum. https://github.com/ethereum/. june howstuffworks.com. how much actual money there the world?, https://money.howstuffworks.com/how-much-money-is-in-the-world.htm. june en.wikipedia.org/wiki/sortition. ben-or. another advantage free choice: completely asynchronous agreement protocols. proc. annual symposium principles distributed computing, acm, new york, pp. castro and liskov. practical byzantine fault tolerance, proceedings the third symposium operating systems design and implementation. new orleans, louisiana, usa, pp. chaum, random sample elections, https://www.scribd.com/mobile/document//random-sa chor and dwork. randomization byzantine agreement, randomness and computation. micali, ed., jai press, greenwich, ct, pp. decker and wattenhofer. information propagation the bitcoin network. -th ieee conference peer-to-peer computing, dolev. the byzantine generals strike again. algorithms, (), pp. dolev and h.r. strong. authenticated algorithms for byzantine agreement. siam journal computing (), dwork and naor. pricing via processing, or, combatting junk mail. advances cryptology, crypto': lecture notes computer science no. springer: feldman and micali. optimal probabilistic algorithm for synchronous byzantine agreement. (preliminary version stoc siam computing, fischer. the consensus problem unreliable distributed systems brief survey). proc. international conference foundations computation, goldwasser, micali, and rivest. digital signature scheme secure against adaptive chosen-message attack. siam journal computing, no. april pp. gorbunov and micali. democoin: publicly verifiable and jointly serviced cryptocurrency. https://eprint.iacr.org//, may katz and c-y koo. expected constant-round protocols for byzantine agreement. https://www.cs.umd.edu/~jkatz/papers/ba.pdf. kiayias, russel, david, and oliynycov.. ouroburos: provably secure proof-of-stake protocol. cryptology eprint archive, report http://eprint.iacr.org//. king and nadal. ppcoin: peer-to-peer crypto-currency with proof-of-stake, lazar and gilad. personal communication. lynch. distributed algorithms. morgan kaufmann publishers, micali. algorand: the efficient public ledger. https://arxiv.org/abs/.. micali. fast and furious byzantine agreement. innovation theoretical computer science berkeley, ca, january single-page abstract. micali. byzantine agreement, made trivial. https://people.csail.mit.edu/silvio/selectedscientifi micali, rabin and vadhan. verifiable random functions. foundations computer science (focs), new york, oct micali and rivest. micropayments revisited. lecture notes computer science, vol. springer verlag, nakamoto. bitcoin: peer-to-peer http://www.bitcoin.org/bitcoin.pdf, may electronic cash system. pass and shi. the sleepy model consensus. cryptology eprint archive, feb report pease, shostak, and lamport. reaching agreement the presence faults. assoc. comput. mach., (), pp. rabin. randomized byzantine generals. foundations computer science (focs), ieee computer society press, los alamitos, ca, pp. turpin and coan. extending binary byzantine agreement multivalued byzantine agreement. inform. process. lett., (), pp.