rchain architecture documentation release ede eykholt, lucius gregory meredith, joseph denman january contents: abstract introduction comparison blockchains architecture overview requirements architectural approach pseudonymous identity and cryptography blockchain data contracts node communications specialk: data continuation access, cache content delivery network attention reputation economy applications contract development deployment governance implementation roadmap call for participation chapter abstract rchain's platform architecture decentralized, economically sustainable public compute infrastructure. the platform design results from the inspirations earlier blockchains and builds top the shoulders giants the disciplines mathematics and programming language design. intended audience: this document written primarily for software designers and developers who want help see this vision realized, and for others who want support these efforts. introduction the rchain cooperative and its partners are building public, sybil-resistant, and censorship-resistant computing utility. this open source project. will blockchain-based platform for specifying, verifying, building, and running decentralized protocols ("smart contracts") that form the base for decentralized applications. top this technology platform, broad array solutions can built, including financial services, monetized content delivery networks, marketplaces, governance solutions, daos, and rchain's own flagship decentralized social platform. the decentralization movement ambitious and will spawn solutions that provide awesome opportunities for new social and economic interactions. decentralization also provides counter-balance abuses and corruption that occasionally occur some organizations where power concentrated, including large corporations and governments. decentralization supports self-determination and the rights individuals self-organize. course, the realities more decentralized world will also have its challenges and issues, such how the needs international law, public good, and compassion will honored. admire and respect the awesome innovation and intentions the bitcoin and ethereum creators, and other platforms that dramatically advanced the state decentralized systems and ushered this new age cryptocurrency and smart contracts. however, also see symptoms that those projects didn't use the best engineering and mathematical models for scaling and correctness order support mission-critical solutions. the ongoing debates about bitcoin scaling and the june issues with the dao smart contract are symptomatic foundational architectural issues. example question: scalable insist explicit serialization order for all transactions conducted planet earth? rchain's requirements, originating from rchain's decentralized social product and its attention reputation economy, are provide content delivery the scale facebook along with support for transaction volume and speed the scale visa. after due diligence the current state many blockchain projects, after deep collaboration with ethereum developers, and after understanding their respective roadmaps, the rchain leadership concluded that the current and near-term blockchain architectures cannot meet these requirements. therefore, rchain and partners resolved build better blockchain architecture. together with the blockchain industry, are still the dawn this decentralized movement, and now the time lay more correct architectural foundation. the journey ahead for those who share this ambitious vision challenging worthwhile, and this document summarizes that vision and how seek accomplish it. compare the blockchains bitcoin and ethereum, rchain architecture documentation, release outline the rchain architecture, rationale for its creation, and pointers initial specifications. comparison blockchains this document assumes the reader familiar with the basics bitcoin and ethereum. one approach introducing the architecture let's compare the characteristics bitcoin, ethereum, and rchain currently planned. chapter abstract rchain architecture documentation, release semantic data structure algoconsensus rithm finality visibility revision mechanism heterosharding geneity basis for sharding number levels concurrency comcontracts putational power runtime architecture program.. comparison blockchains ming language block size bitcoin blockchain chain blocks. each block contains header that points the previous block, list transactions, and other data. ethereum blockchain chain blocks. each block contains header that points the previous block, transaction list, and ommers (uncles) list. current: proof work.future: proof stake stake-based betting blocks. probability transaction reversal diminishes over time, each new block confirmation. private, consortium, public depending deployed nodes. current: soft and hard forks. future: block revisions case temporary network isolation. rchain blockchain graph blo each block contains heade points one more previo blocks, list transactions other data. for details, see blockchain data semantics proof stake: stake-based logical propositions. homogeneous, i.e., not sharded current: homogeneous, i.e., not shardedfuture: two-level n/a address range sharding address space clients subscribe select address namespaces withou downloading the entire bloc able impose different pol different address namespace dynamic composable shard based namespace interac n/a future: two levels: cluster leaves unbounded number level n/a current: future: yes stack-based language with few instructions turing complete yes. allows for concurrent propositions and commit blocks that don't conflict. turing complete script runs bitcoin core, libbitcoin, and other native implementations ethereum virtual machine implemented multiple platforms rhovm implemented platforms script solidity, serpent, lll and any other languages that get implemented the evm. rholang and any other langu that get implemented the rhovm. dynamic dynamic proof work probability transaction reversal diminishes over time, each new block confirmation. global soft and hard forks probability transaction diminishes over time, eac block confirmation. private, consortium, publ depending namespace deployed nodes. block revisions case temporary network isolation rchain architecture documentation, release architecture overview the primary components the architecture are depicted below: like all "layer cake" views architecture, this diagram simplification the actual architecture. first glance, you'll notice there are components expected blockchain architectures, but also components that might not expected all data managed the platform requires some associated payment. course, application could also manage its own data, and that data could referenced via pointer stored the blockchain. addition the datastore the base the architecture, consensus protocol and peer-to-peer gossip network form the foundation. above that, the specialk data continuation access and cache layer evolution the existing specialk technology (including its decentralized content delivery, key-value database, inter-node messaging, data access patterns, and privacy protecting agent model). the casper consensus protocols assure that nodes reach agreement about the contracts, contract state, and transactions for which each node interested. blockchain contracts (aka smart contracts, protocols, programs) will written new domain-specific language for contracts called rholang (or contract languages that compile rholang) and then executed the rho virtual machine number native platforms. smart contracts include some essential system contracts well those providing capabilities for tokens and application-supplied contracts. metered and monetized content delivery network (cdn) enabled through token and micro-payment contracts, accessing mix blockchain and off-chain data. the attention reputation economy provides model and set interactions for motivating respectful and economic creation and dissemination information within social networks. the architecture, there will several apis, especially the top layers. typed apis will provide access the rhovm, contract services, and individual contracts. addition other apis (including restful apis) will provided for accessing the cdn, and the attention reputation economy. chapter abstract rchain architecture documentation, release we'll detail these components the sections below, from the bottom-up. but first, let's discuss the requirements and software architecture approach motivating this platform solution. requirements let's look the requirements for the platform from the vantage point the developers building applications top it. then, let's look what required the platform itself order achieve those requirements. requirements for decentralized application developers fully decentralized tamper-proof blockchain for "immutable" history smart contract state (conserved quantities and state) reliably replicated support for multiple tokens ability write predictably secure software contracts scalable requirements the architecture design with provably correct approaches data separation using namespace addressing reduce unnecessary data replication otherwise independent tokens and contracts support for concurrent protocol execution distributed and decentralized minimal external dependencies peer-to-peer and discoverable nodes consensus protocol that computationally efficient and not resource-intensive non-requirements there long list items the architecture will not address, but let's list few dispel what might otherwise common misperceptions. for example, the architecture will not address: compatibility with smart contracts scripts written other blockchain technologies automated coin conversion within the platform, since this can better handled the application level architectural approach building quality software challenging. easier hand-craft clever software; however, the resulting software often poor quality, riddled with bugs, difficult maintain, and difficult evolve. inheriting and working such software can hellish for development teams. when building open-source system support mission-critical economy, reject minimal-success mindset favor end-to-end correctness. therefore, resolved meet the requirements stated the earlier section, and to: build quality software that implements well-specified protocols. build software based software architecture patterns and other correct-by-construction approaches. requirements rchain architecture documentation, release take cues from mathematics. use formal verification protocols, leveraging model checking and theorem proving. make evidence-based decisions with supporting rationale for design decisions. choose functional programming paradigm, since better enables distributed and parallel processing. apply best practices software patterns, including compositionality. pseudonymous identity and cryptography like other blockchains, rchain will use elliptic curve cryptography (ecc). the exact curve and address formats have not yet been selected. there are several areas which cryptography employed, including: transaction signing data encryption per channel based diffie-hellman key exchange, within and across nodes, and datastores obscurity keys and data dht blockchain data data semantics like ethereum, the rchain blockchain will store contracts and their serialized state. utxo-style transactions will implemented with simpler system-level contracts. like bitcoin and ethereum, tamper-proof blockchain semantics will used create history blocks. the blockchain's main purpose efficiently store essential state, any necessary sequencing, and timestamping. note that the math underlying this blockchain semantic structure known traced monoidal category. for more detail see masahito hasegawa's paper this topic, recursion from cyclic sharing traced monoidal categories and models cyclic lambda calculi. the rchain design considers all storage "conserved", although not all data will conserved forever. instead, data storage will leased and will cost producers that data proportion its size, contract complexity, and lease duration. unlike bitcoin and ethereum, immutable data not promised truly forever; however, very long lease duration equivalent. the simple economic reason justifying leasing that storage must paid someone cannot maintained. we've chosen make the economic mechanism direct. really environmentally unfriendly idea that storage made "free" only subsidize unrelated process. small part the real cost measurable the heat signatures the data centers that are growing staggering size. this charging for data accessed also helps reduce "attack" storage, the storage illegal content discredit the technology. variety data supported, including public unencrypted json, encrypted blobs, mix. this data can also reference off-platform data stored private, consortium, public, obscure locations and formats. chapter abstract rchain architecture documentation, release data storage data will accessed using the specialk semantics and physically stored key-value database. given node can choose which address namespaces cares about, not all data needs replicated every node. addresses and sharding/compositionality contrast other blockchains, where addresses are public keys (or hashes thereof), rchain's address space will structured. this similar how both the internet and the web works, with addresses and urls, respectively. structured addressing approach allows programs talk about "location" much more nuanced and fine-grained way. this design choice enables fast datalog queries based those namespaces and better system performance analyzing communication patterns optimize the sharding solution. this sharding solution allows: dynamic composable sharding based namespace interaction concurrent betting and committing blocks that don't conflict. clients subscribe select address spaces without downloading the entire blockchain. able impose different policies such maximum transaction size different address ranges. arbitrary number levels address namespace. for additional information, see linear types can change the blockchain (pdf, lex, hangout video), which describes the inspirational math and thinking this area. linear types provide nice way decompose the blockchain scalable fashion. already has sharding semantics it, that the type system. namespace definition and policy order support many the use cases that users bitcoin find valuable well broader use cases, namespace definitions will have corresponding policy set that constrains its use, for example setting: maximum contract code size, maximum data size, minimum lease time, maximum lease time, and other parameters with policies such these, namespace can defined provide better guarantees fast transaction speed and immutability, for example. contract ownership, transactions, and messages rchain's contract accounts, transactions, and messages are analogous those ethereum. rate-limiting mechanism rchain's will implement rate-limiting mechanism that related some calculation processing, memory, storage, and bandwidth resources. this mechanism needed order recover costs for the hardware and related operations. although bitcoin and ethereum (gas) have similar needs, the mechanisms are different. specifically, the blockchain data rchain architecture documentation, release metering will not done the level, but will injected the contract code (via source-to-source translation that part the compilation process tokens somewhat similar omni layer, multiple types tokens will supported. these tokens will have different properties depending their type, including parameters such as: supply (initial supply, supply growth function, and final supply), fungibility, and other properties for each type token, there will link between its class (i.e., its set distinguishing properties) and the ratelimiting mechanism. contracts rchain contract well-specified and well-behaved program that interacts with others. contract interaction with clients other contracts via transactions. when the contract given state needs evaluated, read from the blockchain and deserialized into rhovm intermediate representation (ir) the contract with its state parameters. this via delimited continuation pattern. the rhovm compiled into another format that then executed. after the contract run its next transaction state, the resulting state serialized and again stored the blockchain. contract execution model, rholang, and rhovm this section describes the essential requirement for decentralized concurrency internet-scale applications, along with the compute models and programming languages that best suit that requirement. rholang introduced, which behaviorally typed, reflective, higher-order process language. concurrency requirements platform supporting global, decentralized compute utility that supports wide variety applications must scale, and concurrency essential achieve that. transactions that not interact must able complete the same time, because enforce sequencing constraint forces all nodes process all transactions. such sequencing constraint essentially what causes blockchains their current form fundamentally unscalable. when say "concurrency", we're not just talking about multi-threaded implementation functions, but handling non-blocking i/o and concurrent processes within and across nodes. the internet itself built out billions autonomous computing devices each which executing programs concurrently with respect the other devices, but also concurrently the devices themselves, most modern hardware supports native multi-threading capability. decentralization places special emphasis the autonomy and independence devices and programs running them. the apis centralized trusted third parties, which programmers could pretend were part giant sequential computer, will become thing the past. even inside those organizations sequential architecture giving way lots and lots autonomously executing microservices. ethereum intending following the same technique. chapter abstract rchain architecture documentation, release mobile process calculi there are relatively few programming paradigms and languages that handle concurrent processes their core model. instead, they bolt some kind threading-based concurrency model the side address being able scale doing more than one thing time. mobile process calculi provides one model, which we've chosen. they provide fundamentally different notion what computing is. these models, computing arises primarily from the interaction processes. the family mobile process calculi provides optimal foundation for system interacting processes. among these models computation, the applied -calculus stands out. models processes that send queries over channels. this approach maps very well onto today's internet and has been used the tool choice for reasoning about wide variety concerns essential for distributed protocols. beyond this basic fit with the way the internet computes, the mobile process calculi have something else going for them: behavioral types. behavioral types represent new kind typing discipline that constrains not only the shape input and output, but the permitted order inputs and outputs among communicating processes. getting concurrency right hard, and support from this kind typing discipline will extremely valuable ensure end-to-end correctness large system communicating processes. rho-calculus even model based the applied -calculus and equipped with behavioral typing discipline still not quite the best fit for programming language for the decentralized internet, let alone contracting language for the blockchain. there's another key ingredient: the rho-calculus, variant the -calculus, was introduced and provided the first model concurrent computation with reflection. reflection now widely recognized key feature practical programming languages. java, c#, scala, have eventually adopted reflection core feature, and even ocaml and haskell have ultimately developed reflective versions. the reason simple: industrial scale, human agency the end very long chain programs operating programs. programmers use programs write programs, because without the computational leverage would take too long write them industrial scale. reflection one the key features that enables programs write programs, providing disciplined way turn programs into data that programs can operate and then turn the modified data back into programs. lisp programmers have known for decades how powerful this feature and took the modern languages some time catch that understanding. the rhocalculus the first computational model combine all these core requirements: behaviorally typed, fundamentally concurrent, message-passing model, with reflection. for details, see reflective higher-order calculus. rholang rholang fully featured, general purpose, turing complete programming language built from the rho-calculus. rholang rchain's smart contract language. get taste rholang, here's contract named cell that holds value and allows clients get and set it: data request[a] get(ch[a]) set(a) contract cell(client: ch[request[a]], state: ch[a]) select case(get(rtn) client; value state) rtn!(value) case(set(newvalue) client; value state) state!(newvalue) contracts rchain architecture documentation, release the language concurrency-oriented, with focus message-passing through channels. channels are statically typed and can used single message-pipes, streams used store data. similarly typed functional languages, supports algebraic data types and deals with immutable values. supports formal verification through the use behavioral types. document introducing rholang more detail being produced. rhovm the compiled rholang contract executed rho virtual machine (rhovm). this virtual machine derived from the computational model the language, similar other programming languages such scala and haskell. other words, there will tight coupling between rholang and its vm, ensuring correctness. this the machine that will executed the compute utility, and call rhovm. allow clients execute the vm, we'll build compiler pipeline that starts with code that compiled into intermediate representations (irs) that are progressively closer the metal, with each translation step being either provably correct, commercially tested production systems, both. this pipeline illustrated the figure below: let's describe these steps more detail: simplification. from programs written the rholang contracting language from another contract language, this step includes: injection code for the rate-limiting mechanism, desugaring syntax, and simplification for functional equivalencies. the result targets the rhovm ir. note, the state the rhovm can serialized/deserialized to/from storage such the blockchain. chapter abstract rchain architecture documentation, release compilation. from the rhovm delimited continuations ir. continuation passing. from delimited continuations lambda ir. this compilation follows translation pattern from delimited continuations traditional continuation-passing style that has been proven correct. ocaml compilation strategy. from code lambda llvm, the ocaml compiler. note that llvm core libraries provide modern source- and target-independent optimizer, along with code generation support for many popular cpus. for more details see the #rho-lang channel the rchain slack (here join). early compiler work can seen github and discussion gitter. formal specification rholang will formally specified, and are investigating few frameworks such k-framework achieve this. model checking, theorem proving, and composition contracts the rhovm and potentially upstream contracting languages, there are variety techniques and checks that will applied during compile-time and runtime. these help address requirements such how developer and the system itself can know priori that contracts that are well-typed will terminate. formal verification will assure end-to-end correctness via model checking (such slmc) and theorem proving (such pro verif). additionally, these same checks can applied during runtime newly proposed assemblies contracts are evaluated. discovery service advanced discovery feature that will ultimately implemented enables searching for compatible contracts and assembling new composite contract from other contracts. with the formal verification techniques, the author the new contract can guaranteed that when working contracts are plugged together they will also work together. validation and casper consensus protocol nodes that take the validation role have the function achieve consensus the blockchain state. validators also assure blockchain self-consistent and hasn't been tampered with and protect against sybil attack. the casper consensus protocol includes stake-based bonding, unbonding, and betting cycles that result consensus. the purpose decentralized consensus protocol assure consistency blockchains partial blockchains (based shards), across multiple nodes. achieve this any consensus protocol should produce outcome that proof the safety and termination properties class consensus protocols, under wide class fault and network conditions. rchain's consensus protocol uses stake-based betting, similar ethereum's casper design. this called "proof-ofstake" protocol the broader blockchain community, but that label leads some misperceptions including overstated centralization risks. validators are bonded with stake, which security deposit placed escrow-like contract. unlike ethereum's betting whole blocks, rchain's betting logical propositions. proposition set statements about the blockchain, for example: which transactions (i.e. proposed state transitions) must included, which order, which transactions should not included, other properties. concrete example proposition is: "transaction should occur before transaction and "transaction should not included". for more information, see the draft specification logic for betting propositions (v.). certain rendezvous points validators compute maximally consistent subset propositions. some cases, this can computationally hard and take long time. because this time-out will exist, which, reached forces validators contracts rchain architecture documentation, release submit smaller propositions. once there consensus among the validators the maximally consistent subset propositions, the next block can easily materialized finding minimal model under which the propositions are valid. because this design and because the concurrency enabled sharding the address space, consensus can reached for huge number transactions time. let's walk through the typical sequence: validator node role. validators each put stake, which akin bond, order assure the other validators that they will good actors. the stake risk they aren't good actor. clients send transaction requests validators. receiving validators then create proposition including recent transaction. there are sets betting cycles among nodes: the originating validator prepares bet, which includes the following: source the origin the bet target the destination target for the bet claim the claim the bet. this block, proposition, maximally consistent subset propositions belief the player's confidence the claim given the evidence the justification. this denotation the betting strategy used the validator. justification. this evidence for why reasonable bet. the validator places the bet. the receiving validator evaluates the bet. note, these justification structures can used determine various properties the network. for example, algorithm can detect equivocation, create justification graph, detect when too much information the bet. note how attack vectors are considered, and how game theory discipline has been applied the protocol design. the betting cycles continue working toward proof. note: the goal the betting cycle for the validator nodes reach consensus maximally consistent set propositions. prerequisite condition for the proof that the validators are behaving reasonable fashion. eventually the betting cycle will and must converge. the processing partially synchronous during convergence. with by-proposition betting, the design will able synthesize much bigger chunks the blockchain all once. cycles can converge quickly when there are conflicts. the point the by-proposition approach that several blocks can materialized all once. this proposal gets around block size limits. there's argument about because the maximal consistent set propositions might allow for hundreds even thousands blocks agreed all once. this will create huge speed advantage over existing blockchains. for each betting cycle given validator node may win lose their bet amount. scalability achieved via fine-grained sharding proposals and via nesting (recursion) the consensus protocol. chapter abstract rchain architecture documentation, release blocks are synthesized the protocol when there agreement the set maximally-consistent propositions, and this occurs when there proof convergence among the bets. the current betting cycle then collapses. for additional information, see: consensus games axiomatic framework for analyzing and comparing wide range consensus protocols. for more detail rchain's consensus protocol, see logic for betting betting propositions find out more about ethereum's casper and discussions the ethereum research gitter and reddit/ethereum. the math underlying the betting cycle iterated function system. convergence corresponds having attractors (fix-points) ifs. with this, can prove things about convergence with awards and punishments. can give validator-node-betters maximum freedom. the only ones that are left standing are validators that are engaged convergent betting behavior. node communications similar other decentralized implementations, this component handles node discovery, inter-node trust, and communication. number other platform-level protocols will developed, such those related security, node trust, and communications. specialk: data continuation access, cache the current "rchain technology stack delivers decentralized cdn. its primary component specialk, which sits top mongodb and rabbitmq create the decentralized logic for storing and retrieving content, both locally and remotely. specialk implements distributed data-access patterns consistent way, shown below. read write pub/sub messaging pub/sub with history data continuation producer verb (k) item-level read write (distributed locking) ephemeral ephemeral put persistent ephemeral store ephemeral persistent publish consumer verb get read subscribe persistent persistent publish with history subscribe view how two nodes collaborate respond get request shown below: convention continuation function represented parameter named only subset the verbs possible under this decomposition the functionality. the verb fetch, for example, gets the data without leaving continuation around, there data available. this node communications rchain architecture documentation, release the first node checks its in-memory cache, then not found checks its local store, then not found stores delimited continuation that location, and checks the network. when the network returns data, the delimited continuation brought back scope with the retrieved data its parameter. with the rchain platform, the implementation the cdn will also evolve, although not its fundamental design. content delivery network this layer will track access and storage content. software clients will required pay for creation, storage, and retrieval all content delivered to/from the cdn, via microtransactions. since storing and retrieving content not free, why should technical solution make free users like centralized solutions that subsidize the cost indirect ways? with the promise micropayments, the rchain platform can more directly charge for the storage and retrieval content. attention reputation economy from user-centric perspective, this economy aims directly but unobstructedly allow value placed the content's creation, consumption, and promotion. this applies many types content. for example, short textual post created, sent initial distribution list, read, promoted (liked), and made available even more readers. or, short movie can through the same workflow. along these paths, attention given, and rewards can flow back the content originator and promoters. based one's own engagement with the content exchanged to/from chapter abstract rchain architecture documentation, release one's connections, each connection's reputation computed. the reputation rank can used subsequently present content manner consistent with how the user has demonstrated attention the recent past. for more information, see the original whitepaper, rchain the decentralized and distributed social network. the latest thinking about attention reputation economy will described slack discussions and blog posts. fig. economiesvenn.png applications any number and variety applications can built top the rchain platform that provide decentralized public compute utility. these include, for example: wallets exchanges oracles external adapters custom protocols smart contracts smart properties daos social networks marketplaces croll, alistair http://human.com/free-reputation-for-everyone-the-three-non-traditional-economies/ applications rchain architecture documentation, release several application providers are already committed this platform, including rchain for its social product, livelygig for its marketplaces, wewowwe for its sports-based social network, and nobex radio for to-be-announced product. contract development deployment the purpose this next discussion illustrate how namespaces allow for heterogeneous deployment contracts and contract state. namespaces one the crucial features for sharding, and with that get the benefits analogous sidechains, private chains, consortium chains, well the distinction between test and production, all under one rubric. for example, the following diagram depicts some the possible development, test, and deployment configurations and considerations, and how release management enabled using namespaces and sharding. we'll collaborate with ide tool vendors integrate rholang and validation tools. governance like other open source and decentralized projects, and especially those involving money and blockchains, the rchain platform components will require they created, tested, released, and evolved with great care. rchain's leadership fully intends help define these governance processes and empower public community enforce them. implementation roadmap the rchain roadmap currently being developed. major milestones may include the following: chapter abstract rchain architecture documentation, release programming model and execution rholang rhovm blockchain bet-by-proposition casper-style proof stake blockchain storage blockchain metering token content delivery basic query update model attention economy post contract model amp and reo stochasticity call for participation invite you participate rchain's slack channels, joining via http://slack.rchain.coop. need variety talent, but most urgently programmers with solid computer science, formal methods, and ideally experience with mobile process calculi and functional programming. or, individuals who can demonstrate their ability quickly learn these disciplines. need investors help fund the building out this architecture. note that there are many forward-looking statements this document, and are subject many risks. contact lucius gregory meredith and eykholt for more information. call for participation