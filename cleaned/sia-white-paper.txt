sia: simple decentralized storage david vorick nebulous inc. david@nebulouslabs.com luke champine nebulous inc. luke@nebulouslabs.com november abstract network consensus can used automatically enforce storage contracts. importantly, this means that clients not need personally verify storage proofs; they can simply upload their file and let the network the rest. acknowledge that storing data single untrusted host guarantees little the way availability, bandwidth, general quality service. instead, recommend storing data redundantly across multiple hosts. particular, the use erasure codes can enable high availability without excessive redundancy. sia will initially implemented blockchainbased altcoin. future support for two-way peg with bitcoin planned, discussed "enabling blockchain innovations with pegged sidechains" []. the sia protocol largely resembles bitcoin except for the changes noted below. the authors introduce sia, platform for decentralized storage. sia enables the formation storage contracts between peers. contracts are agreements between storage provider and their client, defining what data will stored and what price. they require the storage provider prove, regular intervals, that they are still storing their client's data. contracts are stored blockchain, making them publicly auditable. this respect, sia can viewed bitcoin derivative that includes support for such contracts. sia will initially implemented altcoin, and later financially connected bitcoin via two-way peg. introduction sia decentralized cloud storage platform that intends compete with existing storage solutions, both the and enterprise level. instead renting storage from centralized provider, peers sia rent storage from each other. sia itself stores only the storage contracts formed between parties, defining the terms their arrangement. blockchain, similar bitcoin used for this purpose. forming contract, storage provider (also known host) agrees store client's data, and periodically submit proof their continued storage until the contract expires. the host compensated for every proof they submit, and penalized for missing proof. since these proofs are publicly verifiable (and are publicly available the blockchain), general structure sia's primary departure from bitcoin lies its transactions. bitcoin uses scripting system enable range transaction types, such pay-to-public-keyhash and pay-to-script-hash. sia opts instead use -of-n multi-signature scheme for all transactions, eschewing the scripting system entirely. this reduces complexity and attack surface. sia also extends transactions enable the creation and enforcement storage contracts. three extensions are used accomplish this: contracts, proofs, and contract updates. contracts declare the intention host store file with certain size and hash. they define the regularity with which host must submit storage proofs. once established, contracts can modified later via contract updates. the specifics these transaction types are defined sections and spend conditions include time lock and set public keys, and the number signatures required. output cannot spent until the time lock has expired and enough the specified keys have added their signature. the spend conditions are hashed into merkle tree, using the time lock, the number signatures required, and the public keys leaves. the root hash this tree used the address which the coins are sent. order spend the coins, the spend conditions corresponding the address hash must provided. the use merkle tree allows parties selectively reveal information the spend conditions. for example, the time lock can revealed without revealing the number public keys the number signatures required. should noted that the time lock and number signatures have low entropy, making their hashes vulnerable brute-forcing. this could resolved adding random nonce these fields, increasing their entropy the cost space efficiency. transactions transaction contains the following fields: field version arbitrary data miner fee inputs outputs file contract storage proof signatures description protocol version number used for metadata otherwise reward given miner incoming funds outgoing funds (optional) see: file contracts (optional) see: proof storage (optional) signatures from each input inputs and outputs output comprises volume coins. each output signatures has associated identifier, which derived from the transaction that the output appeared in. the each input transaction must signed. the cryptographic signature itself paired with input id, output transaction defined as: time lock, and set flags indicating which parts the transaction have been signed. the input inh(t||"output"||i) dicates which input the signature being applied to. where cryptographic hashing function, and the time lock specifies when the signature becomes "output" string literal. the block reward and valid. any subset fields the transaction can signed, with the exception the signature itself (as miner fees have special output ids, given by: this would impossible). there also flag inh(h(block header)||"blockreward") dicate that the whole transaction should signed, except for the signatures. this allows for more nuevery input must come from prior output, anced transaction schemes. input simply output id. the actual data being signed, then, concateinputs and outputs are also paired with set nation the time lock, input id, flags, and every spend conditions. inputs contain the spend conditions flagged field. every such signature the transaction themselves, while outputs contain their merkle root must valid for the transaction accepted. hash []. spend conditions file contracts spend conditions are properties that must met file contract agreement between storage before coins are "unlocked" and can spent. the provider and their client. the core file contract the file's merkle root hash. construct this hash, the file split into segments constant size and hashed into merkle tree. the root hash, along with the total size the file, can used verify storage proofs. file contracts also specify duration, challenge frequency, and payout parameters, including the reward for valid proof, the reward for invalid missing proof, and the maximum number proofs that can missed. the challenge frequency specifies how often storage proof must submitted, and creates discrete challenge windows during which host must submit storage proofs (one proof per window). submitting valid proof during the challenge window triggers automatic payment the "valid proof" address (presumably the host). if, the end the challenge window, valid proof has been submitted, coins are instead sent the "missed proof" address (likely unspendable address order disincentivize dos attacks; see section .). contracts define maximum number proofs that can missed; this number exceeded, the contract becomes invalid. the contract still valid the end the contract duration, successfully terminates and any remaining coins are sent the valid proof address. conversely, the contract funds are exhausted before the duration elapses, the maximum number missed proofs exceeded, the contract unsuccessfully terminates and any remaining coins are sent the missed proof address. completing missing proof results new transaction output belonging the recipient specified the contract. the output proof depends the contract id, defined as: formed. the outcome string literal: either "validproof" and "missedproof", corresponding the validity the proof. the output contract termination defined as: h(contract id||outcome) h(contract id||outcome||wi h(contract id||h(bi- where outcome has the potential values "successfultermination" and "unsucessfultermination", corresponding the termination status the contract. file contracts are also created with list "edit conditions," analogous the spend conditions transaction. the edit conditions are fulfilled, the contract may modified. any the values can modified, including the contract funds, file hash, and output addresses. these modifications can affect the validity subsequent storage proofs, contract edits must specify future challenge window which they will become effective. theoretically, peers could create "micro-edit channels" facilitate frequent edits; see discussion micropayment channels, section proof storage storage proof transactions are periodically submitted order fulfill file contracts. each storage proof targets specific file contract. storage proof does not need have any inputs outputs; only contract and the proof data are required. algorithm hosts prove their storage providing segment the original file and list hashes from the file's merkle tree. this information sufficient prove h(transaction||"contract"||i) that the segment came from the original file. because proofs are submitted the blockchain, anyone can where the index the contract within the trans- verify their validity invalidity. each storage proof action. the output the proof can then de- uses randomly selected segment. the random seed termined from: for challenge window given by: where the window index, i.e. the number where bi- the block immediately prior the bewindows that have elapsed since the contract was ginning the host consistently able demonstrate possession random segment, then they are very likely storing the whole file. host storing only the file will unable complete approximately the proofs. miners will include their proofs return for transaction fee. because hosts consent all file contracts, they are free reject any contract that they feel leaves them vulnerable closed window attacks. arbitrary transaction data block withholding attacks each transaction has arbitrary data field which can used for any type information. nodes will required store the arbitrary data signed any signature the transaction. nodes will initially accept arbitrary data per block. this arbitrary data provides hosts and clients with decentralized way organize themselves. can used advertise available space files seeking host, create decentralized file tracker. arbitrary data could also used implement other types soft forks. this would done creating "anyone-can-spend" output but with restrictions specified the arbitrary data. miners that understand the restrictions can block any transaction that spends the output without satisfying the necessary stipulations. naive nodes will stay synchronized without needing able parse the arbitrary data. the random number generator subject manipulation via block withholding attacks, which the attacker withholds blocks until they find one that will produce favorable random number. however, the attacker has only one chance manipulate the random number for particular challenge. furthermore, withholding block manipulate the random number will cost the attacker the block reward. attacker able mine the blocks, then the challenges can manipulated. nevertheless, the remaining are still random, the attacker will still fail some storage proofs. specifically, they will fail half many they would without the withholding attack. protect against such attacks, clients can specify high challenge frequency and large penalties for missing proofs. these precautions should sufficient deter any financially-motivated attacker that controls less than the network's hashing power. regardless, clients are advised plan around potential byzantine attacks, which may not financially motivated. storage ecosystem sia relies ecosystem that facilitates decentralized storage. storage providers can use the arbitrary data field announce themselves the network. this can done using standardized template that closed window attacks clients will able read. clients can use these anhosts can only complete storage proof their proof nouncements create database potential hosts, transaction makes into the blockchain. miners and form contracts with only those they trust. could maliciously exclude storage proofs from blocks, depriving themselves transaction fees but forcing host protections penalty hosts. alternatively, miners could extort hosts requiring large fees include storage contract requires consent from both the storage proofs, knowing that they are more important than provider and their client, allowing the provider rethe average transaction. this termed closed win- ject unfavorable terms unwanted (e.g. illegal) files. dow attack, because the malicious miner has artifi- the provider may also refuse sign contract until cially "closed the window." the entire file has been uploaded them. the defense for this use large window size. contract terms give storage providers some flexhosts can reasonably assume that some percentage ibility. they can advertise themselves minimally reliable, offering low price and agreeing minimal penalties for losing files; they can advertise themselves highly reliable, offering higher price and agreeing harsher penalties for losing files. efficient market will optimize storage strategies. hosts are vulnerable denial service attacks, which could prevent them from submitting storage proofs transferring files. the responsibility the host protect themselves from such attacks. the host the client, and the "download fee" becomes "upload incentive." this scenario, clients offer reward for being sent file, and hosts must compete provide the best quality service. clients may request file any time, which incentivizes hosts maximize uptime order collect many rewards possible. clients can also incentivize greater throughput and lower latency via proportionally larger rewards. clients could even perform random "checkups" that reward hosts simply for being online, even they not wish download anything. however, reiterate that uptime incentives are not part the sia protocol; they are entirely dependent client behavior. payment for downloads expected offered through preexisting micropayment channels []. micropayment channels allow clients make many consecutive small payments with minimal latency and blockchain bloat. hosts could transfer small segment the file and wait receive micropayment before proceeding. the use many consecutive payments allows each party minimize the risk being cheated. micropayments are small enough and fast enough that payments could made every few seconds without having any major effect throughput. client protections clients can use erasure codes, such regenerating codes [], safeguard against hosts going offline. these codes typically operate splitting file into pieces, such that the file can recovered from any subset unique pieces. (the values and vary based the specific erasure code and redundancy factor.) each piece then encrypted and stored across many hosts. this allows client attain high file availability even the average network reliability low. extreme example, only out pieces are needed recover the file, then the client actually relying the most reliable hosts, rather than the average reliability. availability can further improved rehosting file pieces whose hosts have gone offline. other metrics benefit from this strategy well; the client can reduce latency downloading from the closest hosts, increase download speed downloading from the fastest hosts. these downloads can run parallel maximize available bandwidth. basic reputation system clients need reliable method for picking quality hosts. analyzing their history insufficient, because the history could spoofed. host could repeatedly form contracts with itself, agreeing store large "fake" files, such file containing only zeros. would trivial perform storage proofs such data without actually storing anything. mitigate this sybil attack, clients can require that hosts that announce themselves the arbitrary data section also include large volume time locked coins. coins are time locked days into the future, then the host can said have created lock valued coin-days. favoring hosts that have created high-value locks, clients can mitigate the risk sybil attacks, valuable locks are not trivial create. each client can choose their own equation for picking hosts, and can use large number factors, in- uptime incentives the storage proofs contain mechanism enforce constant uptime. there are also provisions that require hosts transfer files clients upon request. one might expect, then, see hosts holding their clients' files hostage and demanding exorbitant fees download them. however, this attack mitigated through the use erasure codes, described section the strategy gives clients the freedom ignore uncooperative hosts and work only with those that are cooperative. result, power shifts from cluding price, lock value, volume storage being offered, and the penalties hosts are willing pay for losing files. more complex systems, such those that use human review other metrics, could implemented out-of-band more centralized setting. minted. this number will decrease coin per block, until minimum coins per block reached. following target minutes between blocks, the annual growth supply is: year growth siafunds there are inefficiencies within the sia incentive scheme. the primary goal sia provide blockchain that enforces storage contracts. the mining reward, however, only indirectly linked the total value contracts being created. the siacoin, especially initially, likely have high volatility. hosts can adversely affected the value the currency shifts mid-contract. result, expect see hosts increasing the price long-term contracts hedge against volatility. additionally, hosts can advertise their prices more stable currency (like usd) and convert siacoin immediately before finalizing contract. eventually, the use two-way pegs with other crypto-assets will give hosts additional means insulate themselves from volatility. sia product nebulous incorporated. nebulous for-profit company, and sia intended become primary source income for the company. currency premining not stable source income, requires creating new currency and tethering the company's revenue the currency's increasing value. when the company needs spend money, must trade away portions its source income. additionally, premining means that one entity has control over large volume the currency, and therefore potentially large and disruptive control over the market. instead, nebulous intends generate revenue from sia manner proportional the value added sia, determined the value the contracts set between clients and hosts. this accomplished imposing fee all contracts. when contract created, the contract fund removed and distributed the holders siafunds. nebulous inc. will initially hold approx. the siafunds, and the early crowd-fund backers sia will hold the rest. siafunds can sent other addresses, the same way that siacoins can sent other addresses. they cannot, however, used fund contracts miner fees. when siafunds are transferred new address, additional unspent output created, containing all the siacoins that have been earned the siafunds since their previous transfer. these siacoins are sent the same address the siafunds. conclusion sia variant the bitcoin protocol that enables decentralized file storage via cryptographic contracts. these contracts can used enforce storage agreements between clients and hosts. after agreeing store file, host must regularly submit storage proofs the network. the host will automatically compensated for storing the file regardless the behavior the client. importantly, contracts not require hosts transfer files back their client when requested. instead, out-of-band ecosystem must created reward hosts for uploading. clients and hosts must also find way coordinate; one mechanism would the arbitrary data field the blockchain. vari economics sia ous precautions have been enumerated which mitithe primary currency sia the siacoin. the gate sybil attacks and the unreliability hosts. supply siacoins will increase permanently, and siafunds are used mechanism generating all fresh supply will given miners block revenue for nebulous inc., the company responsible subisdy. the first block will have coins for the release and maintenance sia. using sia funds instead premining, nebulous more directly correlates revenue actual use the network, and largely unaffected market games that malicious entities may play with the network currency. miners may also derive part their block subsidy from siafunds, with similar benefits. long term, hope add support for two-way-pegs with various currencies, which would enable consumers insulate themselves from the instability single currency. believe sia will provide fertile platform for decentralized cloud storage trustless environments. references satoshi nakamoto, bitcoin: peer-to-peer electronic cash system. r.c. merkle, protocols for public key cryptosystems, proc. symposium security and privacy, ieee computer society, pages april hovav shacham, brent waters, compact proofs retrievability, proc. asiacrypt vol. dec pp. rashmi, nihar shah, and vijay kumar, optimal exact-regenerating codes for distributed storage the msr and mbr points via product-matrix construction. adam back, matt corallo, luke dashjr, mark friedenbach, gregory maxwell, andrew miller, andrew peolstra, jorge timon, pieter wuille, enabling blockchain innovations with pegged sidechains. andrew poelstra, treatise altcoins. gavin andresen, o() block propagation, https://gist.github.com/gavinandresen/ecbadbfac gregory maxwell, deterministic wallets, https://bitcointalk.org/index.php?topic=. etotheipi, ultimate blockchain compression trust-free lite nodes, https://bitcointalk.org/index.php?topic=. gregory maxwell, proof storage make distributed resource consumption costly. https://bitcointalk.org/index.php?topic=. mike hearn, rapidly-adjusted (micro)payments pre-determined party, https://en.bitcoin.it/wiki/contracts#example rapidly-adjusted .micro.payments predetermined party bitcoin developer guide, https://bitcoin.org/en/developer-guide