spacecoin: cryptocurrency based proofs space sunoo park* krzysztof pietrzak+ joel alwen+ georg fuchsbauer+ and peter gazi+ mit ist austria june abstract propose decentralized cryptocurrency based block-chain ledger similar that bitcoin, but where the extremely wasteful proofs work are replaced proofs space, recently introduced dziembowski al. (crypto instead requiring that majority the computing power controlled honest miners (as bitcoin), our currency requires that honest miners dedicate more disk space than potential adversary. once miner has dedicated and initialized some space, participating the mining process very cheap. new block added the chain every fixed period time (say, every minute), and every period miner just has make small number lookups the stored space check she "wins", and thus can add the next block the chain and get the mining reward. because this check cheap, proof-of-space-based currencies share some (but not all) issues with currencies based "proofs stake", like peercoin. concretely, naive solution that simply replaces proofs work with proofs space raises two main issues which address: grinding: miner who can add the next block has some degree freedom shaping how the chain looks, e.g. trying out different sets transactions include her block. the miner can try many possible choices until she finds one which results chain that allows her also mine the next block, thus hijacking the chain forever while dedicating only small amount the space. solve this problem fully "decoupling" the hash chain from the transactions, that there nothing grind. bind the transactions back the hash chain, add extra signature chain, which guarantees that past transactions cannot altered once honest miner adds block. our solution also gives simple and novel way solve the grinding problem currencies based proofs stake. mining multiple chains: since checking whether one can add block cheap, rational miners will not only try extend the so-far-best chain, but also try other chains, the hope that they can extend one them which will ultimately catch and overtake the currently-best chain. (in the context proof-of-stake-based currencies this known the "nothing-at-stake" problem.) this not only gives rational miners larger-thanexpected reward (compared what honest miners get), but also makes consensus very slow, not impossible. our solution this problem based penalizing miners who try work more than one branch the chain. research supported nsf eager cns, nsf frontier cns, the simons foundation (agreement dated june air force laboratory fa-, and lincoln lab po. sunoo@csail.mit.edu research supported erc starting grant (-pspc). pietrzak@ist.ac.at finally, show formally that the proposed cryptocurrency has desirable game-theoretic properties least strong those shown bitcoin (namely, honest mining behavior equilibrium single party holds more than half all space invested the currency). introduction bitcoin decentralized digital currency which was introduced [nak] and now far the most successful digital currency ever deployed. informally, the bitcoin scheme digital coin attached public key digital signature scheme, and belongs the person holding the corresponding secret key sk. order transfer coin from transaction (encoding the statement that the coin belonging transferred signed using sk. the complete record transactions kept public ledger that has the form block chain, which sequence blocks. each block (txi contains, among other information discussed below, set txi new transactions added. the main difficulty when designing digital currency provide security against doublespending. the scheme just outlined, dishonest party holding can sign two different transactions, the first being "real" transaction transferring the coin the public key recipient (typically exchange for some goods), the second transferring itself, i.e. some whose corresponding known the recipient will only possess the coin ultimately (and not ends the ledger. prevent double-spending, one thus must enforce that all parties the network agree the same block chain, except for the last few blocks. party should wait before accepting transaction, until has been the chain long enough that she can reasonably sure that will stay there forever. the bitcoin protocol achieves consensus making computationally hard add block the chain, detailed the following. proofs work (or, how mine bitcoins) order extend block chain with new block bi+ the block bi+ must contain so-called proof work (pow) [dn]. the case bitcoin, the pow simply nonce such that the hash ai+ hash(ui pkminer together with the hash the previous block, the set transactions added and some public key pkminer (whose function explain below) starts with some sufficiently large number 's. hash(*) modeled random oracle (in reality sha-), finding nonce that starts with zeros requires expected number evaluations hash(*). the number the bitcoin scheme set dynamically (and adapted roughly every weeks) that the total computational power the network expected find fresh block every minutes. searching for such block called mining. incentivize mining, every newly added block generates some fresh coins, which are given the public key pkminer whose corresponding secret key known the miner who found the block. there also mechanism incentivize mining via transaction fees. once miner solves the pow, she generates block and sends out the network. this block needs some time propagate through the network, can occur that two blocks extending the same chain are being sent out, and thus there inconsistent view the chain. the bitcoin protocol specifies that every miner should try extend the longest valid branch aware of; this way, even the block chain branches, ultimately one branch will become longer, and the shorter ones will eventually ignored. thus, once transaction has been added morey precisely, not necessarily the longest branch, but the one that required most computation find. the block chain, and sufficiently many blocks have been added after it, will stay the chain forever (waiting for blocks, which takes roughly one hour, considered safe). order double-spend coin, cheating party would have branch off sufficiently far the past and then make this branch "catch up" with the currently longest branch. party cannot this with reasonable probability, unless controls close the entire hash power. crucial property the bitcoin protocol the fact that miners have strong incentive follow the "work the longest chain" rule. rational miner wants the blocks finds end the block chain (and not some dead branch), and achieve this, working towards extending the longest known chain nash equilibrium. consensus bitcoin. one can think the core the bitcoin consensus protocol random selection protocol. every round miner picked random, and this miner allowed add block. the probability particular miner being chosen proportional the fraction the total hash power controls. honest miners control more than half the hash power, this will result consensus protocol for the ledger. honest miners must constantly invest more computing power than potential adversary could accumulate order prevent double spending. estimated that the mining currently uses several energy; moreover, most mining currently done dedicated hardware, which has use beyond mining bitcoins. for these reasons bitcoin considered "environmental disaster" [and] some. proofs stake order find "greener" decentralized cryptocurrency, the community has looked for alternative decentralized consensus protocols and found potentially promising candidate proofs stake (postake). whereas the pow-based bitcoin scheme the probability that party mines the next block proportional the fraction computing power contributes, postake-based scheme this probability should correspond the fraction coins (out all coins ever minted) that holds. this idea very appealing resources (like energy, hardware, etc.) are wasted, but unfortunately, making this approach actually work turns out much more delicate than for pow-based schemes. trying adapt bitcoin straightforward way replacing pow postake, one runs into least three major problems which discuss now. multiple chains: bitcoin, rational miner will always work towards extending the longest chain known him, working any other chain would only lower the probability that potentially mined block will end the block chain. use postake instead pow, then checking whether one can extend chain very cheap, and thus there reason not try extending many different chains parallel. this impedes quick consensus finding like bitcoin, where rational miners concentrate the longest chain, which will make grow faster than others. grinding: bitcoin the miner adding the ith block can influence the hash the chain block his choice transactions included. influencing this value does not result any advantage pow-based scheme like bitcoin. postake-based scheme the other hand, the miner adding block can try out many different hashes until finds "good" one which will allow him also add block (and thus the miner could hijack the chain forever). before, the reason this only problem with postake but not with pow-based schemes that checking whether one can extend after block cheap. participation: postake-based scheme the parties holding coins must also participate securing the currency providing blocks when their coins "win". typically only fraction the parties holding coins will participate, this makes designing postake-based scheme difficult (as the scheme must work matter what the fraction is, and will also constantly change over time). moreover, this security issue when participation very low (as for double-spending sufficient control fraction the coins that slightly larger than that coins participating). the most popular postake-based currency, peercoin, participation already below proofs space this paper propose digital currency schemes which are based so-called proofs space (pospace), recently introduced dziembowski al. [dfkp]. pospace protocol between prover and verifier that has two phases. after initialization phase, the prover supposed store some data size and the verifier stores short commitment this data. later execution phase sends challenge who can efficiently answer with short answer after reading small fraction [dfkp] pospace constructed where any prover that can convince the verifier with constant probability must either honest (meaning has dedicated bits space), run time th(n the execution phase. note that this the best can hope for, cheating prover can aways just store the short communication from the initialization phase and then simply re-initialize the entire storage during the execution phase, which takes time th(n the constructions from [dfkp] are based hard-to-pebble graphs. the vertices such graph are labeled, where for some unique nonce vertex gets label hash(u, where are the labels its children. the prover computes and stores those labels and sends merkle-hash all labels the verifier. the execution phase the verifier simply choses subset those labels opened. some simpler solutions construct pospace that come mind not work. storing function table. tempting "solution" let store the function table ()), (n, random-looking function (*) sorted the second values. challenge would then ask invert the function value (x) for some random which honest prover can time log(n using binary search the sorted table; unfortunately, this doesn't work due time-memory trade-offs [hel], which allow cheating prover only store roughly input/output tuples, while being able invert the function time (in the case where (.) permutation, this goes down time and space, cf. [dfkp, appendix for details). storing (pseudo)random file. another simple idea would let send (pseudo)random bits during initialization, and simply query for some these bits random positions during execution. unfortunately, this requires bits communication, whereas pospace requires that the verifier's efficiency only depends some security parameter, but must basically independent which crucial for all applications pospace discussed [dfkp] and also for this paper. formally, proof space defined four algorithms pos {init, challenge, answer, verify}, and executed between verifier and prover the protocol runs two phases. first describe the initialization phase: p(n and v(n have common input which denotes the amount space should dedicate. alternative and much simpler construction [dfkp] only implies that the cheating prover runs time (n/ log(n )), but here one provably also requires (n/ log(n space. samples some unique nonce and sends computes and stores (g, init(u, and sends the commitment this concludes the initialization phase, after which stores the data size whereas only stores the short commitment and the nonce the size the committed space part the commitment and we'll denote the execution phase, convinces that she really stored samples challenge challenge(n and sends computes the answer answer(u, and sends runs the verification procedure verify(u, and accepts proposition ([dfkp]). there exists pospace the random oracle model with the following properties: efficiency: for statistical security parameter the verifier runs time o() during initialization and o(l log(n during execution. the (honest) prover runs time o(n log log(n during initialization and o(l log log(n during execution. security: assume that (potentially cheating) prover makes accept during the execution phase with probability -th(l) then the prover either stores th(n bits (i.e., much honest prover) runs time th(n (on average). moreover, the pospace satisfies the following two properties (not explicitly mentioned [dfkp]), which will crucial for our application cryptocurrencies. public-coin verifier: the verifier public-coin the execution phase. unique accepting answer: computationally hard find two accepting transcripts (c, a), (c, for the execution phase where (concretely, finding such pair implies breaking the collision-resistance the underlying hash function). game theory spacecoin the miners cryptocurrency are strategic agents who seek maximize the reward that they get for mining blocks. such, crucial property cryptocurrency that "following the rules" equilibrium strategy: other words, important that the protocol rules are designed such way that miners never find themselves situation where "cheating" and deviating from the rules yields more expected profit than mining honestly. contrast previous work the cryptocurrency literature, this paper fully specifies extensive game that corresponds spacecoin mining, and prove that follow the protocol the nonce ensures that the same space cannot used for two different proofs (this will discussed more later). the pospace schemes from [dfkp] the initialization phase actually has two rounds. the first one the verifier sends the commitment the prover, and then, second phase, the prover asks the verifier open the commitment some random positions (concretely, the labels corresponding some random nodes the hard-to-pebble graph, together with the labels their children). this second phase used ensure that the prover committed correctly computed labels for most the vertices. for the application spacecoin, can move this check the execution phase. fact, sufficient when cheating prover gets caught only with some constant probability, which informally the reason why can set the parameter below constant. for the application spacecoin, suffices the error probability sufficiently small constant, and thus (as mentioned the previous footnote) sufficient for constant. rules sequentially rational nash equilibrium this extensive game, long single party holds more than half all space invested the currency prior work related equilibria bitcoin mining has given only informal treatment the problem: notably, [kdf] presents thorough, but still informal, analysis equilibrium strategies bitcoin, and concludes that honest mining nash equilibrium bitcoin (as long single party has more than half the network's computing power). remark that the nash equilibrium widely considered unsatisfactory solution concept for games that are played over multiple time steps, for reasons which will detailed section while previous game-theoretic discussion this literature has been restricted the nash equilibrium concept, prove section that the spacecoin protocol satisfies stronger solution concept called sequentially rational nash equilibrium, which considered the standard for extensive games over many time steps. other related work concept similar proofs space are proofs storage and proofs retrievability (cf. [gjm, bjo, abc+ jk, dpml+ and many more), these are proof systems where verifier sends file prover, and later the prover can convince the verifier that really stored received the file. proving that one stores (random) file certainly shows that one dedicates space, but these proof systems are not proofs space because the verifier has send the entire file the verifier, whereas from pospace require that the verifiers computation (and thus also communication) most polylogarithmic the size the storage dedicated. permacoin. permacoin [mjs+ cryptocurrency similar bitcoin, but where the proofs work are replaced with proofs retrievability. here the miners are actually supposed store useful data, the currency serves data archive, whereas spacecoin the dedicated storage does not store anything useful. like bitcoin, permacoin miners are constantly racing find good proof (only the type proof different), whereas the main goal spacecoin avoid such race: miners only have execute proof once every minute, but apart from that can use their resources (except the space dedicated for mining) useful way. another type proof systems which related pospace are proof secure erasure (pose). informally, pose allows space restricted prover convince verifier that has erased its memory size pose were suggested perito and tsudik [pt], who also proposed scheme where the verifier sends random file size the prover, who then answers with hash this file. using hard pebble graphs, pose with small communication complexity have been constructed [dkw, kk, abfg]. pospace (to precise, pospace where the execution phase requires large space, not just time) implies pose (by simply running the initialisation and execution phase sequentially), but pose seems not imply pospace. the only application pose we're aware the one put forward [pt] (i.e., prove that one has erased its memory), particular, pose cannot used for any the applications pospace put forward [dfkp], and also the cryptocurrency proposed this paper. refer the reader [dfkp] for more detailed discussion pospace vs. pose. burstcoin. the only decentralised cryptocurrency we're aware which uses disk space the primary mining resource burstcoin which was built using the code the proof-of-stake based argue that this unlikely scenario, and remark that the stability bitcoin also known depend single party controlling more than half the network's computing power. section analyze the potential risks for spacecoin the case that single party does indeed hold such large proportion space. http://burstcoin.info/ cryptocurrency nxt the first public mention burstcoin could find from mid-august which over one year after the first public talk proofs space and their potential use constructing "green" cryptocurrency this first proposal cryptocurrency based proofs space had several security issues, was not published. below, observe that burstcoin shares some the security issues that the early proposals had (most notably, timememory trade-offs), and also highlight some other issues with the burstcoin mining process. provide more detailed discussion the burstcoin mining process appendix one the efficiency issues burstcoin that constant fraction (.%) the entire dedicated disk space must read every time new block gets mined (in contrast, spacecoin requires reading only logarithmic fraction). another problem the fact that when miner publishes block and claims that should added the chain, necessary hash over million blocks verify that the miner's claim valid. this means that the computational requirements maintaining the block-chain are nontrivial and could potentially result significant computational footprint large fraction the miners (and other users the currency) verify the block-chain periodically. arguably more serious consequence the potential for denial-of-service attacks where adversary floods the network with false claims. perhaps the most serious security issue with burstcoin that allows for time-memory trade-offs: miner doing just small amount extra computation can mine the same rate honest miner while using just small fraction the disk-space that honest miner would. concrete example, show that there exists alternative mining strategy where order mine block, the miner evaluates the underlying hash function blocks and reads just one block from disk. dishonest miner employing the above strategy would require only the disk space that honest miner would need order mine the same rate. describe this simple attack more detail appendix overview spacecoin high-level protocol description spacecoin follows block-mining paradigm similar the bitcoin system, which miners create blocks transactions which constitute public ledger the form block chain. instead requiring miners provide proof work order create valid transaction block, spacecoin requires miners provide much more efficiently computable proof space. transactions. transactions are performed basically identically bitcoin: each coin "belongs" some public key pk. the block chain acts ledger that keeps track which coins belong which keys (but prevent grinding, suggest new design for the block chain section where the transactions are decoupled from the proofs). transfer coin from transaction specifying this must signed (the secret key for pk), and then added the block chain. also allow special transactions initialize miners, and special type transaction which penalizes miner who extended two different chains using the same proof space. incentivize mining. like bitcoin, there are two ways incentivize miners contribute resources (disk space spacecoin, computing power bitcoin): reward for adding blocks and transactions fees. http://nxt.org/ https://sites.google.com/site/warsawcryptoworkshop/abstracts the underlying hash function burstcoin shabal which was one the sha- candidate submissions http://www.shabal.com. reward: for adding block miner receives some spacecoins, which not come from benefactor, but are created out thin air when the block added the hash chain. how large the reward has specified part the protocol, and will typically depend the index the block. transaction fees: when generating transaction, one can dedicate typically very small) amount the transferred coins the miner who adds the block that includes the transaction the block chain. initialize miner. miner wants contribute bits space the mining effort, she samples public/secret key pair (pk, sk) and runs the pospace initialization procedure. (being non-interactive setting, there verifier generate the unique nonce simply use for this.) (g, init(pk, the miner stores (sg sk) and generates special transaction which just contains (pk, g). once this transaction the block chain the miner can start mining described next. mining. blocks are added the block chain every fixed time period (say, every minute), and require that all parties have clock that roughly synchronized. add block time period the miner retrieves the hash value the last block the best chain far (this chain has blocks), and also challenge how derive the challenge the main difficulty face. our simplest solution assume unpredictable beacon that generates and broadcasts freshly sampled random (or least unpredictable) value from which the challenge derived every minute (we also propose two solutions without assuming beacon). the miner then computes the pospace answer from answer(pk, for two valid proofs (pk, and (pk denote with (recall that the size the space committed (a, that the proof better than postpone the discussion what properties this ordering should satisfy and how defined section for now, only mention that the ordering should satisfy pr[(a (a, that is, the probability that wins proportional its fraction the total space. the probability taken over the choice random oracle used compute the quality proof. the answer found miner good that there realistic chance being the best answer found any miner, the miner creates the next block which contains the pospace proof and transactions and sends out the network the hope that will end the chain. for the remainder this one-minute time period the miner need not anything. mining only requires small amount work (computation, communication and random access the storage) every time period, can run any computer that has some free disk space and connected the internet without any noticeable slowdown. the introduction discussed the three major problems postake-based cryptocurrencies; below shortly sketch how these are addressed our pospace-based scheme: bitcoin, the reward was initially bitcoins, but halves roughly every years, and currently currently, bitcoin the transaction fees are tiny compared the mining reward, but the latter gets smaller, some point transaction fees must become the main incentivizing factor. participation. since scheme based pospace (or pow) stake holders are not required participate mining, the participation problem not issue this work, which makes designing pospace-based scheme significantly easier and more robust than what seems possible with pure postake-based approaches. grinding. solve the grinding problem de-coupling the chain containing the proofs from the transactions, there nothing grind the proof chain. course, must somehow tie the transactions the proofs, which adding chain containing signatures; discuss this section this solution can also used solve the grinding problem postake-based schemes. extending multiple chains. this problem addressed different ways the schemes propose. nutshell, trying extend multiple chains comes almost for free, cannot prevent miners from doing so, but can punish them afterwards. quality pospace proof consider some valid proofs (pk (pkm for space size want assign quality proof (which will only function and such that the probability (over the choice the random oracle hash) that the ith proof has the best "quality" corresponds its fraction the total space, i.e. (aj (ai hash(.) observe that order achieve this, sufficient achieve this for any pair commitments, i.e., [(aj (ai hash(.) all the were the same size could simply define (aj (ai hash(aj there point adding such transaction for another miner. prevent that miner immediately transfers his reward another key and thus avoid punishment specify that the reward for adding block cannot transferred until several (say blocks later (except via punishment transaction). this punishment strategy strongly discourages miner from trying extend more than one chain, doing will most likely lead not getting any reward all, even when having the best proof for given time slot. challenge from the past now describe our scheme without unpredictable beacon. this scheme identical the one outlined above, except that the challenge does not come from the beacon, but derived from the block chain itself. the simplest solution (which does not quite work) let the challenge for block the hash block our block chain consists proof chain, and separate signature chain that binds the transactions the proof chain. only hash the block from the proof chain, problem arises with miners trying grind through several possible challenges, but another problem remains: there are many different chains, the miner gets different challenges for different chains. rational miner would thus compute the answers for many different chains, and one them very good, try add block the corresponding chain, even this chain not the best chain seen far. all miners behave rationally, this will the very least considerably slow down consensus, bad chains get extended with blocks the same quality the currently best chain; thus expect see race between many different chains without the lower-quality chains falling behind rapidly. solution this kind problems that used slasher penalize miners that extend chains that not end the final chain, but this seems not very robust. the solution propose compute the challenge hash block dist (rather than for some appropriately chosen dist (dist seems like good value for -minute time slot). now, miner only obtains different challenges for the ith block two different chains those chains have forked least blocks ago. with dist extremely unlikely that two chains will survive parallel for dist blocks. recall that penalize miner who adds block (using the same challenge) two different chains, thus long have two more chains that all forked more than dist blocks ago, there strong incentive for miners add their blocks the best chain; which why expect the other chains fall behind very fast. the reason cannot set dist arbitrary large that miner time knows its challenges for all the blocks dist. thus, she can compute all the dist answers, and need not access her space for the next dist minutes. dist was very large, miner could use the same space for several space commitments, there would enough time re-instantiate the space several times the dist-blocks window. avoid this, dist should set that initializing the space takes roughly dist minutes. the next section will discuss another reason choose small dist order prevent usage cheap storage devices like tapes for mining. request challenge from other miners finally, inspired existing postake-based schemes, sketch scheme where miner must request the challenge from other miners. miner who tries extend two more chains must publish least two requests for challenges, and any such pair requests for challenges the same time slot (requests contain signature the requesting party) can used create punishing transaction. here must require that miners, when putting their space commitment into the chain, also put some deposit. this deposit can later withdrawn, but the space commitment can only used for mining long the deposit there. miner posts two requests, this pair requests can used get half his deposit, whereas the other half destroyed (this ensures that the miner gets punished even when posting the punishment transaction himself). note that the previous scheme punished miner who added two blocks using the same challenge, here punish the mere attempt request two different challenges for different chains. more concretely, assume miner wants extend some chain with last block phi- first computes index hash(pk, phi- which means must ask the user who mined block i-t for challenge. the miner publishes this request (on some kind bulletin https://blog.ethereum.org////slasher-a-punitive-proof-of-stake-algorithm/ board), hoping that the user who mined block still online and will provide the challenge. incentivize providing challenges, the user providing the challenge will get fraction the reward, should the requesting miner win his block added. limit the domain possible "challenge-providing miners" those that added one the last blocks, can reasonably sure significant fraction them still active, while large enough that the challenge requests for each individual miner are rather small. miner sees request addressing him, can compute the challenge using verifiable pseudorandom function (vrf) and publish it. require vrf here avoid "grinding" through many possible challenges the case the requesting and the providing miner collude, the requesting miner lucky and "asks" himself for challenge. even this happens, using vrf the only thing gained the miner that she she gets one challenge extra for free, thus doubling her chances for mining the next block. realizing such solution seems significantly more complicated and delicate than the previous one, and thus not further discuss this approach here. minor issues now discuss some minor issues that arise and how solve them. dos. party who wants mine must have its space commitment (pk, added the hash chain. malicious party could flood the network with countless requests fake commitments added the chain. one simple way counter this problem request some small transaction fee, done for normal transactions. the drawback that now miners must already possess some coins even start mining. another solution require pospace proof for the commitment (pk, added, i.e., answer(pk, c), where the challenge can for example computed via the fiat-shamir transformation hash(pk, g). this proof only provided convince miners that some work went into generating the commitment, but the proof will not added the chain. reusing space. require that public key only used once for space commitment: commitment (pk, will not added the chain some commitment (pk, already the chain. the pospace scheme from [dfkp] uses the unique nonce (here pk) prefix every random oracle query, the random oracle used the pospace scheme for given commitment (pk, independent from the random oracles used for any other commitments. this implies that space cannot re-used for different commitments. why add commitments the chain. not obvious why require miner first add space commitment (pk, the hash chain before can start mining, instead simply having miners keep this commitment locally and only send out once they found good pospace proof. the reason that the pospace proofs from [dfkp] have the property that one can take correctly constructed commitment (pk, and making minor changes turn into many other commitments (pk, (pk, that can reuse almost all space, while still possible answer almost all challenges correctly. thus, there were requirement have published commitment the block-chain with unique public key, cheating miner could re-use the same space for many different commitments. tapes. the designer(s) bitcoin probably were anticipating that most the mining will done users their personal computers. what happened instead that today almost all mining done clusters application-specific integrated circuits (asics), which can the merkle-hash all the labels hard pebble graph. can change another value simply changing single label, which will not noticed the execution phase unless this particular label with its children requested. computation for tiny fraction the hardware and energy cost general-purpose processor. anticipate that pospace-based currency would mostly use the idle disk space personal computers for mining. although hard disks are rather expensive compared other storage devices most notably, tapes devices like tapes are not really adequate for mining, also require frequent random accesses answer the pospace challenges, which more difficult tapes which are made for long term storage. this clearly true for the first (beacon) and third (challenge from other miners) scheme outlined the previous section, there the proof must computed within single one-minute time slot. things are less clear for our second (challenge from the past) scheme, here the miner only needs compute the proof dist minutes, recall that dist the parameter that specifies that the challenge for block computed hash block dist. has further investigated what extent this actually issue. but given that the cost advantages tapes being debated even for long term storage, seems unlikely that our context, where frequent random access necessary, tapes will bring any advantage. the block-chain format block chain sequence blocks each block (phi created miner and consists three main parts, which call "sub-blocks". each sub-block starts with the index that specifies its position the block chain. below, outline the remaining components the three sub-blocks block the genesis block necessarily has somewhat different format cannot depend previous blocks: the hash sub-block phi contains: -bit hash hash(phi- the hash sub-block from the previous block the chain. "space proof" containing the miners identity (more details this are given below). the transaction sub-block contains: list transactions (defined more detail below). the signature sub-block contains: the miner's signature sign(sk, the transaction sub-block associated with this block. the miner's signature sign(sk, si- the signature sub-block si- associated with the previous block the chain. the links between consecutive blocks the block chain are illustrated figure will also refer the hash sub-blocks the proof chain, and the signature sub-blocks with the transactions the signature chain. solid arrows represent hashes, and dotted arrows represent signatures. notice that while the signature and transaction sub-blocks are all linked together, the hash sub-blocks are only linked each other and not any signature transaction sub-blocks. decoupling proofs from transactions achieve security against grinding: for any space commitment (pk, g), the miner cannot generate two (or more) correctly formatted hashblocks added the proof chain. for this also crucial that the underlying pospace has the "unique accepting answer" property discussed the introduction. http://www.computerworld.com/article//data-center/tape-versus-disk--the-backup-war-exposed. html block block block ... hash hash hash ... the proof chain ... signature signature signature ... the signature chain transaction transaction transaction figure our block chain consists proof chain that does not allow for grinding, and signature chain that binds the transactions the proof chain. the signature chain binds the transactions the proof chain. honest miner (honest defined below) adds the ith block, the transactions corresponding this proof chain block cannot changed any more, even adversary controls all secret keys from miners that added the first blocks. here the miner being honest means that she only signs single block transactions using the secret-key corresponding her identity pk, and moreover keeps secret. see this, note that want change the transactions block the space required get better proof than random challenge with probability note that (vj will usually around the total storage all miners that were active when the jth block was mined. with this definition, natural measure for the quality the chain would simply the sum ij= (vj the problem with this measure that some miner finds extremely good proof, say (v) times larger than the total storage (this will happen roughly every blocks), then the miner could withhold his proof, and blocks later generate fork using this proof followed arbitrarily bad proofs for the remaining blocks. avoid such deep forks, cap proofs that are too good saying that cannot contribute more the sum than, say times the median the last blocks (the median gives good approximation the total space that dedicated towards mining). formally, let (vj recursively defined (vj max{n (vj median(n (vj- (vj- another reason why defining the quality simply ij= (vj problematic, that the total contributed space can increase drastically over time. this case, order come with chain whose quality better than the quality the real chain sufficient dedicate much less than the total space that currently devoted towards mining. for this reason, only take the last blocks into account when computing the quality: qualitypc(ph phi (vj j=max{,i-} start summing with not the genesis block (still defined) will not contain proof. finally, genesis block (ph generated and published; has format different from other blocks. the transactions block contains only one space commitment (commit, txid, (pk )), the hash block contains only some random string, and the signature block contains the signature sign(sk the transactions block (but not the previous signature block, there none). initialize mining. party that wants dedicate bits storage for mining first generates identity and space commitment (pk, sk) sigkeygen (g, init(pk, stores (of size and locally. the miner then generates and publishes transaction ctx (commit, txid, (pk, g)). once ctx has been added transaction the hash chain, the miner can start mining described next. mining. enter time slot the miner retrieves the so-far-best block chain bi- (that is, the chain maximizing qualitypc(ph phi- assume that the miner "honestly" stores space and the corresponding commitment (pk, has been added some transcription block (ai the nash equilibrium concept was originally formulated for one-shot games, and known have some shortcomings the setting extensive games. informally, the nash equilibrium does not account for the possibility players changing their strategy partway through the game: particular, there exist nash equilibria that are not "stable" the sense that given the ability change strategies during the game, rational player would stick with his equilibrium strategy all the way the end the game. example ["unstable" game]consider simple two-player game two rounds: the first round, player chooses either strategy the second round, player chooses either strategy the game tree given below, where the notation (x, the leaves denotes that player gets payoff and player gets payoff that leaf reached. player turn player turn player turn figure game tree for the "unstable" game. nash equilibrium this game for player choose and player always choose however, the strategy profile (b, seems "unstable" the following sense: player does not want switch from strategy because the "threat" that player will then straightforward verify that this equilibrium, considering the payoff matrix the game. this example, assume that the game with perfect information. choose however, the situation where player has actually chosen strategy clearly better for player play rather than follow through with the threatened strategy that is, the threat does not seem credible. address these shortcomings the nash equilibrium concept for extensive games, alternative (stronger) notion has been proposed: the sequentially rational nash equilibrium. this stronger concept ensures that players are making the best decision possible any point during game-play. game with imperfect information, necessary consider not only the strategy profile, but the players' beliefs any point time about how game-play arrived the current information set. strategy profile which takes into account players' beliefs called assessment. definition [assessment] assessment extensive game pair where strategy profile and belief system, which each function that assigns every information set probability measure the histories the information set. definition (i)(h) represents the probability that player assigns the history having occurred, conditioned the information set having been reached. for each now define ((~ )|i) the expected utility player the information set given the strategy profile and belief system that is, ((~ )|i) a|h) u(i)(h). write ((~ denote ((~ )|{()}), that is, the expected utility for player the beginning the game. assessment (a, said sequentially rational for every and every information set the strategy player best response the other players' strategies, given i's beliefs formal definition follows. ~ui extensive game. definition (sequentially rational assessment). let hn, assessment sequentially rational for every and every strategy player for every information set holds that ((~ )|i) (((ai )|i). definition almost fully captures the idea players should making the best decision possible given their beliefs any point during game-play. fully characterize sequentially rational nash equilibrium, require additionally that the beliefs the players consistent with for example, event occurs with zero probability then require that the players also believe that will occur with zero probability. ~ui extensive game. definition [consistent assessment] let hn, strategy profile said completely mixed assigns positive probability every action every information set. assessment consistent there sequence ((~ ))nn assignments that converges euclidean space, where each completely mixed and each belief system derived from using bayes' rule. finally, arrive the definition sequentially rational nash equilibrium. definition [sequentially rational nash equilibrium]an assessment sequentially rational nash equilibrium sequentially rational and consistent. game-theoretic analysis spacecoin order analyze the game-theoretic properties spacecoin mining, define extensive game, spacecoingame, which models the actions that miners can take, and the associated payoffs. facilitate analysis, simplify the action space the game much possible while still accurately modeling the incentives spacecoin miners. concretely: not include the action creating space commitment because (as discussed section under "mining") can assume that rational miners will commit all the space they have, and nothing else. not include the action creating transactions because such actions not affect the rewards that players receive from mining blocks, except the case punishment transactions. deal with the case punishment transactions, define the payoff player who mines multiple blocks the same time step zero. this payoff function exactly captures that miner the actual spacecoin protocol, because dominant strategy for each other miner create punishment transaction (including positive transaction fee) she sees that cheating player has mined multiple blocks time step, and hence can assume that the cheating player will surely punished later point the protocol. since the punishment penalizes the cheating player the amount the mining reward, follows that the cheater's overall utility for the time step which cheated zero. not explicitly model the amount space that each player has instead, study the two critical cases: our initial analysis, assume that miner controls more than the space committed active miners. then, discuss potential issues that arise miner does control majority the space. definition [the spacecoin game] let denote set all blocks defined section for any number players any number time steps and any reward function follows: define the extensive game spacecoingamep,k,r hn, the set histories defined inductively follows. the action set the chance player (h) the same for every history the empty sequence and (()) {(, for each let any non-terminal history where the latest action profile consists the actions each player {c} history and for each player the action (si pair sets. then for any the action set (h) player (h) p(t where i[n action (si can interpreted follows: the set blocks from the previous time step which player attempts extend this time step, and the set extended blocks which player announces this time step. later this section, address what happens miner gains additional space (or loses some space) during the game. remark that the standard way model this would assign type each player, representing how much space has. the probability measure (*, uniform over for each define the partition equivalence relation the equivalence relation defined inductively follows (we write [h]i denote the equivalence class under [()]i {()}, that is, the empty sequence equivalent only itself. [(h, ((s (sn ))]i ((s (sn where and are histories and the pairs (sj and (sj are actions player that is, two histories are equivalent under they are identical except the "first components" the actions (sj taken the players other than where each defined described below. for history let beac(h) denote the sequence actions taken the chance player and let beacj (h) denote the jth action taken the chance player for block let b.c denote the challenge within the proof space recall that quality(b) was defined section define quality(b) b.c quality(b, otherwise. similarly, let qualitypc((b qualitypc((b [l], otherwise. let blocks(h) denote the sequence "winning blocks" each time step the game, defined inductively: blocks(()) blocks((h ((s (sn ))) arg maxbt (quality(b, beac|h| (h))), where i[n let blocksj (h) denote the jth block the blockchain. assume that the winning block unique each time step let winners(h) denote the sequence players who announce the winning block each time step the game, defined inductively follows: winners(()) winners(h ((s (sn ))) arg maxi[n maxbti (quality(b, beac|h| (h))). let winnersj (h) denote the jth winner the sequence winners(h). let onlyonej (i, indicator variable for the event that player i's jth action (si the history does not mine multiple blocks, i.e. |ti the length the histories information set that is, player i's next action information set ({blocksj (i)} {extendi (blocksj (i), beacj (i))}) then nash equilibrium spacecoingamep,k,r proof. take any player the definition extend, for any information set with {()}, the quality the extended blockchain qualitypc((blocks(i), extendi (b, beacj (i))), beac(i)) the same for any block which was announced time step therefore, utility can gained choosing any block over any other block extend: that is, (ai for any strategy which distributes probability over actions the form (s, where |s| moreover, not extending any block extending multiple blocks precludes player from being the "winner" and receiving the reward this time step, extending block preferable not extending any block. that is, (ai for any strategy which assigns nonzero probability any action the form (s, where |s| have shown that (ai for all strategies player the theorem follows. theorem let {init, challenge, answer, verify} proof space. for any number players any number time steps and any reward function let assessment spacecoingamep,k,r where: and are defined theorem and for each define the completely mixed strategy profile which (at history assigns probability /|ai (h)|n every action except and assigns all remaining probability derived from using bayes' rule the following way: limn- where for each derived from using bayes' rule. then sequentially rational nash equilibrium spacecoingamep,k,r all histories information set must the same length. proof. let any information set player spacecoingamep,k,r and let the length histories follows from definition that the expected utility player ((~ )|i) di,winnersj (h) onlyonej (i, r(blocksj (h)) ((~ )), j[l] where the utility function player the game spacecoingamep,k-l,r since winners, onlyone, and blocks are invariant over histories within any given information set, the summation term can computed explicitly player hence, order maximize his expected utility the player needs simply maximize ((~ )). let a|k-l |k-l denote the assessment for the first time steps the game. theorem |k-l nash equilibrium spacecoingamep,k-l,r since derived from bayes' rule, follows that ((~ )|i) (((ai )|i) for any strategy player applying this argument for every conclude that sequentially rational spacecoingamep,k,r construction, limn- and limn- consistent. the theorem follows. parameters. the spacecoin game parametrized and natural ask: require that the number miners fixed advance, that the block-chain will end after certain number time-steps? the answer no. theorem gives sequentially rational nash equilibrium which each player's strategy independent and makes sense for each miner play this strategy even unknown changes over time. light this, from each rational player's point view, can considered the number time-steps that intends participate the game: perhaps his goal use his earnings buy house after time-steps, perhaps does not expect live for more than time-steps the crucial observation that even different players have different values "in their heads", their equilibrium strategies are still the same. buying space. players' strategies equilibrium not depend the amount space that (they believe) other players possess. also, showed above that the equilibrium strategies are robust changes hence, player's amount space changes (e.g. buys/sells hard disk), then can simply create new space commitment, and then behave "new player" with the new amount space. the attack". player controls more than half the total space that belongs active miners, then following the protocol rules longer nash equilibrium, because whichever branch the block-chain chooses mine will eventually become the highestquality chain. thus, can decide arbitrary rules about which blocks extend, and the other players will incentivized adapt their strategies accordingly. moreover, can prevent certain transactions from ever getting into the block-chain, refusing extend blocks which contain these transactions consequence, can mine multiple blocks per time-step without ever being punished. this attack was first analyzed [kdf] the context bitcoin, which suffers from the same problem (with respect computing power rather than space). may seem unrealistic that single party would control more than half the total space that belongs active miners widely adopted currency. more realistic concern could that large group miners (in mining pool may acquire more half the total space. however, under the assumption that each miner individual strategic agent, consider the latter case, upper bound the number time-steps that the player intends stay the game. reasonable treat upper bound because maximizing expected utility after time-steps also maximizes expected utility after any time-steps, shown the proof theorem unlikely that such mining pool could much damage: for this, large group self-interested and relatively anonymous agents would have coordinate and trust each other throughout the duration attack. particular, each rational miner the pool must convinced that will get his share the attack profits, and seems highly unlikely that large group anonymous people would all trust each other so. the improbableness attack mining pool supported recent events: when large mining pool (ghash.io) was nearing bitcoin computing power self-interested miners started leaving the mining pool order avoid destabilizing the currency. references [abc+ giuseppe ateniese, randal burns, reza curtmola, joseph herring, lea kissner, zachary peterson, and dawn song. provable data possession untrusted stores. peng ning, sabrina capitani vimercati, and paul syverson, editors, acm ccs pages acm press, october [abfg] giuseppe ateniese, ilario bonacina, antonio faonio, and nicola galesi. proofs space: when space the essence. michel abdalla and roberto prisco, editors, scn volume lncs, pages springer, september [and] nate anderson. mining bitcoins takes power, but "environmental disaster"?, april http://tinyurl.com/cdhat. [bjo] kevin bowers, ari juels, and alina oprea. proofs retrievability: theory and implementation. ccsw, pages [dfkp] stefan dziembowski, sebastian faust, vladimir kolmogorov, and krzysztof pietrzak. proofs space. crypto [dkw] stefan dziembowski, tomasz kazana, and daniel wichs. one-time computable self-erasing functions. yuval ishai, editor, tcc volume lncs, pages springer, march [dn] cynthia dwork and moni naor. pricing via processing combatting junk mail. ernest brickell, editor, crypto', volume lncs, pages springer, august [dpml+ pietro, l.v. mancini, yee wei law, etalle, and havinga. lkhw: directed diffusion-based secure multicast scheme for wireless sensor networks. parallel processing workshops, proceedings. international conference on, pages [gjm] philippe golle, stanislaw jarecki, and ilya mironov. cryptographic primitives enforcing communication and storage complexity. matt blaze, editor, volume lncs, pages springer, march [hel] martin hellman. cryptanalytic time-memory trade-off. ieee transactions information theory, ():-, [jk] ari juels and burton kaliski jr. pors: proofs retrievability for large files. peng ning, sabrina capitani vimercati, and paul syverson, editors, acm ccs pages acm press, october [kdf] joshua kroll, ian davey, and edward felten. the economics bitcoin mining, bitcoin the presence adversaries. workshop the economics information security, june [kk] nikolaos karvelas and aggelos kiayias. efficient proofs secure erasure. security and cryptography for networks international conference, scn amalfi, italy, september proceedings, pages [mjs+ andrew miller, ari juels, elaine shi, bryan parno, and jonathan katz. permacoin: repurposing bitcoin work for data preservation. ieee symposium security and privacy, pages ieee computer society press, may [nak] satoshi nakamoto. bitcoin: peer-to-peer electronic cash system, http: //bitcoin.org/bitcoin.pdf. [nas] john nash. equilibrium points n-person games. proceedings the national academy sciences, ():-, [pt] daniele perito and gene tsudik. secure code update for embedded devices via proofs secure erasure. dimitris gritzalis, bart preneel, and marianthi theoharidou, editors, esorics volume lncs, pages springer, september burstcoin this section give some more details the efficiency and security issues burstcoin outlined section not only discuss burstcoin because relevant related work, but also, looking its design illustrates some the challenges that had solve when designing proof space based cryptocurrency. the only specification the burstcoin mining process that were able find the webpage http://burstcoin.info/intro, which unfortunately rather informal. the description below thus only our best guess how exactly the mining process burstcoin works, mostly based the figure http://burstcoin.info/assets/img/flow.png. burstcoin uses the shabal hash function which below will denote with h(*). mine burstcoin, miner first initialises his disk space follows: picks nonce and account identifier (which hash public key) id, and then computes iteratively values h(id, and xi+ h(xi kxi- for the miner then stores where each block called "scoop", and the scoops together are called "plot". the miner supposed store many plots can (using different nonces) until all the dedicated space filled. compute plot, one must hash million -bit blocks the following assume for simplicity that there just one plot shabal was submission nist's cryptographic hash algorithm competition candidate for sha-. its documentation can found http://www.shabal.com. note that equation (), freshly computed block prepended the previous input. this important shabal iterated hash function: appending instead prepending would bring the number hashes required compute plot down linear (instead quadratic) the length the plot, but the same time would allow for much more dramatic time-memory trade-offs than the ones outlined below. efficiency. once every few minutes, new block gets added the hash-chain. this point the miner can compute designated (public) index and must look the value this then determines the miner "wins" and thus can add the next block the block-chain note that this requires accessing constant fraction the entire dedicated disk space (i.e. one block per plot, .%), every time new block gets mined. moreover, order verify that miner "won" and can add block, necessary recompute the entire plot from the initial inputs (id, u), which, mentioned above, involves hashing over blocks. comparison, spacecoin, the number bits read from the disk only logarithmic the size the dedicated space, and verification also just requires logarithmic number hashes. (in bitcoin, verification requires just single hash.) time-memory trade-offs. observe that burstcoin allows for simple time-memory trade-off: instead storing entire plot miner can initially compute and store only the value the miner then re-computes the required scoop given time-step, but only sufficiently small (say, this would require hashing only most blocks thus, the miner will get shot adding block only the time slots, but now also only requires fraction the space that would needed store entire plot. using this strategy, given some fixed amount disk-space, possible mine ./. times faster than the honest mining algorithm, the price having compute modest number extra hashes. more generally, using this type mining strategy, possible mine times faster the price having hash blocks with every block read from the disk. given that application-specific integrated circuits (asics) can compute the order millions hashes per second per dollar invested such time-memory trade-offs seem practical remark that http://burstcoin.info/intro, the creators burstcoin discuss the possibility mining their currency pure proof-of-work style, though they come different conclusion from ours: technically, this mining process can mined pow-style, however mining intended will yield thousands times the hashrate, and your hardware will sit idle most the time. continuously hashing until block found unnecessary, waiting long enough will cause any nonce eventually become valid. grinding and extending multiple chains. the two main challenges had overcome when designing spacecoin were attacks based grinding and mining multiple chains. (the problem with time-memory trade-offs was solved the proofs space [dfkp] paper upon which this work builds.) due lack documentation the burstcoin mining process, not know what extent burstcoin can attacked using grinding extending multiple chains. from our understanding the burstcoin mining process, seems especially crucial avoid grinding the index the scoop used given round: otherwise, malicious miner could "hijack" the chain forever (i.e. mine all future blocks) using only very small fraction the total dedicated space, follows. the figure http://burstcoin.info/assets/img/flow.png indicates that this scoop index computed from two values prevgensig and prevblkgenerator. the naming indicates that prevgensig corresponds the value newgensig used the previous the details how add block the chain are irrelevant for this discussion, and hence omit them. precise, the miner would compute and then set https://en.bitcoin.it/wiki/mining_hardware_comparison however, remark that currently, asics exist primarily for the sha hash function used bitcoin (and not for the more unconventional shabal hash used burstcoin). block. this value computed deterministically and thus "ungrindable". were not able find details the functionality prevblkgenerator not know whether can grinded; however, seems possible that this value serves bind transactions proofs within given block, and thus can grinded (by trying different sets transactions include block).