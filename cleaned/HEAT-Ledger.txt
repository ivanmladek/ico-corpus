heuristically enhanced asynchronous transactions white paper d.m. klerk svante lehtinen heat ledger ltd table contents introduction unlimited scalability removal embedded database use off-heap memory split balances from transactions and blocks chain blockchains slicing the blockchain general description heat token distribution and the genesis block details slicing added security from pos consensus validating the most recent blocks segment networking improvements real-time external replication the replication layer extending the message protocol real-time asset-to-asset exchange bringing decentralized asset exchange web scale colored accounts and private assets custom asset exchange [aae] crowfunding and fiat trading gateways distributed services architecture dsa services are not smart contracts writing distributed services service example what type services can expect service operator's privileges and liabilities ability chain services smart (offline) vouchers eee off-chain messaging account structure and aliases heat account identifiers aliases empty balance pruning and temporary accounts minimum forger balance ___________________________ account control and multi-sig protecting your stake limit amount transferred per day multi-sig accounts heat rewards mechanism two-tier rewards how reward block generators (pos model) how reward blockchain storage (pop model) each segment gets the same reward pop challenges fair beyond fair the challenger account challenge generation the actual challenge conclusion white paper version history ___________________________ introduction heat ledger self-appointed "gen cryptocurrency platform focusing resolving the two most pressing pitfalls the existing and cryptocurrency server software solutions; low transaction rate throughput and the burden hosting large blockchain files any single node. like the heat software itself, this document work progress that will amended and expanded the project evolves. designed deliver reasonably complete, quasi-technical treatise the basic elements the initial heat system available the time genesis block september heat part inspired open source nxt uses the time proven proof-of-stake consensus algorithm but tuned for -second blocks. feature wise, many parts the heat service offering and middleware solutions are based those originally developed for fimk other parts the heat core fully rewritten java, making optimally suited for custom financial business applications providing microsecond latency (up million writes per second), vastly increased vertical scalability, and superior failover resiliency when compared legacy datasystems. heat general technical highlights: written enterprise friendly java based secure, mit licensed nxt for cryptography and consensus code architected with re-use for private chains mind optimized for speed and low memory usage massively scalable through the use not one single blockchain, but chain blockchains (only the last one the chain required each node) application level contains all the latest cryptocurrency features and more, including custom asset-to-asset trading, distributed apps and end-to-end encrypted instant messaging. heat cryptocurrency employs radically new approaches the way cryptocurrencies are built, the most notable these being complete removal the embedded database. another major core change consists changes the mechanism the network layer works. for storing the consensus blockchain, heat does not use single blockchain file ever increasing size. instead heat makes use serialized blockchain files limited size, accompanied small balance files. when the latest blockchain file reaches threshold size (of few gb, specified genesis block) the protocol will automatically switch new blocks file cryptographically linked the previous blocks balance files. the details achieve this are principle rather similar how blocks are chained each other. https://nxt.org average block target http://fimk.fi ___________________________ through these radical changes both the storage layer and the networking layer estimate possible sustain least transactions per second load all year round. theoretical constant rate tps would produce worth archivable blocks files per year roughly new block files per day, all commodity (affordable) hardware. would however the need arise process even higher numbers eventually approaching the visanet max level tps) thanks the vertical scalability heat all that's needed support these kind boost rates are just stronger servers with more processing cores and ram onboard. unlimited scalability many have heard the issue "scalability" which most popular blockchains face. the difficulty handling ever increasing number transactions the blockchain puts growing pressure the resources each node the network. the current generation blockchains (eg. bitcoin ethereum, dash, nxt) most have embedded database where they store both all blocks data and all balances. those embedded databases give the user the ability ask the running coin daemon for any block transaction from the past. while lack better solution this sure helps users, fact does not help the core operations all. instead comes brobdingnagian cost, especially for blockchains that skip the usage more performant leveldb but opt for the featureful and thus slower sql database. leveldb has its limitations also; you cannot store anything leveldb that requires more than one hard disk, more practically the maximum size low gb. stated, the core process has use for the past blocks and transactions. all access that really required constant basis access the most recent blocks. this needed for removing transactions the rare case blockchain fork resolution. removal embedded database not embedding leveldb store transactions and blocks, account balances and the order books for all asset pairs, heat uses custom build storage and access solution based memory mapped files and tailored specifically address the needs cryptocurrency node. https://usa.visa.com/dam/vcom/download/corporate/media/visa-fact-sheet-jun.pdf https://github.com/bitcoin/bitcoin https://github.com/ethereum/go-ethereum https://github.com/dashpay/dash https://bitbucket.org/jeanlucpicard/nxt/src http://leveldb.org/ http://www.hdatabase.com/html/main.html ___________________________ computing, mmap() posix-compliant unix system call that maps files devices into memory. method memory-mapped file i/o. naturally implements demand paging, because file contents are not read from disk initially and not use physical ram all. the actual reads from disk are performed "lazy" manner, after specific location accessed. memory mapped files offer the possibility access disk stored data random sequence and near ram memory speeds without the need load this data ram. (the idea originally inspired ramchains implementation jl). use off-heap memory heat written java and thus uses the java garbage collector manage and free app memory not used any longer. while java offers much safer code with regard memory management than apps written c++, this safety comes big cost. applications written c++ don't have garbage collector and thus don't have pause execution other code while the doing its thing. inspired the high-frequency trading industry were lead investigate the software components used these hft companies. hft requires massive amounts data that need accessed lightning speeds. the needs hft systems and blockchains systems overlap. our search lead chronicle software, more specifically their lgpl licenced product chronicle map. chronicle map/queue properties high throughput, low latency, cross process, persisted key value store. off heap data storage, with microsecond latency. designed used java, pauseless, garbage free manner. better utilizes your existing hardware offering vertical scalability. concurrent writes one machine using single copy memory. resilient writes process dies, the last write not lost). entirely embedded, need for any additional processes. million updates per second with million key-values core machine, with heap and minor collections. data not lost even the jvm crashes the next line. important part the application startup process, where might needed scan all transactions the blockchain rebuild validate the various running balances. loading multi-giga-byte block file into memory mapped file not problem since this takes just about second. https://en.wikipedia.org/wiki/mmap http://wiki.supernet.org/wiki/ramchains https://en.wikipedia.org/wiki/high-frequency_trading http://chronicle.software/ https://github.com/openhft/chronicle-map ___________________________ subsequently scanning through all the transactions made extremely fast using off-heap memory during the scanning process exclusively, eliminating the need for the garbage collector even run. regular startups heat without the need scan transactions are near instant since all that has loaded are the balance files which require much less space than the block files. split balance storage from transactions blocks cryptocurrency decentralized ledger architecture you always have list transactions since the genesis block. reading all those transactions allows you build the balances for each account. the storage needed for balances much less than what need store the actual transactions. example let's imagine that individual accounts have made total transactions. accounts transactions total size (in bytes) total size (key=,val=) can seen the total amount storage needed store the balances for accounts just mb. translate this account for all the billion users the internet and we'll end with balance file just gb. heat produces several distinct files all loaded memory mapped files and all serving homogenous data type. there are files for unconfirmed balances, confirmed balances, unconfirmed and confirmed asset balances but also for open buy and sell orders. each these files comes with accompanying recovery file that holds the transactional data the last grouped update. the recovery files serve dual purpose: use them rollback transaction (grouped set updates) and use them recover startup when the app process has crashed was stopped for another reason (system crash/power outage). chain blockchains [to implemented after the heat main net has been successfully released] heat instead one single blockchain have segmented parts the blockchain. segments are numbered and there limit the number segments. balances are distributed separately from the blocks and transactions the blockchain segment. balance files are much smaller than blockchain files. the balance files accompany each segment file, you need scan segment using the balance file starting point get the final balance for that segment. contained the balance file cryptographic checksum the expected post-scan balance which should match there match the segment invalid. http://www.statista.com/statistics//number-of-internet-users-worldwide/ ___________________________ let's take example new heat user, bob. bob downloads heat client-server package, and with this comes the initial balance file. bob then also downloads all balance files for all segments (these are around per segment). finally bob downloads the most recently sealed segment. bob can verify that all balance files that has downloaded all link back all the way the original genesis segment. each balance file comes with sha hash the previous balance file, plus bit checksum all the balances the previous balance file. when bob downloads all balance files (/~, the size the blocks) his heat software can verify all balance files all the way the last one for which has downloaded the segment. when bob's heat server software now applies all transactions gets the starting balance from where can start downloading transactions from the network. block height counter tracked separately and keeps increasing normally when new blockchain segment started. slicing the blockchain general description note that these parts are still development, for discussion and cannot rule out changes the details the implementation plan. why heat launched without the blockchain slicing operational? there great urgency get the first block split the main net, and that fact does not arise only because the mass stored data small right after release. more importantly unlike cryptocurrencies driven database storage heat does not get significantly slower over time for the growing pile archival transactions. the blocks and transactions are stored heat way that imposes very small computational and memory-wise cost the resources. heat already capable supporting the first block segment huge size, while for bitcoin nxt for instance blockchain several hundred gigabytes more terabyte would require extremely powerful servers. all heat needs just the disk space, relatively fast disks (ssd) and modest amount ram. servers with ram work fine. this possible since store blocks and transactions all one after the other disk, scanning the blocks and transactions order literally means reading each byte disk one after the other. faster method than this exists non-experimental computing date. ___________________________ all the other parts the heat framework are ready for block segment splitting. already all balance storages have been constructed ways support this. the practical benefits allowing distributed archival small sliced block files, and also proper implementation the heat proof-of-presence incentive mechanism demand eventual implementation the sliced blockchain structure not long after the launch heat main net. heat token distribution and the genesis block from july through august heat has had its initial public distribution, "initial coin offering" [ico] period, during which founders reserve their stake the heat tokens. each founder gets her share heat tokens based the proportional amount price laddered heat ico credits they have pledged through paying freely chosen amount btc, nxt, fimk eth heat ledger ltd's ico accounts through one the party escrow agents used during the ico. distribute the million heat [or million case full reservation] after the ico period over, heat ledger ltd arranges the required facilities the heatledger.com web site. stakeholders need through authentication process, consisting creation individual heat founder account which the heat tokens are transferred immediately after automated ownership verification the original credit purchasing cryptocurrency account. all these initial accounts are imported into special piece data file called the genesis block. practice this part the genesis block inclusion looks like plain text file with entries each new line where each entry contains public key hex form and balance displayed the smallest unit heat (hqt, heat quotient). the heat server source code there hardcoded sha hash with which first validate the genesis plain text file before generate the genesis block that starts the chain. the choice place the genesis accounts separate file instead hard coding them the source code save application memory and more easily switch different genesis block when applications the heat software are used corporate private blockchain products. ___________________________ when the genesis block place, will have entry the blocks segment file (sequentially stored data) and there will entry the balance store for each genesis account. the balance each account initially will the amount assigned the genesis plain text file. details slicing now that the system ready for use, stakeholders can start sending transactions and node operators can unlock their heat server and start forging blocks. once this process has run for while see some smaller data stores that hold balances, asset balances, open orders and public keys. and one much larger (several gb) data store that holds all transactions. when the block slicing mechanism deployed, all nodes the network will know exactly what block height new blocks segment will started. whether hardcode that height the source code (easiest solution), publish that the blockchain use some other method where base the moment the split for instance the actual size all blocks disk, remains decided. the time split, all live running nodes active and connected the moment the split will see new file appear their hard disk. the previous segment was called heat-blockchain (for instance) the new file would named heat-blockchain-. those online servers can now serve transactions from the past block segment any peer that wants those per the standard peer peer operations. since balance stores belong specific blocks store, the moment the split all active nodes the network will also generate new balance stores. there are several balance stores for all the different types balances. the balance stores for the new block file will initially start exact copies their previous versions. this cloning such happens extremely fast since the balance stores are based memory mapped files and mostly use off-heap memory. during the cloning process when visit each balance predetermined order create checksum all balances. the checksum generated building sha hash which updated with each account balance combo. also added the sha hash are all the final checksums that came out each previous balance store before this one. all previous checksums keep travelling forward the future each new balance store. this chaining checksums make impossible later present altered balance file simply because its checksum would never match the one for the genuine file got during cloning. other words, the digest hash (checksum) from the previous step added seed with all other previous checksums for each balance file before that, stored the new balance file. this arrangement requires new users who come online the first time the network later download all the past balance files able validate the last transaction segment. however the new user does not need download the archived block segments, resulting significant savings the size downloaded data from peers. ___________________________ added security from pos consensus add second layer security the sliced block files, apply the strength the pos consensus protocol and the generally recognized inability for any attacker obtain access over half all the total heat stake existence. after all nodes the network have switched new segment and all have generated their new balance stores which include the checksum the previous balance store starting block the new segment and during blocks, each forger must include the carryover checksum every block forges. any node the network receiving new block finds the carryover checksum does not match the actual correct checksum, the block rejected. the chance forking the network rather slim this way. the maximum rollback blocks has already been passed the network cannot back point before the segment split. the only nodes landing fork would the ones who include checksum that considered false the rest the network. new user's heat server software automatically verifies that all the balance files really belong together calculating and comparing the balance checksums itself. let's take example: are block segments the future, this means the total chain size could have become perhaps larger than available space the user's hard disk. downloading all segments longer even option for him. what can download the very latest completed blocks segment. still largish file few but well within the standards are used the cryptocurrency scene. the user's server software also downloads all the past balance files, but since these are less the size blocks segment this has minimal performance impact. his heat server scans each balance file and before accepting them makes sure all the checksums match all the way from the genesis the final balance file. next comes the big moment; the user's server needs validate the final blocks segment had downloaded from the network. needs validate all transactions and blocks that segment, but without access all previous blocks and transactions! the protocol did require access those past transactions, then definition the whole mechanism would never work truly global scale crypto platform. relying having access virtually endless set transactions does not scale under the technology available for humankind currently. ___________________________ validating the most recent blocks segment heat has already shown far the fastest public decentralized ledger available feat made possible only its unique design and the use custom designed storage and balance components. but speed not enough cannot safely ignore the many tera- petabytes transactions that would doubt make such transactions network global span. let's walk through the process our friend bob validating the block and balance files for his single node. bob has all balance files (lets say generations them) bob confirms each balance file all the way back from genesis up-to-now all connect each other (confirmed through checksums each follow balance store references its past store) bob however doesn't know all balances are the real balances, this remains seen later bob downloads the most recent completed block+transactions segment bob however still cannot sure that this the 'real' data set, this still remains seen. bob downloaded block segment number the network currently segment number bob now takes the balance store segment number and starts there.. the number balance store should consist exactly all the final balances the heat network the time the number segment was created and should also the starting state the number blocks file. bob now assumes the number balance file the real balance (which could still false but he'll find out later). bob can already confirm the number balance store has the same checksum that was written times all forgers the start the number segment. this way bob could least know that the full pos forging weight that point time agreed upon the checksum for that balance store. bob now starts scanning segment which filled with transactions. each transaction validated and applied, each time updating the final state the number balance store. each new transaction will update the balance store. when bob done applying all the transactions the number blocks store, all correct, his final balances should match exactly the same balances that can found the number final balance store. course, it's still possible now that bob was duped into downloading fake balances files and could have downloaded fake blocks segments, which all match up. but create such fake matching balances and matching transactions, that simple task. highly unlikely attacker could that, but theoretically possible. succeed with fake blockchain attack needs not only convince the majority the network this fact, but also make sure the rollback required less than blocks, since that's the maximum allowed number blocks blockchain reorg. brute forcing and discovering and distributing such fake datasets will not only cost lot time, also exposes you the moment you start the attack. for all practical purposes this level security sufficient. now bob pretty sure his balances and transactions are valid and starts join the peer peer block distribution network. joining the network bob will find himself the start segment the network will start feeding him blocks and transactions. since the start the number segment there are blocks that all carry the checksum for the number balance store, all signed and validated the full pos weight the blockchain, bob can now sure that all his balance files and blocks segments are valid. ___________________________ networking improvements for its peer--peer and api connections, nxt and its clones rely jetty which embeddable tried and tested servlet container and web server solution, incepted newer networking libraries and paradigms have however emerged. where jetty blocking network framework which means schedules one thread per connection more advanced solutions like netty used heat exist. part the mentioned scalability netty direct consequence its asynchronous design: does not require thread per request and therefore able handle more concurrent connections with less available memory compared thread-per-request approach. with less threads running your server, the operating system will less busy doing context switches and other thread related overhead. this can lead performance increase. the case netty this seems true has found its way into businesses such twitter and facebook which handle impressive amounts concurrent requests. (source existing earlier research has also shown the inefficiency most the cryptocurrency peer-to-peer protocols. major case such inefficiencies the double (or multiple) transport blocks and transaction data peers that already have those blocks. heat use smarter protocol where peers don't transfer blocks data other peers unless those peers explicitly indicate they want that data. another difference that strive connect much more peers each other the same time. again, reference nxt currently has default connections that are kept alive public peers. with heat and non-blocking asynchronous websocket connections over netty believe can support between and active connections other peers. the optimal standard number active connections something still under investigation the time this writing. further optimize network performance, heat will exclusively use binary messages between peers. this will significantly clip the amount network bandwidth consumed compared the current situation where messages are encoded json. memory consumption can further lowered passing the binary messages received over the network directly the off-heap storage layer, decreasing the need for garbage collection. http://www.eclipse.org/jetty/ http://netty.io/ http://ayedo.github.io/netty////what-is-netty.html scaling decentralized blockchains http://fc.ifca.ai/bitcoin/papers/cde+.pdf ___________________________ real-time external replication discarding the database from the heat core have removed one the major bottlenecks the daily and consensus operations. longer having worry about later discoverability transactions and blocks, have been able to: scale infinitely since there more need for each peer demand produce data from any transactions from the past improve performance longer need re-index the whole database table upon each insert, because processing new transactions now only requires storing them the end the list existing transactions. through these implementations however lose the possibility perform powerful sql queries the blocks and transaction data using only regular peer. accommodate for this loss functionality and even way beyond, have created the replication layer. the replication layer the replication layer event based optional and configurable event sink mechanism where you run heat together with mysql [or another brand of] database server. this server can either the same machine somewhere else the local network. mysql support comes out the box, but turn builds generic implementation that allows write event sink any type database server. all you need add vendor specific java class that provides all the database specific sql queries for that database and heat will happily replicate that database type. standard parts real-time replicate include: confirmed and unconfirmed transactions. while the heat core handles and stores confirmed and unconfirmed transactions separately, through the replication abstraction are able produce coherent collection transactions consisting all unconfirmed transactions the start the collection and all confirmed transactions behind that. this greatly eases creating client view all real-time transactions. all balances for all accounts all blocks metadata. don't store the block contents signatures, saving lot storage. all public keys for all accounts all messages either sent regular message transaction included message attachment any type transaction. optionally you can configure heat with your private key and all messages are replicated encrypted. this gives someone running replication the possibility store all his private data encrypted the blockchain yet have replicated and unencrypted real-time his/her mysql server for fast indexing, custom queries etc. all assets, trades and orders. orders are matched real-time based unconfirmed transactions. case new block indicates have not matched our orders correctly according our view the unconfirmed transaction ordering, this corrected instantly upon seeing the new block over the event sink. https://www.mysql.com/ ___________________________ extending the message protocol for commercial projects before the concrete plan for heat materialized, had handle number domain objects that had stored the blockchain, yet also available real-time our mysql application server. for this have created addition the replication layer where you can create binary messages [either encrypted not] recognized the replication code and handed off their correct handlers. these handlers have written the user; handlers are java classes that have unique and that know how interpret binary message input and apply that data the mysql database. the replication extensions most cases need additional table definitions, for this out the box there schema versioning solution where all you need enter are your table definitions updates. heat replication will take care applying these updates when needed. turned out very simple integrate binary message support into the heat html client framework. things get even easier through use typescript the client language. typescript allows create interfaces that perfectly wrap and handle the binary data encodings. for now heat has only used custom built message handlers. but this not how intend our users utilize them. big part the handler work consists manually entering code that interprets the binary data and translates that variables (numbers, strings etc). this tedious work and perfectly suited for automation. all that's needed set table definitions and some formalized message data structures. have not concluded exactly how best expose the extended messaging protocol allow anyone run his own custom protocol top heat. ideas range from java helper classes json custom dsl based jruby. real-time asset-to-asset exchange bringing decentralized asset exchange web scale through the help real-time replication presented the previous section, have been able create relatively efficient live view the state all orders the heat asset-to-asset exchange [aae]. traditionally, asset exchange applications based cryptographic ledgers are not suited for high speed trading. fact they are usually anything other but real-time, due the serious speed limitations applying transaction data blocks with delay several minutes before becoming available for further transactions. https://en.wikipedia.org/wiki/domain-specific_language http://jruby.org/ ___________________________ order expose the heat aae web scale massive audience, have implemented secondary web application that serves the apis that the client uses show the full trading ui. all this external the functioning the heat core and thus has impact the magnitude orders and users the protocol can handle. for client prototype have created play! framework application scala that connects the replicated mysql database expose this real-time exchange data. tests have shown can serve huge numbers users and process enormous numbers orders all from relatively light server. note: real time asset exchange data not new. fimk and nxt+ (see example supernet asset over virtual exchange) have already created mechanism called virtual exchange layer which does similar thing. the difference heat that whereas the virtual exchange layer api that calculates the most recent order state each request, with heat the final order state always available any time straight from mysql (or whatever database you use for replication). part the process implement new generation scalable blockchain and bring most the features legacy trading platforms blockchain, heat introduces mandatory expiration orders. expiration achieved two step process; first the orders are recorded with expiration timestamp between second and seconds days) from order time. while the heat client and order matching middle layer ignore any expired orders any time, such orders are completely purged blockchain rescan every hours. colored accounts and private assets the unique colored account implementation that fimk has provided since early enabling custom assets pricing and trading, ported heat is. the idea colored account that you can create "colored coins" within the heat ledger simply tagging account instead tagging subset tokens. the creator color you can transmutate any heat you own into that color and change any colored heat back into heat again. once having created new colored tokens you can use all the features heat. the features available work only long you are using them within subset accounts assigned the same account color. while all standard assets the heat asset exchange are priced heat, creating asset through colored account imposes the created asset's price base for the particular account color (for instance eur) instead heat. this step alone gives birth custom assets priced another asset. however, isolate the colored asset from the general heat token flow, all accounts wishing trade that asset need again assigned the correct color the asset issuer. heat includes yet another asset feature making possible mark asset private, for both colored and standard assets. private assets can only traded accounts selected the asset issuer. addition private assets can use custom order and trade fees charged from the users eventually broadcasting their buy sell cancel order transactions. https://github.com/fimkrypto/nxt-plus https://www.mofowallet.com/launch.html#/assets/nxt//trade https://lompsa.com/#/activity/fim/assets/latest ___________________________ custom asset exchange [aae] the term implies, asset-to-asset exchange enables trading custom tokens, priced any other custom token. the pricing currency issue has generally been problem child for the few crypto ledgers that have the asset exchange functionality available all. addition fimk, least bitshares and more recently the waves technology have made possible price assets any other token. heat's initial version achieves the custom assets functionality through the colored accounts mechanism. have implementation plan standing for more direct native asset-to-asset trading, which will deployed once the heat main net has been launched and running stable condition for while. that time, the heat system will support multiple different technical routes issue, price and trade custom assets, making suitable for wide variety real world business applications. crowdfunding and fiat trading gateways the flexibility and robust processing capabilities the heat aae are specifically fit for any kind crowdfunding and share issuance applications. evolved from traditional crowdfunding, projects crowdfunded through heat's system may issue tokens for investors and enable immediate later phase trade these tokens the heat decentralized [or company's privately commissioned] crypto ledger. large volume trading with instantly matched trades longer produce any hindrance thanks heat's hft processing speed. colored semi-public tokens private proprietary blockchains are the obvious choice represent national fiat money [eur, usd] against which real world assets are priced in. while technically possible arrange fiat assets for any the competing platforms mentioned previously, the obstacles achieve real fiat trading blockchain are more acutely related regulatory and legal obstacles. thus the point entry often too high rather obscure for licensed money transmitter business engage mission critical fiat operations through experimental public ledgers. heat ledger ltd's business model provide custom trading blockchains for corporate use, well low point entry the public heat blockchain for medium weight agile fsps through this incentive the company strives towards joint venture projects with licensed money transmitters, provide showcase real world fiat applications used through the heat software. the nontechnical details this subject are outside the scope this document and are discussed elsewhere when permitted the business arrangements. https://bitshares.org/ https://wavesplatform.com financial service provider ___________________________ distributed services architecture (dsa) note: the name distributed services architecture already use http://iot-dsa.org/ heat answers the call for blockchain based distributed applications its own ingenious way. have named the technique "distributed services architecture" [dsa]. with dsa heat users are able write software applications either java javascript and have these apps serve clients interactively using the blockchain (encrypted) distributed state full memory space. dsa based proprietary stateful interactive communication protocol, indeed being very similar the well known http protocol powering the internet today. with dsa the heat core will allow the creation wide range digital currency and database services. the services can offered decentralized and anonymous way and service providers can prove they have acted fair. anyone free offer any kind mostly automated services just offering them their heat software node. any these services would normally require fairly technical setup which least requires running and securing always online server and writing software that handles the automation part. the distributed services architecture solves the following difficulties normally faced with when developing and offering cryptocurrency other digital services. need for web server you run heat node and install your automated services heat need write the service's software: that you use one the pre-built services and offer your own service operator can stay completely anonymous instead http web server, the dsa protocol allows you run your service even being online briefly only, for instance only few minutes each day. the protocol would still allow users interact with your service you were always online. heat can run over tor even further mask the service provider's identity way cheat for service operator the service implementation code can made publicly available.since all service inputs and outputs are the blockchain they can all verified anyone with access the blockchain. imagine service where you can exchange cryptocurrencies. when you interact with dsa service and after first contact gives you price/quote for which will exchange your cryptocurrencies. now have public record that service provider handing you that quote. this helps the customer inspect all the previous uses the service (and how the service obliged them). the other hand the service that gave you the quote also uses during the processing the service requests. the stored record from the point view the service basically execution context that never expires giving the service script access all archived inputs and outputs they were simple variables the service script. ___________________________ ability chain services and create service networks: distributed services are meant for reusability. the idea here that eventually thousands individual services are run the heat blockchain, then new services can constructed re-using existing services and making them available end users. services are not smart contracts are means smart contracts, the main reason being that according our definition smart contract, smart contract runs independently and runs all peers the network. distributed services are different several ways. distributed service smart contract invoked blockchain "events" yes yes receives its input over the blockchain yes yes returns its output over the blockchain yes yes runs massive scale, individual services don't run all nodes the network. yes author can stay anonymous yes yes comes with built in, powerful payment solution yes yes can access data from outside the blockchain (exchange rates, betting scores etc.) yes can invoke external services perform outside yes blockchain actions (like sending email wiring eur receiver) can chained: you can build new services/contracts combining existing services/contracts yes yes can interact with other blockchains yes running contract/service free yes writing distributed services writing distributed services made easy. while all the input and outputs and from all services are encoded dense binary messages, this does not mean creating services (especially from javascript even better typescript) requires any knowledge this. all the input and output marshalling handled the heat libs. what remains for the service creator only implementing the service class itself. ___________________________ service example without going into too much detail let's describe how write very simple service that automates sending email for us. why need such service you might ask? could ideal building block for other services include the option send emails, for instance service that provides two-factor authentication (just example). the following service written typescript, language created microsoft and that compiles javascript. the heat client framework completely written typescript. class sendemailinput sender recipient subject body class sendemailoutput success true class sendemailservice extends distributedservice public api "sendemail": "input": sendemailinput, "output": sendemailoutput, "fee": (input: sendemailinput) return input.body.length public sendemail(transaction: transaction, input: sendemailinput, callback: (output: sendemailoutput) void) emailapi.sendemail(input.recipient, input.sender, input.subject, input.body).then( (success: boolean) callback({ success: success }); you can see there isn't lot code. yet with this piece code alone, compiled and installed your heat services directory you could serving anyone the world who wants send automated email. you would each time receiving fee payment heat and your service will not run until the price you declared was paid full your account. ___________________________ besides sending email, there are numerous other some seen before other environments and some never thought about small software services you other users can create the heat dsa. those service implementers don't have write the actual service code. instead they could use your service (such the email snippet above), another service your service networking with, and pass the (minimal) cost for using your service the customer. what type services can expect the sky the limit with regard the types services that can expected run the heat network. however below described example set services broadly convey idea what possible. list set service categories although the list limited size note that these categories can applied almost any cryptocurrency and even every fiat currency out there today. oracle service oracle writes (foreign) fact the blockchain. through oracle becomes possible create transaction the heat blockchain that does not execute until event outside the heat blockchain has happened. good example using oracle: bob sends alice heat tokens but the transaction will not execute before the oracle service writes blockchain the transaction details alice about her btc payment bob. escrow service requesting new escrow, both parties send money the escrow. escrow will not release funds before both parties agree. could combined with oracle service where escrow releases funds based oracle saying the requirements are met. time-based data decryption (secret reveal) service based certain date [block height], transaction the heat blockchain some other real world event coming from oracle this service decrypts and publishes sends predefined recipient some secret you gave advance. co-signer service for use with multi-sig transactions btc/eth/heat/etc. the user this service will use the service provider public key required co-signer multi signature transaction. when the requirement met the service provider will add his signature the multi-sig transaction which will then execute. gateway trade bot service with gateway trade bot service you can buy/sell cryptocurrency exchange. example such service would users sending eth the service eth address. when received the service will immediately sell the eth for btc and transfer the real btc for the seller. webshop simplification you sell digital products the internet (music video files for instance) you could create service where you either return link download the digital product, you could return cryptographic key for the buyer unlock the digital product. creating new service implementation for one the categories would consist copying existing implementation and only changing the details, which some cases could just single line code. ___________________________ service operator's privileges and liabilities anonymity and the option for strong cryptographic identification service operators can remain anonymous. because all contact with the service operator runs over the blockchain, additionally protected tor anonymizing relay layer desired, there direct way pinpoint the physical location the service unless the service operator wants so. the other hand, since the service identified its heat account this offers strong nonbreakable proof identity when desired. also hallmarking [public registration your node address] heat node can used provide higher level cryptographic proof about the service operator's identity and even location, where desired the service operator himself. fraud proof technically, enhanced with decentralized reputation system the service operator can course cheat, for instance oracle service writes the blockchain that certain btc transaction has happened while reality did not, the operator could that way keep funds that not belong him. but anyone who wants can simply verify that what the oracle has written such case actually false. this could even automated from the heat client where with single click your client downloads the service implementation code and runs it, using the same inputs since they are the blockchain, thus revealing fake result. what also becomes important factor when multiple service providers offer the same service, how much trust reputation the provider has. simple feedback can made available comments attached the service operator, required more detailed reputation system may created which will use the blockchain its backbone. ability chain services since service inputs and outputs are both the blockchain possible chain one service after the other. because you call service through payment transaction that transaction could made execute only when certain requirements are met. this chaining feature enables the emergence automated software service networks massive scale, that could become sophisticated enough provide services based implementations neural expert systems. smart (offline) vouchers smart vouchers unique heat feature that allows anyone with heat account generate possibly millions transactions and hand those out anyone the world, all for the price single transaction fee. smart vouchers are conditional transactions (payments, messages, asset transfers etc.) that can generated offline, completely free charge. unlike standard transactions smart vouchers are not stored the blockchain. instead they are generated offline and handed out one one their recipients the form either very small file piece text varying length. ___________________________ either way, the voucher fully signed transaction which can sent the blockchain either anyone (in case the voucher not fixed one account) only the account the voucher was created for. the smart part heat vouchers their conditionality. while you can generate million vouchers, you make each voucher only valid certain alias has certain value (or falls certain range values) you now have way securely hand out vouchers mass quantities and externally control their validity. use cases for smart vouchers range from decentralized lotteries methods more easily introducing new users the heat network services through for instance rebate coupons. smart vouchers allow business operators hand out free heat assets but zero cost the user does not use his voucher. eee off-chain messaging heat contains native messenger that can send not only blockchain archived message transactions, but also off-chain messages free charge between two endpoints. this kind messaging end-toend encrypted, the only way decrypt the transmitted data using either the sender's the receiver's private key. off-chain messaging also does not leave archive the encrypted message (or metadata) the blockchain, giving impression more secure way communication than blockchain based messaging. use off-chain messaging, both parties the message channel need online the time message sending. gossip protocol used transmit the messages. the gossip protocol basically the peer-to-peer protocol that assures all transactions are distributed throughout the network among all peers. heat reuses that protocol allow flow selected messages over the same protocol, free charge yet still limited and overseen, prioritized lower than transactions and based the space available the transmit channel. heat's binary data format makes highly efficient transmit data between peers, expected that there nearly all cases sufficient allowance transmit off-chain messages throughout the network that they reach the recipient. account structure and aliases heat account identifiers for new heat accounts users default create human readable identifiers through the standard heat client. they have choice public identifier private indentifier. identifiers are usually email accounts the form either inhouse user@heatledger.com, external user@herownemail.com. the email account format chosen facilitate user migration from legacy email software that often insecure use. external email identifiers are verified through (verifier email sent heat ledger ltd's server). the heat client's messaging solution embeds notification messages through standard email when desirable. https://en.wikipedia.org/wiki/gossip_protocol ___________________________ public identifiers are stored the blockchain and are visible all. private identifiers are different instead their plain text identifier, heat stores byte hash the identifier. this way participants need know the identifier before they can use it, yet can assure delivery transactions the correct account through checking the identifier hash from the heat blockchain. advanced users are able create standard heat accounts completely decentralized manner, just publishing the -bit public key the blockchain and without storing any extra identifiers the blockchain. aliases aliases are free form text identifiers with some free form data associated them. aliases are always temporary, meaning they will available for while and will automatically deleted after certain number blocks. the reason not feasible keep aliases around forever that such system would not scale. there virtual limitless demand for aliases all sorts (to power vouchers for one thing). however, before alias expires the alias assigner has window certain number blocks which can extend the alias registration paying standard alias fee. alias keys consist bytes, which enough fit heat public key basically any other unique key. alias values consist bytes which more than enough fit even the highest numbers. these sizes are much smaller than the original nxt aliases for instance, which had byte keys and byte values. however return for stripping the more extensive data store will able scale massive worldwide usage smart vouchers way affordably support all sorts offline blockchain uses. such deployments can assist businesses securely create perfectly scalable voucher solutions power anything from lotteries, crowdsales, and ticket sales distributed on-blockchain voting solutions which include strong (off-chain) identities voters and loss heat transaction costs case users fail redeem their vouchers. empty balance pruning and temporary accounts heat balances and accounts are identified internally their byte [java long primitive] numeric id. everywhere where account details are stored they always are identified their byte key. this highly efficient means process and store data. top layer however, heat accounts are identified their byte bit public keys, and turn secured their bit private key. able internally link byte account ids byte account public keys, record all public keys must kept and track what account represents which public key respectively. this very costly terms storage, since each new account (unlike each transaction) has permanently stored and distributed over the network. ___________________________ mitigate this resource cost heat will actively start removing all public keys and balances for each account having had balance lower than (eg. heat) for more than blocks. users don't want their public keys removed they have make sure their balances never decrease below the heat client and api are designed not accidentally overdraft the minimum balance. this function effectively allows complete deletion accounts from the blockchain, and the use temporary accounts the form vouchers for instance. the limit for minimum balance subject increase the future with the expansion the number heat accounts and consequently the size the heat balance files that are mandatory for all new nodes. minimum forger balance heat you need least heat able forge blocks. practice amount that small has negligible chance forging block, however reasonable allow testing forging setup for new users with low heat token balances. heat account control and multi-sig protecting your stake extremely important aspect holding possibly large sums heat your account, never lose the private key that account. you lose your key you either lose access your funds, someone else can get access your funds. unfortunately, over the several years that have worked with and created new blockchain solutions have seen happen too often that large stakeholders lose considerable sums all even their holdings. very efficient method prevent losses from large holdings through account control. heat will incorporate the following two forms account control either the initial main net release, update shortly after. limit amount transferred per day large holders like exchanges should definitely use this feature. place account under account control happens through sending special transaction. with this transaction you include emergency public key and amount that can transferred without using the emergency key each blocks. unauthorized party obtains access that account, the most he/she can take the maximum allowed amount. you detect the breach time and use your emergency key you can transfer all funds new secure account. since these account control instructions storage section that cannot discarded later on, the transaction fee for such account higher than sending normal payment transaction. ___________________________ multi-sig accounts heat accounts can assigned multi-signature status. this means that the owner the account can send special transaction which includes definition other accounts that from then have also sign each transaction coming from that original account, for the accepted the blockchain. since these multi-sig settings also storage section that cannot easily pruned later on, the transaction fee for this initial "mark-account-multi-sig" transaction higher than for normal payment transactions. heat rewards mechanism two-tier rewards heat, like most public decentralized ledgers, wants incentivise active network participants and uses hybrid award system reward contributing users; reward for generating blocks (proof-of-stake, pos). this involves running full node, unlocked and with the user's stake applied generate blocks. users who run block generating node generally need have least moderate amount heat their account. reward for storing the blockchain (proof-of-presence, pop). only the most recent blocks file distributed amongst all nodes, previous blocks files are not needed for normal operations. heat incentives users store and make available previously archived block files. how reward block generators (pos model) block generation ("forging") mechanism creating new heat tokens and distributing transactions fees reward node runners, based the amount heat tokens available account unlocked (signed in) node. account that generates block awarded yearly declining guaranteed reward, plus all transaction fees, until after years when the guaranteed amount becomes and the block reward consists just the transaction fees for the block. expect there sufficient amount fees then incentivize suitable number active pos nodes. ___________________________ how reward blockchain storage (pop model) heat want nodes host past blocks segments and past balance stores. however not required for node have stored these block segments and balance stores for able forge blocks. the reward systems function independently each other. before nodes are eligible for pop rewards they must register hallmark. hallmark assigns static your account and stores this the blockchain. other peers the network who connect you over that same address now know what account runs that node and what his pos weight (forging amount) is. the open source protocol readily favors hallmarked nodes over non-hallmarked when comes its choice where download blocks and transactions from. once you have registered your node's address through hallmark, your node advertises exactly what past blocks segments you have archived and are making available the network. this registration available segment serves purposes: establishes index for nodes the network that wish download that segment. through your registration they now know your node able serve blocks from whichever segment registered. serves indicator for nodes that are looking for the most profitable segments host, since the most rare segments get the highest rewards. the challenge protocol that demands proof individual archival nodes uses this registry randomly select nodes and segments for which generates custom challenge based the hallmarked account. https://bitbucket.org/jeanlucpicard/nxt/downloads ___________________________ after you have hallmarked your node you can register unregister your node having certain blocks segments. having registered segment (which are identified their numeric index the genesis segment being segment automatically means you will participate the pop reward contest for the next block. important that your node online all the time you wish participate the pop rewards, since the protocol penalizes you skipping turn case you failed respond challenge case you responded with wrong answer the challenge. each segment gets the same reward important goal the pop protocol rewards make even distribution all the various block segments available over the entire network. one segment hosted fewer hallmarked nodes than another segment, the pop reward mechanism automatically makes theoretically more profitable host that more rare segment. the reward algorithm knows how many segments there are the network. initially there one segment, this the segment that contains the genesis block and the first set blocks after that. when this segment completed there will two segments: one segment which completed and one which the active not yet completed segment. during the period the first segment, when other segment has yet been completed, the protocol uses relatively small random sections the active segment create challenges for those parts the blockchain. through evenly random lottery mechanism all hallmarked accounts select the account that gets solve the challenge. from point when the first segment completed and gets archived, different algorithm will applied. for scalability reasons, the pop rewards are aggregated batches average blocks, and rewarded the finder every block (random, average). the algorithm that runs random intervals will start randomly selecting one the completed segments. this ensures that each segment entitled the same amount pop reward. when segment selected the protocol randomly selects hallmarked account that says has that segment. for this hallmarked account challenge created and published the blockchain through transaction. the hallmarked account solves the challenge correctly (if its response matches the question) the protocol rewards this account with the heat pop reward. doesn't solve (false answer nonresponse) then that hallmarked account has skip one next turn before can solve challenge again. when configuring the heat server with access your private key can sign transactions and setup your hallmark, all this challenge solving and responding happens automatically. note: maximize secure usage the private key with locally installed heat server, possible assign the pos weight your cold wallet account through offline balance leasing. this way you could use second blank account the hallmark account and signature account, without ever exposing your main account's private key online node. ___________________________ pop challenges fair beyond fair challenges are always provably fair. anyone can verify that the correct, random challenge was indeed correctly generated the generator account and written properly the blockchain. you could run the same challenge creator algorithm and will see the challenge creator not only created the correct challenge with the correct solution its answer, but also that the challenge truly questions the correct part the blockchain and not some section the challenge creator just happens have. challenge itself consists challenger account writing challenge the blockchain. the idea the challenge that anyone knows what the answer should be. but what not known secret included inside the challenge. the challenged account must decrypt the secret before getting access the actual answer. the expected answer and the decrypted data are the same, this indicates the challenged account must have known the secret. the challenger account early phases the heat network, heat ledger ltd developers will operate the single challenger account. because this account bound strict protocol rules could not viewed being autonomous granting undue power the developers. all can what the protocol allows do, decline from its assigned tasks and nothing. nothing done this immediately becomes clear anyone the network. when the early operational phase has been passed, will change the way the challenger account works. will become more decentralized process allowing network users also play the role challenger. being completely rule bound this will not impose threat but make the challenger process more durable and better suited for decentralized system. will for one allow for better storage scaling through segment distribution over multiple challenger accounts, the single challenger does not have hold all segments order create challenges. challenge generation there are several parts the challenge generation algorithm. all parts are however under active development and might change based future insights. selection the challenge block (when the challenge) selection the challenge segment (what are creating challenge for) selection the challenged account (who has solve the challenge) selection the challenge seed (random input prevent pre-calculations) ___________________________ selection the challenge block challenges are created random interval, every blocks average new challenge block selected. the selection challenge block based the block id, which number. block challenge block if: (block_id_number this gives average hits but randomly distributed. selection the challenge segment each challenge supposed select evenly selected segment all existing segments, the idea being that rewarding for segments equal way are sure equal distribution segments over all nodes. this method guarantees that matter how large the blockchain grows, there will always high incentive archive the most rare parts the network, ensuring always equal distribution all past segments. select segment look the number possible segments select from the first place. there are for instance segments, each numbered from have randomly select all with equal chance. for this will also use the current block number and select the closest segment based off that, again using modulo arithmetic. selection the challenged account every possible account registered hallmarked account and also acknowledged whether they are hosting the selected segment. from the list registered accounts one will selected the challenged account. find the selected account take sha hash the current block signature and add that the previous block signature. the resulting hash add the selected segment. then check each registered account and for each account create sha hash its public key, added that the block signature. take the last bytes each these resulting hashes; whichever account has the highest number wins and the challenged account. selection the challenge seed the challenge seed random unpredictable piece data. for this again create sha hash, feed the block signature, feed the challenger account public key, and feed the public key the challenged account. the resulting digest the challenge seed. ___________________________ the actual challenge this point know when create the challenge, what the challenge will about, who challenged and what the answer the challenge should (the answer being the seed). now time create the challenge and write that challenge the blockchain. first the challenger account creates checksum the segment part that. the result byte array very large number). now the challenger creates sha hash the block signature, the challenged account public key and the checksum obtained previous phase. the result the secret that has published the challenged account. next the challenger creates sha hash the secret and together with the challenge details (what segment, what account) publishes this the blockchain transaction. the challenged account responds with transaction that contains the secret which when put through sha gives the same hash the published hash the protocol would consider that challenge solved correctly. conclusion the heat decentralized crypto ledger platform ambitious business project bringing together several dramatic server level changes, client side features and middleware system arrangements form the basis software solutions suitable for financial applications today and the future. extensive scope and going boldly where crypto geek has gone before, the heat team look forward bringing the maximum technological capacity modern commodity hardware the use everyday distributed blockchain applications. eventually, this feat will made possible only through the engagement supportive community. careful technical and structural design together with the enthusiastic users involved with the distribution the heat system and token strive achieve the status heat being rightfully recognized proper, first "gen cryptocurrency platform. ___________________________ white paper version history initial publication minor wording changes, improved pdf formatting ___________________________