abstract flash will implement new delegate-based consensus model called flash consensus (fc). retains the decentralized spirit cryptocurrency relying elected delegates rapidly reach blockchain consensus and ensure security. every user will able use flash coins cast votes for delegates. delegates will vote network matters such transaction fees and miner selection. delegates elect miners who create new blocks the blockchain. rather than using pos pow secure the chain, controls the ordering block generation rights providing each miner with specific timeslot during which they can mine block. when miner creates block the chain, that block serves vote indicating legitimacy. this new delegate model maintains network security while simultaneously enabling high transaction throughput. the algorithm also introduces concept called consensus height (ch). refers the moment when elected miners have created block top any given block the chain. when this happens, consensus has been achieved and block considered legitimate. network entity types there are three types entities flash's new network: normal users delegates elected delegates permanent delegates miners normal users any flash address holding least one flash coin considered normal user for the purpose this discussion. just like bitcoin, there are on-chain user identifiers, just utxo's controlled pseudo-anonymous addresses. elected delegates delegates are elected normal users. delegates must run for election staking minimum flash and providing information about themselves, including delegate id. users use the coin they control vote delegates into office. once elected, delegates can vote matters relating the flash network. each delegate places votes which are weighted based on: the amount flash they've staked the amount votes they've received how long they've been office (seniority) delegates are elected for period days time. votes for delegates can cast any time, but they are only evaluated once every days during re-election. there are maximum delegates (total sum elected and permanent delegates). there are more than nodes running for election elected delegate, then the top based the criteria above will elected. delegates must stake their coin begin running for election, and their coin must remain staked for the entire election period. third-parties may also stake coins for any given delegate, but those staked coins are locked for the entire election period and term. delegates can remove themselves from the running for the next election cycle any time, but their coins must remain staked during the current cycle. delegates will automatically removed from office they become inactive. delegates receive portion the network transaction fees compensation for their duties. permanent delegates the delegates, are permanent delegates who not require voting via elections. these permanent delegates are otherwise the same elected delegates; they must stake the minimum flash, their vote weight based the same factors, they can miners, they are compensated the same, and have the same requirements. the only difference that the minimum staking requirement mine flash instead flash required elected delegates. permanent delegates not have run for election. permanent delegate positions are held initially those who have contributed the strength and well-being the flash ecosystem; these positions are transferable. permanent delegate does not stake the required minimum flash, becomes inactive, they maintain their position permanent delegate but cannot act delegate until good standing until this role has been transferred someone who meets the above requirements. miners only delegates can become miners, and they signaling that they wish miner and gaining support from their fellow delegates the form votes and having staked minimum flash. the minimum staking mine for permanent delegates initially set flash. delegates are therefore responsible for voting high-quality and trustworthy miners. the number miners kept low, maximum order support high block rates across the network and high transaction throughput. the larger the mining pool, the less efficient becomes, which why flash's limited miner count optimal balance between security and performance. miners receive portion the network transaction fees compensation for their duties. transaction fees network bootstrapping, there will default fee flash per kilobyte, with minimum fee flash. the transaction fee rate and minimum are parameters that delegates can vote on. transaction fees are not collected per block the miners, but rather fees are collected once each day and distributed both miners and delegates. staking mechanics order run for election, one must create flash address represent their node. the candidate will then identified that address and the actions they take will signed with the associated private key. enter the election, the candidate can use the wallet create and broadcast their node's registration form along with their flash stake. all registrations and stakes are sent special election address from which the network will not allow spending, except return the staked coins back the sender the sender request. strict rules are enforced the acceptance and return funds and from the special election address. delegates must stake minimum flash register for election. the more coin staked, the higher probability they will become elected, the more influence they will have future votes, and the more rewards they will receive. additional stake contributions can made for delegate any person any time, however, all staked funds will remain locked for the entire election campaign, well for the subsequent election term(s), assuming that delegate elected. voting mechanics every transaction has the opportunity vote for delegate prepending zero-value transaction output that transaction that uses the op_return opcode followed new voting related opcodes and data. voting related op_return outputs must always the first output. the sender transaction able use this op_return metadata specify which delegates receive how much the transaction's voting power. the wallet will make managing user's votes easy possible showing which coins their wallet are voting for which delegates and which coins are not voting all, and automatically managing the casting votes according the configuration specified the user. voting not required transaction, but encouraged for the security the network. this method where the sender sets the voting metadata has unfortunate side-effect the user experience: every time person receives flash, they will need send back themselves along with their vote they want that flash used vote different way than the sender specified. the wallet can configured this automatically that barely noticeable the user. this annoyance and will generate some redundant transactions users re-send funds recast votes, but this method allows for dramatically more efficient accounting and scaling for the voting system than other methods. the need resend transactions recast votes can also leveraged combine transactions reduce the total utxo set. voting done delegates matters relating the network are handled differently than user votes. when delegate votes, they send transaction special voting address with data attached indicating what they are voting and what their vote is. flash coin need sent vote, however, normal network transaction fees apply. delegate's vote can come from any address, but the vote data must signed that delegate's private key. mining mechanics miners are elected delegates, and only delegates (elected permanent with the requisite minimum flash staked) can become miner. delegates vote for miners with their vote-weight, which derived from coin stake, user votes, and seniority, and they spread their vote-weight over many few miners they like. the top miners, scored accumulated vote-weight the ballots, become the elected miners. elected miner identified bad actor, unreliable node, then delegates can update their votes and remove that bad miner block. miners must maintain accurate system clock and have low-latency and highbandwidth network connection order effectively participate miner. the system tuned generate block every seconds, however when the network idle then blocks need emitted. clock skew the block timestamp will have maximum allowance seconds the future, and block can have timestamp earlier than the block before it. when miner creates block, they place their delegate the coinbase transaction for identification purposes, along with signature prove them. there block reward for miners claim, per-block transaction fees claim, and therefore, incentive mine blocks fast possible. block difficulty fixed very low value that there hashpower arms race; any modern cpu can hash block under second. secure the blockchain strict rules are enforced control the order which elected miners are allowed create blocks. each elected miner assigned single second window which they can create block, block needed, and then the next miner the list gets their own second window. this ordered timeslot assignment prevents conflicts over who will mine the next block, thereby reducing the amount bandwidth and processing that usually wasted high block-rate networks conflicting chains are passed around and evaluated. this timeslot assignment also ensures that every elected miner has fair chance create block. assign timeslots miners, function similar the following javascript function will used: function canitmine(minerposition, timestamp){ return (timestamp minerposition); there list currently elected miners that maintained each node, and updated miners are voted and out. miner's "position" the index the elected miner array that corresponds that miner. when miner checking whether can mine any given moment, passes its own position into the "canitmine" function along with the current system time unix format. when node evaluating block for correctness before acceptance, passes the position the miner who mined that block into this function along with the timestamp from that block. because each block creation asserts that the creator believes the chain blocks before true and accurate, each block mined effectively vote the miner what the correct current chain is. any given time, there consensus height, block height which consensus has been achieved the elected miners, and this consensus height increases new blocks are mined. for any given block the miners the elected miner pool have each created block the chain above then consensus has been achieved for and all transactions and before block are guaranteed final. the consensus height, then, all transactions included below the consensus height are considered final, and all transactions above the consensus height are the process being finalized. "confirmations" are longer measurement how many blocks have been built top given transaction's block, instead "confirmations" measure how many elected miners have mined block top that transaction's block, divided how many miners are needed achieve consensus. therefore "confirmations" effectively the percentage consensus given transaction block has achieved. given transaction which was included block blocks were built top unique miners from the -miner pool elected miners, then and all other transactions have consensus percentage of: (miners' blocks) (in pool) (for consensus) consensus 'confirmations' once transaction has reached exceeded "confirmations" then final and there risk being rolled back double-spend. all calculations and readouts for "confirmations" will capped reduce confusion. long attacker not able compromise more than the elected miner pool, double spending given transaction impossible once the consensus height has reached exceeded that transaction's block. all the elected miner pool remains online and mining blocks, then transactions will finalized within approximately seconds (>% miners second blocks all valid transactions will included blocks within seconds second blocks and all parties involved are trustworthy, then that transaction may actionable the recipient with confirmation just single miner avg, max). for guaranteed finality when dealing with untrusted parties, the recipient should wait for "confirmations", which should take about seconds. for comparison, pure proof-of-work and proof-of-stake systems never provide guaranteed transaction finality without centralized checkpointing. blockchain fork resolution described above, there consensus height ch) which increases new blocks are mined. node ever accepts blockchain fork that goes deeper than the current ch; the effectively dynamic checkpoint that voted into existence the miners. when there are two competing forks above the then the fork with the most unique miners'participation wins. if, for example, fork blocks long but only unique miners made those blocks, while fork blocks long with each block being mined unique miner unique miners) then wins. both forks have the same number unique miners participating, then the longer fork wins. elected miner evaluating two forks and that miner able mine new block either fork, then will prior comparing the forks. initial blockchain sync, node may poisoned malicious peer with invalid blockchain, and the rule that states that reorgs cannot deeper than the current may prevent the node from ever finding the true blockchain. this happens, then the node will need first connect only node the correct blockchain, and after finds true ch, then the node can openly connect any peer. votes and for delegates are only counted once the transaction that cast them has reached confirmations (full consensus), with the exception miner selection. when delegate changes its vote for miners, those votes are counted instantly and the elected miner pool changed result, then that change applies the next block. network idling the earlier years any cryptocurrency network there may long periods zero transaction activity. layer- adoption grows that will also decrease the level on-chain activity required for layer- supporting networks. order avoid the senseless creation empty useless blocks, the new flash network supports idling. all incentives for miners mine blocks fast possible have been removed, and nchainwork longer exists, the network can simply stop creating blocks when there longer need for them. good deal bandwidth and index space saved idling, and also keeps blockchain syncing efficient possible. order for the network idle without negatively affecting users, the miners must continue mining blocks the normal second rate until there are transactions above the consensus height. the network idle and single transaction broadcasted, the miners will begin mining blocks immediately, and they will continue for approximately blocks until that transaction has reached full consensus. after that, the miners will idle again until the next time valid transaction broadcasted. miner and delegate reward mechanics every day will start with transaction that distributes earnings miners and delegates. earnings are derived from network transaction fees all fees over the last day are added up, split half that goes miners and goes delegates, and then they are allocated described below. the for delegates allocated based each delegate's vote-weight the time the reward tx's creation. the greater the vote-weight delegate, the greater their share the reward. the for miners allocated equally across elected miners. foundation rewards the third millennium foundation pledges donate flash the miners and delegates every day the form transaction fees. this will done using automated process send one transaction day from the flash foundation's wallet with transaction fee. these donations will continue until some_expiration_date. voting related opcodes the voting system requires sending signed voting metadata the blockchain for all users see. order maintain backwards compatibility with all tools built for bitcoin, this metadata sent using the standard op_return bitcoin opcode the script zerovalue output. bitcoin tools not parse op_return data, nor this data stored memory, only disk. flash implements several new voting opcodes which are only used after op_return opcode, and these new opcodes tell the parser how interpret the metadata provided. list new opcodes: op_reg_dg: delegate registration and information updates op_stake_dg: provide additional stake for delegate op_vote_dg: user vote for delegate op_dg_vote: delegate vote network related matter op_dg_sign: used coinbase prove block creator's identity these new opcodes must used zero-value txout script immediately after op_return opcode, and this zero-value output must the first txout (position transaction. only the first txout parsed for voting opcodes, and only that first txout starts with op_return. special election address this valid flash address which has special rules for both receiving and sending transactions. coins being staked for delegates are sent this address, delegate registration information. all transactions into and out this address must pay the normal network transaction fees. nobody will ever know the private key for this address, and even were somehow derived, the network only allows coins controlled this address returned the specified return address the original sender, they cannot stolen. receiving rules: there can one many inputs. there more than one input, return address must specified the voting metadata. the first op_reg_dg for given delegateid must send least flash this address. any additional stake must least flash. there one output, then must op_reg_dg operation that updating existing delegate there are two outputs then the second must send the coins being staked the special election address and the first output must op_stake_dg operation adding existing delegate's stake op_reg_dg operation that registering new delegate. operation-specific metadata provided after the opcode. sending rules: anyone can spend these coins without the special election address' privkey all transactions received this address have delegateid that they are being staked for. that delegateid must not currently elected delegate; coins staked for the delegate can only reclaimed that delegate did not win the election they have completed their withdrawal from office. for each input being spent the output address must match the return address the input's corresponding metadata, not provided then the output address must match the original sending address (return sender). special voting address this valid flash address which has special rules for receiving transactions and rejects all sending transactions. when delegate casts vote they send transaction this address with the vote data and they pay transaction fee for sending the tx. coin ever deposited this address, simply used make easier account for votes. monitoring this address will effectively monitor all votes delegates. receiving rules: there can only one output which uses the op_return opcode followed the op_dg_vote opcode and data the op_dg_vote data must validate successfully sending rules: transactions sent this address can ever spent the opcode op_dg_vote explained later section, are the details relating how delegate casts votes and how the votes are counted. election registration form register for election delegate transaction with least flash must sent the special election address, along with op_return txout with the opcode op_reg_dg which includes hex-encoded serialized json data like: delegatepubkey: [full pubkey], infoversion: [number], displayname: [string], enabled: [boolean], mining: [boolean], auditurl: [url], contacts: optional type: [email/chat/irc/url/whatever], address: [address] type: [email/chat/irc/url/whatever], address: [address] website: [url] optional, registeredtime: [int], timestamp first ever registration the registration json document must less than when encoded. example the script txout[] which registering delegate: op_return op_reg_dg [regdata] [delegatesig] delegate can update this form any time simply providing new registration form with the updated data and incremented 'infoversion' field. additional stake required for updates this form long enough coin already staked for this delegate meet the minimum requirement flash. explanation the fields: delegatepubkey: this the full pubkey that identifies the delegate. all future actions taken this delegate will signed with this pubkey's corresponding private key. infoversion: this number that incremented with every update this delegate's registration form ensure proper state. without this any delays replication chain reorgs might cause older version overwrite newer version. displayname: this intended human-readable string that will appear various user interfaces for identifying this delegate, addition the delegateid. enabled: set true then this delegateid will eligible for election. set false then will not be. when elected delegate wishes withdraw from their duties then they must set this false and await the end the current election term, and then they can reclaim their staked coin. mining: when set true then this delegate signalling that they want miner, they become eligible for election miner. set false then this delegate not eligible. this delegate already elected miner they can set this field false withdraw from mining. registering potential miner then minimum flash must staked. auditurl: this the url which exposes this delegate's audit interface. there new api command which when queried returns information that can used prove this node alive and measure certain performance characteristics. recommended that service like memcached used when hosting this url shield the node from excessive queries. auditing explained further detail later section this document. contacts: this json array which contains list contact objects. each object specifies the type contact address being provided and the address itself. this intended provide way for the community contact the owner this delegate. this optional; however, the community unlikely vote for delegate that they know nothing about. website: this url linking website that represents this delegate the organization that owns the delegate. this optional; however, the community unlikely vote for delegate that they know nothing about. delegatesig: this registration form can sent from any address, doesn't have from the delegate directly, however the 'regdata' json object must signed with the private key corresponding the delegatepubkey, and that signature must placed this field. when the registration data received the delegateid generated converting the delegatepubkey into flash address. staking for delegates any address may contribute stake any delegate, however, coins may staked for any delegate that has not registered, and the first registration must include least flash stake. the first registration stake must included with the registration transaction, but further stake contributions can provided sending the coins the special election address with the op_stake_dg opcode. the staking transaction must have two outputs with the second sending the coin staked the special election address (minimum flash), and the first output must have zero value and use the op_return opcode followed the op_stake_dg opcode followed the delegateid being staked for, and optionally followed return address for the staked funds. return address specified, then the funds can only returned the sender. example: op_return op_stake_dg [delegateid] [returnaddress] should noted that staked coins will not able returned until the delegate they are being staked for has withdrawn from office and has ended their current election term. stake coins for delegate surrender control them for long that delegate running for election and serving their term(s). voting for delegates normal users vote for delegates prepending zero-value output their transaction which uses the op_return opcode followed the op_vote_dg opcode, followed the list delegateid's vote for with each transaction output. votes cast the tx's inputs are destroyed and votes are created with the new outputs. the op_vote_dg opcode expects simple list delegateid's, one for each txout (not counting the first txout which contains this metadata) and the entirety each output's coin amount used vote for the delegate described this array. example: op_return op_vote_dg [delegateid] [delegateid] [delegateid] the first delegateid the op_vote_dg list receives the vote txout[], the second delegateid the list recieves the vote txout[], and on. there are more txouts than delegateid's provided, then the txouts that are missing corresponding delegateid are simply not counted the vote. delegateid provided the op_vote_dg list not valid then the entire transaction rejected. voting delegates delegates vote sending transaction the special voting address. use this address makes easy account for how and when delegates vote, and this address has special rules described the special voting address section above. the transaction casting the vote does having single output that uses the op_return opcode followed the op_dg_vote opcode and data describing the vote. votes are described using json object which passed the op_dg_vote opcode. each key the votedata object represents ballot item, and each value indicates the vote itself. each value the votedata json object has maximum size limit and the entire votedata object has max size limit kb. given the coin supply and the minimum delegate registration stake, there can never more than delegates the running, and therefore the mapdelegatestate variable that holds voting information can never more than approximately mb. practice ought order magnitude smaller. the opcode op_dg_vote expects three arguments: op_return op_dg_vote [delegateid] [votedata] [votesig] the 'votesig' argument signature the 'votedata' argument, signed with the private key that corresponds the delegateid. the 'votedata' argument hexencoded serialized json document follows: voteheight: mintxfee: satoshis txfeeperbyte: satoshis miners: delegateid: vote-weight delegateid: vote-weight delegateid: vote-weight explanation the keys and values: key: the key this json object represents the ballot item for which this vote being cast. each time sent update the votedata the update considered incremental applied top the existing votedata for that delegate, overwriting any existing values for given keys. setting key's value 'null' will delete the key and the value, thereby withdrawing the vote. value: this the value the vote being cast. the value can more than size. new values for pre-existing keys will overwrite the old value. any transaction using the op_dg_vote opcode with json document that differs from the format described above, which violates any the constraints described, considered invalid and discarded. the limitations the size the vote data prevents dos and spam attacks, and the overall structure the voting document allows great flexibility for future ballot items. op_dg_vote transactions must pay the same per-byte transaction fee every other the network. the special key 'voteheight' the votedata incremented each time delegate updates its vote. this allows the network apply these vote updates mapdelegatestate the correct order. delegate attempts provide update with voteheight for example, without previously providing update with height then the update for rejected. second update for received, then rejected. different txid that claims update included block after reorg then the first update reversed and the second update applied; the mapdelegatestate data must kept sync with the validated votes the blockchain. vote accounting and indexing this voting system has been carefully designed efficient possible, add little overhead the blockchain and node processing requirements possible, order facilitate the highest transactions-per-second rate possible. addition performance considerations, ideal maintain full compatibility with all bitcoin related tools, this voting system has been designed maintain that backwards compatibility. every vote cast, every stake made, and every delegate registration performed via output the first output position which uses the op_return opcode followed new voting opcode that unique flash, followed the voting metadata. any bitcoinbased script interpreter will not parse the data following the op_return opcode, but the flash script parser will continue reading the script there voting opcode immediately after the op_return opcode. requiring that this voting metadata the first output position (txout[]) assures efficient lookups when discovering old votes that are being destroyed new outputs. also increases op_return script parsing skipping the parsing any op_return data that not the txout[] position. facilitate accounting and indexing the core code some new variables and structs will created: 'delegate' class: this holds information about delegate and methods for polling and interacting with delegates 'mapdelegatestate': this delegateid-indexed map delegate objects 'votestate' struct: this holds the current ruleset, the result the vote, derived from mapdelegatestate 'pendingvote' struct: this struct that contains information about vote that pending full consensus before being counted. attributes include blockheight, txid, and interpreted vote data. 'mappendingvotes': this txid-indexed map pendingvote structs, used for accessing pendingvotes txid. removed due chain reorg then that removed from this map well the multimap mentioned below. 'mmpendingvotesbyblock': this blockheight-indexed multimap vectors txid's. when the consensus height updated this multimap scanned find all pendingvotes that are now fully confirmed and then their votes are counted. once all transactions discovered vector are counted, all corresponding txid's are removed from mappendingvotes and then the vector removed from this mmpendingvotesbyblock. given max coin supply and minimum delegate registration stake amount there will never more than entries the mapdelegatestate variable. when delegate reclaims their stake, their entry mapdelegatestate will deleted. upon receiving valid delegate registration transaction, each node will check see this new delegateid already exists mapdelegatestate and will add new struct does not exist. when receiving valid registration updates each node will overwrite the given delegateid's entry mapdelegatestate with the new struct that the new struct has higher infoversion number than the existing entry. each new block accepted into the blockchain, each transaction the block checked for voting metadata txout[], and present, will validated and noted mappendingvotes and mmpendingvotesbyblock. votes are not counted until the consensus height has reached surpassed that transaction's blockheight. every has inputs and outputs; any votes previously cast the inputs must subtracted from mapdelegatestate and any votes cast the outputs must added. each time the consensus height changes, which might happen with every new block, mmpendingvotesbyblock iterated and each entry with blockheight below the new consensus height processed and removed from both the multimap and the map. processing mmpendingvotesbyblock means fetch each transaction the vector being processed, parse the voting metadata, and update mapdelegatestate count the new votes. mapdelegatestate changed after processing, the new consensus height changes, all votes mapdelegatestate are re-counted and the global votestate struct updated index the current active ruleset. future blocks will validated against this updated ruleset. this way, running total maintained for all votes mapdelegatestate, updated with each consensus height change, and the result the vote indexed structvotestate that all parameters can easily and efficiently looked up. note: changes delegate's miner vote processed instantly when received node, but all other changes must wait for full finalization allowing the consensus height reach that vote's block. calculating vote results the keys the votedata object are arbitrary, however, there are several keys which will utilized default when the flash network launched. other keys will ignored. each key votedata can use different method for determining the outcome the vote, and that method hardcoded the flash governance code. here are explanations the voting method for each the votedata keys supported launch: voteheight: this number that incremented each time delegate updates their vote. sequentially ordering vote updates assures that the updates are applied mapdelegatestate the correct order. mintxfee: this the minimum transaction fee allowed for any tx, denominated satoshis. the outcome the vote the weighted median all delegate votes, weighted with their voteweight. txfeeperb: this the fee per byte the transaction size, denominated satoshis per byte. the outcome the vote the weighted median all delegate votes, weighted with their voteweight. miners: the outcome this vote array the top miner delegateid's, sorted cumulative voteweight from every delegate. the voteweight contribution from delegate that delegate's total voteweight multiplied the percentage that the delegate gave this miner. coinbase transaction and delegate signatures every block mined will have coinbase transaction with inputs, similar most bitcoinderived cryptocurrencies, however flash's coinbase transaction will have zero-value txout[] that uses the op_return and op_dg_sign opcodes follows: op_return op_dg_sign [delegateid] [delegatesigofblockhash] this txout[] proof that the given delegateid was the creator the block. once every day, the coinbase transaction will contain additional outputs distribute the previous day's rewards miners and delegates. these rewards will distributed described the "miner and delegate reward mechanics" section above. each day progresses and fees are paid, those fees are burned, they are temporarily removed from the coin supply. the first block every day recreates those burned coins and distributes them the miners and delegates. audit interface and url there will new api command called getauditpoint which can used the community verify that this delegate online with blockchain that in-sync. this command takes arguments. when users are choosing delegate(s) vote for from list, that list ought show the sync-state each delegate that the user has information inform their vote. the response from the getauditpoint api call will follow the standard bitcoin api format and might look like this: error: null, result: auditpoint: delegateid: [pubkey], blockheight: [chain-tip height], blockhash: [chain-tip blockhash], mempoolsz: [number], timestamp: [current time] delegatesig: [base signature with privkey] id: each call this api will generate fresh signed message with the node's current timestamp and chain-tip information. delegates that are currently elected are running for election need make this information publicly accessible. recommended use separate caching proxy front this api call protect against dos and spam attacks, and hide the delegate's true from the public, desired. delegate info interface there will new api command called getdelegateinfo which returns json object revealing information about every delegate, both elected and running. the results this api command will used for dashboard displays community websites and the wallet. this command has one optional argument: delegateid. specifying delegateid will filter the results only return voting status for the specified delegate, otherwise data for all delegates will returned. the data provided this api command's response derived from the mapdelegatestate variable. this information can used see information about all delegates, including which delegates are voting which direction and with how much influence. example: error: null, result: delegatecount: votescast: totalvotespossible: totalvoteweight: delegates: "sojgfwfsjfwjgfsmbzadqt": key delegateid infoversion: displayname: "this delegate", enabled: true, mining: true, auditurl: "http://...:/audit", contacts: type: "email", address: "contact@delegate.com" website: "http://delegate.com", registeredtime: lastdgvotetime: votesrcvd: stake: timeinoffice: voteweight: votedata: mintxfee: satoshis txfeeperbyte: satoshis per byte miners: delegateid: vote-weight delegateid: vote-weight delegateid: vote-weight "usgssdvnkdpasdmopzvc": key delegateid infoversion: displayname: "another delegate", enabled: true, mining: true, auditurl: "http://...:/audit", contacts: type: "email", address: "contact@delegate.com" website: "http://delegate.com", registeredtime: lastdgvotetime: votesrcvd: stake: timeinoffice: voteweight: votedata: mintxfee: satoshis txfeeperbyte: satoshis per byte miners: delegateid: vote-weight delegateid: vote-weight delegateid: vote-weight id: vote state interface there will new api command called getvotestate which returns json object revealing the current state all ballot items accounted for the structvotestate variable. this the law for the current block. example: error: null, result: mintxfee: txfeeperbyte: miners: map elected miners delegateid: true, delegateid: true, delegateid: true id: this api command and structvotestate are intended only show the result all votes the previous block's closing, which makes these results the ruleset that will applied the next block generated. more details are needed about weights and delegates, then the getdelegateinfo api command should used instead. voting user interface both the wallet and the cli will provide interfaces for voting. the wallets will have configuration parameters that can set control automated voting with coins held the wallet, well interfaces that show the current state this wallet's voting power. because votes are cast coins are spent, not they are held, the automated voting will allow the user set threshold level for the amount coin the wallet that not voting specified, and when that threshold exceeded, the automation will send that coin back into the wallet with the correct voting preference set. the voting automation will default combine all transactions into one output when resending self, unless the user has opted out combining. miner and delegate statistics data can collected for both miners and delegates from their published auditurl's for monitoring how well synced they are. all delegates and miners should rapidly sync the current chain tip and maintain roughly identical mempool count. the auditurl provides signed message showing this information from each delegate and miner. additional miner statistics can collected from the blockchain itself, analyzing the coinbase transaction identify which miners are participating properly. elected miners should never miss their block generation timeslot unless the network idling, and miner misses too high percentage their timeslots, then they should replaced with more reliable miner. gathering the necessary information and making accessible all users, becomes possible for the community make informed decisions about delegate and miner elections, and well-informed decisions will lead optimally efficient network.