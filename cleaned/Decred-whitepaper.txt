this repository explore search features enterprise ethereum wiki code issues watch pull requests wiki pulse sign pricing star sign fork graphs white paper lefteris karapetsas edited this page days ago revisions next-generation smart contract and decentralized application platform pages satoshi nakamoto's development bitcoin has often been hailed radical basics development money and currency, being the first example digital asset which home simultaneously has backing "intrinsic value" and centralized issuer controller. however, ethereum whitepaper another, arguably more important, part the bitcoin experiment the underlying blockchain design rationale technology tool distributed consensus, and attention rapidly starting shift this other ethereum yellow paper faq aspect bitcoin. commonly cited alternative applications blockchain technology include using on-blockchain digital assets represent custom currencies and financial instruments ("colored ethereum clients coins"), the ownership underlying physical device ("smart property"), non-fungible assets webthree (c++) such domain names ("namecoin"), well more complex applications involving having geth (go) digital assets being directly controlled piece code implementing arbitrary rules ("smart pyeth (python) contracts") even blockchain-based "decentralized autonomous organizations" (daos). what ethereum intends provide blockchain with built-in fully fledged turing-complete programming language that can used create "contracts" that can used encode arbitrary state transition functions, allowing users create any the systems described above, well many others that have not yet imagined, simply writing the logic few lines code. dapp development dapp developer resources javascript api json rpc api solidity solidity features table contents useful dapp patterns standardized contract apis dapp using meteor history bitcoin state transition system mining merkle trees alternative blockchain applications scripting ethereum ethereum accounts messages and transactions ethereum state transition function code execution blockchain and mining applications ethereum development tutorial mix tutorial mix features serpent lll mutan dksv technologies rlp encoding rlpx node discovery protocol dksvpp wire protocol dksvpp whitepaper (wip) web secret storage ethereum technologies token systems patricia tree financial derivatives wire protocol identity and reputation systems light client protocol subtleties decentralized file storage solidity, docs abi decentralized autonomous organizations natspec format further applications contract abi miscellanea and concerns bad block reporting bad chain canary modified ghost implementation extra data fees brain wallet computation and turing-completeness currency and issuance mining centralization scalability ethash/dashimoto ethash ethash api conclusion notes and further reading introduction bitcoin and existing concepts ethash dag infrastructure development morden inter-exchange client address protocol url hint protocol history natspec determination the concept decentralized digital currency, well alternative applications like property mining registries, has been around for decades. the anonymous e-cash protocols the and the mostly reliant cryptographic primitive known chaumian blinding, provided currency with high degree privacy, but the protocols largely failed gain traction because their reliance centralized intermediary. wei dai's b-money became the first proposal exchange integration licensing network status raspberry concerning whisper introduce the idea creating money through solving computational puzzles well whisper proposal decentralized consensus, but the proposal was scant details how decentralized consensus whisper overview could actually implemented. hal finney introduced concept "reusable proofs work", system which uses ideas from b-money together with adam back's computationally difficult hashcash puzzles create concept for cryptocurrency, but once again fell short the ideal relying trusted computing backend. decentralized currency was for the poc- wire protocol poc- wire protocol poc- whitepaper misc first time implemented practice satoshi nakamoto, combining established primitives for hard problems managing ownership through public key cryptography with consensus algorithm for keeping track cryptocurrency who owns coins, known "proof work". chain fibers glossary the mechanism behind proof work was breakthrough the space because simultaneously solved two problems. first, provided simple and moderately effective consensus algorithm, allowing nodes the network collectively agree set canonical updates the state the bitcoin ledger. second, provided mechanism for allowing free entry into the consensus process, solving the political problem deciding who gets influence the consensus, while simultaneously preventing sybil attacks. does this substituting formal barrier participation, such the requirement registered unique entity particular list, with economic barrier the weight single node the consensus voting process directly proportional the computing power that the node brings. since then, alternative approach has been proposed called proof stake, calculating the weight node being proportional its currency holdings and not computational resources; the discussion the relative merits the two approaches beyond the scope this paper but should noted that both approaches can used serve the backbone cryptocurrency. bitcoin state transition system from technical standpoint, the ledger cryptocurrency such bitcoin can thought state transition system, where there "state" consisting the ownership status all existing bitcoins and "state transition function" that takes state and transaction and outputs new state which the result. standard banking system, for example, the state balance sheet, transaction request move from and the state transition function reduces the value a's account and increases the value b's account $x. a's account has less than the first place, the state transition function returns error. hence, one can formally define: apply(s,tx) error the banking system defined above: clone this wiki locally https://github.com/ethereum/wiki.wiki.git apply({ alice: bob: },"send from alice bob") alice: bob: but: apply({ alice: bob: },"send from alice bob") error the "state" bitcoin the collection all coins (technically, "unspent transaction outputs" utxo) that have been minted and not yet spent, with each utxo having denomination and owner (defined -byte address which essentially cryptographic public key[]). transaction contains one more inputs, with each input containing reference existing utxo and cryptographic signature produced the private key associated with the owner's address, and one more outputs, with each output containing new utxo added the state. the state transition function apply(s,tx) can defined roughly follows: for each input the referenced utxo not return error. the provided signature does not match the owner the utxo, return error. the sum the denominations all input utxo less than the sum the denominations all output utxo, return error. return with all input utxo removed and all output utxo added. the first half the first step prevents transaction senders from spending coins that not exist, the second half the first step prevents transaction senders from spending other people's coins, and the second step enforces conservation value. order use this for payment, the protocol follows. suppose alice wants send btc bob. first, alice will look for set available utxo that she owns that totals least btc. realistically, alice will not able get exactly btc; say that the smallest she can get ++=. she then creates transaction with those three inputs and two outputs. the first output will btc with bob's address its owner, and the second output will the remaining btc "change", with the owner being alice herself. mining had access trustworthy centralized service, this system would trivial implement; could simply coded exactly described, using centralized server's hard drive keep track the state. however, with bitcoin are trying build decentralized currency system, will need combine the state transaction system with consensus system order ensure that everyone agrees the order transactions. bitcoin's decentralized consensus process requires nodes the network continuously attempt produce packages transactions called "blocks". the network intended produce roughly one block every ten minutes, with each block containing timestamp, nonce, reference (ie. hash of) the previous block and list all the transactions that have taken place since the previous block. over time, this creates persistent, ever-growing, "blockchain" that constantly updates represent the latest state the bitcoin ledger. the algorithm for checking block valid, expressed this paradigm, follows: check the previous block referenced the block exists and valid. check that the timestamp the block greater than that the previous block[] and less than hours into the future check that the proof work the block valid. let s[] the state the end the previous block. suppose the block's transaction list with transactions. for all ...n- set s[i+] apply(s[i],tx[i]) any application returns error, exit and return false. return true, and register s[n] the state the end this block. essentially, each transaction the block must provide valid state transition from what was the canonical state before the transaction was executed some new state. note that the state not encoded the block any way; purely abstraction remembered the validating node and can only (securely) computed for any block starting from the genesis state and sequentially applying every transaction every block. additionally, note that the order which the miner includes transactions into the block matters; there are two transactions and block such that spends utxo created then the block will valid comes before but not otherwise. the one validity condition present the above list that not found other systems the requirement for "proof work". the precise condition that the double-sha hash every block, treated -bit number, must less than dynamically adjusted target, which the time this writing approximately the purpose this make block creation computationally "hard", thereby preventing sybil attackers from remaking the entire blockchain their favor. because sha designed completely unpredictable pseudorandom function, the only way create valid block simply trial and error, repeatedly incrementing the nonce and seeing the new hash matches. the current target the network must make average tries before valid block found; general, the target recalibrated the network every blocks that average new block produced some node the network every ten minutes. order compensate miners for this computational work, the miner every block entitled include transaction giving themselves btc out nowhere. additionally, any transaction has higher total denomination its inputs than its outputs, the difference also goes the miner "transaction fee". incidentally, this also the only mechanism which btc are issued; the genesis state contained coins all. order better understand the purpose mining, let examine what happens the event malicious attacker. since bitcoin's underlying cryptography known secure, the attacker will target the one part the bitcoin system that not protected cryptography directly: the order transactions. the attacker's strategy simple: send btc merchant exchange for some product (preferably rapid-delivery digital good) wait for the delivery the product produce another transaction sending the same btc himself try convince the network that his transaction himself was the one that came first. once step has taken place, after few minutes some miner will include the transaction block, say block number after about one hour, five more blocks will have been added the chain after that block, with each those blocks indirectly pointing the transaction and thus "confirming" it. this point, the merchant will accept the payment finalized and deliver the product; since are assuming this digital good, delivery instant. now, the attacker creates another transaction sending the btc himself. the attacker simply releases into the wild, the transaction will not processed; miners will attempt run apply(s,tx) and notice that consumes utxo which longer the state. instead, the attacker creates "fork" the blockchain, starting mining another version block pointing the same block parent but with the new transaction place the old one. because the block data different, this requires redoing the proof work. furthermore, the attacker's new version block has different hash, the original blocks not "point" it; thus, the original chain and the attacker's new chain are completely separate. the rule that fork the longest blockchain taken the truth, and legitimate miners will work the chain while the attacker alone working the chain. order for the attacker make his blockchain the longest, would need have more computational power than the rest the network combined order catch (hence, attack"). merkle trees left: suffices present only small number nodes merkle tree give proof the validity branch. right: any attempt change any part the merkle tree will eventually lead inconsistency somewhere the chain. important scalability feature bitcoin that the block stored multi-level data structure. the "hash" block actually only the hash the block header, roughly -byte piece data that contains the timestamp, nonce, previous block hash and the root hash data structure called the merkle tree storing all transactions the block. merkle tree type binary tree, composed set nodes with large number leaf nodes the bottom the tree containing the underlying data, set intermediate nodes where each node the hash its two children, and finally single root node, also formed from the hash its two children, representing the "top" the tree. the purpose the merkle tree allow the data block delivered piecemeal: node can download only the header block from one source, the small part the tree relevant them from another source, and still assured that all the data correct. the reason why this works that hashes propagate upward: malicious user attempts swap fake transaction into the bottom merkle tree, this change will cause change the node above, and then change the node above that, finally changing the root the tree and therefore the hash the block, causing the protocol register completely different block (almost certainly with invalid proof work). the merkle tree protocol arguably essential long-term sustainability. "full node" the bitcoin network, one that stores and processes the entirety every block, takes about disk space the bitcoin network april and growing over gigabyte per month. currently, this viable for some desktop computers and not phones, and later the future only businesses and hobbyists will able participate. protocol known "simplified payment verification" (spv) allows for another class nodes exist, called "light nodes", which download the block headers, verify the proof work the block headers, and then download only the "branches" associated with transactions that are relevant them. this allows light nodes determine with strong guarantee security what the status any bitcoin transaction, and their current balance, while downloading only very small portion the entire blockchain. alternative blockchain applications the idea taking the underlying blockchain idea and applying other concepts also has long history. nick szabo came out with the concept "secure property titles with owner authority", document describing how "new advances replicated database technology" will allow for blockchain-based system for storing registry who owns what land, creating elaborate framework including concepts such homesteading, adverse possession and georgian land tax. however, there was unfortunately effective replicated database system available the time, and the protocol was never implemented practice. after however, once bitcoin's decentralized consensus was developed number alternative applications rapidly began emerge. namecoin created namecoin best described decentralized name registration database. decentralized protocols like tor, bitcoin and bitmessage, there needs some way identifying accounts that other people can interact with them, but all existing solutions the only kind identifier available pseudorandom hash like lwwpzbqahwjltcibcrhqythaguwy ideally, one would like able have account with name like "george". however, the problem that one person can create account named "george" then someone else can use the same process register "george" for themselves well and impersonate them. the only solution first-to-file paradigm, where the first registerer succeeds and the second fails problem perfectly suited for the bitcoin consensus protocol. namecoin the oldest, and most successful, implementation name registration system using such idea. colored coins the purpose colored coins serve protocol allow people create their own digital currencies or, the important trivial case currency with one unit, digital tokens, the bitcoin blockchain. the colored coins protocol, one "issues" new currency publicly assigning color specific bitcoin utxo, and the protocol recursively defines the color other utxo the same the color the inputs that the transaction creating them spent (some special rules apply the case mixed-color inputs). this allows users maintain wallets containing only utxo specific color and send them around much like regular bitcoins, backtracking through the blockchain determine the color any utxo that they receive. metacoins the idea behind metacoin have protocol that lives top bitcoin, using bitcoin transactions store metacoin transactions but having different state transition function, apply' because the metacoin protocol cannot prevent invalid metacoin transactions from appearing the bitcoin blockchain, rule added that apply'(s,tx) returns error, the protocol defaults apply'(s,tx) this provides easy mechanism for creating arbitrary cryptocurrency protocol, potentially with advanced features that cannot implemented inside bitcoin itself, but with very low development cost since the complexities mining and networking are already handled the bitcoin protocol. metacoins have been used implement some classes financial contracts, name registration and decentralized exchange. thus, general, there are two approaches toward building consensus protocol: building independent network, and building protocol top bitcoin. the former approach, while reasonably successful the case applications like namecoin, difficult implement; each individual implementation needs bootstrap independent blockchain, well building and testing all the necessary state transition and networking code. additionally, predict that the set applications for decentralized consensus technology will follow power law distribution where the vast majority applications would too small warrant their own blockchain, and note that there exist large classes decentralized applications, particularly decentralized autonomous organizations, that need interact with each other. the bitcoin-based approach, the other hand, has the flaw that does not inherit the simplified payment verification features bitcoin. spv works for bitcoin because can use blockchain depth proxy for validity; some point, once the ancestors transaction far enough back, safe say that they were legitimately part the state. blockchain-based meta-protocols, the other hand, cannot force the blockchain not include transactions that are not valid within the context their own protocols. hence, fully secure spv meta-protocol implementation would need backward scan all the way the beginning the bitcoin blockchain determine whether not certain transactions are valid. currently, all "light" implementations bitcoin-based metaprotocols rely trusted server provide the data, arguably highly suboptimal result especially when one the primary purposes cryptocurrency eliminate the need for trust. scripting even without any extensions, the bitcoin protocol actually does facilitate weak version concept "smart contracts". utxo bitcoin can owned not just public key, but also more complicated script expressed simple stack-based programming language. this paradigm, transaction spending that utxo must provide data that satisfies the script. indeed, even the basic public key ownership mechanism implemented via script: the script takes elliptic curve signature input, verifies against the transaction and the address that owns the utxo, and returns the verification successful and otherwise. other, more complicated, scripts exist for various additional use cases. for example, one can construct script that requires signatures from two out given three private keys validate ("multisig"), setup useful for corporate accounts, secure savings accounts and some merchant escrow situations. scripts can also used pay bounties for solutions computational problems, and one can even construct script that says something like "this bitcoin utxo yours you can provide spv proof that you sent dogecoin transaction this denomination me", essentially allowing decentralized crosscryptocurrency exchange. however, the scripting language implemented bitcoin has several important limitations: lack turing-completeness that say, while there large subset computation that the bitcoin scripting language supports, does not nearly support everything. the main category that missing loops. this done avoid infinite loops during transaction verification; theoretically surmountable obstacle for script programmers, since any loop can simulated simply repeating the underlying code many times with statement, but does lead scripts that are very space-inefficient. for example, implementing alternative elliptic curve signature algorithm would likely require repeated multiplication rounds all individually included the code. value-blindness there way for utxo script provide fine-grained control over the amount that can withdrawn. for example, one powerful use case oracle contract would hedging contract, where and put worth btc and after days the script sends worth btc and the rest this would require oracle determine the value btc usd, but even then massive improvement terms trust and infrastructure requirement over the fully centralized solutions that are available now. however, because utxo are all-or-nothing, the only way achieve this through the very inefficient hack having many utxo varying denominations (eg. one utxo for every and having pick which utxo send and which lack state utxo can either spent unspent; there opportunity for multi-stage contracts scripts which keep any other internal state beyond that. this makes hard make multi-stage options contracts, decentralized exchange offers two-stage cryptographic commitment protocols (necessary for secure computational bounties). also means that utxo can only used build simple, one-off contracts and not more complex "stateful" contracts such decentralized organizations, and makes meta-protocols difficult implement. binary state combined with value-blindness also mean that another important application, withdrawal limits, impossible. blockchain-blindness utxo are blind blockchain data such the nonce, the timestamp and previous block hash. this severely limits applications gambling, and several other categories, depriving the scripting language potentially valuable source randomness. thus, see three approaches building advanced applications top cryptocurrency: building new blockchain, using scripting top bitcoin, and building meta-protocol top bitcoin. building new blockchain allows for unlimited freedom building feature set, but the cost development time, bootstrapping effort and security. using scripting easy implement and standardize, but very limited its capabilities, and meta-protocols, while easy, suffer from faults scalability. with ethereum, intend build alternative framework that provides even larger gains ease development well even stronger light client properties, while the same time allowing applications share economic environment and blockchain security. ethereum the intent ethereum create alternative protocol for building decentralized applications, providing different set tradeoffs that believe will very useful for large class decentralized applications, with particular emphasis situations where rapid development time, security for small and rarely used applications, and the ability different applications very efficiently interact, are important. ethereum does this building what essentially the ultimate abstract foundational layer: blockchain with built-in turing-complete programming language, allowing anyone write smart contracts and decentralized applications where they can create their own arbitrary rules for ownership, transaction formats and state transition functions. bare-bones version namecoin can written two lines code, and other protocols like currencies and reputation systems can built under twenty. smart contracts, cryptographic "boxes" that contain value and only unlock certain conditions are met, can also built top the platform, with vastly more power than that offered bitcoin scripting because the added powers turingcompleteness, value-awareness, blockchain-awareness and state. ethereum accounts ethereum, the state made objects called "accounts", with each account having -byte address and state transitions being direct transfers value and information between accounts. ethereum account contains four fields: the nonce, counter used make sure each transaction can only processed once the account's current ether balance the account's contract code, present the account's storage (empty default) "ether" the main internal crypto-fuel ethereum, and used pay transaction fees. general, there are two types accounts: externally owned accounts, controlled private keys, and contract accounts, controlled their contract code. externally owned account has code, and one can send messages from externally owned account creating and signing transaction; contract account, every time the contract account receives message its code activates, allowing read and write internal storage and send other messages create contracts turn. note that "contracts" ethereum should not seen something that should "fulfilled" "complied with"; rather, they are more like "autonomous agents" that live inside the ethereum execution environment, always executing specific piece code when "poked" message transaction, and having direct control over their own ether balance and their own key/value store keep track persistent variables. messages and transactions the term "transaction" used ethereum refer the signed data package that stores message sent from externally owned account. transactions contain: the recipient the message signature identifying the sender the amount ether transfer from the sender the recipient optional data field startgas value, representing the maximum number computational steps the transaction execution allowed take gasprice value, representing the fee the sender pays per computational step the first three are standard fields expected any cryptocurrency. the data field has function default, but the virtual machine has opcode using which contract can access the data; example use case, contract functioning on-blockchain domain registration service, then may wish interpret the data being passed containing two "fields", the first field being domain register and the second field being the address register to. the contract would read these values from the message data and appropriately place them storage. the startgas and gasprice fields are crucial for ethereum's anti-denial service model. order prevent accidental hostile infinite loops other computational wastage code, each transaction required set limit how many computational steps code execution can use. the fundamental unit computation "gas"; usually, computational step costs gas, but some operations cost higher amounts gas because they are more computationally expensive, increase the amount data that must stored part the state. there also fee gas for every byte the transaction data. the intent the fee system require attacker pay proportionately for every resource that they consume, including computation, bandwidth and storage; hence, any transaction that leads the network consuming greater amount any these resources must have gas fee roughly proportional the increment. messages contracts have the ability send "messages" other contracts. messages are virtual objects that are never serialized and exist only the ethereum execution environment. message contains: the sender the message (implicit) the recipient the message the amount ether transfer alongside the message optional data field startgas value essentially, message like transaction, except produced contract and not external actor. message produced when contract currently executing code executes the call opcode, which produces and executes message. like transaction, message leads the recipient account running its code. thus, contracts can have relationships with other contracts exactly the same way that external actors can. note that the gas allowance assigned transaction contract applies the total gas consumed that transaction and all sub-executions. for example, external actor sends transaction with gas, and consumes gas before sending message and the internal execution consumes gas before returning, then can spend another gas before running out gas. ethereum state transition function the ethereum state transition function, apply(s,tx) can defined follows: check the transaction well-formed (ie. has the right number values), the signature valid, and the nonce matches the nonce the sender's account. not, return error. calculate the transaction fee startgas gasprice and determine the sending address from the signature. subtract the fee from the sender's account balance and increment the sender's nonce. there not enough balance spend, return error. initialize gas startgas and take off certain quantity gas per byte pay for the bytes the transaction. transfer the transaction value from the sender's account the receiving account. the receiving account does not yet exist, create it. the receiving account contract, run the contract's code either completion until the execution runs out gas. the value transfer failed because the sender did not have enough money, the code execution ran out gas, revert all state changes except the payment the fees, and add the fees the miner's account. otherwise, refund the fees for all remaining gas the sender, and send the fees paid for gas consumed the miner. for example, suppose that the contract's code is: !self.storage[calldataload()]: self.storage[calldataload()] calldataload() note that reality the contract code written the low-level evm code; this example written serpent, one our high-level languages, for clarity, and can compiled down evm code. suppose that the contract's storage starts off empty, and transaction sent with ether value, gas, ether gasprice, and bytes data, with bytes representing the number and bytes representing the string charlie the process for the state transition function this case follows: check that the transaction valid and well formed. check that the transaction sender has least ether. is, then subtract ether from the sender's account. initialize gas assuming the transaction bytes long and the byte-fee subtract that there gas left. subtract more ether from the sender's account, and add the contract's account. run the code. this case, this simple: checks the contract's storage index used, notices that not, and sets the storage index the value charlie suppose this takes gas, the remaining amount gas add ether back the sender's account, and return the resulting state. there was contract the receiving end the transaction, then the total transaction fee would simply equal the provided gasprice multiplied the length the transaction bytes, and the data sent alongside the transaction would irrelevant. note that messages work equivalently transactions terms reverts: message execution runs out gas, then that message's execution, and all other executions triggered that execution, revert, but parent executions not need revert. this means that "safe" for contract call another contract, calls with gas then a's execution guaranteed lose most gas. finally, note that there opcode, create that creates contract; its execution mechanics are generally similar call with the exception that the output the execution determines the code newly created contract. code execution the code ethereum contracts written low-level, stack-based bytecode language, referred "ethereum virtual machine code" "evm code". the code consists series bytes, where each byte represents operation. general, code execution infinite loop that consists repeatedly carrying out the operation the current program counter (which begins zero) and then incrementing the program counter one, until the end the code reached error stop return instruction detected. the operations have access three types space which store data: the stack, last-in-first-out container which values can pushed and popped memory, infinitely expandable byte array the contract's long-term storage, key/value store. unlike stack and memory, which reset after computation ends, storage persists for the long term. the code can also access the value, sender and data the incoming message, well block header data, and the code can also return byte array data output. the formal execution model evm code surprisingly simple. while the ethereum virtual machine running, its full computational state can defined the tuple (block_state, transaction, message, code, memory, stack, pc, gas) where block_state the global state containing all accounts and includes balances and storage. the start every round execution, the current instruction found taking the byte code (or len(code) and each instruction has its own definition terms how affects the tuple. for example, add pops two items off the stack and pushes their sum, reduces gas and increments and sstore pushes the top two items off the stack and inserts the second item into the contract's storage the index specified the first item. although there are many ways optimize ethereum virtual machine execution via just-in-time compilation, basic implementation ethereum can done few hundred lines code. blockchain and mining the ethereum blockchain many ways similar the bitcoin blockchain, although does have some differences. the main difference between ethereum and bitcoin with regard the blockchain architecture that, unlike bitcoin, ethereum blocks contain copy both the transaction list and the most recent state. aside from that, two other values, the block number and the difficulty, are also stored the block. the basic block validation algorithm ethereum follows: check the previous block referenced exists and valid. check that the timestamp the block greater than that the referenced previous block and less than minutes into the future check that the block number, difficulty, transaction root, uncle root and gas limit (various lowlevel ethereum-specific concepts) are valid. check that the proof work the block valid. let s[] the state the end the previous block. let the block's transaction list, with transactions. for all ...n- set s[i+] apply(s[i],tx[i]) any applications returns error, the total gas consumed the block until this point exceeds the gaslimit return error. let s_final s[n] but adding the block reward paid the miner. check the merkle tree root the state s_final equal the final state root provided the block header. is, the block valid; otherwise, not valid. the approach may seem highly inefficient first glance, because needs store the entire state with each block, but reality efficiency should comparable that bitcoin. the reason that the state stored the tree structure, and after every block only small part the tree needs changed. thus, general, between two adjacent blocks the vast majority the tree should the same, and therefore the data can stored once and referenced twice using pointers (ie. hashes subtrees). special kind tree known "patricia tree" used accomplish this, including modification the merkle tree concept that allows for nodes inserted and deleted, and not just changed, efficiently. additionally, because all the state information part the last block, there need store the entire blockchain history strategy which, could applied bitcoin, can calculated provide savings space. commonly asked question "where" contract code executed, terms physical hardware. this has simple answer: the process executing contract code part the definition the state transition function, which part the block validation algorithm, transaction added into block the code execution spawned that transaction will executed all nodes, now and the future, that download and validate block applications general, there are three types applications top ethereum. the first category financial applications, providing users with more powerful ways managing and entering into contracts using their money. this includes sub-currencies, financial derivatives, hedging contracts, savings wallets, wills, and ultimately even some classes full-scale employment contracts. the second category semi-financial applications, where money involved but there also heavy nonmonetary side what being done; perfect example self-enforcing bounties for solutions computational problems. finally, there are applications such online voting and decentralized governance that are not financial all. token systems on-blockchain token systems have many applications ranging from sub-currencies representing assets such usd gold company stocks, individual tokens representing smart property, secure unforgeable coupons, and even token systems with ties conventional value all, used point systems for incentivization. token systems are surprisingly easy implement ethereum. the key point understand that all currency, token system, fundamentally database with one operation: subtract units from and give units with the proviso that (i) had least units before the transaction and the transaction approved all that takes implement token system implement this logic into contract. the basic code for implementing token system serpent looks follows: def send(to, value): self.storage[msg.sender] value: self.storage[msg.sender] self.storage[msg.sender] value self.storage[to] self.storage[to] value this essentially literal implementation the "banking system" state transition function described further above this document. few extra lines code need added provide for the initial step distributing the currency units the first place and few other edge cases, and ideally function would added let other contracts query for the balance address. but that's all there it. theoretically, ethereum-based token systems acting sub-currencies can potentially include another important feature that on-chain bitcoin-based meta-currencies lack: the ability pay transaction fees directly that currency. the way this would implemented that the contract would maintain ether balance with which would refund ether used pay fees the sender, and would refill this balance collecting the internal currency units that takes fees and reselling them constant running auction. users would thus need "activate" their accounts with ether, but once the ether there would reusable because the contract would refund each time. financial derivatives and stable-value currencies financial derivatives are the most common application "smart contract", and one the simplest implement code. the main challenge implementing financial contracts that the majority them require reference external price ticker; for example, very desirable application smart contract that hedges against the volatility ether (or another cryptocurrency) with respect the dollar, but doing this requires the contract know what the value eth/usd is. the simplest way this through "data feed" contract maintained specific party (eg. nasdaq) designed that that party has the ability update the contract needed, and providing interface that allows other contracts send message that contract and get back response that provides the price. given that critical ingredient, the hedging contract would look follows: wait for party input ether. wait for party input ether. record the usd value ether, calculated querying the data feed contract, storage, say this $x. after days, allow "reactivate" the contract order send worth ether (calculated querying the data feed contract again get the new price) and the rest such contract would have significant potential crypto-commerce. one the main problems cited about cryptocurrency the fact that it's volatile; although many users and merchants may want the security and convenience dealing with cryptographic assets, they many not wish face that prospect losing the value their funds single day. until now, the most commonly proposed solution has been issuer-backed assets; the idea that issuer creates sub-currency which they have the right issue and revoke units, and provide one unit the currency anyone who provides them (offline) with one unit specified underlying asset (eg. gold, usd). the issuer then promises provide one unit the underlying asset anyone who sends back one unit the crypto-asset. this mechanism allows any non-cryptographic asset "uplifted" into cryptographic asset, provided that the issuer can trusted. practice, however, issuers are not always trustworthy, and some cases the banking infrastructure too weak, too hostile, for such services exist. financial derivatives provide alternative. here, instead single issuer providing the funds back asset, decentralized market speculators, betting that the price cryptographic reference asset (eg. eth) will up, plays that role. unlike issuers, speculators have option default their side the bargain because the hedging contract holds their funds escrow. note that this approach not fully decentralized, because trusted source still needed provide the price ticker, although arguably even still this massive improvement terms reducing infrastructure requirements (unlike being issuer, issuing price feed requires licenses and can likely categorized free speech) and reducing the potential for fraud. identity and reputation systems the earliest alternative cryptocurrency all, namecoin, attempted use bitcoin-like blockchain provide name registration system, where users can register their names public database alongside other data. the major cited use case for dns system, mapping domain names like "bitcoin.org" (or, namecoin's case, "bitcoin.bit") address. other use cases include email authentication and potentially more advanced reputation systems. here the basic contract provide namecoin-like name registration system ethereum: def register(name, value): !self.storage[name]: self.storage[name] value the contract very simple; all database inside the ethereum network that can added to, but not modified removed from. anyone can register name with some value, and that registration then sticks forever. more sophisticated name registration contract will also have "function clause" allowing other contracts query it, well mechanism for the "owner" (ie. the first registerer) name change the data transfer ownership. one can even add reputation and web-of-trust functionality top. decentralized file storage over the past few years, there have emerged number popular online file storage startups, the most prominent being dropbox, seeking allow users upload backup their hard drive and have the service store the backup and allow the user access exchange for monthly fee. however, this point the file storage market times relatively inefficient; cursory look various existing solutions shows that, particularly the "uncanny valley" level which neither free quotas nor enterprise-level discounts kick in, monthly prices for mainstream file storage costs are such that you are paying for more than the cost the entire hard drive single month. ethereum contracts can allow for the development decentralized file storage ecosystem, where individual users can earn small quantities money renting out their own hard drives and unused space can used further drive down the costs file storage. the key underpinning piece such device would what have termed the "decentralized dropbox contract". this contract works follows. first, one splits the desired data into blocks, encrypting each block for privacy, and builds merkle tree out it. one then makes contract with the rule that, every blocks, the contract would pick random index the merkle tree (using the previous block hash, accessible from contract code, source randomness), and give ether the first entity supply transaction with simplified payment verification-like proof ownership the block that particular index the tree. when user wants re-download their file, they can use micropayment channel protocol (eg. pay szabo per kilobytes) recover the file; the most fee-efficient approach for the payer not publish the transaction until the end, instead replacing the transaction with slightly more lucrative one with the same nonce after every kilobytes. important feature the protocol that, although may seem like one trusting many random nodes not decide forget the file, one can reduce that risk down near-zero splitting the file into many pieces via secret sharing, and watching the contracts see each piece still some node's possession. contract still paying out money, that provides cryptographic proof that someone out there still storing the file. decentralized autonomous organizations the general concept "decentralized autonomous organization" that virtual entity that has certain set members shareholders which, perhaps with majority, have the right spend the entity's funds and modify its code. the members would collectively decide how the organization should allocate its funds. methods for allocating dao's funds could range from bounties, salaries even more exotic mechanisms such internal currency reward work. this essentially replicates the legal trappings traditional company nonprofit but using only cryptographic blockchain technology for enforcement. far much the talk around daos has been around the "capitalist" model "decentralized autonomous corporation" (dac) with dividend-receiving shareholders and tradable shares; alternative, perhaps described "decentralized autonomous community", would have all members have equal share the decision making and require existing members agree add remove member. the requirement that one person can only have one membership would then need enforced collectively the group. general outline for how code dao follows. the simplest design simply piece selfmodifying code that changes two thirds members agree change. although code theoretically immutable, one can easily get around this and have de-facto mutability having chunks the code separate contracts, and having the address which contracts call stored the modifiable storage. simple implementation such dao contract, there would three transaction types, distinquished the data provided the transaction: [,i,k,v] register proposal with index change the address storage index value [,i] register vote favor proposal [,i] finalize proposal enough votes have been made the contract would then have clauses for each these. would maintain record all open storage changes, along with list who voted for them. would also have list all members. when any storage change gets two thirds members voting for it, finalizing transaction could execute the change. more sophisticated skeleton would also have built-in voting ability for features like sending transaction, adding members and removing members, and may even provide for liquid democracy-style vote delegation (ie. anyone can assign someone vote for them, and assignment transitive assigns and assigns then determines a's vote). this design would allow the dao grow organically decentralized community, allowing people eventually delegate the task filtering out who member specialists, although unlike the "current system" specialists can easily pop and out existence over time individual community members change their alignments. alternative model for decentralized corporation, where any account can have zero more shares, and two thirds the shares are required make decision. complete skeleton would involve asset management functionality, the ability make offer buy sell shares, and the ability accept offers (preferably with order-matching mechanism inside the contract). delegation would also exist liquid democracy-style, generalizing the concept "board directors". further applications savings wallets. suppose that alice wants keep her funds safe, but worried that she will lose someone will hack her private key. she puts ether into contract with bob, bank, follows: alice alone can withdraw maximum the funds per day. bob alone can withdraw maximum the funds per day, but alice has the ability make transaction with her key shutting off this ability. alice and bob together can withdraw anything. normally, per day enough for alice, and alice wants withdraw more she can contact bob for help. alice's key gets hacked, she runs bob move the funds new contract. she loses her key, bob will get the funds out eventually. bob turns out malicious, then she can turn off his ability withdraw. crop insurance. one can easily make financial derivatives contract but using data feed the weather instead any price index. farmer iowa purchases derivative that pays out inversely based the precipitation iowa, then there drought, the farmer will automatically receive money and there enough rain the farmer will happy because their crops would well. this can expanded natural disaster insurance generally. decentralized data feed. for financial contracts for difference, may actually possible decentralize the data feed via protocol called "schellingcoin". schellingcoin basically works follows: parties all put into the system the value given datum (eg. the eth/usd price), the values are sorted, and everyone between the and percentile gets one token reward. everyone has the incentive provide the answer that everyone else will provide, and the only value that large number players can realistically agree the obvious default: the truth. this creates decentralized protocol that can theoretically provide any number values, including the eth/usd price, the temperature berlin even the result particular hard computation. smart multisignature escrow. bitcoin allows multisignature transaction contracts where, for example, three out given five keys can spend the funds. ethereum allows for more granularity; for example, four out five can spend everything, three out five can spend per day, and two out five can spend per day. additionally, ethereum multisig asynchronous two parties can register their signatures the blockchain different times and the last signature will automatically send the transaction. cloud computing. the evm technology can also used create verifiable computing environment, allowing users ask others carry out computations and then optionally ask for proofs that computations certain randomly selected checkpoints were done correctly. this allows for the creation cloud computing market where any user can participate with their desktop, laptop specialized server, and spot-checking together with security deposits can used ensure that the system trustworthy (ie. nodes cannot profitably cheat). although such system may not suitable for all tasks; tasks that require high level inter-process communication, for example, cannot easily done large cloud nodes. other tasks, however, are much easier parallelize; projects like seti@home, folding@home and genetic algorithms can easily implemented top such platform. peer-to-peer gambling. any number peer-to-peer gambling protocols, such frank stajano and richard clayton's cyberdice, can implemented the ethereum blockchain. the simplest gambling protocol actually simply contract for difference the next block hash, and more advanced protocols can built from there, creating gambling services with near-zero fees that have ability cheat. prediction markets. provided oracle schellingcoin, prediction markets are also easy implement, and prediction markets together with schellingcoin may prove the first mainstream application futarchy governance protocol for decentralized organizations. on-chain decentralized marketplaces, using the identity and reputation system base. miscellanea and concerns modified ghost implementation the "greedy heaviest observed subtree" (ghost) protocol innovation first introduced yonatan sompolinsky and aviv zohar december the motivation behind ghost that blockchains with fast confirmation times currently suffer from reduced security due high stale rate because blocks take certain time propagate through the network, miner mines block and then miner happens mine another block before miner a's block propagates miner b's block will end wasted and will not contribute network security. furthermore, there centralization issue: miner mining pool with hashpower and has hashpower, will have risk producing stale block the time (since the other the time produced the last block and will get mining data immediately) whereas will have risk producing stale block the time. thus, the block interval short enough for the stale rate high, will substantially more efficient simply virtue its size. with these two effects combined, blockchains which produce blocks quickly are very likely lead one mining pool having large enough percentage the network hashpower have facto control over the mining process. described sompolinsky and zohar, ghost solves the first issue network security loss including stale blocks the calculation which chain the "longest"; that say, not just the parent and further ancestors block, but also the stale descendants the block's ancestor (in ethereum jargon, "uncles") are added the calculation which block has the largest total proof work backing it. solve the second issue centralization bias, beyond the protocol described sompolinsky and zohar, and also provide block rewards stales: stale block receives its base reward, and the nephew that includes the stale block receives the remaining .%. transaction fees, however, are not awarded uncles. ethereum implements simplified version ghost which only goes down seven levels. specifically, defined follows: block must specify parent, and must specify more uncles uncle included block must have the following properties: must direct child the kth generation ancestor where note that the per-operation fee provided the sender, and thus lower bound the benefit that the sender derives from the transaction, and the cost the entire network together processing operation. hence, miners have the incentive include only those transactions for which the total utilitarian benefit exceeds the cost. however, there are several important deviations from those assumptions reality: the miner does pay higher cost process the transaction than the other verifying nodes, since the extra verification time delays block propagation and thus increases the chance the block will become stale. there exist nonmining full nodes. the mining power distribution may end radically inegalitarian practice. speculators, political enemies and crazies whose utility function includes causing harm the network exist, and they can cleverly set contracts where their cost much lower than the cost paid other verifying nodes. provides tendency for the miner include fewer transactions, and increases hence, these two effects least partially cancel each other out. and are the major issue; solve them simply institute floating cap: block can have more operations than blk_limit_factor times the long-term exponential moving average. specifically: blk.oplimit floor((blk.parent.oplimit (emafactor floor(parent.opcount blk_limit_factor)) ema_factor) blk_limit_factor and ema_factor are constants that will set and for the time being, but will likely changed after further analysis. there another factor disincentivizing large block sizes bitcoin: blocks that are large will take longer propagate, and thus have higher probability becoming stales. ethereum, highly gas-consuming blocks can also take longer propagate both because they are physically larger and because they take longer process the transaction state transitions validate. this delay disincentive significant consideration bitcoin, but less ethereum because the ghost protocol; hence, relying regulated block limits provides more stable baseline. computation and turing-completeness important note that the ethereum virtual machine turing-complete; this means that evm code can encode any computation that can conceivably carried out, including infinite loops. evm code allows looping two ways. first, there jump instruction that allows the program jump back previous spot the code, and jumpi instruction conditional jumping, allowing for statements like while s[i] nodes would able use those nodes run that part the computation, and see that the s[i] generated does not match the s[i] provided. another, more sophisticated, attack would involve the malicious miners publishing incomplete blocks, the full information does not even exist determine whether not blocks are valid. the solution this challenge-response protocol: verification nodes issue "challenges" the form target transaction indices, and upon receiving node light node treats the block untrusted until another node, whether the miner another verifier, provides subset patricia nodes proof validity. conclusion the ethereum protocol was originally conceived upgraded version cryptocurrency, providing advanced features such on-blockchain escrow, withdrawal limits, financial contracts, gambling markets and the like via highly generalized programming language. the ethereum protocol would not "support" any the applications directly, but the existence turing-complete programming language means that arbitrary contracts can theoretically created for any transaction type application. what more interesting about ethereum, however, that the ethereum protocol moves far beyond just currency. protocols around decentralized file storage, decentralized computation and decentralized prediction markets, among dozens other such concepts, have the potential substantially increase the efficiency the computational industry, and provide massive boost other peer-to-peer protocols adding for the first time economic layer. finally, there also substantial array applications that have nothing with money all. the concept arbitrary state transition function implemented the ethereum protocol provides for platform with unique potential; rather than being closed-ended, single-purpose protocol intended for specific array applications data storage, gambling finance, ethereum open-ended design, and believe that extremely well-suited serving foundational layer for very large number both financial and non-financial protocols the years come. notes and further reading notes sophisticated reader may notice that fact bitcoin address the hash the elliptic curve public key, and not the public key itself. however, fact perfectly legitimate cryptographic terminology refer the pubkey hash public key itself. this because bitcoin's cryptography can considered custom digital signature algorithm, where the public key consists the hash the ecc pubkey, the signature consists the ecc pubkey concatenated with the ecc signature, and the verification algorithm involves checking the ecc pubkey the signature against the ecc pubkey hash provided public key and then verifying the ecc signature against the ecc pubkey. technically, the median the previous blocks. internally, and "charlie" are both numbers, with the latter being big-endian base representation. numbers can least and most further reading intrinsic value: http://bitcoinmagazine.com//an-exploration-of-intrinsic-value-what-it-iswhy-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it/ smart property: https://en.bitcoin.it/wiki/smart_property smart contracts: https://en.bitcoin.it/wiki/contracts b-money: http://www.weidai.com/bmoney.txt reusable proofs work: http://www.finney.org/~hal/rpow/ secure property titles with owner authority: http://szabo.best.vwh.net/securetitle.html bitcoin whitepaper: http://bitcoin.org/bitcoin.pdf namecoin: https://namecoin.org/ zooko's triangle: http://en.wikipedia.org/wiki/zooko's_triangle colored coins whitepaper: https://docs.google.com/a/buterin.com/document/d/ankp_cvztcmlizwdvswmqjclizr tluowuzbe/edit mastercoin whitepaper: https://github.com/mastercoin-msc/spec decentralized autonomous corporations, bitcoin magazine: http://bitcoinmagazine.com//bootstrapping-a-decentralized-autonomous-corporation-part-i/ simplified payment verification: https://en.bitcoin.it/wiki/scalability#simplifiedpaymentverification merkle trees: http://en.wikipedia.org/wiki/merkle_tree patricia trees: http://en.wikipedia.org/wiki/patricia_tree ghost: http://www.cs.huji.ac.il/~avivz/pubs//btc_scalability_full.pdf storj and autonomous agents, jeff garzik: http://garzikrants.blogspot.ca///storj-andbitcoin-autonomous-agents.html mike hearn smart property turing festival: http://www.youtube.com/watch? v=pupamfpoy ethereum rlp: https://github.com/ethereum/wiki/wiki/%benglish%d-rlp ethereum merkle patricia trees: https://github.com/ethereum/wiki/wiki/%benglish%dpatricia-tree peter todd merkle sum trees: http://sourceforge.net/p/bitcoin/mailman/message// english japanese romanian german chinese italian spanish french persian) hangeul (korean) (c) github, inc. terms privacy security contact help status api training shop blog about pricing