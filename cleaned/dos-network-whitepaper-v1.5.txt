ecentralized racle rvice boosting blockchain usability with off-chain data verifiable computing power info@dos.network last update: table contents introduction motivation existing approaches introducing dos network detailed design high-level architecture on-chain detailed design proxy system on-chain governance systems off-chain detailed design part decentralized data feed oracle part ii: computation oracle cross-chain interoperability premium data feeds and marketplace future r&d work token economy participants dos system network bootstrap token distribution use cases decentralized derivatives stablecoins decentralized lending platform decentralized insurance decentralized casino decentralized prediction market decentralized computation market and execution scalability references appendixes introduction motivation blockchain, the distributed ledger technology, gaining massive attention all over the world. emerging from bitcoin blockchain has features such distributed global states, tamperproof the byzantine environment, and central authorities single point failure; thus blockchain believed the building block trust and value exchange. moreover, the advent ethereum pushes decentralized economy one step further, introducing user-defined states and turing-complete virtual machine, enabling the booming decentralized applications well smart contracts. although that nowadays the killer apps blockchains are probably decentralized trustless crowdfunding and some game-theory based financial games, smart contracts and dapps are being developed talents all industries: content monetization, decentralized cloud storage, insurance, games, decentralized casino and prediction markets, etc. strongly believe that blockchains and smart contracts are still their infancy, with more and more unimaginable use cases coming. however, due the inherent limitation existing blockchains' consensus mechanisms and their deterministic virtual machines, currently there are two biggest issues hindering the widespread adoption smart contracts and the emergence large-scale commercial dapps: smart contracts can neither directly pull internet data nor invoke external web api themselves, while it's inevitable for any commercial applications such insurance interact with the real world especially with the internet. on-chain computation resource and capacity are fact very expensive and limited existing smart contract platforms such ethereum. together with execution gas cost, block gas limit and verifier's dilemma leads execution scalability issues and makes infeasible, not impossible, achieve commercial computation goals such large-scale matrix multiplication, model training, rendering, etc. on-chain computing the smart contract. overcoming these problems important resolving current blockchains' transaction throughput issues. necessary make same amount effort enrich smart contracts and decentralized economy with real world events and more computing powers before blockchain hits mass adoption. problem definition and existing approaches complexity and computability theory, define oracle entity which capable resolving any decision problem and/or function problem. oracle basically treated "black box" that provides solutions for any given request. specifically, the context blockchain and smart contract, classify oracle machine into two categories: data feed oracle feeding external data smart contracts upon request, unlocking the potential interactions between business-level smart contract and off-chain events. computation oracle performing user-defined computation-intensive tasks off-chain, supplying unlimited computing power existing blockchains, bringing decentralized token economy the traditional computation market. but oracle off-chain third-party service that not governed blockchain consensus mechanism, the main concern then how trust those third-party services' honesty. there're several existing centralized and decentralized oracle solutions: some them are focused feeding external data smart contracts, while others are focused fixing the on-chain computation problem, with majority them are built for ethereum blockchain: data feed oracle oraclize provides centralized data feed oracle service for ethereum blockchain. with the help amazon web services (aws) and tlsnotary proof oraclize proves itself have performed the calling contracts' requests faithfully. however, dapps not favor centralized solution essence not only that the trust dependency shifted oraclize company and then amazon, but also since system only decentralized the most centralized component within it, oraclize becomes the single point failure (spof) the whole stack. another dilemma that tlsnotary proofs themselves are gigantic size, passing proofs back on-chain costs tons gas, which paid the end user the calling contract. the proofs cannot easily verified on-chain the calling contract real time. the extra cost the bloated proof plus premium charged oraclize their profit make the total cost using oraclize much higher than what claimed their document. oraclize has been running its business since and turns out quite popular oracle service for the time being, probably due the lack other friendly and usable oracle services. town crier another centralized data feed oracle built ethereum blockchain, mainly utilizing intel software guard extension (sgx) deliver authenticated data feeds smart contracts. sgx manages trusted execution environment (tee) named "enclave", inside which core user program code executed and protected against other malicious programs, including the operating system itself. the secure execution the core user program code inside sgx enclave could also remotely attested end users. sgx and many other commercial tee are closed-source and/or undocumented, thus the trust dependency shifted the design and implementation intel company well hardware manufacturers. this may sound better than oraclize's solution, but town crier also comes with its own problems: centralized solution, suffers from the same spof issue mentioned above. sgx suffers from the most recent security vulnerabilities like foreshadow and spectre targeting intel cpu and sgx, which not easily patchable without severely hurting performance. researchers have also revealed other security issues such synchronization bugs and other attacks hijack control flow and leaking private information from sgx enclaves. town crier only supports limited types apis and data feeds, and exclusively built for ethereum blockchain. town crier has started serving ethereum mainnet since may, but seldom used comparing oraclize. chainlink the first proposed decentralized oracle ethereum blockchain. aims perform on-chain aggregation with governances ensure data correctness its current development plan. on-chain aggregation appears straight-forward, but has several drawbacks, the biggest which its excessive gas consumptions the number transactions spamming the blockchain proportional the number oracle clients participated each consensus round. its long-term roadmap, would explore approaches support off-chain aggregation. however, its protocol and signature scheme interactive and involves multiple rounds message communications, and worst condition requires majority off-chain clients participate thus with poor performance and scalability. moreover, reputation based oracle node selection easily leads the matthew effect and prone collusion and targeted attacks. also claims the long-term plan explore the use intel sgx, the pros and cons which has been described the previous section. chainlink has finished its token sale september, until now, still developing on-chain aggregation implementation and usable product yet. augur and gnosis are decentralized prediction markets that bring the predicted results real world events into blockchain means collective intelligence. ideally voting distributed different token holders and the predicted result consented majority votes. augur and gnosis are good reporting low-frequent and future events such presidential election result, sports bettings, etc. however, they are not appropriate for reporting the more-often real-time and on-demand events due heavy user engagement and therefore long delay. moreover, the credibility predicted result may compromised the token distribution not even e.g. gnosis team holding all gno tokens. computation oracle oraclize also supports simple computation script running outsourcing sandboxed aws virtual machine. the computation task needs follow specific format defined oraclize, and any large-scale use oraclize computation oracle hasn't been seen yet. besides that, other features oraclize can found the data feed oracle section above. sgx based computation oracle: there are some projects and startups currently investigating the possibility using sgx other trusted hardware perform off-chain computation. although currently there existing workable product yet, this interesting topic attracting public attention. below are some our takeaways: regarding the technology sgx itself, see the pros and cons discussed the data feed oracle section above. regarding sgx's adoption rate and usability, sgx was first introduced late along with the generation intel cpu based skylake microarchitecture. that means, lot personal computers and cloud servers are not yet equipped with sgx-enabled cpus, thus sgx-based computation solution limited usability and actually highly centralized. moreover, even with sgx-enabled processors, one also needs turn sgx the bios settings [][] this requires special knowledge operate personal computer, and many cloud server providers may not willing all. regarding developer-friendly, except purchasing sgx-enabled cpu and turning the bios settings on, developers need request commercial use license from intel before using the sgx sdk, then partition/refactor the user program code into untrusted and trusted parts, only the trusted part can run inside sgx enclave. this process usually lengthy and bug-prone, and must developed low level programming languages such c/c++, rust, etc. for the trusted part running inside sgx enclave, there are also restrictions only limited numbers library functions are provided the sdk, many system calls (e.g. open file) and cpu instructions are not allowed; the enclave memory size also small, not originally designed for loading all program code and user data directly. truebit the first proposed scalable off-chain computation protocol for ethereum blockchain means interactive proofs between off-chain solvers and challengers and creatively-designed incentive models. case dispute, solvers and challengers play interactive off-chain verification game recursively checking the remaining computation steps until the first point where they disagree with the state change after applying this computation step. the final judge then happens on-chain the smart contract determine which state change valid. truebit also needs implement on-chain interpreter solidity order execute this computation step. truebit introduces the concept "forced error rate" and maintains "jackpot repository" order incentivize challengers perform their due diligence. this basically forms into the architecture verifiable computation where computation outsourced off-chain but verification happens on-chain. verifiable computation the ideal solution bring scalable computation blockchains. however, truebit still its early days with tons development do. also the complex incentive model and interactive verification game add more security risks itself expect see more experimentation and progress truebit. introducing dos network dos network scalable layer- protocol that offers decentralized data feed oracle and decentralized verifiable computation oracle mainstream blockchains. connects on-chain smart contracts off-chain internet data, also supplies unlimited verifiable computation power blockchains, enabling more commercial applications with real world use cases. dos network chain-agnostic, meaning that could serve all existing smart contract platforms; decentralized, meaning that has single point failure, central trust single company special hardware, the trust lives math and code; horizontally scalable, meaning that with more nodes running dos client software the whole network offers more capability and computation power supported blockchains; designed with cryptoeconomic models, meaning that the protocol resistant sybil attacks and the network effect expanded with provable credibility. dos network partitioned into two layers with several key components: on-chain part set dos system contracts deployed supported blockchains, mainly including functionalities such request handling and response/computation result verification, node registration and staking, stats monitoring, payment processing, etc. on-chain system contracts also provide universal interface all user contracts across supported chains. off-chain part client software implementing the core protocol run third party users aiming for economic rewards, constituting distributed network. client software includes several important modules: event monitoring and chain adaptor module, distributed randomness engine module, off-chain group consensus module, and request processing/computation task processing module depending the type oracle service the user node provides. will discuss aforementioned components dos network details the following parts, analyzing dos on-chain architecture and off-chain core protocols. for data feed oracles will demonstrate how the off-chain dos clients reach consensus the open and byzantine environment means unbiased verifiable randomness generation and non-interactive, deterministic threshold signatures. for computation oracles will elaborate how achieve the same verifiable computation architecture similar that truebit but non-interactive way, powered zksnark and the state-of-art technique generate zksnark public parameters (called the "setup phase", the "ceremony" zcash) scalable and trustless way using the randomness engine build for the data feed oracle. will also discuss dos token economy which bootstraps and expands the network incentivizing node operators provide honest services exchange for economic rewards. based the protocol and infrastructure provide, decentralized data feed marketplace could built onboard more data feeds for dapps (demand side), and allow premium data providers (supply side) monetize from both blockchain traffic and traditional web traffic. decentralized computation marketplace could also built bring decentralization and cryptoeconomics commercial computation applications like video/audio transcoding, machine learning model training, rendering and on, which are currently monopolized tech giants like google, amazon, microsoft, etc. detailed design high-level architecture life oracle request take ethereum blockchain example briefly discuss the overall process on-demand data query initiated user contract. looks similar the request response pattern, however, asynchronous process from user contract's point view: user contract makes data query request through message call dos on-chain system bunch smart contracts open sourced and published with well documentation provided developers), specifically the dos proxy contract; dos proxy contract triggers event along with query parameters; dos clients (off-chain part dos network running users), which keep monitoring the blockchain for the defined event, are notified. ideally there would thousands dos nodes running, out which registered group will randomly selected, means the distributed randomness engine built with verifiable random function (vrf). members the selected group the due diligence, calling web api, performing computation, executing configured script concurrently; they will reach "in-group" consensus the t-out-of-n threshold signature algorithm and report back the agreed result dos on-chain system, long more than members the randomly selected group are honest. the selected group members' identity and qos (responsiveness/correctness, etc.) performance will recorded on-chain, for monitoring and data analysis purposes. dos proxy contract notifies the user contract that the result ready, calling callback function provided user contract. the overall workflow verifiable computation oracle looks similar and also make use the distributed randomness engine, but with several differences for step we'll discuss the details later sections. on-chain detailed design proxy system the proxy system provides standard on-chain interfaces user contracts and will asynchronously callback user contracts once the response ready. the interface provided user contracts universal and simple demonstrated below: making query request dos proxy contract; consuming the result backfilled from __callback__ function finish some post-processing work. pragma solidity import github.com/openzeppelin/zeppelin-solidity/contracts/ownership/ownable.sol" import ./dosonchainsdk.sol" examnple user contract asks anything from off-chain world through url. contract example ownable, dosonchainsdk string public response; query_id valid_status mapping(uint bool) private _valid; bool public repeated_call false default timeout for etheruem seconds: two blocks. uint public timeout string public last_queried_url; string public last_queried_selector; event settimeout(uint previoustimeout, uint newtimeout); event responseready(uint requestid); function setquerymode (bool new_mode) public onlyowner repeated_call new_mode; function settimeout (uint new_timeout) public onlyowner emit settimeout(timeout, new_timeout); timeout new_timeout; function request (string memory url, string memory selector) public last_queried_url url; last_queried_selector selector; uint dosquery (timeout, url, selector); (id _valid[id] true else revert( "invalid query id." user-defined callback function take and process response. function __callback__ (uint requestid, bytes memory result) external require (msg.sender fromdosproxycontract(), "unauthenticated response." require (_valid[requestid], "response with invalid query id!" emit responseready(requestid); response string(result); delete _valid[requestid]; (repeated_call) request(last_queried_url, last_queried_selector); example using on-chain sdk on-chain governance systems monitoring system monitoring system proposed keep on-chain records the off-chain dos nodes' qos (quality-of-service) metrics and network stats, including: random number generated latest round's selected off-chain group, which could serve new kind on-chain random source; group size, number registered groups, number times each registered group has been selected, uptime and decomposition time get rid adaptive adversaries, etc.; payment, weight percentage, and callback delay stats processed and unhandled query requests; quality score registered off-chain dos nodes including correctness and responsiveness their reported results nodes with extremely bad quality score will excluded from off-chain consensus protocol and payment process; more... based these rich on-chain metrics monitoring dapp could built, showcasing the live status dos network. registration system for dos off-chain nodes join the network, they need stake and lock some dos tokens security deposit, and register their deposit address well payment address the registration contract. they will registered within least one threshold group groups may overlap with each other. the registration process threshold groups are described the off-chain architecture section below. the security deposit makes the system resistant sybil attacks and enhances network security. also serves kind commitment that the node operator would contribute bandwidth and computation power strengthen dos network, and they will compensated for "mining" rewards well earning processing fees. the lockup period helps stabilize the network get rid too frequent registration and deregistration flips. any instance with out-of-bound offtime would also penalized forfeiting part its deposit. groups with responses certain limit would removed from registration system. payment system the payment query request goes the selected threshold group that handles it, and distributed among honest members. payments will stored the payment contract first, the transfer node runners doesn't necessarily happen real time withdrawal pattern preferable and node operators are able check and withdraw their earnings through frontend interacting with payment contract directly. dos token used the form natively supported payment token, well the staking token. however, for blockchains with widely-accepted stablecoins (e.g. ethereum), the stablecoin would preferable payment token since node runners won't risking for the volatility crypto prices; the pricing model for the fees will also easier make. we'll support dos payment token first, the long run, node runners and token holders will have governance rights vote for which stablecoins (dai/usdc/tusd/etc.) accepted extra payment tokens. different payment schemes will also supported: pay-per-use will widely adopted and suitable for personal developers and light-use dapps, while discounted subscription model will more favorable heavily dependent applications such stablecoins and other decentralized open finance platforms. the on-chain system will take modular design pattern into mind that all on-chain contracts will upgradable. since it's open and distributed network environment with different parties have different economic appeals, there's simple perfect model rule them all. more governance experiments and economic models will researched and explored future. off-chain detailed design part decentralized data feed oracle looks very similar the problem that blockchains need resolve order for off-chain dos nodes agree the result the same api call open and byzantine network environment. taking look back how bitcoin and other proof-of-x system works, essence they're trying achieve random leader election each round protocol, means certain resource that hopefully single party can easily monopolize; long the majority the network honest, the blockchain reaches consensus the sense probability. generating unbiased randomness specifically important reaching byzantine fault tolerant consensus. demonstrate the off-chain consensus protocol below, mainly leveraging verifiable random function (vrf) and threshold signature scheme put simple, instead doing leader election among all nodes, perform random group selection among all registered groups for each protocol run; utilizing the threshold signature cryptography, the selected group could reach off-chain consensus long more than (the threshold) members are honest. define the random number generated last round published on-chain ri- each registered group the same group size and there're registered groups, then for current round group registration and re-grouping: newly registered nodes come pending state first, once the pending pool contains enough pending nodes and they have been waited for sufficient time, they will randomly selected form new threshold groups. handle the condition "burst registration" while still generating honest majority group, working groups would randomly selected and dissolved, along with pending nodes there would nodes total. fisher-yates algorithm applied shuffle them into new working groups and get them registered. eliminate adaptive adversaries, each group also carries maturity period, say, several days, after which group members are dissolved into pending nodes. one-time non-interactive dkg (distributed key generation) protocol with threshold will then kicked off among members newly registered group that: centralized party holds the group secret key gi, gi, only logically exists but will never computed revealed any member during the lifetime group unless malicious party controls majority members the group. each member will allocated with group secret key share gi, verifiable and trustless way. the group public key gi, collectively generated and published the registration contract on-chain, updating number registered groups random group selection the randomly selected group for current round would be: g[ri- mod group consensus via (t, threshold signature each off-chain member processes the query request and gets its corresponding response member signes with its own group secret key share gi,jsk i,jd sign(dj gi,jsk and broadcasts the signature share i,jd its peers the threshold group waiting for other members' signature shares the same time. applying (t, threshold signature scheme here means that least members' signature shares the same response are required generate valid group signature and any combination the valid group signature shares could combined into the same and deterministic but there's way for less than members generate valid group signature. (t,n) threshold signature scheme verification and payout the first honest member who successfully combines the group signature delivers its peers, {d, the blockchain, and gets accepted after on-chain verification erif y(d, gi, other honest members stop processing upon receiving and verifying the group signature ideally there'll only valid response the blockchain, but cases multiple honest nodes report simultaneously, only the first verified response will honored the on-chain proxy system and others will omitted. threshold group randomly selected and one dos instance could belong multiple groups, long dos nodes are geographically distributed, the chance each honest instance being reporter and getting accepted will amortized during period time. processing fee oracle request the handled threshold group locked the on-chain payment system contract, and can withdrawn node runners anytime. ten percent processing fees goes foundation token pool, all honest members the threshold group get even split the remaining part. membership eligibility malicious member punishment malicious members could send arbitrary response the blockchain, however, they wouldn't pass the on-chain verification long they don't fetch and report the real response data the first place, and they'll flagged ineligible and excluded from future protocol run and the payment process. this case their security deposit will also forfeited, which will burned forever, will foundation token pool, and the remaining will deposited into the transaction fee reimbursement pool (see below section) freeloading protection since all honest members get even split the payout, the algorithm implicitly overcomes the "freeloading" issue, i.e. malicious nodes simply monitor pending transactions the system contract and frontrun the pending ones with much higher gas, without actually handling the request. also order incentivize participation the protocol and provide good bandwidth/computation resources with short delay, each group carries quality score: after certain timeout period there's response for the selected group, its negative score incremented and subsequent group selected. group with abnormal negative/positive ratio too high negative scores will kicked out protocol run and all members inside the group are losing nobody participated. gas sustainability and fee reimbursement pool ethereum's gas model requires the gas costs paid node who initiates transaction, including the gas costs any subsequent message calls derived from that. the gas costs delivering back the response data, group signature and executing the on-chain verification function need compensated honest members ensure the sustainability the unstoppable, unbiased, and secure random number generation process, transaction fee reimbursement pool will reserved. the initial funding comes from foundation donation and ecosystem building token pool, with malicious nodes' security deposit forfeited and deposited into the pool cover future reimbursement. noting that execution calling contracts' customized callback function also costs gas, which should not charged reimbursed node runners though, the complexity and gas consumption callback function purely the hands calling contracts, thus should only covered themselves. calling contracts are able set the gas price and they need make sure they have enough balance left cover the gas consumption their callback functions. the amount escrowed the payment contract, case response verification failure would returned calling contracts, otherwise it'll paid the node successfully delivers response and passes verification. non-interactiveness and immediate finality unlike pbft other communication-based consensus algorithms, there's multiple rounds message transmissions. that say, the algorithm scalable, even with group size hundreds the estimated size message transmitted capped several kbs total. also, unlike pow/pos other resource-based consensus algorithms, the finality here immediate. this due the magic (t, threshold signature that any valid signature share could recover the same original signature. bls threshold signature scheme good candidate because its unique, deterministic, non-interactive, shorter signature and other features mentioned []. randomness generation for next round member signes ri- using their group secret key share gi, sign(last blockhash ri- gi, broadcasting group signature share peers and applying the same threshold signature scheme above: long one member receives any valid signature shares combines them into the group signature thus random number generated for next round could the hash this group signature: h(s which unpredictable until it's generated and also verifiable on-chain. published on-chain and used select threshold group and generate random number for the next round protocol run the iteration continues forever and this called distributed randomness engine. safety analysis and protocol enhancements assuming dos network has total number nodes, the number byzantine nodes where threshold set meaning that least members are required for group reach consensus. define the probability randomly sampling nodes out nodes, out are byzantine nodes. thus: nm-b which conforms the hypergeometric probability distribution then the probability selected group reporting byzantine result is: byzantine result and the probability selected group couldn't reach consensus for honest members is: result thus the confidence have the result is: conf ident min {-p byzantine result result min the probability confidently reaching consensus the correct result comes maximum when conf ident attack conf ident using online calculator [][] it's obvious get the result below: byzantine ratio conf ident attack based above observation propose several protocol updates below: network size very reasonable short mid term estimate: zencash has network secure nodes after debut oct smartcash has network masternodes only after days launch announcement. expect dos network grows into several thousand nodes the long run. minimizing byzantine ratio the byzantine ratio the whole dos network significantly affects system safety even with small decrease byzantine ratio see huge confidence increase. taking advantage verifiable threshold signature scheme and the punishment malicious nodes could significantly decrease the byzantine ratio. each group also carries maturity period eliminate adaptive adversaries. maximizing parallelism with two types groups obvious that the larger the group size the safer dos network would be. however, there's dilemma that the larger the group size, the unfriendlier the data provider should get rid someone abusing dos network perform ddos attack the data source. with aim provide least six nines (.%, with millionth attack rate) confidence well overcoming the dilemma, there'll two types threshold groups: randomness engine group with group size large and safe enough e.g. driving the whole system solely generating unbiased and unpredictable random numbers. worker group groups processing the real query, with the group size bounded prevent exploiting data providers' resources. worker groups are selected the hash random number generated randomness engine group along with uery_idj gworkerquery gworkers [h(ri- query_idj mod workers thus different worker groups will selected for different queries and they can processed parallely achieve maximum scalability. part ii: computation oracle verifiable computation means client could outsource the computing some functions untrusted third parties with enough computing power. the result, along with proof demonstrating the validity and soundness the result, would returned the client, the client could then execute verification step instead performing the original computation. could already provide consensus-based computation oracle solution once part done, the idea quite straightforward: for each computation request, randomly select group computing nodes, execute the deterministic computation task each group member and send back the result agreed the majority. this could serve our short term plan for the computation oracle service we'd like offer supported blockchains, however, there better option we'd like offer the long-term roadmap. with the successful byzantium hard fork october, ethereum now capable verifying zksnark proofs smart contracts (see appendix ii). this enables build zksnark-based verifiable computation oracle, where the execution happens off-chain and verification happens on-chain. the whole process could roughly broken down into three phases: setup phase for each specific computation, define its equivalent arithmetic circuit secret random numbers ("toxic-waste" zcash) that must destroyed after the setup phase. two public available keys would generated the setup phase: setup (l, where called proving key used the off-chain computing phase and called verification key used on-chain verification phase. this setup phase only needs run once for each type computation task long the computation logic/step doesn't change, and could reused for different inputs. verification contract with hardcoded could deployed on-chain now verify future computation results for different inputs (see example contract appendix ii). off-chain computation phase the computation could then carried off-chain with any valid input this could further broken down into two steps: (i) performing computation and come with the result: ompute (c, (ii) generating proof for using proving key proof generatep roof (c, the proof along with the computation result then sent back on-chain the verification contract. on-chain verification phase one final step happening on-chain check the validity computation result given corresponding input erif ier.at(contract address).v erif y([p proof [i, ... o]) comparing with consensus-based computation oracle interactive verification game between solver and challenger (truebit), zksnark based off-chain computation only needs executed once. there's interaction between the prover and verifier, meaning non-interactive. the proof succinct, meaning its size small and independent the complexity the computation; the verification algorithm verifies the validity quickly and it's also independent the complexity the computation, only depends the size the input. these features make ideal solution bring unbounded computation power and execution scalability blockchains. there're several tricky points though. first the toxic waste that's used the setup phase, must destroyed and must not leaked otherwise fake proofs would generated attest computation. second, for the arithmetic circuit generation, computation task cannot apply zksnark directly before being converted the right form called "rank- constraint system" (rcs) then finally "quadratic arithmetic program" (qap). working directly with rcs qap sounds like writing assembly code hand, which error-prone and involves non-trivial work, not friendly for most developers. these problems need resolved order bring practical zksnark-based verifiable computation blockchains. new multiparty computation (mpc) protocol that could scaled hundreds even thousands participants has recently been proposed zcash researchers fix the trusted setup issue. the protocol has the property that all the participants have compromised dishonest order compromise the final parameters. moreover, now the trustless setup has been separated into two stages: one big, single "system-wide" trustless setup called "powers tau" has produced partial zksnark public parameters reused for all zksnark circuits within given size bound. application-specific trustless mpc setup still needed for each type computation task, but because the partial parameters produced powers tau, the application specific mpc much cheaper and achievable through the randomly selected working group. address the second issue, will define and formalize domain specific language (dsl) called "zinc" for verifiable computation, the grammar similar python javascript, with high-level abstractions such variables, conditions and flow control statements, loops, functions, module/file imports, etc. developers are able write off-chain computation code high-level programming language without the need understanding the crazy math under zksnark deal with low-level details like rcs. we'll also develop toolchain including sdk and front-end compiler compiling high-level zinc code into low-level rcs, and connecting existing proving system like scipr lab's libsnark back-end. the toolchain will also provide command line tool well library code integrated into dos client software enable verifiable computations and make them adaptable supported chains automatically. cross-chain interoperability dos network opens door perform cross-chain interaction between heterogeneous blockchains. assuming dos network supports data feed oracle services both ethereum blockchain and eos blockchain, then theoretically, smart contract ethereum able trigger cross-chain state changes, flowing through dos client nodes, calling into smart contract eos. dos network thus acting connectors bridges between supported heterogeneous chains. simple application like exchanging heterogenous crypto asset atomically. decentralized exchanges nowadays can only trade homogeneous crypto assets the same blockchain, decentralized exchanges e.g. etherdelta relayers are unable trade against eos tokens directly. however, with the help dos network, it's achievable deploying two dex contracts ethereum and eos blockchain respectively and defining two cooperative functions trigger orderbook and account balance state changes upon calling from the other dex contract address through dos connectors. this example showcases the potential dos network cross-chain interoperability. the operation and maintenance any newly supported blockchain's nodes (full node, light node, utilizing remote full node services like infura node operators' own economic interests and capability, while dos network team responsible for porting and deploying on-chain system contracts newly supported chains and releasing off-chain core client software including protocol update and new adapter support. start oracle services newly supported chains need through similar bootstrapping process mentioned section .., mainly the one-time group registration and non-interactive dkg process. noting that for various supported blockchains, chain-wide system variables like group size and number registered groups could different; the random number generated and published different chains are also different general. premium data feeds marketplace data and apis are powering web apps, mobile apps, iot devices, and are now growing into multi-billion-dollar business addition bringing open and free apis blockchain through decentralized data feed oracles, we're also planning build data feed marketplace, specifically targeting premium data feeds and making them available on-chain. keep the kiss principle mind for premium data providers and dapp developers that they only need undergo minimum even change from their sides. market contract would developed and deployed supported public chains. its main purposes are for premium data providers register and publish their specs and offers; and place group and demonstrate premium data feeds for dapp developers choose and purchase from. would host server and marketplace frontend for better user experiences and support structured data discovery like searching and ranking premium data feeds category and keyword. but actually all marketplace information stored market contract on-chain and ipfs, our hosted server only acts caching layer and any direct interaction with market contract and ipfs totally feasible. premium data providers register first publish their specs and offers, including but not limited api category, format, addresses receiving payments from the on-chain calling contracts, payment scheme e.g. pay-per-use, subscription-based, etc. sdk going released premium data providers including functionalities light clients with network connection full nodes, data providers are expected make minimum changes from their side. user contracts calling for specific category off-chain premium data would simply search for existing ones from marketplace contract and pick the most suitable one. there's such premium data feed available on-chain yet, developers could start bounty using dos tokens and the community would reach out corresponding data providers help integrate their service on-chain. all the on-chain data public for now, secret information like private key api token should stored on-chain smart contracts. we're addressing the problem other approaches: queries for premium off-chain data would use different interface from querying open and free data, but the calling sequence similar normal ones and goes into proxy contract, which talks market contract make sure the requested premium data source has been registered and checks whether the calling contract has enough dos tokens pay premium data providers. the payment then held on-chain payment contracts and wouldn't delivered premium data providers until the response backfilled the calling contract. the off-chain dos network talks the premium data provider, with the help light client sdk, data providers make sure the pending payment coming from calling contract with matched query escrowed the payment contract, before giving back data. this way premium data providers are able monetize from blockchain traffic without being abused unpaid user contracts normal unauthorized internet traffic. future r&d work some related ongoing and future research work improve dos network are listed below. threshold cryptography, distributed key generation, and vrf are actively exploring other signature schemes besides threshold-bls signature, with properties including verifiability, uniqueness/determinism, with non-interactive threshold version and short size. other advanced dkg protocols besides feldman's and pedersen's and verifiable secret sharing schemes are also our eyes. we're seeing emerging research and applications verifiable random function the blockchain space, notably the consensus engines algorand, dfinity and cardano are highly dependent vrf. we'd like explore more applications vrf byzantine fault-tolerant consensus algorithms and non-interactive zero knowledge systems. verifiable off-chain computaion we're actively exploring and working zk-snark related topics especially like general purpose front-end compilers from high-level languages rcs, low-level libraries and implementations proving systems e.g. libsnark, bellman, etc. we're also evaluating and keeping eyes other advanced verifiable computation techniques that are probably still more theoretic stage than production ready, like fully homomorphic encryption program obfuscation, and the latest scalable, toxic-waste-free, post-quantum-secure zk-stark technology. token economy we'll issue dos token which utility token based ethereum erc standard ethereum the first blockchain support. dos token will utilized incentivize various participants the system and ensure growth and development the ecosystem. future, may swap tokens other supported primary smart contract platforms like eos, thunder, tron, etc. participants dos system there are mainly three types participants dos network. they are tightly connected dos token and together constitute the dos ecosystem: dapp developers dapp developers and/or calling contracts need pay processing fees dos nodes for each fulfilled request pay-per-use subscription-based scheme order request external data perform off-chain verifiable computation tasks. dos token will the first accepted fee token used pay processing fees node runners, however token holders have the governance right vote for what else accepted fee tokens, like for example, stablecoins. developers also pay premium data feeds per their specs and they could set bounties using dos tokens the marketplace contract request for missing premium data feeds. node runners the off-chain dos network consisted third party user-engaged node runners. there are two types nodes: data carrier node and computation node. node operator could maintain either both types depending their economic interests and capabilities. each operator locks certain amount dos tokens security deposit, say dos token, and they will awarded with processing fees for the oracle services they provide. malicious nodes will detected protocols and their security deposit will forfeited. premium data providers registering the open marketplace with customized payment schemes and specs, premium data providers could have entirely new path monetize their valuable data feeds from blockchain traffic addition the traditional internet traffic. network bootstrap several proposals are made for cold startup the dos network: incentive program for dapp developers developer program would start encourage more dapps and developers utilizing the dos service. developers who submit development proposals and proof usages will granted with dos tokens free trials for reimbursement the processing fees they pay node operators. "mining" incentives for node runners node incentive program called "mining" would start incentivize more node runners join bootstrap the off-chain network. three hundred and fifty million out total) dos tokens are reserved mining incentive. addition the normal processing fees they earn, node operators will also "mine" dos token from mining reserve determined return rate. with more nodes joining the network, the return rate decreases over time, demonstrated the table below: number nodes time joining year roi year roi year roi year roi year roi [,] mining incentive stops after the mining reserve exhausted, which will roughly sustain ten years. incentive for premium data providers first all premium data providers would collect corresponding bounties started developers from the marketplace contract. besides that, order incentivize premium data provider integrate with dos network and onboard more premium events, bonus program designed award data providers for each milestone they achieve, e.g. for the first and paid calls from calling contracts data providers will awarded with bonus dos tokens from the ecosystem reserve. other details incentive program and bootstrap plan are determined, including but not limited lock drop, developer bounty programs, hackathons, etc. combining with mining incentive all dos tokens are reserved for network effects and ecosystem usage. token distribution symbol dos total supply billion (,,,) allocation mining incentive: ecosystem building: (for node lock drop, exchange listing fees, network bootstrap incentives, bounty tasks, strategic partnership etc.) community token promotion: lock up, vesting after months) private sale: lock up, vesting quarterly over months) team: (lock first months and vesting monthly next months) foundation reserve: (for marketing, legal, pr, business development, etc.) advisor: (lock first months) use cases dos network provides the ability for on-chain smart contracts reaching and reacting external events decentralized and trustless way. this unlocks lot use cases that smart contracts are now capable with the help dos network. decentralized derivatives derivatives are financial contracts between two more parties whose values are based the underlying assets. derivatives allow people put different viewpoints (long short) the underlying assets and essence promote the financial stability. public smart contract platforms make possible create and trade financial derivatives including blockchain based assets; for example, market protocol decentralized derivatives association and dydx protocol are all working hard push the boundary forward. dos network could take significant role decentralized derivatives providing price feeds, settlement values and contract expirations determine gain loss for participating parties. stablecoins stablecoins are cryptocurrencies with stable fiat value, reducing volatility and making them more appealing store value and medium exchange many ways, they are honored the holy grail digital currency. when referring stablecoins we're not talking about ious issued centralized company, such tether digix but more about decentralized and algorithmically controlled cryptocurrency, such collateral backed stablecoins like bitusd and dai and seigniorage shares based stablecoins like basecoin and kusd all stablecoins need the help oracle system like dos network get external data about exchange rate between stablecoins and the asset they're pegged to. decentralized lending platform decentralized peer-to-peer lending platforms like salt lending and ethlend allow anonymous users pledge crypto assets blockchain exchange for fiat crypto loans. dos network could applied introduce market rates during loan creation and monitor the ratio crypto collaterals the loaned amounts, triggering liquidation events loan terms are met. furthermore, ethlend also uses oracles import borrowers' social media data and other identity info differentiate interest rates between different borrowers. decentralized insurance etherisc building platform for decentralized insurance applications like flight delay insurance and crop insurance bringing efficiency and transparency with lower operational costs. users purchase insurance policy and pay the premium ether and they'll get corresponding payout ether back according the policy case agreed-on conditions are met. introducing external data and events into smart contracts, dos network helps those decentralized insurance products policy underwriting and payout decisions case claims well schedule future checks the time policy expiration achieve automatic payout. decentralized casino decentralized casinos like dicewin etheroll and edgeless benefit lot from blockchains terms transparency, near-instant secure fund transfer, and provably fair with house edge comparing traditional online casinos with %~% house edge. unpredictable and verifiable random number generation the core any casino game, but random number generation pure deterministic environment (on-chain) difficult even impossible theory. dos network able generate provably secure, verifiable, unbiased and unstoppable random entropies for those dapps use. decentralized prediction markets decentralized prediction markets like augur and gnosis utilize wisdom the crowds predict real world outcomes such presidential election and sports betting result. dos network could used for fast and secure resolution case the voted results being challenged users. decentralized computation markets and execution scalability bypassing the block gas limit and expensive on-chain computation cost, dos network connects redundant third party computing power with business computation intensive tasks such machine learning model training, rendering, scientific computing like dna sequencing. our long-term roadmap, zksnark based computation oracle would also offer privacy computing tasks private input supported. also for the current blockchain scalability debate, would bring unlimited execution scalability supported chains. references satoshi nakomoto, "bitcoin: peer-to-peer electronic cash system", https://bitcoin.org/bitcoin.pdf vitalik buterin, next-generation smart contract and decentralized application platform", https://github.com/ethereum/wiki/wiki/white-paper state the dapps, https://www.stateofthedapps.com verifier's dilemma, loi luu, jason teutsch, etc. "demystifying incentives the consensus computer", https://eprint.iacr.org//.pdf oracle machine, https://en.wikipedia.org/wiki/oracle_machine oraclize, http://www.oraclize.it tlsnotary cryptographic proof online accounts, https://tlsnotary.org spof, https://en.wikipedia.org/wiki/single_point_of_failure town crier, http://www.town-crier.org tee, https://en.wikipedia.org/wiki/trusted_execution_environment foreshadow attack, https://foreshadowattack.eu. meltdown and spectre attack, https://meltdownattack.com asyncshock: exploiting synchronisation bugs intel sgx enclaves, https://www.ibr.cs.tu-bs.de/users/weichbr/papers/esorics.pdf malware guard extension: using sgx conceal cache attacks, https://arxiv.org/abs/. chainlink, https://www.smartcontract.com augur, http://www.augur.net gnosis, https://gnosis.pm sgx enabled processors, https://software.intel.com/en-us/forums/intel-software-guardextensions-intel-sgx/topic/ sgx security and dev review, https://www.blackhat.com/docs/us-/materials/us--aumasson-sgx-secureenclaves-in-practice-security-and-crypto-review.pdf truebit, https://truebit.io truebit whitepaper verification game, https://people.cs.uchicago.edu/~teutsch/papers/truebit.pdf truebit whitepaper security patches, https://people.cs.uchicago.edu/~teutsch/papers/truebit.pdf verifiable computation, https://en.wikipedia.org/wiki/verifiable_computing zksnark nutshell, https://blog.ethereum.org////zksnarks-in-a-nutshell sean bowe, ariel gabizon, ian miers, "scalable mpc for zksnark parameters the random beacon model", https://eprint.iacr.org//.pdf timo hanke, mahnush movahedi, dominic williams, "dfinity consensus system", https://dfinity.org/pdf-viewer/pdfs/viewer?file=../library/dfinity-consensus.pdf rosario gennaro, stanislaw jarecki, hugo krawczyk, tal rabin, "secure distributed key generation for discrete-log based cryptosystems", https://link.springer.com/article/./s--- dan bone, ben lynn, hovav shacham, "short signatures from the weil pairing", https://link.springer.com/article/./s--- leslie lamport, robert shostak, marshall pease, "the byzantine generals problem", http://lamport.azurewebsites.net/pubs/byz.pdf hypergeometric distribution, https://en.wikipedia.org/wiki/hypergeometric_distribution hypergeometric calculator, http://stattrek.com/online-calculator/hypergeometric.aspx hypergeometric distribution calculator, http://keisan.casio.com/exec/system/ zencash secure node network stats, https://securenodes.eu.zensystem.io smartcash masternode network stats, https://smartcash.bitcoiner.me/smartnodes/worldmap byzantium hard fork, https://blog.ethereum.org////byzantium-hf-announcement arithmetic circuit, https://en.wikipedia.org/wiki/arithmetic_circuit_complexity powers tau ceremony, https://z.cash.foundation//blog/conclusion-of-powers-of-tau libsnark, https://github.com/scipr-lab/libsnark infura, https://infura.io internet api economy, http://www-.ibm.com/press/us/en/pressrelease/.wss kiss principle, https://en.wikipedia.org/wiki/kiss_principle homomorphic encryption, https://en.wikipedia.org/wiki/homomorphic_encryption zk-stark, https://eprint.iacr.org//.pdf market protocol, https://www.marketprotocol.io decentralized derivatives association, https://www.decentralizedderivatives.org dydx protocol, https://dydx.exchange tether, https://tether.to digix, https://digix.global bitusd, https://coinmarketcap.com/currencies/bitusd dai, decentralized stablecoin, https://makerdao.com robert sams, note cryptocurrency stabilisation: seigniorage shares", https://bravenewcoin.com/assets/whitepapers/a-note-on-cryptocurrency-stabilisationseigniorage-shares.pdf basecoin, http://www.getbasecoin.com kusd, https://www.kowala.tech salt lending, https://www.saltlending.com ethlend, http://ethlend.io etherisc, https://etherisc.com dicewin casino, https://dice.win etheroll casino, https://etheroll.com edgeless casino, https://edgeless.io appendixes appendix supported query types dos network. query type example web api dosquery(timeout, "https://api.coinbase.com/v/prices/btc-usd/buy", "$.data.amount"); premium web api* dosquerypremium(timeout,"https://us-zipcode.api.smartystreets.com/lookup?state=ca&zip code=", "$.result", ["@from_uc_addr", "@other_param"]); cross-chain contract call* dosqueryxchain(timeout, "eos", ["@ddex_contract_addr", "@eos_token", "buy", ]); consensus-based off-chain computation* doscompute(timeout, "@ipfs_code_hash", [@arg, @arg, ...]); zksnark-based off-chain computation** doszkcompute(timeout, "@ipfs_code_hash", [@arg, @arg, ...]) mid-term goal. long-term goal. appendix ii: example verificaion code zksnark proofs solidity. pragma solidity library pairing struct gpoint uint uint encoding field elements is: x[] x[] struct gpoint uint[ uint[ generator function internal returns (gpoint) return gpoint( generator function internal returns (gpoint) return gpoint( @return the negation i.e. p.add(p.negate()) should zero. function negate (gpoint internal returns (gpoint) the prime the base field f_q for uint (p.x p.y return gpoint( return gpoint(p.x, (p.y q)); return the sum two points function addition (gpoint gpoint internal returns (gpoint uint[ memory input; input[ p.x; input[ p.y; input[ p.x; input[ p.y; bool success; assembly success call(sub(gas, input, use "invalid" make gas estimation work switch success case invalid require (success); return the product point and scalar, i.e. p.scalar_mul() and p.addition(p) p.scalar_mul() for all points function scalar_mul (gpoint uint internal returns (gpoint uint[ memory input; input[ p.x; input[ p.y; input[ bool success; assembly success call(sub(gas, input, use "invalid" make gas estimation work switch success case invalid require (success); return the result pairing check: e(p[], p[]) .... e(p[n], p[n]) e.g. pairing([p(), p().negate()], [p(), p()]) should return true. function pairing (gpoint[] gpoint[] internal returns (bool) require (p.length p.length); uint elements p.length; uint inputsize elements uint[] memory input new uint[](inputsize); for (uint elements; i++) input[i p[i].x; input[i p[i].y; input[i p[i].x[ input[i p[i].x[ input[i p[i].y[ input[i p[i].y[ uint[ memory out; bool success; assembly success call(sub(gas, add(input, mul(inputsize, out, use "invalid" make gas estimation work switch success case invalid require (success); return out[ helper funciton for pairing check two pairs. function pairingprod (gpoint gpoint gpoint gpoint internal returns (bool) gpoint[] memory new gpoint[]( gpoint[] memory new gpoint[]( return pairing(p, p); helper funciton for pairing check three pairs. function pairingprod gpoint gpoint gpoint gpoint gpoint gpoint internal returns (bool) gpoint[] memory new gpoint[]( gpoint[] memory new gpoint[]( return pairing(p, p); helper funciton for pairing check four pairs. function pairingprod gpoint gpoint gpoint gpoint gpoint gpoint gpoint gpoint internal returns (bool) gpoint[] memory new gpoint[]( gpoint[] memory new gpoint[]( return pairing(p, p); contract verifier using pairing for struct verifyingkey pairing.gpoint pairing.gpoint pairing.gpoint pairing.gpoint gamma; pairing.gpoint gammabeta; pairing.gpoint gammabeta; pairing.gpoint pairing.gpoint[] ic; struct proof pairing.gpoint pairing.gpoint pairing.gpoint pairing.gpoint pairing.gpoint pairing.gpoint pairing.gpoint pairing.gpoint a_p; b_p; c_p; function verifyingkey pure internal returns (verifyingkey vk) vk.a pairing.gpoint([ xfcfaebbffafebeafddaeadbdcfe xedcbebbdadfdadcaedacaefebdac xcfbcfbbbfcfdbcdfbcaec xaddaaccdaafeecaabcdfebdceefe ]); vk.b pairing.gpoint( xddccafdadabfbcbdbfbddeafdbdb xffbadcbddbaefbdadbefeac vk.c pairing.gpoint([ xbecffddfbcdebbcbaeefbfc xbbbcddcbbcdacb xfebfbfacdddcafeedaafbfbe xeefbfbccfddfeaceafaadfec ]); vk.gamma pairing.gpoint([ xcbdaaacdacbebdeceacd xeecacaedfcceecfdedcabeee xebaeeafcabefdfcfbcfdbefde xbafbfddceeabebeadbceabfebab ]); vk.gammabeta pairing.gpoint( xffdefdbefffcfbbbbcdabcafcead xbafecabbaefedacdadfebe vk.gammabeta pairing.gpoint([ xfcbfedbfacddcfacccfcfbbcaa xdbadfafbaefdecdeacfcbc xbfededfecdacfacddcdea xfcbdeadccccfbeeadedacaccdabea ]); vk.z pairing.gpoint([ xafdfdfbbafbdcadcdbadcceae xeddbbdceedbcfcdaeefabecad xbeadbbcfaabcbbbffabaeebbaaffdae xfefddfaedeaacafec ]); vk.ic new pairing.gpoint[]( vk.ic[ pairing.gpoint( xdfddffdbeafcbdbfbedeabdecdada xdbefabfbfccbbedffefbcfdceedee vk.ic[ pairing.gpoint( xbbdfabeaebfdcbefdfbebfdcfb xbcdbedffebdbeacbfcdbaac vk.ic[ pairing.gpoint( xabacadaecdccacdafdbacfeafc xcdbafacabbddbeaacefee vk.ic[ pairing.gpoint( xffcbcbddbccfccefbfbccc xacdadddeeceaeedfcfacebedc function verify (uint[] input, proof proof) internal returns (uint) verifyingkey memory verifyingkey(); require (input.length vk.ic.length); compute the linear combination vk_x pairing.gpoint memory vk_x pairing.gpoint( for (uint input.length; i++) vk_x pairing.addition(vk_x, pairing.scalar_mul(vk.ic[i input[i])); vk_x pairing.addition(vk_x, vk.ic[ ]); (!pairing.pairingprod(proof.a, vk.a, pairing.negate(proof.a_p), pairing.p())) eturn (!pairing.pairingprod(vk.b, proof.b, pairing.negate(proof.b_p), pairing.p())) eturn (!pairing.pairingprod(proof.c, vk.c, pairing.negate(proof.c_p), pairing.p())) eturn (!pairing.pairingprod( proof.k, vk.gamma, pairing.negate(pairing.addition(vk_x, pairing.addition(proof.a, proof.c))), vk.gammabeta, pairing.negate(vk.gammabeta), proof.b return (!pairing.pairingprod( pairing.addition(vk_x, proof.a), proof.b, pairing.negate(proof.h), vk.z, pairing.negate(proof.c), pairing.p() return return event verified(string s); function erifytx uint[ uint[ a_p, uint[ uint[ b_p, uint[ uint[ c_p, uint[ uint[ uint[ input public returns (bool proof memory proof; proof.a pairing.gpoint(a[ ]); proof.a_p pairing.gpoint(a_p[ a_p[ ]); proof.b pairing.gpoint([b[ ]], [b[ ]]); proof.b_p pairing.gpoint(b_p[ b_p[ ]); proof.c pairing.gpoint(c[ ]); proof.c_p pairing.gpoint(c_p[ c_p[ ]); proof.h pairing.gpoint(h[ ]); proof.k pairing.gpoint(k[ ]); uint[] memory inputvalues new uint[](input.length); for (uint input.length; i++){ inputvalues[i] input[i]; (verify(inputvalues, proof) emit verified( "successfully verified simple computation function addition(a,b)." return true else return false