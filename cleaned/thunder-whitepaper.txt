the thunder protocol rafael pass and elaine shi thunder research introduction this white paper, introduce the thunder protocol, new and provably secure consensus protocol, which overcomes the two main bottlenecks classic blockchains: throughput: existing blockchains employed major crypto-currencies (e.g., bitcoin ethereum) require flooding the whole network with all the transactions. consequence, these blockchains not scale well handle large transaction volume. for instance, bitcoin and ethereum can handle less than transactions/second. this small throughput severely hinders wide-spread adoption such crypto-currencies. comparison, visa handles transactions/sec. confirmation times: the security nakamoto's blockchain protocol requires the block-time significantly larger than the maximum network latency []; this why bitcoin, new blocks transactions get mined every minutes, and transaction only considered confirmed once has been incorporated block and there are subsequent blocks following it; thus takes average one hour for transaction confirmed (with low confidence). while ethereum uses smaller block-time, the average confirmation time still remains relatively high--approximately minutes. these long confirmation times hinder many important applications (especially smart contract applications). our thunder protocol overcomes both these issues, achieving both high throughput and fast confirmation time (under typical circumstances within network roundtrips), while being robust attack. while are aware several other recently suggested approaches for overcoming the above two bottlenecks, these approaches are either restricted only payments (and not handle smart contracts), provide security only against weaker /-attack; additionally, many approaches are based heuristic arguments, whereas our protocol accompanied rigorous proof security; see section for more details. the design thunder inspired new theoretical paradigm for consensus proposed our earlier work, thunderella [], and provides the first practical instantiation this general paradigm. this paradigm can instantiated using either proof-of-work proof-of-stake. the thunder protocol following our thunderella paradigm [], the key idea behind thunder combine "standard" blockchain--which will refer the slow chain--with optimistic fast-path. the fast path coordinated new entity referred the accelerator, and requires the use committee "stake-holders". long the accelerator acting honestly, network conditions are good, and c)> the committee are honest, barely need use the slow-chain all; instead, transactions can confirmed the fast-path the committee using extremely simple and lean fast-path protocol. this protocol offers both high throughput and instant confirmation transactions. but the fast-path only confirms new transactions assuming the above mentioned good conditions are met. when they are not (e.g., the accelerator misbehaves under attack), leverage the "slow chain" recover provably sound manner. proceed provide more detailed description our new consensus protocol. consensus and blockchains roughly speaking, blockchain simply permissionless implementation primitive known state machine replication, consensus the distributed systems literature. consensus: consensus protocol enables maintaining "linearly ordered log" transactions distributed fashion such that the following two properties hold: consistency: any point the execution, all honest participants have consistent logs transactions--that is, either their logs are identical, one participant's log prefix the other's. liveness: any honest protocol participant can propose add transaction; this transaction then guaranteed incorporated into their logs within some fixed, small amount time; additionally, whenever participant sees some transaction their log, the same transaction will appear every other participant's log within some fixed, small amount time. essence, these properties mean that from the view the participants, they are communicating with trusted third party that maintains global, ordered, append-only log transactions that anyone can add to--in essence public ledger. our goal here implement consensus protocol the permissionless setting with high throughput and fast confirmation transactions. blockchains: formal definition blockchain can found []. strictly speaking, blockchain does not directly give the above-described consistency property; rather, the consistency property defined for blockchain that players have consistent view the blockchain when dropping the last blocks, where security parameter other words, the last blocks may "unstable", but everything before that has been stabilized (except with exponentially vanishing probability function the security parameter k). other than the above-mentioned main properties consistency and liveness, also defines notion bounded chain-growth: the length the blockchain should grow well-define pace, not fast and not too slow. will require the use slow-chain that satisfies such bounded chain-growth. pass al. show that nakamoto's protocol satisfies all the above properties once the mining hardness appropriately set (as function the network delay and total computing power) assuming that majority the mining done honest users (a.k.a. "computational honest majority"). more precisely, the nakamoto protocol satisfies consistency and liveness and only the mining-hardness set function the maximum network latency that the block-time (which the bitcoin system set minutes) significantly exceeds the maximum network latency. ethereum's protocol related nakamoto's and ought satisfy them well. security contexts: ipants. will distinguish between two different conditions the network partic- worst-case conditions under which the protocol guaranteed provide consistency and liveness (i.e., are conditions under which the protocol guaranteed secure). our case, will the conditions that: the underlying slow-chain secure (which turn follows from computational honest majority the case nakamoto's blockchain); and, majority the committee honest. under such worst-case conditions, confirmation times may slow, and the transaction load may limited (just the case for bitcoin and ethereum). optimistic conditions under which the transaction volume can large, and transactions are "instantly" confirmed. our case, will the conditions: the slow-chain secure; the accelerator online and honest; the committee online and honest. our new thunder protocol will make use simple fast-path protocol conjunction with underlying slow-chain ensure worst-case security under and instant-confirmation and highthroughput under mentioned above, the key idea make use the "fast-path" protocol when things work well, and only use the slow-chain recover from faults. simple fast-path protocol consider first the following simple fast-path protocol: have designated entity: the accelerator. all new transactions are sent the accelerator; the accelerator bundles transactions into micro-blocks, signs each micro-block with increasing sequence numbers seq, and sends out the signed micro-block "committee" players. the committee members "ack" all accelerator-signed micro-blocks signing them, but only ack most one micro-block per sequence number. when micro-block has received acks (i.e., signatures) from more than the committee members, refer the micro-block being notarized (and the notarization the microblock this collection these signatures. participants can directly output their longest actual implementation, one would make use aggregate signature scheme describe the notarization compact form. sequence consecutive (in terms their sequence numbers) notarized micro-blocks--all transactions contained them are considered confirmed. this way, the fast-path instantly finalizes transactions. easy prove (and well-known) that this protocol consistent under the condition wfast the committee members are honest"); additionally, satisfies liveness with instant confirmation under the conditions ofast the accelerator online and honest, the committee members are online and honest". fact, under these optimistic conditions, only need communication rounds confirm transaction! this approach extremely practical and indeed similar protocols are often used practice--for instance chain.com uses related protocol for their permissioned consensus protocol. the problem with this approach, however, that the protocol does not satisfy liveness (even "slow" liveness) under condition wfast the accelerator cheating (or simply taken down from the network), the protocol halts. (indeed, this case chain.com would have manually fix the issue, which impossible decentralized setting.) how recover from faults overcome this problem, leverage the underlying "slow-chain" which assume satisfies both consistency and liveness. roughly speaking, deal with this follows. heartbeats: for every length the slow-chain, the accelerator takes the hash the current log (of the fast path) and sends out the tuple (`, seq) (where seq the current sequence number) get notarized the committee members (who all check that correct based the history they have seen); refer notarized version such tuple (`, seq) heartbeat. the accelerator subsequently required post the heartbeat the slow-chain. cool-down: next, some user notices that its transaction not getting confirmed the accelerator/committee, some "evidence" this will become apparent the underlying slowchain--as shall see shortly, the evidence simply the fact that heartbeat has been observed the slow-chain for sufficiently long period time. (note that liveness, and the bounded chain growth properties the slow-chain, accelerator and more than the committee are online and honest, are guaranteed that heartbeat for length gets incorporated close length `). whenever such evidence cheating (i.e., recent heartbeat are contained the slow-chain) has been found, enter "cool-down" period, where committee members stop signing messages from the accelerator, yet allow anyone post any "new" notarized transactions (which were not included the most recent heartbeat) the slow-chain. the length the cool-down period counted blocks the slow-chain (say blocks where security parameter). slow mode: finally, after the cool-down period ends, can safely enter "slow period" where transactions only get confirmed the slow-chain blockchain (and the fast-path longer active). stay the slow-chain for appropriate amount time counted blocks the slow-chain (e.g., enough blocks restore replace faulty accelerator) and can next reboot with new epoch the fast-path protocol; more details the reboot step can found section let point out the reason for having cool-down period: without it, players may disagree the set fast-path transactions that have been confirmed before entering the "slow mode", and thus may end with inconsistent views. the cool-down period enables honest players post all notarized transactions they have seen the slow-chain, and thus (slowly) reach consensus this set transactions; once have reached this consistent view (at the end the cool-down), can finally fully switch over confirming new transactions the slow-chain. collecting evidence cheating: "yell" transactions remains explain how collect evidence that the accelerator (and/or committee) cheating simply "offline". player notices that his transaction not getting confirmed the accelerator committee, can send special yell transaction (which contains the transaction wants see confirmed) the underlying slow-chain. the accelerator additionally instructed confirm all such yell transactions sees the slow-chain. now, committee member sees some transactions the slow-chain that have not gotten notarized within sufficiently long amount time--counted blocks the slow-chain (say within blocks)--they know that the accelerator (or large fraction the committee members) must cheating offline. this point, the committee member will stop signing heartbeat messages. so, long just the committee are honest, cheating accelerator will "choked"-- new heartbeats accelerator will notarized. consequently, everyone that observes the slow-chain will enter the "cool-down" phase and subsequently the slow mode. how reboot the fast path once have entered the slow mode where all transactions are being posted the slow-chain, need have way return the fast path. the simplest method for the current accelerator (once has recovered from the fault), post "summon" message the slow-chain summon committee members retry certain point time (expressed terms some future height the slow-chain). more generally, thunder nodes can use the slow-chain discuss and vote how and when rebootstrap, possibly renegotiate the committee and leader election strategy the meanwhile. the general form, nodes can inspect stabilized prefix the slow-chain, and imagine that some predicate can applied the prefix decide when nodes should make attempt reboot the fast path (see section for more discussions). how select the committee far have deferred the discussion how the committee selected. also here, may consider multiple approaches. rely recent miners: perhaps the simplest approach select the committee the miners of, say, the most recent blocks the slow-chain (as was done []). note, however, that rely this approach, need ensure that the underlying slow-chain "fair" the sense that the fraction honestly mined blocks close the fraction honest players. this not the case for nakamoto's original blockchain nor ethereum (see e.g., []), but shown [], any blockchain can turned into fair one. use this approach, the resulting protocol will now consistent and live under simply the condition ="computational honest majority" (as this condition implies that majority the committee will honest), and high-throughput and instant confirmation holds under the optimistic conditions the accelerator honest, fraction the mining power honest." subsample from all stake-holders: the blockchain used for cryptocurrency (as intend here), may instead select the committee subsampling from the recent stake-holders. this can done using the method from our earlier work snow white []: the committee that active when the slow chain has length selected based the stake-holders when then the slow chain had length using selection function that takes input the hash the chain length `-k. explained more detail our earlier work [], the reasons for the "look-back" prevent against attacks where attacker adaptively selects its keys have higher probability getting elected the committee. this approach ensures consistency and liveness under the conditions the slow-chain secure, the stake holders are honest"; and achieves fast confirmation under the conditions the accelerator online and honest, the stake holders are online and honest". the drawback this approach that may too optimistic assume that majority stake-holders are online (and thus the conditions for the fast path may rarely hold). the next approach deals with that issue. select from stake-holders putting down escrow: one potential drawback the above approach that not stake-holders may want participate transaction validation. rather than subsampling from the full set stake holders, may instead ask stake-holders that intend participate the put down escrow (as message posted the slow-chain). can then select from these stake-holders who have put down escrow. one idea select the members putting down the most amount escrow, since would like encourage more stake join the committee and protect the fast path. the actual algorithm implemented motivated this idea but carefully crafted variant such that can prove that the equilibrium behavior satisfies certain desirable properties. more generally, committee selection can performed applying general predicate stabilized part the slow-chain. the full thunder protocol specification here provide the full protocol specification. let security parameter: mentioned before, will require the underlying slow-chain guarantee consistency and liveness except with negligible probability (concrete parameters will presented forthcoming implementation paper.) for simplicity exposition, first describe protocol that starts off the fast mode and simply enters the slow mode when the optimistic conditions stop holding; later, section explain how extend the protocol enable "reboot" the fast mode. for simplicity, also assume that each microblock contains just single transaction tx--in practice, microblock will contain batch transactions (and our protocol can extended deal with any batching method). notations and useful definitions the underlying slow-chain. nodes (a.k.a. "miners") run underlying blockchain protocol referred the "slow chain"; use the notation chain denote node's the view the slow chain. use the notation chain[: denote the prefix chain upto the `-th block; use chain[: -`] denote chain where the last blocks have been removed. (recall that the consistency property blockchain does not guarantee that everyone has consistent view the whole chains, but they once the last where security parameter, blocks--that the "unstable blocks" have been removed.) chain[` denote the part chain from the `-th block the -th block. assume there there some commonly known starting length `start for the slow-chain which begin the execution the thunder protocol. committee selection. assume that there publicly-known function denoted comm which takes input the stabilized part the blockchain chain[: -k] and outputs set committee members denoted comm(chain[: -k]). (we discussed few concrete committee selection methods section ..) micro-blocks: each micro-block the fast-path log has the form (mblock, seq, tx) where seq sequence number, the slow-chain length associated with the micro-block (indicating the slow-chain length when this transaction was proposed), and transaction. heartbeats: heartbeat has the same form micro-block except that the transaction replaced simply the hash the log: more precisely, heartbeat has the form (heartbeat, seq, say that such heartbeat associated with slow-chain length notarization. let the form (mblock, seq, (heartbeat, seq, say that the notarization w.r.t. chain fraction comm(chain[: k]) some message the form (mblock, (heartbeat, for which notarization request was sent out, compute aggregate signature from the collected signatures well the accelerator's own signature and broadcast well its notarization committee members: upon receiving tuple the form (mblock, seq, tx) (heartbeat, seq, with valid signature from the accelerator: assert that the node member comm(chain[: k]) assert that within +-.k |chain|; assert that other tuple with the sequence number seq has been signed; type mblock, sign and return the the tuple and signature the accelerator. the type heartbeat, assert that h(log where log the node's fast-path log sequence number seq let txs* all yell transactions chain[: -k]; assert that log contains all them. sign and return the the tuple and signature the accelerator. clients: upon receiving transaction tx: send the accelerator. the transaction has not gotten included the node's fast-path log before the slow-chain has grown steps, broadcast yell transaction for (to the underlying slow-chain). miners: participate the underlying slow-chain's mining. the input the slow-chain protocol includes: every yell transaction the node aware that has not yet been included the slow-chain; every notarized heartbeat that has not been included the slow-chain far. slow-mode protocol the slow mode, committee members ignore all messages from the accelerator. clients propose transactions only the slow-chain broadcasting any new transaction receives input. miners: let the smallest skipped heartbeat that triggered the slow mode. let the hash digest inside the heartbeat associated with length chain, and let log* the prefix the fast-path log that matches the hash participate the slow-chain mining; every round, input the slow-chain protocol: every notarized transaction that not contained log* and not chain; and every other transaction has observed (including those inside yell transactions) but has not been incorporated log* chain yet. everyone: this condition does not hold, store the transaction incoming message buffer until the sequence number log exceeds seq. broadcast the fast-path log including notarization every micro-block. let the earliest block such that chain[: contains skipped heartbeat let log the maximal lucky sequence (see section notarized tuples (tl txl where each notarized tuple has been observed until the end the cool-down period, i.e., the prefix chain[: there are multiple such lucky sequences, let log arbitrary one. suppose that chain[: -k] contains heartbeats consecutive slow-chain lengths where `start let logstable lucky sequence notarized tuples consistent with the hashes these heartbeats output the concatenation the following every round: logstable every tuple log whose sequence number not included logstable all other transactions contained chain[: -k] that have not yet been output (in the same order they appear chain). rebooting the fast path when nodes are the slow mode, they can reboot fast path execution again follows; let start(*) some general predicate which determines when leave the slow-mode (examples such predicates can found section .). let the earliest block such that chain[: contains skipped heartbeat. let chain* the shortest prefix chain such that |chain* and start(chain* -k]) where start policy-predicate, node would now enter the fast mode, and reset `start |chain* when there are multiple transitions between slow and fast modes, need assign unique epoch number every time new fast mode initiated. all mblock and heartbeat messages should additionally tagged with the epoch number (for simplicity, our earlier description omitted this epoch number). finally, when there are multiple epochs (where each epoch contains fast mode followed slow mode), nodes should sequentially output the logs all epochs one one (our above description explained how output the log from one such epoch). comparison with related initiatives provide some comparisons with related initiatives. offchain payment channels (e.g., lightning networks and raiden networks []) and state channels support fast offchain payments, but existing systems offer little smart contract programming support; moreover, parties need engage prior setup. several initiatives rely "classical-style" consensus methods build decentralized cryptocurrency. for example, zilliqa and tendermint rely pbft its variants reach consensus. comparison with thunder, which combines asynchronous fast path and synchronous "fallback", pbft instead relies asynchronous recovery path. this means that optimization practice, suffices check the part the slow-chain chain[`start `]. exceeds |chain|, round down |chain|. such lucky sequence has not been observed, query nodes the network for such lucky sequence; and before reply obtained, just output the same log the previous round. pbft can tolerate most fraction corruption due well-known lower bound (in contrast, our approach tolerates attack); pbft requires more rounds voting the normal path (which necessary for asynchronous recovery) and thus least twice slow our protocol; and comparison, our approach conceptually much simpler than pbft and thus friendlier implementation and large-scale deployment the beautiful work algorand designs new synchronous state machine replication protocol and builds cryptocurrency top. just like ours, their protocol provably secure. however, only tolerates corruptions; moreover, their approach requires complete redesign the consensus layer, whereas our approach allows accelerate any existing blockchain using simple fast-path protocol. several works rely dag-based approach [,] (rather than chain-based) prevent doublespending. these works not realize our notion linearly ordered log; they also not support general smart contracts/dapps. dfinity's approach relies offchain voting blocks reach finality blocks time". their approach does not improve throughput w.r.t. the underlying slowchain. ethereum's casper also relies offchain voting blocks, but they checkpoint blocks and not improve speed and throughput. the elegant plasma framework poon and buterin and several sharding initiatives are conceptually related ours. these approaches are orthogonal and complementary our effort. acknowledgments are very grateful the thunder team and vitalik buterin for his insightful feedback and comments. references https://lightning.network/. https://raiden.network/. https://www.zilliqa.com/. http://iota.org/. https://dfinity.org/. sharding blockchains. https://github.com/ethereum/wiki/wiki/sharding-faq. vitalik buterin. https://medium.com/@vitalikbuterin/ minimal-slashing-conditions-fbfcc, vitalik buterin and vlad zamfir. casper. https://blog.ethereum.org//// introducing-casper-friendly-ghost/, miguel castro and barbara liskov. practical byzantine fault tolerance. osdi, jing chen and silvio micali. algorand: https://arxiv.org/abs/., the efficient and democratic ledger. phil daian, rafael pass, and elaine shi. snow white: robustly reconfigurable consensus and applications provably secure proofs stake. cryptology eprint archive, report cynthia dwork, nancy lynch, and larry stockmeyer. consensus the presence partial synchrony. acm, stefan dziembowski, lisa eckey, sebastian faust, and daniel malinowski. perun: virtual payment channels over cryptographic currencies. iacr cryptology eprint archive, ittay eyal and emin gun sirer. majority not enough: bitcoin mining vulnerable. fc, pedro fonseca, kaiyuan zhang, wang, and arvind krishnamurthy. empirical study the correctness formally verified distributed systems. proceedings the twelfth european conference computer systems, eurosys pages new york, ny, usa, acm. kokoris-kogias, jovanovic, gasser, gailly, syta, and ford. omniledger: secure, scale-out, decentralized ledger via sharding. ieee symposium security and privacy (sp), volume pages jae kwon. tendermint: tendermint.pdf, consensus without mining. http://tendermint.com/docs/ andrew miller, iddo bentov, ranjit kumaresan, and patrick mccorry. sprites: payment channels that faster than lightning. corr, abs/., andrew miller, xia, kyle croman, elaine shi, and dawn song. the honey badger bft protocols. proceedings the acm sigsac conference computer and communications security, ccs pages new york, ny, usa, acm. rafael pass, lior seeman, and abhi shelat. analysis the blockchain protocol asynchronous networks. eurocrypt, rafael pass and elaine shi. thunderella: blockchains with optimistic instant confirmation. https://eprint.iacr.org//.pdf. rafael pass and elaine shi. fruitchains: fair blockchain. podc, rafael pass and elaine shi. hybrid consensus: efficient consensus the permissionless model. disc, joseph poon and vitalik buterin. plasma: scalable autonomous smart contracts. https: //plasma.io/. yonatan sompolinsky, yoad lewenberg, and aviv zohar. spectre: fast and scalable cryptocurrency protocol. iacr cryptology eprint archive,