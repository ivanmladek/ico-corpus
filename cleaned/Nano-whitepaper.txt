nano: feeless distributed cryptocurrency network colin lemahieu clemahieu@nano.co abstract--recently, high demand and limited scalability have increased the average transaction times and fees popular cryptocurrencies, yielding unsatisfactory experience. here introduce nano, cryptocurrency with novel block-lattice architecture where each account has its own blockchain, delivering near instantaneous transaction speed and unlimited scalability. each user has their own blockchain, allowing them update asynchronously the rest the network, resulting fast transactions with minimal overhead. transactions keep track account balances rather than transaction amounts, allowing aggressive database pruning without compromising security. date, the nano network has processed million transactions with unpruned ledger size only .gb. nano's feeless, split-second transactions make the premier cryptocurrency for consumer transactions. index terms--cryptocurrency, blockchain, nano, distributed ledger, digital, transactions ntroduction ince the implementation bitcoin there has been growing shift away from traditional, governmentbacked currencies and financial systems towards modern payments systems based cryptography, which offer the ability store and transfer funds trustless and secure manner []. order function effectively, currency must easily transferable, non-reversible, and have limited fees. the increased transaction times, large fees, and questionable network scalability have raised questions about the practicality bitcoin everyday currency. this paper, introduce nano, low-latency cryptocurrency built innovative block-lattice data structure offering unlimited scalability and transaction fees. nano design simple protocol with the sole purpose being high-performance cryptocurrency. the nano protocol can run low-power hardware, allowing practical, decentralized cryptocurrency for everyday use. cryptocurrency statistics reported this paper are accurate publication date. ii. background anonymous individual under the pseudonym satoshi nakamoto published whitepaper outlining the world's first decentralized cryptocurrency, bitcoin []. key innovation brought about bitcoin was the blockchain, public, immutable and decentralized data-structure which used ledger for the currency's transactions. unfortunately, bitcoin matured, several issues the protocol made bitcoin prohibitive for many applications: poor scalability: each block the blockchain can store limited amount data, which means the system can only process many transactions per second, making spots block commodity. currently the median transaction fee []. high latency: the average confirmation time minutes []. power inefficient: the bitcoin network consumes estimated .twh per year, using average kwh per transaction []. bitcoin, and other cryptocurrencies, function achieving consensus their global ledgers order verify legitimate transactions while resisting malicious actors. bitcoin achieves consensus via economic measure called proof work (pow). pow system participants compete compute number, called nonce, such that the hash the entire block target range. this valid range inversely proportional the cumulative computation power the entire bitcoin network order maintain consistent average time taken find valid nonce. the finder valid nonce then allowed add the block the blockchain; therefore, those who exhaust more computational resources compute nonce play greater role the state the blockchain. pow provides resistance against sybil attack, where entity behaves multiple entities gain additional power decentralized system, and also greatly reduces race conditions that inherently exist while accessing global data-structure. alternative consensus protocol, proof stake (pos), was first introduced peercoin []. pos system, participants vote with weight equivalent the amount wealth they possess given cryptocurrency. with this arrangement, those who have greater financial investment are given more power and are inherently incentivized maintain the honesty the system risk losing their investment. pos does away with the wasteful computation power competition, only requiring light-weight software running low power hardware. the original nano (raiblocks) paper and first beta implementation were published december, making one the first directed acyclic graph (dag) based cryptocurrencies []. soon after, other dag cryptocurrencies began develop, most notably dagcoin/byteball and iota [], []. these dag-based cryptocurrencies broke the blockchain mold, improving system performance and security. byteball achieves consensus relying "main-chain" comprised honest, reputable and user-trusted "witnesses", while iota achieves consensus via the cumulative pow stacked transactions. nano achieves consensus via balance-weighted vote repeat receive quorum observe confirm (a) when conflict detected, further overhead required. repeat receive observe conflict vote confirm (b) the event conflicting transaction, nodes vote for the valid transaction. fig. nano requires additional overhead for typical transactions. the event conflicting transactions, nodes must vote for the transaction keep conflicting transactions. this consensus system provides quicker, more deterministic transactions while still maintaining strong, decentralized system. nano continues this development and has positioned itself one the highest performing cryptocurrencies. iii. nano omponents before describing the overall nano architecture, define the individual components that make the system. account account the public-key portion digital signature key-pair. the public-key, also referred the address, shared with other network participants while the private-key kept secret. digitally signed packet data ensures that the contents were approved the private-key holder. one user may control many accounts, but only one public address may exist per account. block/transaction the term "block" and "transaction" are often used interchangeably, where block contains single transaction. transaction specifically refers the action while block refers the digital encoding the transaction. transactions are signed the private-key belonging the account which the transaction performed. account block account block account block account block account block account block account block account block account block account block account block account block fig. each account has its own blockchain containing the account's balance history. block must open transaction (section iv-b) ledger the ledger the global set accounts where each account has its own transaction chain (figure this key design component that falls under the category replacing run-time agreement with design-time agreement; everyone agrees via signature checking that only account owner can modify their own chain. this converts seemingly shared datastructure, distributed ledger, set non-shared ones. node node piece software running computer that conforms the nano protocol and participates the nano network. the software manages the ledger and any accounts the node may control, any. node may either store the entire ledger pruned history containing only the last few block each account's blockchain. when setting new node recommended verify the entire history and prune locally. iv. ystem overview unlike blockchains used many other cryptocurrencies, nano uses block-lattice structure. each account has its own blockchain (account-chain) equivalent the account's transaction/balance history (figure each account-chain can only updated the account's owner; this allows each accountchain updated immediately and asynchronously the rest the block-lattice, resulting quick transactions. nano's protocol extremely light-weight; each transaction fits within the required minimum udp packet size for being transmitted over the internet. hardware requirements for nodes are also minimal, since nodes only have record and rebroadcast blocks for most transactions (figure the system initiated with genesis account containing the genesis balance. the genesis balance fixed quantity and can never increased. the genesis balance divided and sent other accounts via send transactions registered the genesis account-chain. the sum the balances all accounts will never exceed the initial genesis balance which gives the system upper bound quantity and ability increase it. this section will walk through how different types transactions are constructed and propagated throughout the network. transactions transferring funds from one account another requires two transactions: send deducting the amount from the sender's time fig. visualization the block-lattice. every transfer funds requires send block (s) and receive block (r), each signed their account-chain's owner (a,b,c) balance and receive adding the amount the receiving account's balance (figure transferring amounts separate transactions the sender's and receiver's accounts serves few important purposes: sequencing incoming transfers that are inherently asynchronous. keeping transactions small fit udp packets. facilitating ledger pruning minimizing the data footprint. isolating settled transactions from unsettled ones. more than one account transferring the same destination account asynchronous operation; network latency and the sending accounts not necessarily being communication with each other means there universally agreeable way know which transaction happened first. since addition associative, the order the inputs are sequenced does not matter, and hence simply need global agreement. this key design component that converts run-time agreement design-time agreement. the receiving account has control over deciding which transfer arrived first and expressed the signed order the incoming blocks. account wants make large transfer that was received set many small transfers, want represent this way that fits within udp packet. when receiving account sequences input transfers, keeps running total its account balance that any time has the ability transfer any amount with fixed size transaction. this differs from the input/output transaction model used bitcoin and other cryptocurrencies. some nodes are uninterested expending resources store account's full transaction history; they are only interested each account's current balance. when account makes transaction, encodes its accumulated balance and these nodes only need keep track the latest block, which allows them discard historical data while maintaining correctness. even with focus design-time agreements, there delay window when validating transactions due identifying and handling bad actors the network. since agreements nano are reached quickly, the order milliseconds seconds, can present the user with two familiar categories incoming transactions: settled and unsettled. settled transactions are transactions where account has generated receive blocks. unsettled transactions have not yet been incorporated the receiver's cumulative balance. this replacement for the more complex and unfamiliar confirmations metric other cryptocurrencies. creating account create account, you need issue open transaction (figure open transaction always the first transaction every account-chain and can created upon the first receipt funds. the account field stores the public-key (address) derived from the private-key that used for signing. the source field contains the hash the transaction that sent the funds. account creation, representative must chosen vote your behalf; this can changed later (section iv-f). the account can declare itself its own representative. open account: dcb...aefab, source: dcebfc...aeba, representative: xrb_anr...posrs, work: type: open, signature: b...cb fig. anatomy open transaction account balance the account balance recorded within the ledger itself. rather than recording the amount transaction, verification (section iv-i) requires checking the difference between the balance the send block and the balance the preceding block. the receiving account may then increment the previous balance measured into the final balance given the new receive block. this done improve processing speed when downloading high volumes blocks. when requesting account history, amounts are already given. sending from account send from address, the address must already have existing open block, and therefore balance (figure the previous field contains the hash the previous block the account-chain. the destination field contains the account for funds sent to. send block immutable once confirmed. once broadcasted the network, funds are immediately deducted from the balance the senders account and wait pending until the receiving party signs block accept these funds. pending funds should not considered awaiting confirmation, they are good spent from the senders account and the sender cannot revoke the transaction. send previous: ea...ffebf, balance: aa...ddc, destination: xrb_w...mgoeuufdp, work: type: send, signature: b...cb fig. anatomy send transaction change previous: dcb...aefab, representative: xrb_anrz...posrs, work: type: change, signature: b...cb fig. anatomy change transaction cause conflicting view the status account and must resolved. only the account's owner has the ability sign blocks into their account-chain, fork must the result poor programming malicious intent (double-spend) the account's owner. account block receiving transaction complete transaction, the recipient sent funds must create receive block their own account-chain (figure the source field references the hash the associated send transaction. once this block created and broadcasted, the accounts balance updated and the funds have officially moved into their account. receive previous: dcb...aefab, source: dcebfc...aeba, work: type: receive, signature: b...cb account block account block account block fig. fork occurs when two (or more) signed blocks reference the same previous block. older blocks are the left; newer blocks are the right upon detection, representative will create vote referencing the block its ledger and broadcast the network. the weight node's vote, the sum the balances all accounts that have named its representative. the node will observe incoming votes from the other online representatives and keep cumulative tally for voting periods, minute total, and confirm the winning block (equation fig. anatomy receive transaction assigning representative account holders having the ability choose representative vote their behalf powerful decentralization tool that has strong analog proof work proof stake protocols. conventional pos systems, the account owner's node must running participate voting. continuously running node impractical for many users; giving representative the power vote account's behalf relaxes this requirement. account holders have the ability reassign consensus any account any time. change transaction changes the representative account subtracting the vote weight from the old representative and adding the weight the new representative (figure funds are moved this transaction, and the representative does not have spending power the account's funds. forks and voting fork occurs when signed blocks claim the same block their predecessor (figure these blocks v(bj =bj arg max v(bj the most popular block will have the majority the votes and will retained the node's ledger (equation the block(s) that lose the vote are discarded. representative replaces block its ledger, will create new vote with higher sequence number and broadcast the new vote the network. this the only scenario where representatives vote. some circumstances, brief network connectivity issues may cause broadcasted block not accepted all peers. any subsequent block this account will ignored invalid peers that did not see the initial broadcast. rebroadcast this block will accepted the remaining peers and subsequent blocks will retrieved automatically. even when fork missing block occurs, only the accounts referenced the transaction are affected; the rest the network proceeds with processing transactions for all other accounts. proof work transaction flooding all four transaction types have work field that must correctly populated. the work field allows the transaction creator compute nonce such that the hash the nonce concatenated with the previous field receive/send/change transactions the account field open transaction below certain threshold value. unlike bitcoin, the pow nano simply used anti-spam tool, similar hashcash, and can computed the order seconds []. once transaction sent, the pow for the subsequent block can precomputed since the previous block field known; this will make transactions appear instantaneous end-user long the time between transactions greater than the time required compute the pow. malicious entity could send many unnecessary but valid transactions between accounts under its control attempt saturate the network. with transaction fees they are able continue this attack indefinitely. however, the pow required for each transaction limits the transaction rate the malicious entity could generate without significantly investing computational resources. even under such attack attempt inflate the ledger, nodes that are not full historical nodes are able prune old transactions from their chain; this clamps the storage usage from this type attack for almost all users. transaction verification for block considered valid, must have the following attributes: the block must not already the ledger (duplicate transaction). must signed the account's owner. the previous block the head block the accountchain. exists but not the head, fork. the account must have open block. the computed hash meets the pow threshold requirement. receive block, check the source block hash pending, meaning has not already been redeemed. send block, the balance must less than the previous balance. attack ectors nano, like all decentralized cryptocurrencies, may attacked malicious parties for attempted financial gain system demise. this section outline few possible attack scenarios, the consequences such attack, and how nano's protocol takes preventative measures. block gap synchronization section iv-g, discussed the scenario where block may not properly broadcasted, causing the network ignore subsequent blocks. node observes block that does not have the referenced previous block, has two options: ignore the block might malicious garbage block. request resync with another node. the case resync, tcp connection must formed with bootstrapping node facilitate the increased amount traffic resync requires. however, the block was actually bad block, then the resync was unnecessary and needlessly increased traffic the network. this network amplification attack and results denial-of-service. avoid unnecessary resyncing, nodes will wait until certain threshold votes have been observed for potentially malicious block before initiating connection bootstrap node synchronize. block doesn't receive enough votes can assumed junk data. sybil attack entity could create hundreds nano nodes single machine; however, since the voting system weighted based account balance, adding extra nodes the network will not gain attacker extra votes. therefore there advantage gained via sybil attack. penny-spend attack penny-spend attack where attacker spends infinitesimal quantities large number accounts order waste the storage resources nodes. block publishing ratelimited the pow, this limits the creation accounts and transactions certain extent. nodes that are not full historical nodes can prune accounts below statistical metric where the account most likely not valid account. finally, nano tuned use minimal permanent storage space, space required store one additional account proportional the size open block indexing this equates being able store million penny-spend account. nodes wanted prune more aggressively, they can calculate distribution based access frequency and delegate infrequently used accounts slower storage. precomputed pow attack since the owner account will the only entity adding blocks the account-chain, sequential blocks can computed, along with their pow, before being broadcasted the network. here the attacker generates myriad sequential blocks, each minimal value, over extended period time. certain point, the attacker performs denial service (dos) flooding the network with lots valid transactions, which other nodes will process and echo quickly possible. this advanced version the transaction flooding described section v-b. such attack would only work briefly, but could used conjunction with other attacks, such attack (section v-f) increase effectiveness. transaction rate-limiting and other techniques are currently being investigated mitigate attacks. attack the metric consensus for nano balance weighted voting system. attacker able gain over the voting strength, they can cause the network oscillate consensus rendering the system broken. attacker able lower the amount balance they must forfeit preventing good nodes from voting through network dos. nano takes the following measures prevent such attack: the primary defense against this type attack votingweight being tied investment the system. account holder inherently incentivized maintain the honesty the system protect their investment. attempting flip the ledger would destructive the system whole which would destroy their investment. the cost this attack proportional the market capitalization nano. pow systems, technology can invented that gives disproportionate control compared monetary investment and the attack successful, this technology could repurposed after the attack complete. with nano the cost attacking the system scales with the system itself and attack were successful the investment the attack cannot recovered. order maintain the maximum quorum voters, the next line defense representative voting. account holders who are unable reliably participate voting for connectivity reasons can name representative who can vote with the weight their balance. maximizing the number and diversity representatives increases network resiliency. forks nano are never accidental, nodes can make policy decisions how interact with forked blocks. the only time non-attacker accounts are vulnerable block forks they receive balance from attacking account. accounts wanting secure from block forks can wait little lot longer before receiving from account who generated forks opt never receive all. receivers could also generate separate accounts use when receiving funds from dubious accounts order insulate other accounts. final line defense that has not yet been implemented block cementing. nano goes great lengths settle block forks quickly via voting. nodes could configured cement blocks, which would prevent them from being rolled back after certain period time. the network sufficiently secured through focusing fast settling time prevent ambiguous forks. more sophisticated version attack detailed figure "offline" the percentage representatives who have been named but are not online vote. "stake" the amount investment the attacker voting with. "active" representatives that are online and voting according the protocol. attacker can offset the amount stake they must forfeit knocking other voters offline via network dos attack. this attack can sustained, the representatives being attacked will become unsynchronized and this demonstrated "unsync." finally, attacker can gain short burst relative voting strength switching their denial service attack new set representatives while the old set resynchronizing their ledger, this demonstrated "attack." offline unsync attack active stake fig. potential voting arrangement that could lower attack requirements. attacker able cause stake >active combination these circumstances, they would able successfully flip votes the ledger the expense their stake. can estimate how much this type attack could cost examining the market cap other systems. estimate representatives are offline attacked via dos, attacker would need purchase the market cap order attack the system via voting. bootstrap poisoning the longer attacker able hold old private-key with balance, the higher the probability that balances that existed that time will not have participating representatives because their balances representatives have transferred newer accounts. this means node bootstrapped old representation the network where the attacker has quorum voting stake compared representatives that point time, they would able oscillate voting decisions that node. this new user wanted interact with anyone besides the attacking node all their transactions would denied since they have different head blocks. the net result nodes can waste the time new nodes the network feeding them bad information. prevent this, nodes can paired with initial database accounts and knowngood block heads; this replacement for downloading the database all the way back the genesis block. the closer the download being current, the higher the probability accurately defending against this attack. the end, this attack probably worse than feeding junk data nodes while bootstrapping, since they wouldn't able transact with anyone who has contemporary database. vi. mplementation currently the reference implementation implemented c++ and has been producing releases since github []. design features the nano implementation adheres the architecture standard outlined this paper. additional specifications are described here. signing algorithm: nano uses modified elliptic curve algorithm with blakeb hashing for all digital signatures []. was chosen for fast signing, fast verification, and high security. hashing algorithm: since the hashing algorithm only used prevent network spam, the algorithm choice less important when compared mining-based cryptocurrencies. our implementation uses blakeb digest algorithm against block contents []. key derivation function: the reference wallet, keys are encrypted password and the password fed through key derivation function protect against asic cracking attempts. presently argon the winner the only public competition aimed creating resilient key derivation function. block interval: since each account has its own blockchain, updates can performed asynchronous the state network. therefore there are block intervals and transactions can published instantly. udp message protocol: our system designed operate indefinitely using the minimum amount computing resources possible. all messages the system were designed stateless and fit within single udp packet. this also makes easier for lite peers with intermittent connectivity participate the network without reestablishing short-term tcp connections. tcp used only for new peers when they want bootstrap the block chains bulk fashion. nodes can sure their transaction was received the network observing transaction broadcast traffic from other nodes should see several copies echoed back itself. ipv and multicast building top connection-less udp allows future implementations use ipv multicast replacement for traditional transaction flooding and vote broadcast. this will reduce network bandwidth consumption and give more policy flexibility nodes going forward. performance the time this writing, million transactions have been processed the nano network, yielding blockchain size .gb. transaction times are measured the order seconds. current reference implementation operating commodity ssds can process over transactions per second being primarily bound. vii. esource sage this overview resources used nano node. additionally, over ideas for reducing resource usage for specific use cases. reduced nodes are typically called light, pruned, simplified payment verification (spv) nodes. network the network activity node dependent how much the node contributes towards the health network. representative: representative node requires maximum network resources observes vote traffic from other representatives and publishes its own votes. trustless: trustless node similar representative node but only observer, doesn't contain representative account private key and does not publish votes its own. trusting: trusting node observes vote traffic from one representative trusts correctly perform consensus. this cuts down the amount inbound vote traffic from representatives going this node. light: light node also trusting node that only observes traffic for accounts which interested allowing minimal network usage. bootstrap: bootstrap node serves parts all the ledger for nodes that are bringing themselves online. this done over tcp connection rather than udp since involves large amount data that requires advanced flow control. disk capacity depending the user demands, different node configurations require different storage requirements. historical: node interested keeping full historical record all transactions will require the maximum amount storage. current: due the design keeping accumulated balances with blocks, nodes only need keep the latest head blocks for each account order participate consensus. node uninterested keeping full history can opt keep only the head blocks. light: light node keeps local ledger data and only participates the network observe activity accounts which interested optionally create new transactions with private keys holds. cpu transaction generating: node interested creating new transactions must produce proof work nonce order pass nano's throttling mechanism. computation various hardware benchmarked appendix representative: representative must verify signatures for blocks, votes, and also produce its own signatures participate consensus. the amount cpu resources for representative node significantly less than transaction generating and should work with any single cpu contemporary computer. observer: observer node doesn't generate its own votes. since signature generation overhead minimal, the cpu requirements are almost identical running representative node. viii. onclusion this paper presented the framework for trustless, feeless, low-latency cryptocurrency that utilizes novel blocklattice structure and delegated proof stake voting. the network requires minimal resources, high-power mining hardware, and can process high transaction throughput. all this achieved having individual blockchains for each account, eliminating access issues and inefficiencies global data-structure. identified possible attack vectors the system and presented arguments how nano resistant these forms attacks. ppendix ardware benchmarks mentioned previously, the pow nano reduce network spam. our node implementation provides acceleration that can take advantage opencl compatible gpus. table provides real-life benchmark comparison various hardware. currently the pow threshold fixed, but adaptive threshold may implemented average computing power progresses. table ardware erformance device nvidia tesla (aws) nvidia tesla (google,cloud) nvidia tesla (google,cloud) amd nvidia gtx intel core avx intel core k,webassembly (firefox) google cloud vcores arm server cores (scaleway) transactions per second .-. .-. acknowledgment would like thank brian pugh for compiling and formatting this paper. eferences nakamoto, "bitcoin: peer-to-peer electronic cash system," [online]. available: http://bitcoin.org/bitcoin.pdf "bitcoin median transaction fee historical chart." [online]. available: https://bitinfocharts.com/comparison/bitcoin-median transaction fee.html "bitcoin average confirmation time." [online]. available: https: //blockchain.info/charts/avg-confirmation-time "bitcoin energy consumption index." [online]. available: https: //digiconomist.net/bitcoin-energy-consumption king and nadal, "ppcoin: peer-to-peer crypto-currency with proof-of-stake," [online]. available: https://peercoin.net/assets/ paper/peercoin-paper.pdf lemahieu, "raiblocks distributed ledger network," ribero and raissar, "dagcoin whitepaper," popov, "the tangle," back, "hashcash denial service counter-measure," [online]. available: http://www.hashcash.org/papers/hashcash.pdf lemahieu, "raiblocks," [online]. available: https://github. com/clemahieu/raiblocks bernstein, duif, lange, shwabe, and b.-y. yang, "high-speed high-security signatures," [online]. available: http://ed.cr.yp.to/ed-.pdf j.-p. aumasson, neves, wilcox-o'hearn, and winnerlein, "blake: simpler, smaller, fast md," [online]. available: https://blake.net/blake.pdf biryukov, dinu, and khovratovich, "argon: the memoryhard function for password hashing and other applications," [online]. available: https://password-hashing.net/argon-specs.pdf