kyber: on-chain liquidity protocol introduction protocol architecture design properties overview network actors kyber core smart contracts takers reserves execution sequences basic token trade token token trade reserves registration connecting liquidity between kyber based networks practical relay between chains relay network assets non smart contract enabled blockchains kyber network crystal (knc) usage main areas knc usage economic facilitation governance token treasury funds knc one single token unified supply across chains interchangeability between chains protocol level governance and treasury moving forward specifications protocol functions token trades adding and removing reserves and token pairs reserves interface getconversionrate trade kyber: on-chain liquidity protocol april abstract this paper presents kyber, fully on-chain liquidity protocol for implementing instant cryptocurrency token swaps decentralized manner any smart contract enabled blockchain. kyber design allows for any party contribute aggregated pool liquidity within each blockchain while providing single endpoint for takers execute trades using the best rates available. envision connected liquidity network that facilitates seamless, decentralized cross-chain token swaps across kyber based networks different chains. this paper provides the technical specifications and key design principles the protocol followed when being implemented smart contract enabled blockchains. also includes the specifications for liquidity makers takers participate any given implementation. introduction cryptocurrency trading centralized exchanges has been shown vulnerable cybersecurity hacking and internal frauds over the years, with the most infamous hacks being mt. gox and coincheck. addition, trading centralized exchanges not compatible with defi applications since technically infeasible bridge between decentralized applications and centralized servers without compromising the trust model. regardless, defi applications all need access good liquidity sources which critical component provide good services. currently, decentralized liquidity comprised various sources including dexes (uniswap, oasisdex, bancor), decentralized funds and other financial apps. the more scattered the sources, the harder becomes for anyone either find the best rate for their trade even find enough liquidity for their need. kyber fully on-chain liquidity protocol that can implemented any smart contract enabled blockchain. kyber's solution allows liquidity aggregated from diverse sources into single network, which turn provides single endpoint for takers seamlessly perform multiple token trades single blockchain transaction. end users, dapps any other party only need query this single endpoint get the best available rate for their trade. the protocol allows for wide range implementation possibilities for liquidity providers, allowing wide range entities contribute liquidity, including end users, decentralized exchanges and other decentralized protocols. the taker side, end users, cryptocurrency wallets, and smart contracts are able perform instant and trustless token trades the best rates available amongst the sources. the on-chain instant exchange property critical for enabling wide range decentralized use cases, including financial protocols and cryptocurrency payments. one would expect different implementations kyber protocol other public blockchains make on-chain instant exchanges available for various use cases and applications these blockchains. there are number other blockchains with distinctively different feature sets, solving different use cases, resulting plethora diverse emerging digital ecosystems. order support these emerging ecosystems, the kyber protocol will play key role these blockchains facilitating liquidity between the different stakeholders the respective ecosystems. addition, standardizing the design the reserve based liquidity model and actively working cross-chain solutions such peacerelay and the waterloo relay bridge, envision connected liquidity network across the implementations different chains. over time, envision the protocol contributors, network maintainers and community knc token holders working together govern kyber. kyber scales, appropriately decentralized governance framework will critical order decide important upgrades, treasury allocation, and additional features the protocol, and standardize the key aspects the implementations. particular, kyber will support one main implementation per blockchain that follows the exact protocol specification, knc governance, and utility. ii. protocol architecture design properties the heart the design, the protocol smart contracts offer single interface for the best available token exchange rates taken from aggregated liquidity pool across diverse sources. aggregated liquidity pool. the protocol aggregates various liquidity sources into one liquidity pool, making easy for takers find the best rates offered with one function call. diverse sources liquidity the protocol allows different types liquidity sources plugged into. liquidity providers may employ different strategies and different implementations contribute liquidity the protocol. permissionless. the protocol designed permissionless where any developer can set various types reserves, and any end user can contribute liquidity. implementations need take into consideration various security vectors, such reserve spamming, but can mitigated through staking mechanism. can expect implementations permissioned initially until the maintainers are confident about these considerations. the core feature that the kyber protocol facilitates the token swap between taker and liquidity sources. the protocol aims provide the following properties for token trades: instant settlement. takers not have wait for their orders fulfilled, since trade matching and settlement occurs single blockchain transaction. this enables trades part series actions happening single smart contract function. atomicity. when takers make trade request, their trade either gets fully executed, reverted. this "all nothing" aspect means that takers are not exposed the risk partial trade execution. public rate verification. anyone can verify the rates that are being offered reserves and have their trades instantly settled just querying from the smart contracts. ease integration. trustless and atomic token trades can directly and easily integrated into other smart contracts, thereby enabling multiple trades performed smart contract function. overview the protocol implemented set smart contracts any blockchain that fits the requirements. the following diagram shows overview the various actors involved implementation the protocol. figure overview actors protocol implementation briefly define the actors below. the details how each actor works specified section network actors takers refer anyone who can directly call the smart contract functions trade tokens, such end-users, dapps, and wallets. reserves refer anyone who wishes provide liquidity. they have implement the smart contract functions defined the reserve interface order registered and have their token pairs listed. registered reserves refer those that will cycled through for matching taker requests. maintainers refer anyone who has permission access the functions for the adding/removing reserves and token pairs, such dao the team behind the protocol implementation. all, they comprise the network which refers all the actors involved any given implementation the protocol. the protocol implementation needs have the following: functions for takers check rates and execute the trades functions for the maintainers register/remove reserves and token pairs reserve interface that defines the functions reserves needs implement network actors kyber core smart contracts kyber core smart contracts implementation the protocol that has major protocol functions allow actors join and interact with the network. for example, the kyber core smart contracts provide functions for the listing and delisting reserves and trading pairs having clear interfaces for the reserves comply able register the network and adding support for new trading pairs. addition, the kyber core smart contracts also provide function for takers query the best rate among all the registered reserves, and perform the trades with the corresponding rate and reserve. trading pair consists quote token and any other token that the reserve wishes support. the quote token the token that either traded from for all trades. for example, the ethereum implementation the kyber protocol uses ether the quote token. order search for the best rate, all reserves supporting the requested token pair will iterated through. hence, the kyber core smart contracts need have this search algorithm implemented. the key functions implemented the kyber core smart contracts are listed figure below. will visit and explain the implementation details and security considerations each function the specification section figure kyber core smart contract oop diagram takers taker entity that takes the liquidity provided the registered reserves calling the trade() function the protocol smart contracts trade from one token another token. taker can any blockchain entity including end user address, decentralized exchanges any smart contracts. when calling the trade() function, the taker needs specify the source and destination tokens, the minimum acceptable rate for the taker, and send the corresponding amount source token along. the taker will receive the destination token immediately the transaction successfully executed, otherwise the source token will refunded entirely. reserves reserves are liquidity sources the network that provide liquidity terms tokens inventory and prices their smart contracts. implementing the reserve interface, depicted figure below, the reserve can register the protocol smart contracts and offer its liquidity for takers take. the details for how reserves determine the prices and manage their inventory not dictated the protocol and entirely the reserves, long the implementation complies with the reserve interface. that opens wide range reserve types that can part the network including manually managed reserves (i.e. having market makers actively manage the prices and inventory), automated market making reserves well many other on-chain liquidity sources. once the taker sent the request, the protocol smart contracts will query the corresponding function the reserve smart contract (e.g. getconversionrate() query the price, and trade() execute the trade). worth noting that the permissionless implementation the protocol, one may have consider how prevent potential attacks that makes costly execute trades, even block trades from being successfully executed, such reserve spamming attack (i.e. attacker sets and register lot reserves) malicious implementation reserves (e.g. reserves not honor the quoted rates). figure reserve interface oop diagram iii. execution sequences when trade executed, kyber's main contract invokes functions iterate through all listed reserves find and select the one offering the best exchange rate. the source tokens are transferred from the takers that reserve, and the reserve's destination tokens are transferred the specified destination address. basic token trade basic token trade one that has the quote token either the source destination token the trade request. the execution flow basic token trade depicted the diagram below, where taker would like exchange bat tokens for eth example. the trade happens single blockchain transaction. figure basic token trade execution flow taker sends eth the protocol contract, and would like receive bat return. protocol contract queries the first reserve for its eth bat exchange rate. reserve offers exchange rate eth for bat. protocol contract queries the second reserve for its eth bat exchange rate. reserve offers exchange rate eth for bat. this process goes for the other reserves. after the iteration, reserve discovered have offered the best eth bat exchange rate. protocol contract sends eth reserve the reserve sends bat the taker. token token trade token token trade one where the quote token neither the source nor the destination token the trade request. the exchange flow token token trade depicted the diagram below, where taker would like exchange bat tokens for dai example. the trade happens single blockchain transaction. figure token token trade execution flow taker sends bat the protocol contract, and would like receive dai return. protocol contract sends bat the reserve offering the best bat eth rate. protocol contract receives eth return. protocol contract sends eth the reserve offering the best eth dai rate. protocol contract receives dai return. protocol contract sends dai the user. while the diagram depicts reserves being selected for the token trades, possible that the same reserve selected. reserves registration the diagram below shows how the protocol contract interacts with the reserve smart contract for its addition removal from the network reserves, listing its token(s) for trading, and reading its token exchange rates. there are many possible implementations reserves. anyone can create new reserve, long the reserve smart contract contains the methods specified the "feeding rates and providing liquidity" section. the reserve needs added the network reserves order selected for taker trade requests. figure reserve interaction with protocol protocol contract adds the reserve into the network. protocol contract enables the token pairs the reserve for trading. iv. connecting liquidity between kyber based networks currently, kyber network fully developed with robust user base and dapp ecosystem single blockchain ethereum. this paper, outline how liquidity can connected between various smart contract enabled blockchains several practical approaches that kyber has explored thus far. allowing liquidity moved freely and (somewhat) transparently between different chains, kyber enables much more connected liquidity network between various blockchain ecosystems. connected liquidity network for decentralized cross-chain swaps across kyber implementations practical relay between chains for smart contract-enabled chains, the most practical interoperability implementation have light client smart contract which can implemented both blockchains and efficient algorithm verify the hash functions from both blockchains with minimal computation costs can used. our waterloo project, presented proof concept prove the feasibility practical relay approach between ethereum and eos. also demonstrated similar approach the peacerelay project connect between ethereum and ethereum classic. expect generalized approach the above applicable any smart contract enabled blockchain where light client can implemented smart contract that chain. relay implements bi-directional relay block headers between two blockchains. such bridge, block headers blockchain are constantly being submitted smart contract blockchain which implements light client logic verify the validity the headers. analogously, headers from blockchain are submitted smart contract blockchain all the blockchain protocols are aware of, the block header contains mathematically verifiable witness for every transaction the block. typically, this the form merkle root all the included transactions. hence, smart contract that validates headers can used also validate the existence transaction that header. once smart contract can verify transactions, can also verify operation, e.g., token transfer, that was done this action. the smart contracts each blockchain serves light client, and such does not verify the validity the block content, but rather only the block header. the relays will used transfer assets between the different blockchains enable trading activity across blockchains while using each one's distinct advantages. for example, the eos chain has advantage enabling higher frequency trading due its higher transaction-per-second rate, while the ethereum chain considered more secure the crypto community large and currently offers more popular assets with advanced financial primitives, such with the defi projects. cross-chain trades occur, anyone can view the corresponding transaction hashes cross-chain conversion. every token that moves through the protocol verifiable all chains where the token trades have taken place. relay network the first key implementing decentralized token swaps across two networks different blockchains creating relay for every unidirectional cross-chain link, and having entities relay and validate cross-chain communications. each individual kyber network deployment linked relayer and validator network smart contract enabled blockchain. the relays can designed open and trustless such that anyone can join and relay transactions, assets between chains, removing potential central points failure. the above diagram shows one potential chain topology for the relay network, where ethereum the center, connecting the other chains. this relay network will active area research, which expect share results future updates. assets non smart contract enabled blockchains for cryptocurrencies with blockchains that not natively support smart contracts, approach similar wrapped btc (wbtc) can adopted. tokenized cryptocurrencies wrapped coins utilize custodian model implement the tokenization cryptocurrency such bitcoin monero smart contract enabled blockchain. for each wrapped coin minted into existence the smart contract enabled blockchain, there equivalent amount the same cryptocurrency held custody ratio. this method has the benefit the ease transparency with all custodian funds being fully verifiable on-chain. the wrapped coin approach pragmatic one and represents immediate benefit dexes, dapps, and other smart contracts without any restriction. kyber network crystal (knc) usage kyber network crystal (knc) integral part the kyber protocol, and will serve crucial economic, governance and treasury functionalities across all implementations the protocol. networks that not have knc key part the usage utility and governance will not considered and will not supported either the project the community. the exact usage knc different chains dependent the specific implementation. key details include specific features the different chains, and the maturity both the ecosystem and the protocol implementation. the network maintainers are expected make these decisions initially, and after the implementation reaches certain stage maturity, expect the decisions made community knc holders. such, can expect see distinction between protocol maintainers, who focus protocol level governance like unified knc supply, and network maintainers, who focus the economics and technical features the implementation their chain. roles likely responsibilities involving knc protocol maintainer (for the whole protocol) governing the unified knc supply protocol specs and treasury cross-chain compatibility for knc network maintainers (for each blockchain implementation, ie. the network) governance implementation, ensuring conforms the protocol specs determining tokenomic parameters protocol level and network level maintainers main areas knc usage here are the main areas expect knc used: economic facilitation knc used part the transaction facilitate ongoing system operations. for example, getting reserves pay fee knc for every trade acts barrier for them perform wash trading. this fee can incorporated into their spread. addition, users who need instant liquidity can pay the fees order get the trade facilitated. the scope kyber expands, there are several possible mechanisms leverage knc staking mechanism acts barrier for malicious actors and safeguards the integrity the kyber ecosystem. for example, requirement for reserves stake knc considered part the network, requirement for relayers and validators facilitate cross-chain transactions between kyber based networks different chains. governance token knc will utilized for governance the protocol level and for the networks different chains. for protocol level specs and initiatives, expect there overall knc based dao which will help make decisions for the overall spec and funding proposals. for individual implementations the various chains, there will host tokenomic parameters, upgrade decisions, token listings, which knc stakeholders will turn able vote and decide on. treasury funds top the economic and governance knc, expect there knc based treasury that network maintainers and the dao members can leverage source funds fund development, marketing and growth the kyber protocol via open grant programs and proposals. this will allow network the most important contributors, those who drive adoption and those who build the core platform earn part their income with knc. getting knc into the hands contributors, and giving them economic interest the success the platform, move towards sustainable decentralized community and system. knc one single token while knc will get represented different chains (via relays), will managed one single token terms unified supply, interchangeability and terms being used for protocol governance and treasury. unified supply across chains knc supply will managed one economic concept. any event which might require transfer knc from the ethereum chain another chain, changes the unified supply will have approved the dao protocol maintainers, and are only likely occur when the protocol gets implemented chain. interchangeability between chains are striving for interchangeability between chains that knc tokens can easily moved from one chain another. such, are exploring various cross-chain technologies (e.g. peacerelay and waterloo) that can enable this functionality way that technically feasible. protocol level governance and treasury apart from governing the unified knc token supply and making decisions the protocol specifications, protocol maintainers also govern treasury fund research and development efforts for adoption the protocol different blockchains, for knc token interoperability and other causes. moving forward the kyber system and community grows, knc will play ever more crucial role ensuring that kyber continues evolve cohesive economic and purposeful community. look forward including more details about knc, particularly the protocol level governance, managing knc ledger and supply across-chains, and the technical workings the dao and treasury future papers. vi. specifications protocol functions the methods below are all implemented smart contracts, and are used interact with the protocol smart contracts. token trades the contract functions below are executed the taker view the expected token conversion rate, and make trade request. getexpectedrate the getexpectedrate() function called query for the expected and slippage token exchange rate the src token the dest token. parameter type description src address source token address dest address destination token address srcqty uint amount source token figure input parameters getexpectedrate() function parameter expectedrate type uint description expected token exchange rate figure return parameter getexpectedrate() function rate zero signifies that trade from the requested source token amount the destination token not possible the moment. the rates returned are precision values regardless the source destination's token decimals. give example below. example token token name token symbol token decimals src gifto gto dest zilliqa zil figure token information for conversion rate example suppose taker queries for the gto zil conversion rate, and the number returned. assume that the precision value **. (**) this means gto token can exchanged for zil tokens. hence, see that even though the source and token decimals are different, the returned rate precision values. trade the trade() function called trade from one token another. the converted tokens will sent destaddress the implementation this function should consider all security checks prevent rate manipulation from the reserves and/ incorrect implementation the reserves make sure the trade happens expected for taker. parameter type description src address source token address srcamount uint amount source token dest address destination token address destaddress address recipient address for destination tokens maxdestamount uint maximum amount destination tokens convert to. any excess source tokens after conversion are returned the sender. minconversionrate uint minimum conversion rate; trade cancelled rate lower. this parameter protects the user from rate slippage while the transaction being mined being included the blockchain. figure input parameters trade() function parameter type uint description actual amount destination tokens traded figure return parameter tradewithhint() function adding and removing reserves and token pairs the functions below are executed add remove new reserves, and enable disable token trades. addreserve the addreserve() function called add reserve liquidity provider. parameter type description reserve address reserve contract address filterflag boolean dependent protocol implementation decide how use this flag figure input parameters addreserve() function parameter type description bool returns true operation successful, false otherwise figure return parameter addreserve() function removereserve the removereserve() function called remove reserve from the protocol. parameter type description reserve address reserve contract address index uint index reserve the reserve array figure input parameters for removereserve() function parameter type bool description returns true operation successful, false otherwise figure return parameter removereserve() function listpairforreserve the listpairforreserve() function called denote which token pairs are supported for each listed reserve. parameter type description reserve address reserve contract address token address token address buytoken boolean true: buying tokens enabled false: buying tokens disabled selltoken boolean true: selling tokens enabled false: selling tokens disabled add boolean true: enable token pair trade false: disable token pair trade figure input parameters listpairforreserve() function parameter type bool description returns true operation successful, false otherwise figure return parameter for listpairforreserve() function reserves interface any reserve that wants provide liquidity for protocol users will need implement methods for connecting the main protocol contract. getconversionrate the getconversionrate() function implemented the reserve for the main protocol contract obtain token exchange rates. parameter type description src address source token address dest address destination token address srcqty uint amount source tokens figure input parameters getconversionrate() function parameter type uint description token conversion rate figure return parameter getconversionrate() function the conversion rate returned precision values regardless the source's destination's token decimals, explained above the getexpectedrate() function. addition, the reserve unable fulfill the trade request (eg. does not hold enough destination tokens for the taker exchange to), expected return rate zero. trade the trade() function called the main protocol contract when the reserve selected fill the user trade order. notice that this function differs from that the taking orders. interface, the network contract expects reserves implement this trade() function order actually use the `srcamount` `srctoken` the network sent to, calculate the amount `desttoken` regarding `conversionrate` and send them `destaddress`, `validate` param the reserve use. parameter type description srctoken address source token address srcamount uint amount source token desttoken address destination token address destaddress address recipient address for destination tokens conversionrate uint actual token conversion rate validate boolean true: additional validations are performed false: additional validations are not performed figure input parameters trade() function parameter type bool description returns true operation successful, false otherwise figure return parameter trade() function the reserve part the network reserves once has been added and its token pairs listed for trading.