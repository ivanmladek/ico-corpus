zerocash: decentralized anonymous payments from bitcoin (extended version) eli ben-sasson* alessandro chiesa+ ian miers++ christina garman++ eran tromerss matthew green++ madars virza+ may abstract bitcoin the first digital currency see widespread adoption. although payments are conducted between pseudonyms, bitcoin cannot offer strong privacy guarantees: payment transactions are recorded public decentralized ledger, from which much information can deduced. zerocoin (miers al., ieee s&p tackles some these privacy issues unlinking transactions from the payment's origin. yet still reveals payment destinations and amounts, and limited functionality. this paper, construct full-fledged ledger-based digital currency with strong privacy guarantees. our results leverage recent advances zero-knowledge succinct non-interactive arguments knowledge (zk-snarks). formulate and construct decentralized anonymous payment schemes (dap schemes). dap scheme lets users pay each other directly and privately: the corresponding transaction hides the payment's origin, destination, and amount. provide formal definitions and proofs the construction's security. then build zerocash, practical instantiation our dap scheme construction. zerocash, transactions are less than and take under verify orders magnitude more efficient than the less-anonymous zerocoin and competitive with plain bitcoin. keywords: bitcoin, decentralized electronic cash, zero-knowledge proofs technion, eli@cs.technion.ac.il mit, {alexch, madars}@mit.edu johns hopkins university, {cgarman, imiers, mgreen}@cs.jhu.edu tel aviv university, tromer@cs.tau.ac.il contents introduction zk-snarks centralized anonymous payment systems decentralized anonymous payment schemes zerocash paper organization background zk-snarks informal definition comparison with nizks known constructions and security zk-snark implementations definition decentralized anonymous payment scheme data structures algorithms completeness security construction decentralized anonymous payment scheme cryptographic building blocks zk-snarks for pouring coins algorithm constructions completeness and security zerocash instantiation building blocks arithmetic circuit for pouring coins integration with existing ledger-based currencies integration replacing the base currency integration hybrid currency extending the bitcoin protocol support the combined additional anonymity considerations semantics experiments performance zk-snarks for pouring coins performance zerocash algorithms large-scale network simulation optimizations and extensions everlasting anonymity fast block propagation improved storage requirements concurrent work conclusion acknowledgments overview bitcoin and zerocoin bitcoin zerocoin completeness dap schemes security dap schemes ledger indistinguishability transaction non-malleability balance proof theorem proof ledger indistinguishability proof transaction non-malleability proof balance references introduction bitcoin the first digital currency achieve widespread adoption. the currency owes its rise part the fact that, unlike traditional e-cash schemes [cha, chl, st], requires trusted parties. instead appointing central bank, bitcoin uses distributed ledger known the block chain store transactions carried out between users. because the block chain massively replicated mutually-distrustful peers, the information contains public. while users may employ many identities (or pseudonyms) enhance their privacy, increasing body research shows that anyone can de-anonymize bitcoin using information the block chain [rm, bbsu, rs, mpj+ such the structure the transaction graph well the value and dates transactions. result, bitcoin fails offer even modicum the privacy provided traditional payment systems, let alone the robust privacy anonymous e-cash schemes. while bitcoin not anonymous itself, those with sufficient motivation can obfuscate their transaction history with the help mixes (also known laundries tumblers). mix allows users entrust set coins pool operated central party and then, after some interval, retrieve different coins (with the same total value) from the pool. however, mixes suffer from three limitations: (i) the delay reclaim coins must large allow enough coins mixed in; (ii) the mix operator can trace coins; and (iii) the mix operator may steal coins. for users with "something hide", these risks may acceptable. but typical legitimate users wish keep their spending habits private from their peers, are risk-averse and not wish expend continual effort protecting their privacy, and are often not sufficiently aware that their privacy has been compromised. protect their privacy, users thus need instant, risk-free, and, most importantly, automatic guarantee that data revealing their spending habits and account balances not publicly accessible their neighbors, co-workers, and the merchants with whom they business. anonymous transactions also ensure that the market value coin independent its history, thus ensuring that legitimate users' coins remain fungible. zerocoin: decentralized mix. miers al. [mggr] proposed zerocoin, which extends bitcoin provide strong anonymity guarantees. like many e-cash protocols (e.g., [chl]), zerocoin employs zero-knowledge proofs prevent transaction graph analyses. unlike earlier practical e-cash protocols, however, zerocoin does not rely digital signatures validate coins, nor does require central bank prevent double spending. instead, zerocoin authenticates coins proving, zero-knowledge, that they belong public list valid coins (which can maintained the block chain). yet rather than full-fledged anonymous currency, zerocoin decentralized mix, where users may periodically "wash" their bitcoins via the zerocoin protocol. routine day-to-day transactions must conducted via bitcoin, due reasons that now review. the first reason performance. redeeming zerocoins requires double-discrete-logarithm proofs knowledge, which have size that exceeds and require verify (at the -bit security level). these proofs must broadcast through the network, verified every node, and permanently stored the ledger. the entailed costs are higher, orders magnitude, than those bitcoin and can seriously tax bitcoin network operating normal scale. coinjoin [max], alternative proposal, replaces the central party mix with multi-signature transactions that involve many collaborating bitcoin users. coinjoin can thus only mix small volumes coins amongst users who are currently online, prone denial-of-service attacks third parties, and requires effort find mixing partners. while the methods detail this paper accomplish this, the same techniques open the door for privacy-preserving accountability and oversight (see section these published numbers [mggr] actually use mix parameters both -bit and -bit security for different components the construction. the cost higher all parameters are instantiated -bit security. the second reason functionality. while zerocoin constitutes basic e-cash scheme, lacks critical features required full-fledged anonymous payments. first, zerocoin uses coins fixed denomination: does not support payments exact values, nor does provide means give change following transaction (i.e., divide coins). second, zerocoin has mechanism for one user pay another one directly "zerocoins". and third, while zerocoin provides anonymity unlinking payment transaction from its origin address, does not hide the amount other metadata about transactions occurring the network. our contribution. addressing this challenge, this work offers two main contributions. introduce the notion decentralized anonymous payment scheme, which formally captures the functionality and security guarantees full-fledged decentralized electronic currency with strong anonymity guarantees. provide construction this primitive and prove its security under specific cryptographic assumptions. the construction leverages recent advances the area zero-knowledge proofs. specifically, uses zero-knowledge succinct non-interactive arguments knowledge (zk-snarks) [gro, lip, bci+ ggpr, pghr, bcg+ lip, bctv]. implement the above primitive, via system that call zerocash. our system (at bits security): reduces the size transactions spending coin under (an improvement over .%); reduces the spend-transaction verification time under (an improvement over .%); allows for anonymous transactions variable amounts; hides transaction amounts and the values coins held users; and allows for payments made directly user's fixed address (without user interaction). validate our system, measured its performance and established feasibility conducting experiments test network nodes (approximately the unique ips the bitcoin network and the nodes reachable any given time [dw]). this inspires confidence that zerocash can deployed fork bitcoin and operate the same scale. thus, due its substantially improved functionality and performance, zerocash makes possible entirely replace traditional bitcoin payments with anonymous alternatives. concurrent work. the idea using zk-snarks the bitcoin setting was first presented one the authors bitcoin [ben]. concurrent work, danezis al. [dfkp] suggest using zk-snarks reduce proof size and verification time zerocoin; see section for comparison. zk-snarks zk-snark efficient variant zero-knowledge proof knowledge [gmr], which first informally describe via example. suppose alice wishes prove bob the statement (alice) own bitcoins". simple method for alice point coins the block chain and, for each them, sign message ("hello, world") using the secret key that controls that coin. alas, this method leaks knowledge bob, identifying which coins are alice's. zero-knowledge proof knowledge allows alice achieve the same goal, while revealing information bob (beyond the fact that she knows some secret keys that control coins). crucially, such proofs can obtained for any statement that can verified true use efficient computation involving auxiliary inputs such trapdoors and passwords (such statements are called "np statements"). now sketch more technical terms the definition zk-snark; see section for more details. zk-snark non-interactive zero-knowledge proof knowledge that succinct, i.e., for which proofs are very short and easy verify. more precisely, let language, and let nondeterministic decision circuit for given instance size zk-snark can used prove and verify membership for instances size follows. after taking input, trusted party conducts one-time setup phase that results two public keys: proving key and verification key vk. the proving key enables any (untrusted) prover produce proof attesting the fact that for instance (of size his choice. the non-interactive proof zero knowledge and proof knowledge. anyone can use the verification key verify the proof particular zk-snark proofs are publicly verifiable: anyone can verify without ever having interact with the prover who generated succinctness requires that (for given security level) has constant size and can verified time that linear |x| (rather than linear |c|). centralized anonymous payment systems before describing our new decentralized payment system, put context recalling two pre-bitcoin payment schemes, both which relied bank, acting central trusted party. anonymous e-cash. chaum [cha] first obtained anonymous e-cash. chaum's scheme, the minting coin involves both user, alice, and the bank: mint coin given value alice first selects random secret serial number (unknown the bank); then, the bank, after deducting from alice's balance, signs via blind signature. afterwards, alice wants transfer her coin bob, she reveals him and proves that was signed the bank; during this transfer, bob (or the bank) cannot deduce alice's identity from the revealed information. double-spending prevented because the bank will not honor coin with previously-seen serial number. unforgeable e-cash. one problem with chaum's scheme that coins can forged the bank's secret key compromised. sander and ta-shma [st] addressed this, follows. the bank maintains public merkle tree "coin commitments", and users periodically retrieve its root rt; particular, the bank maintains secrets. when alice requests coin (of unit value), she picks random serial number and auxiliary string and then sends crh(snkr) the bank, where crh collision-resistant hash; the bank deducts the appropriate amount from alice's balance and then records leaf the merkle tree. afterwards, pay bob, alice sends him along with zero-knowledge proof knowledge the following statement: "there exists such that crh(snkr) leaf merkle tree with root rt". other words, alice can convince bob that the serial number contained some coin commitment the merkle tree; but the zero-knowledge property prevents bob from learning information about which coin commitment alice's, thereby protecting alice's identity. later, bob can "cash out" alice's coin showing and the bank. moving fungible anonymous decentralized system. this paper, like [st], hash coin's serial number and use merkle trees compactly represent the set minted coins. unlike [st], also ensure the privacy coin's value and support transactions that split and merge coins, thus achieving (and implementing) new kind fully-fungible and divisible payment scheme. bitcoin (and stark contrast previous e-cash schemes), not rely trusted bank. therefore, require new set definitions and protocols, designed protect alice's anonymity while preventing her from falsely increasing her balance under the veil her boosted privacy. informal description our payment scheme follows. decentralized anonymous payment schemes construct decentralized anonymous payment (dap) scheme, which decentralized e-cash scheme that allows direct anonymous payments any amount. see section for formal definition. omit details about how the bank can identify alice the event that she double spends her coin. here, outline our construction six incremental steps; the construction details are section our construction functions top any ledger-based base currency, such bitcoin. any given time, unique valid snapshot the currency's ledger available all users. the ledger sequence transactions and append-only. transactions include both the underlying currency's transactions, well new transactions introduced our construction. for concreteness, focus the discussion below bitcoin (though later definitions and constructions are stated abstractly). assume familiarity with bitcoin [nak] and zerocoin [mggr]; both are reviewed appendix step user anonymity with fixed-value coins. first describe simplified construction, which all coins have the same value of, e.g., btc. this construction, similar the zerocoin protocol, shows how hide payment's origin. terms tools, make use zk-snarks (recalled above) and commitment scheme. let comm denote statistically-hiding non-interactive commitment scheme (i.e., given randomness and message the commitment commr (m); subsequently, opened revealing and and one can verify that commr (m) equals c). the simplified construction, new coin minted follows: user samples random serial number and trapdoor computes coin commitment commr (sn), and sets (r, sn, cm). corresponding mint transaction txmint containing (but not r), sent the ledger; txmint appended the ledger only has paid btc backing escrow pool (e.g., the btc may paid via plaintext information encoded txmint mint transactions are thus certificates deposit, deriving their value from the backing pool. subsequently, letting cmlist denote the list all coin commitments the ledger, may spend posting spend transaction txspend that contains (i) the coin's serial number sn; and (ii) zk-snark proof the statement know such that commr (sn) appears the list cmlist coin commitments". assuming that does not already appear the ledger (as part past spend transaction), can redeem the deposited amount btc, which can either keep, transfer someone else, mint new coin. (if does already appear the ledger, this considered double spending, and the transaction discarded.) user anonymity achieved because the proof zero-knowledge: while revealed, information about is, and finding which the numerous commitments cmlist corresponds particular spend transaction txspend equivalent inverting (x) commx (sn), which assumed infeasible. thus, the origin the payment anonymous. step compressing the list coin commitments. the above statement, cmlist specified explicitly list coin commitments. this naive representation severely limits scalability because the time and space complexity most protocol algorithms (e.g., the proof verification algorithm) grow linearly with cmlist. moreover, coin commitments corresponding already-spent coins cannot dropped from cmlist reduce costs, since they cannot identified (due the same zero-knowledge property that provides anonymity). [st], rely collision-resistant function crh avoid explicit representation cmlist. maintain efficiently-updatable append-only crh-based merkle tree tree(cmlist) over the (growing) list cmlist and let denote the root tree(cmlist). well-known that can updated account for the insertion new leaves with time and space proportional just the tree depth. hence, the time and space complexity reduced from linear the size cmlist logarithmic. with this mind, modify the statement the following one: know such that commr (sn) appears leaf crh-based merkle tree whose root rt". compared with the naive data structure for cmlist, this modification increases exponentially the size cmlist that given zk-snark implementation can support. (concretely: using merkle trees depth zerocash supports coins.) step extending coins for direct anonymous payments. far, the coin commitment coin commitment the coin's serial number sn. however, this creates problem when transferring another user. indeed, suppose that user created and sends another user first, since knows sn, the spending both non-anonymous (since sees when spent, recognizing sn) and risky (since could still spend first). thus, must immediately spend and mint new coin protect himself. second, fact wants transfer e.g., btc, then doing both unwieldy (since requires transfers) and non-anonymous (since the amount the transfer leaked). and third, transfers amounts that are not multiples btc (the fixed value coin) are not supported. thus, the simplified construction described inadequate payment scheme. address this modifying the derivation coin commitment, and using pseudorandom functions target payments and derive serial numbers, follows. use three pseudorandom functions (derived from single one). for seed these are denoted prfaddr (*), prfsn (*), and prfpk (*). assume that prf moreover collision-resistant. provide targets for payments, use addresses: each user generates address key pair (apk ask the address public key and address private key respectively. the coins contain the value apk and can spent only with knowledge ask key pair (apk ask sampled selecting random seed ask and setting apk prfaddr ask (). user can generate and use any number address key pairs. next, redesign minting allow for greater functionality. mint coin desired value the user first samples which secret value that determines the coin's serial number prfsn ask (r). then, commits the tuple (apk two phases: (a) computes commr (apk kr) for random and then (b) computes comms (vkk) for random the minting results coin (apk cm) and mint transaction txmint (v, cm). crucially, due the nested commitment, anyone can verify that txmint coin commitment coin value (by checking that comms (vkk) equals cm) but cannot discern the owner (by learning the address key apk serial number (derived from because these are hidden before, txmint accepted the ledger only deposits the correct amount, this case btc. coins are spent using the pour operation, which takes set input coins, consumed, and "pours" their value into set fresh output coins such that the total value output coins equals old the total value the input coins. suppose that with address key pair (aold ask wishes consume old old old old old new and cnew with total his coin cold (aold and produce two new coins new (the addresses value vnew vnew old respectively targeted address public keys anew and pk, pk, new anew pk, and apk, may belong some other user.) the user for each proceeds new comm new (anew krnew follows: (i) samples serial number randomness rnew (ii) computes pk,i new new new new for random and (iii) computes cmi commsnew for random snew new new new new new new (anew new rnew this yields the coins cnew (anew pk, and pk, new new new next, produces zk-snark proof ppour for the following statement, which call pour: new "given the merkle-tree root rt, serial number snold and coin commitments cmnew old new new old know coins and address secret key ask such that: old old the coins are well-formed: for cold holds that old commrold (aold and commsold old old and similarly for cnew and cnew addr the address secret key matches the public key: aold prfaold (). the serial number computed correctly: snold prfsn (rold aold the coin commitment cmold appears leaf merkle-tree with root rt. the values add up: vnew vnew old new resulting pour transaction txpour (rt, snold cmnew ppour appended the ledger. (as before, the transaction rejected the serial number appears previous transaction.) now suppose that does not know, say, the address secret key anew sk, that associated with the new because cannot provide anew part the witness public key anew then, cannot spend pk, sk, new subsequent pour operation. furthermore, when user who knows anew sk, does spend the user cannot track it, because knows information about its revealed serial number, which snnew prfsn (rnew anew sk, also observe that txpour reveals information about how the value the consumed coin was divided among the two new fresh coins, nor which coin commitment corresponds the consumed coin, nor the address public keys which the two new fresh coins are targeted. the payment was conducted full anonymity. more generally, user may pour old coins into new coins. for simplicity consider the case old new without loss generality. indeed, for old new the user can compose log old log new the -input/-output pours. step sending coins. suppose that anew pk, the address public key order allow actually spend the new coin cnew produced above, must somehow send the secret values cnew one way for send private message, but the requisite private communication channel necessitates additional infrastructure assumptions. avoid this "out-of-band" channel and instead build this capability directly into our construction leveraging the ledger follows. modify the structure address key pair. each user now has key pair (addrpk addrsk where addrpk (apk pkenc and addrsk (ask skenc the values (apk ask are generated before. addition, (pkenc skenc key pair for key-private encryption scheme [bbdp]. new new then, computes the ciphertext that the encryption the plaintext (vnew rnew new new under pkenc, (which part address public key addrsk, and includes the pour transaction txpour the user can then find and decrypt this message (using his sknew enc, scanning the pour transactions the public ledger. again, note that adding txpour leaks neither paid amounts, nor target addresses due the key-private property the encryption scheme. (the user does the same with cnew and includes corresponding ciphertext txpour step public outputs. the construction far allows users mint, merge, and split coins. but how can user redeem one his coins, i.e., convert back the base currency (bitcoin)? for this, modify the pour operation include public output. when spending coin, the user also specifies nonnegative vpub and transaction string info the balance equation the statement pour changed accordingly: "vnew vnew vpub old thus, the input value old part vpub publicly declared, and its target specified, somehow, the string info. the string info can used specify the destination these redeemed funds (e.g., bitcoin wallet public key). both vpub and info are now included the resulting pour transaction txpour (the public output optional, the user can set vpub step non-malleability. prevent malleability attacks pour transaction txpour (e.g., embezzlement re-targeting the public output the pour modifying info), further modify the statement pour and use digital signatures. specifically, during the pour operation, the user (i) samples key pair (pksig sksig for one-time signature scheme; (ii) computes hsig crh(pksig (iii) computes the two values prfpk (hsig and prfpk (hsig which act macs aold aold sk, sk, these public outputs can considered "input" bitcoin-style transaction, where the string info contains the bitcoin output scripts. this mechanism also allows support bitcoin's public transaction fees. "tie" hsig both address secret keys; (iv) modifies pour include the three values hsig and prove that the latter two are computed correctly; and (v) uses sksig sign every value associated with the pour operation, thus obtaining signature which included, along with pksig txpour since the aold sk,i are secret, and with high probability hsig changes for each pour transaction, the values are unpredictable. moreover, the signature the statement (and other values) binds all these together, argued more detail appendix and appendix this ends the outline the construction, which summarized part figure conclude noting that, due the zk-snark, our construction requires one-time trusted setup public parameters. the soundness the proofs depends this trust, though anonymity continues hold even the setup corrupted malicious party. (a) merke tree over (cm,cm,...) crh crh crh crh crh crh (c) coin commitment (d) serial number comm prfsn crh comm crh ... merkle-tree root coin commitment serial number coin value commitment rand. serial number rand. (apk,pkenc) address public key (ask,skenc) address secret key crh crh (b) coin ((apk,pkenc), cm) prfaddr figure (a) illustration the crh-based merkle tree over the list cmlist coin commitments. (b) coin (c) illustration the structure coin commitment cm. (d) illustration the structure coin serial number sn. zerocash outline zerocash, concrete implementation, bits security, our dap scheme construction; see section for details. zerocash entails carefully instantiating the cryptographic ingredients the construction ensure that the zk-snark, the "heaviest" component, efficient enough practice. the construction, the zk-snark used prove/verify specific statement: pour. while zk-snarks are asymptotically efficient, their concrete efficiency depends the arithmetic circuit that used decide the statement. thus, seek instantiations for which can design relatively small arithmetic circuit cpour for verifying the statement pour. our approach instantiate all the necessary cryptographic ingredients (commitment schemes, pseudorandom functions, and collision-resistant hashing) based sha. first design hand-optimized circuit for verifying sha computations (or, more precisely, its compression function, which suffices for our purposes). then, use this circuit construct cpour which verifies all the necessary checks for satisfying the statement cpour this, along with judicious parameter choices, and state-of-the-art implementation zk-snark for arithmetic circuits [bctv] (see section .), results zk-snark prover alternatively, could have opted rely the circuit generators [pghr, bcg+ bctv], which support various classes programs, writing code expressing the pour checks. however, discussed later, these generic approaches are more expensive than our hand-optimized construction. running time few minutes and zk-snark verifier running time few milliseconds. this allows the dap scheme implementation practical for deployment, our experiments show. zerocash can integrated into bitcoin forks (commonly referred "altcoins"); later describe how this done. paper organization the remainder this paper organized follows. section provides background zk-snarks. define dap schemes section and our construction thereof section section discusses the concrete instantiation zerocash. section describes the integration zerocash into existing ledger-based currencies. section provides microbenchmarks for our prototype implementation, well results based full-network simulations. section describes optimizations. discuss concurrent work section and summarize our contributions and future directions section background zk-snarks the main cryptographic primitive used this paper special kind succinct non-interactive argument knowledge (snark). concretely, use publicly-verifiable preprocessing zeroknowledge snark, zk-snark for short. this section provide basic background zk-snarks, provide informal definition, compare zk-snarks with the more familiar notion nizks, and recall known constructions and implementations. informal definition informally define zk-snarks for arithmetic circuit satisfiability. refer the reader to, e.g., [bci+ for formal definition. for field f-arithmetic circuit takes inputs that are elements and its gates output elements naturally associate circuit with the function computes. model nondeterminism consider circuits that have input and auxiliary input called witness. the circuits consider only have bilinear gates. arithmetic circuit satisfiability defined analogously the boolean case, follows. definition the arithmetic circuit satisfiability problem f-arithmetic circuit captured the relation {(x, c(x, its language s.t. c(x, given field (publicly-verifiable preprocessing) zk-snark for f-arithmetic circuit satisfiability triple polynomial-time algorithms (keygen, prove, verify): keygen(l (pk, vk). input security parameter (presented unary) and farithmetic circuit the key generator keygen probabilistically samples proving key and verification key vk. both keys are published public parameters and can used, any number times, prove/verify membership prove(pk, input proving key and any (x, the prover prove outputs non-interactive proof for the statement gate with inputs bilinear the output h~a, h~b, for some ~a, fm+ these include addition, multiplication, negation, and constant gates. verify(vk, input verification key vk, input and proof the verifier verify outputs convinced that zk-snark satisfies the following properties. completeness. for every security parameter any f-arithmetic circuit and any (x, the honest prover can convince the verifier. namely, with probability negl(l) the following experiment: (pk, vk) keygen(l c); prove(pk, a); verify(vk, p). succinctness. honestly-generated proof has bits and verify(vk, runs time (|x|). (here, hides fixed polynomial factor l.) proof knowledge (and soundness). the verifier accepts proof output bounded prover, then the prover "knows" witness for the given instance. (in particular, soundness holds against bounded provers.) namely, for every poly(l)-size adversary there poly(l)-size extractor such that verify(vk, and (x, with probability negl(l) the following experiment: (pk, vk) keygen(l c); (x, a(pk, vk); e(pk, vk). perfect zero knowledge. honestly-generated proof perfect zero knowledge. namely, there polynomial-time simulator sim such that for all stateful distinguishers the following two probabilities are equal: (x, d(p) (pk, vk) keygen(l (x, (x, d(pk, vk) and d(p) prove(pk, (the probability that d(p) honest proof) (pk, vk, trap) sim(l (x, d(pk, vk) sim(trap, (the probability that d(p) simulated proof) remark. both proof knowledge and zero knowledge are essential the use zk-snarks this paper. indeed, consider circuits that verify assertions about cryptographic primitives (such using knowledge sha pre-image binding commitment). thus does not suffice merely know that, for given input witness for exists. instead, proof knowledge ensures that witness can efficiently found (by extracting from the prover) whenever the verifier accepts proof. for zero knowledge, ensures that proof leaks information about the witness, beyond the fact that remark. the security proofs (see appendix d), deal with provers producing vector inputs together with vector corresponding proofs such cases, convenient use extractor that can extract vector witnesses containing valid witness for each valid proof. this "multiinstance" extraction follows from the "single-instance" one described above [bcct, bcct]. namely, (keygen, prove, verify) zk-snark, then for any poly(l)-size prover adversary there exists poly(l)-size extractor such that (pk, vk) keygen(l verify(vk, (~x, a(pk, vk) vmint vaddr-a where: (i) vunspent the total value unspent coins scoin (ii) vbasecoin the total value public outputs placed the ledger; (iii) vmint the total value a's mint transactions; (iv) vaddr-a the total value payments received from addresses addr; (v) va-addr the total value payments sent addresses addr. balance requires that wins bal with only negligible probability. construction decentralized anonymous payment scheme show how construct dap scheme (introduced section using zk-snarks and other building blocks. later, section give concrete instantiation this construction. cryptographic building blocks first introduce notation for the standard cryptographic building blocks that use. assume familiarity with the definitions these building blocks; for more details, see, e.g., [kl]. throughout, denotes the security parameter. collision-resistant hashing. use collision-resistant hash function crh }o(l) pseudorandom functions. use pseudorandom function family prf {prfx }o(l) where denotes the seed. from prfx derive three "non-overlapping" pseudorandom functions, chosen arbitrarily prfaddr (z) prfx (kz) prfsn (z) prfx (kz) prfx (z) prfx (kz). furthermore, assume that prf also collision resistant, the sense that infeasible find (x, such that prfsn (z) prfx statistically-hiding commitments. use commitment scheme comm where the binding property holds computationally, while the hiding property holds statistically. denoted {commx }o(l) where denotes the commitment trapdoor. namely, reveal commitment value suffices provide and the trapdoor then one can check that commx (z). one-time strongly-unforgeable digital signatures. use digital signature scheme sig (gsig ksig ssig vsig that works follows. gsig ppsig given security parameter (presented unary), gsig samples public parameters ppsig for the encryption scheme. ksig (ppsig (pksig sksig given public parameters ppsig ksig samples public key and secret key for single user. ssig (sksig given secret key sksig and message ssig signs obtain signature vsig (pksig given public key pksig message and signature vsig outputs the signature valid for message else outputs the signature scheme sig satisfies the security property one-time strong unforgeability against chosen-message attacks (suf-cma security). key-private public-key encryption. use public-key encryption scheme enc (genc kenc eenc denc that works follows. genc ppenc given security parameter (presented unary), genc samples public parameters ppenc for the encryption scheme. kenc (ppenc (pkenc skenc given public parameters ppenc kenc samples public key and secret key for single user. eenc (pkenc given public key pkenc and message eenc encrypts obtain ciphertext denc (skenc given secret key skenc and ciphertext denc decrypts produce message (or decryption fails). the encryption scheme enc satisfies two security properties: (i) ciphertext indistinguishability under chosen-ciphertext attack (ind-cca security); and (ii) key indistinguishability under chosen-ciphertext attack (ik-cca security). while the first property standard, the second less known; informally, ik-cca requires that ciphertexts cannot linked the public key used encrypt them, other ciphertexts encrypted with the same public key. for definitions, refer the reader [bbdp]. zk-snarks for pouring coins outlined section our construction invokes zk-snark for specific statement, pour, which now define. first recall the context motivating pour. when user pours "old" coins old new new cold into new coins corresponding pour transaction old new new txpour (rt, snold vpub info, generated. our construction, need provide evidence "*" that various conditions were respected the pour operation. concretely, txpour should demonstrate that (i) owns old old old cold (ii) coin commitments for appear somewhere the ledger; (iii) the revealed old old old new new are serial numbers are cold (iv) the revealed coin commitments new new (v) balance preserved. our construction achieves this including zk-snark proof ppour for the statement pour which checks the above invariants (as well others needed for non-malleability). the statement pour. concretely, the statement pour defined follows. old new new instances are the form (rt, snold vpub hsig thus, instance specifies root for crh-based merkle tree (over the list commitments far), the two serial numbers the consumed coins, two coin commitments for the two new coins, public value, and fields hsig used for non-malleability. old old old new new witnesses are the form (path path cold addrsk, addrsk, where, for each old old old old old old cold (addrpk,i cmi new new new new new cnew (addrnew cmnew for the same cmi pk,i old old addrold pk,i (apk,i pkenc,i new new addrnew pk,i (apk,i pkenc,i old old addrold sk,i (ask,i skenc,i thus, witness specifies authentication paths for the two new coin commitments, the entirety coin information about both the old and new coins, and address secret keys for the old coins. given pour instance witness valid for the following holds: for each old (a) the coin commitment cmold appears the ledger, i.e., pathi valid authentication old path for leaf cmi with respect root rt, crh-based merkle tree. addr old old (b) the address secret key aold sk,i matches the address public key i.e., apk,i prfaold (). sk,i old old old (c) the serial number snold computed correctly, i.e., sni prfaold (ri sk,i old old old (d) the coin cold (commrold (aold well-formed, i.e., cmi commsold pk,i kri )kvi new new new new (e) the coin well-formed, i.e., cmi commsnew (commrinew (apk,i kri )kvinew (f) the address secret key aold sk,i ties hsig i.e., prfaold (ikhsig sk,i balance preserved: vnew vnew vpub vold vold (with vold vold and vold vold and vold vold then choice can satisfy the constraint vmint vaddr-a else, outputs remark. there are two methods for spend more public-output money than owns: (i) directly inserting transactions the ledger, and (ii) asking honest parties create such transactions. the first method accounted for the computation vbasecoin while the second method accounted for the computation va-addr (since must first pay the honest party). proof theorem prove theorem omit formal proof the completeness claim; one can verify that the dap scheme's completeness follows, straightforward way, from the completeness the construction's building blocks. next, argue security via three separate proofs, respectively showing that our construction satisfies (i) ledger indistinguishability, (ii) transaction non-malleability, and (iii) balance. proof ledger indistinguishability describe simulation asim which the adversary interacts with challenger the l-ind experiment. however asim differs from the l-ind experiment critical way: all answers sent are computed independently the bit that a's advantage asim the remainder the proof devoted showing that advl-ind p,a (l) (i.e., a's advantage the l-ind experiment) most negligibly different than a's advantage asim the simulation. the simulation asim works follows. first, after sampling random, samples setup(l with the following modification: the zk-snark keys are generated (pkpour vkpour trap) sim(l cpour obtain the zero-knowledge trapdoor trap. then, the l-ind experiment, sends and then initializes two separate dap oracles odap and odap afterwards, l-ind, asim proceeds steps and, each step, provides two ledgers dap (lleft lright where lleft the current ledger obdap and lright l-b the one o-b then sends message (q, which consist two (publicly-consistent) queries the same type. the challenger acts differently depending the query type, follows. answering createaddress queries. this case, createaddress. answer behaves l-ind, except for the following modification: after obtaining (addrpk addrsk createaddress(pp), replaces apk addrpk with random string the appropriate length; then, stores addrsk table and returns addrpk afterwards, does the same for answering mint queries. this case, (mint, addrpk and (mint, addrpk answer behaves l-ind, except for the following modification: the mint algorithm computes the commitment commr kr), for random string the appropriate length, instead commr (apk kr), where apk the value specified addrpk afterwards, does the same for old old answering pour queries. this case, and both have the form (pour, cmold addrpk, old new new new addrpk, info, vnew vnew addrpk, addrpk, vpub answer modifies the way some values are computed: compute rti accumulating all the valid coin commitments set vpub and info the corresponding input values. for each (a) sample uniformly random snold address generated previous query createaddress, (i) sample (b) addrnew pk,j coin commitment cmnew random input, (ii) run kenc (ppenc (pkenc skenc and new compute eenc (pkenc for random suitable length. new (c) otherwise, calculate (cmnew the pour algorithm. set and random strings the appropriate length. compute all remaining values the pour algorithm old new new the pour proof computed ppour sim(trap, x), where (rt, snold vpub afterwards, does the same for answering receive queries. this case, (receive, addrpk and (receive, addrpk the answer each query proceeds the l-ind experiment. answering insert queries. this case, (insert, tx) and (insert, the answer each query proceeds the l-ind experiment. each the above cases, the response computed independently the bit thus, when outputs guess must the case that i.e., a's advantage asim proof that the simulation indistinguishable from the real experiment. now describe sequence hybrid experiments (areal asim each which challenger conducts modification the l-ind experiment with define areal the original l-ind experiment, and asim the simulation described above. with slight abuse notation, given experiment define adva the absolute value the difference between (i) the l-ind advantage and (ii) the l-ind advantage areal also, let qca the total number createaddress queries issued the total number pour queries issued and the total number mint queries issued finally, define advenc a's advantage enc's ind-cca and ik-cca experiments, advprf a's advantage distinguishing the pseudorandom function prf from random one, and advcomm a's advantage against the hiding property comm. now describe each the hybrid experiments. note that the restrictions the experiment, the value vinew identical between qleft and qright experiment the experiment modifies areal simulating the zk-snarks. more precisely, modify areal that simulates each zk-snark proof, follows. the beginning the experiment, instead invoking keygen(l cpour invokes sim(l cpour and obtains (pkpour vkpour trap). each subsequent invocation the pour algorithm, computes ppour sim(trap, x), without using any witnesses, instead using prove. since the zk-snark system perfect zero knowledge, the distribution the simulated ppour identical that the proofs computed areal hence adva experiment the experiment modifies replacing the ciphertexts pour transaction encryptions random strings. more precisely, modify that, each time new issues pour query where one the output addresses (addrnew pk, addrpk, the set addresses new are generated previously generated createaddress query, the two ciphertexts cnew new new new follows: (i) (pkenc skenc kenc (ppenc (ii) for each eenc (pknew enc,j where message sampled uniformly from the plaintext space the encryption scheme. lemma (see below), |adva adva *q the ik-cca ind-cca experiments. use hybrid intermediate between and concretely, modifies that each ciphertext (where the corresponding public key appears the set generated createaddress query) replaced with the encryption the same plaintext, but under new, random public key generated via the kenc algorithm. (for comparison, modifies that each plaintext replaced with random plaintext drawn from the plaintext space.) now argue that a's advantage distinguishing and most advenc and for distinguishing and overall, deduce that |adva adva *q assume maximum adversarial advantage advenc against the ik-cca experiment for the encryption scheme, then get that advh adva vmint vaddr-a light the above, suffices argue that the augmented ledger induced the (modified) bal experiment balanced with all but negligible probability. suppose, way contradiction, that not the case: induces, with non-negligible probability, augmented ledger (l, ~a) that not balanced. distinguish between five cases, corresponding which one the above conditions does not hold with non-negligible probability. each case, show how reach contradiction, concluding the proof. violates condition suppose that wins but violates condition non-negligible. construction odap every (txpour (l, ~a) for which txpour was not inserted satisfies condition thus, the violation can only originate from pair (txpour (l, ~a) for which txpour old old was inserted and such that: (i) cmold (ii) there such that cmi has corresponding output coin commitment any pour mint transaction that precedes txpour observe that the validity txpour implies that: old old equals the two serial numbers snold and are distinct. moreover, recalling that each sni old old old old old prfaold (ri this also implies that (ask, (ask, sk,i the witness contains two valid authentication paths path path for merkle tree constructed using only coin commitments transactions preceding txpour either (i) (ii), reach contradiction. indeed: old old old (i) cmold then the fact that implies that the witness contains two old old distinct openings (the first opening contains (aold sk, while the second opening old contains (aold sk, )). this violates the binding property the commitment scheme comm. (ii) there such that cmold does not previously appear then pathi invalid authentication path, and thus yields collision the function crh. this violates the collision resistance crh. violates condition ii. suppose that wins but violates condition non-negligible. observe that, when condition violated, contains two pour transactions txpour txpour spending the same coin commitment cm, and revealing two serial numbers and since txpour txpour are valid, must the case that however (as argued already above), both transactions spend but produce different serial numbers, then the corresponding witnesses contain different openings cm. this contradicts the binding property the commitment scheme comm. violates condition iii. suppose that wins but violates condition iii non-negligible. this case, the contradiction immediate: whenever condition iii violated, the equation vold vold vnew vnew vpub does not hold, and thus, construction the statement pour, the soundness the zk-snark violated well. violates condition iv. suppose that wins but violates condition non-negligible. observe that, when condition violated, contains: pour transaction txpour which coin commitment cmold opened value old and also (mint pour) transaction that opens cmold value different from old this contradicts the binding property the commitment scheme comm. violates condition suppose that wins but violates condition non-negligible. observe that, when condition violated, contains inserted pour transaction txpour that spends the output previous transaction whose public address addrpk (apk pkenc lies addr; moreover, the witness associated contains ask such that apk prfaddr ask (). omit the full argument, but one can verify that, this case, can construct new adversary that uses distinguish, with non-negligible probability, prf from random function. references [bb] dan boneh and xavier boyen. secure identity based encryption without random oracles. proceedings the annual international cryptology conference, crypto pages [bbdp] mihir bellare, alexandra boldyreva, anand desai, and david pointcheval. key-privacy publickey encryption. proceedings the international conference the theory and application cryptology and information security, asiacrypt pages [bbsu] simon barber, xavier boyen, elaine shi, and ersin uzun. bitter better how make bitcoin better currency. proceedings the international conference financial cryptography and data security, pages [bcct] nir bitansky, ran canetti, alessandro chiesa, and eran tromer. from extractable collision resistance succinct non-interactive arguments knowledge, and back again. proceedings the innovations theoretical computer science conference, itcs pages [bcct] nir bitansky, ran canetti, alessandro chiesa, and eran tromer. recursive composition and bootstrapping for snarks and proof-carrying data. proceedings the acm symposium the theory computing, stoc pages [bcg+ eli ben-sasson, alessandro chiesa, daniel genkin, eran tromer, and madars virza. snarks for verifying program executions succinctly and zero knowledge. proceedings the annual international cryptology conference, crypto pages [bcgta] eli ben-sasson, alessandro chiesa, daniel genkin, and eran tromer. fast reductions from rams delegatable succinct constraint satisfaction problems. proceedings the innovations theoretical computer science conference, itcs pages [bcgtb] eli ben-sasson, alessandro chiesa, daniel genkin, and eran tromer. the concrete efficiency probabilistically-checkable proofs. proceedings the acm symposium the theory computing, stoc pages [bci+ nir bitansky, alessandro chiesa, yuval ishai, rafail ostrovsky, and omer paneth. succinct noninteractive arguments via linear interactive proofs. proceedings the theory cryptography conference, tcc pages [bctv] eli ben-sasson, alessandro chiesa, eran tromer, and madars virza. succinct non-interactive zero knowledge for von neumann architecture. proceedings the usenix security symposium, security pages ???-???, available http://eprint.iacr.org//. [bel] mihir bellare. new proofs for nmac and hmac: security without collision-resistance. proceedings the annual international conference advances cryptology, crypto pages [ben] eli ben-sasson. universal and affordable computational integrity, may bitcoin the future payments. url: http://www.youtube.com/watch?v=yrcpreupkcu&feature=youtu.be&t=ms. [bfls] laszlo babai, lance fortnow, leonid levin, and mario szegedy. checking computations polylogarithmic time. proceedings the annual acm symposium theory computing, stoc pages [bgh+ eli ben-sasson, oded goldreich, prahladh harsha, madhu sudan, and salil vadhan. short pcps verifiable polylogarithmic time. proceedings the annual ieee conference computational complexity, ccc pages [cer] certicom research. sec elliptic curve cryptography, url: http://www.secg.org/collateral/ sec_final.pdf. [cha] david chaum. blind signatures for untraceable payments. proceedings the annual international cryptology conference, crypto pages [chl] jan camenisch, susan hohenberger, and anna lysyanskaya. compact e-cash. proceedings the annual international conference theory and applications cryptographic techniques, eurocrypt pages [cl] jan camenisch and anna lysyanskaya. efficient system for non-transferable anonymous credentials with optional anonymity revocation. proceedings the annual international conference theory and application cryptographic techniques, eurocrypt pages [ddm] george danezis, roger dingledine, and nick mathewson. mixminion: design type iii anonymous remailer protocol. proceedings the ieee symposium security and privacy, pages [dfkp] george danezis, cedric fournet, markulf kohlweiss, and bryan parno. pinocchio coin: building zerocoin from succinct pairing-based proof system. proceedings the workshop language support for privacy enhancing technologies, petshop url: http://www.cs.ucl.ac.uk/staff/g. danezis/papers/danezisfournetkohlweissparno.pdf. [dms] roger dingledine, nick mathewson, and paul syverson. tor: the second-generation onion router. proceedings the usenix security symposium, security pages [dw] christian decker and roger wattenhofer. information propagation the bitcoin network. proceedings the ieee international conference peer-to-peer computing, pages [es] ittay eyal and emin gun sirer. majority not enough: bitcoin mining vulnerable, [gen] rosario gennaro. multi-trapdoor commitments and their applications proofs knowledge secure under concurrent man-in-the-middle attacks. proceedings the annual international cryptology conference, crypto pages [ggpr] rosario gennaro, craig gentry, bryan parno, and mariana raykova. quadratic span programs and succinct nizks without pcps. proceedings the annual international conference theory and application cryptographic techniques, eurocrypt pages [gmr] shafi goldwasser, silvio micali, and charles rackoff. the knowledge complexity interactive proof systems. siam journal computing, ():-, preliminary version appeared stoc [gosa] jens groth, rafail ostrovsky, and amit sahai. non-interactive zaps and new techniques for nizk. proceedings the annual international conference advances cryptology, crypto pages [gosb] jens groth, rafail ostrovsky, and amit sahai. perfect non-interactive zero knowledge for np. proceedings the annual international conference advances cryptology, eurocrypt pages [gro] jens groth. short pairing-based non-interactive zero-knowledge arguments. proceedings the international conference the theory and application cryptology and information security, asiacrypt pages [gw] craig gentry and daniel wichs. separating succinct non-interactive arguments from all falsifiable assumptions. proceedings the annual acm symposium theory computing, stoc pages [kl] jonathan katz and yehuda lindell. introduction modern cryptography. chapman hall/crc, [lee] timothy lee. bitcoin needs scale factor compete with visa. here's how it. the washington post (http://www.washingtonpost.com), november [lip] helger lipmaa. progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. proceedings the theory cryptography conference theory cryptography, tcc pages [lip] helger lipmaa. succinct non-interactive zero knowledge arguments from span programs and linear error-correcting codes. proceedings the international conference the theory and application cryptology and information security, asiacrypt pages [max] greg maxwell. coinjoin: bitcoin privacy for the real world, august bitcoin forum. url: https://bitcointalk.org/index.php?topic=.. [mggr] ian miers, christina garman, matthew green, and aviel rubin. zerocoin: anonymous distributed e-cash from bitcoin. proceedings the ieee symposium security and privacy, pages [mic] silvio micali. computationally sound proofs. siam journal computing, ():-, preliminary version appeared focs [mpj+ sarah meiklejohn, marjori pomarole, grant jordan, kirill levchenko, damon mccoy, geoffrey voelker, and stefan savage. fistful bitcoins: characterizing payments among men with names. proceedings the conference internet measurement conference, imc pages [nak] satoshi nakamoto. bitcoin: peer-to-peer electronic cash system, url: http://www.bitcoin. org/bitcoin.pdf. [nat] national institute standards and technology. fips pub secure hash standard. http: //csrc.nist.gov/publications/pubsfips.html, [pghr] bryan parno, craig gentry, jon howell, and mariana raykova. pinocchio: nearly practical verifiable computation. proceedings the ieee symposium security and privacy, oakland pages [pol] polarssl. polarssl. http://polarssl.org, oct [rm] fergal reid and harrigan martin. analysis anonymity the bitcoin system. proceedings the ieee international conference privacy, security, risk and trust and social computing, socialcom/passat pages [rs] dorit ron and adi shamir. quantitative analysis the full bitcoin transaction graph. cryptology eprint archive, report [st] tomas sander and amnon ta-shma. auditable, anonymous electronic cash. proceedings the annual international cryptology conference advances cryptology, crypto pages [val] paul valiant. incrementally verifiable computation proofs knowledge imply time/space efficiency. proceedings the theory cryptography conference, tcc pages [wui] pieter wuille. proposed bip for dealing with malleability. available https://gist.github.com/ sipa/,