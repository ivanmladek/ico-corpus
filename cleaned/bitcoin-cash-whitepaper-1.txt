bitcoin: peer-to-peer electronic cash system satoshi nakamoto satoshin@gmx.com www.bitcoin.org abstract. purely peer-to-peer version electronic cash would allow online payments sent directly from one party another without going through financial institution. digital signatures provide part the solution, but the main benefits are lost trusted third party still required prevent double-spending. propose solution the double-spending problem using peer-to-peer network. the network timestamps transactions hashing them into ongoing chain hash-based proof-of-work, forming record that cannot changed without redoing the proof-of-work. the longest chain not only serves proof the sequence events witnessed, but proof that came from the largest pool cpu power. long majority cpu power controlled nodes that are not cooperating attack the network, they'll generate the longest chain and outpace attackers. the network itself requires minimal structure. messages are broadcast best effort basis, and nodes can leave and rejoin the network will, accepting the longest proof-of-work chain proof what happened while they were gone. introduction commerce the internet has come rely almost exclusively financial institutions serving trusted third parties process electronic payments. while the system works well enough for most transactions, still suffers from the inherent weaknesses the trust based model. completely non-reversible transactions are not really possible, since financial institutions cannot avoid mediating disputes. the cost mediation increases transaction costs, limiting the minimum practical transaction size and cutting off the possibility for small casual transactions, and there broader cost the loss ability make non-reversible payments for nonreversible services. with the possibility reversal, the need for trust spreads. merchants must wary their customers, hassling them for more information than they would otherwise need. certain percentage fraud accepted unavoidable. these costs and payment uncertainties can avoided person using physical currency, but mechanism exists make payments over communications channel without trusted party. what needed electronic payment system based cryptographic proof instead trust, allowing any two willing parties transact directly with each other without the need for trusted third party. transactions that are computationally impractical reverse would protect sellers from fraud, and routine escrow mechanisms could easily implemented protect buyers. this paper, propose solution the double-spending problem using peer-to-peer distributed timestamp server generate computational proof the chronological order transactions. the system secure long honest nodes collectively control more cpu power than any cooperating group attacker nodes. transactions define electronic coin chain digital signatures. each owner transfers the coin the next digitally signing hash the previous transaction and the public key the next owner and adding these the end the coin. payee can verify the signatures verify the chain ownership. transaction transaction owner public key transaction owner public key hash owner public key hash ver hash ver ify owner signature owner signature owner private key owner signature owner private key owner private key the problem course the payee can't verify that one the owners did not double-spend the coin. common solution introduce trusted central authority, mint, that checks every transaction for double spending. after each transaction, the coin must returned the mint issue new coin, and only coins issued directly from the mint are trusted not double-spent. the problem with this solution that the fate the entire money system depends the company running the mint, with every transaction having through them, just like bank. need way for the payee know that the previous owners did not sign any earlier transactions. for our purposes, the earliest transaction the one that counts, don't care about later attempts double-spend. the only way confirm the absence transaction aware all transactions. the mint based model, the mint was aware all transactions and decided which arrived first. accomplish this without trusted party, transactions must publicly announced [], and need system for participants agree single history the order which they were received. the payee needs proof that the time each transaction, the majority nodes agreed was the first received. timestamp server the solution propose begins with timestamp server. timestamp server works taking hash block items timestamped and widely publishing the hash, such newspaper usenet post [-]. the timestamp proves that the data must have existed the time, obviously, order get into the hash. each timestamp includes the previous timestamp its hash, forming chain, with each additional timestamp reinforcing the ones before it. hash hash block item block item ... item item ... proof-of-work implement distributed timestamp server peer-to-peer basis, will need use proofof-work system similar adam back's hashcash [], rather than newspaper usenet posts. the proof-of-work involves scanning for value that when hashed, such with sha-, the hash begins with number zero bits. the average work required exponential the number zero bits required and can verified executing single hash. for our timestamp network, implement the proof-of-work incrementing nonce the block until value found that gives the block's hash the required zero bits. once the cpu effort has been expended make satisfy the proof-of-work, the block cannot changed without redoing the work. later blocks are chained after it, the work change the block would include redoing all the blocks after it. block block prev hash nonce prev hash ... nonce ... the proof-of-work also solves the problem determining representation majority decision making. the majority were based one-ip-address-one-vote, could subverted anyone able allocate many ips. proof-of-work essentially one-cpu-one-vote. the majority decision represented the longest chain, which has the greatest proof-of-work effort invested it. majority cpu power controlled honest nodes, the honest chain will grow the fastest and outpace any competing chains. modify past block, attacker would have redo the proof-of-work the block and all blocks after and then catch with and surpass the work the honest nodes. will show later that the probability slower attacker catching diminishes exponentially subsequent blocks are added. compensate for increasing hardware speed and varying interest running nodes over time, the proof-of-work difficulty determined moving average targeting average number blocks per hour. they're generated too fast, the difficulty increases. network the steps run the network are follows: new transactions are broadcast all nodes. each node collects new transactions into block. each node works finding difficult proof-of-work for its block. when node finds proof-of-work, broadcasts the block all nodes. nodes accept the block only all transactions are valid and not already spent. nodes express their acceptance the block working creating the next block the chain, using the hash the accepted block the previous hash. nodes always consider the longest chain the correct one and will keep working extending it. two nodes broadcast different versions the next block simultaneously, some nodes may receive one the other first. that case, they work the first one they received, but save the other branch case becomes longer. the tie will broken when the next proofof-work found and one branch becomes longer; the nodes that were working the other branch will then switch the longer one. new transaction broadcasts not necessarily need reach all nodes. long they reach many nodes, they will get into block before long. block broadcasts are also tolerant dropped messages. node does not receive block, will request when receives the next block and realizes missed one. incentive convention, the first transaction block special transaction that starts new coin owned the creator the block. this adds incentive for nodes support the network, and provides way initially distribute coins into circulation, since there central authority issue them. the steady addition constant amount new coins analogous gold miners expending resources add gold circulation. our case, cpu time and electricity that expended. the incentive can also funded with transaction fees. the output value transaction less than its input value, the difference transaction fee that added the incentive value the block containing the transaction. once predetermined number coins have entered circulation, the incentive can transition entirely transaction fees and completely inflation free. the incentive may help encourage nodes stay honest. greedy attacker able assemble more cpu power than all the honest nodes, would have choose between using defraud people stealing back his payments, using generate new coins. ought find more profitable play the rules, such rules that favour him with more new coins than everyone else combined, than undermine the system and the validity his own wealth. reclaiming disk space once the latest transaction coin buried under enough blocks, the spent transactions before can discarded save disk space. facilitate this without breaking the block's hash, transactions are hashed merkle tree [][][], with only the root included the block's hash. old blocks can then compacted stubbing off branches the tree. the interior hashes not need stored. block block block header (block hash) prev hash nonce block header (block hash) prev hash root hash hash nonce root hash hash hash hash hash hash hash hash hash hash transactions hashed merkle tree after pruning tx- from the block block header with transactions would about bytes. suppose blocks are generated every minutes, bytes .mb per year. with computer systems typically selling with ram and moore's law predicting current growth .gb per year, storage should not problem even the block headers must kept memory. simplified payment verification possible verify payments without running full network node. user only needs keep copy the block headers the longest proof-of-work chain, which can get querying network nodes until he's convinced has the longest chain, and obtain the merkle branch linking the transaction the block it's timestamped in. can't check the transaction for himself, but linking place the chain, can see that network node has accepted it, and blocks added after further confirm the network has accepted it. longest proof-of-work chain block header prev hash block header nonce block header prev hash merkle root nonce prev hash merkle root hash nonce merkle root hash merkle branch for hash hash such, the verification reliable long honest nodes control the network, but more vulnerable the network overpowered attacker. while network nodes can verify transactions for themselves, the simplified method can fooled attacker's fabricated transactions for long the attacker can continue overpower the network. one strategy protect against this would accept alerts from network nodes when they detect invalid block, prompting the user's software download the full block and alerted transactions confirm the inconsistency. businesses that receive frequent payments will probably still want run their own nodes for more independent security and quicker verification. combining and splitting value although would possible handle coins individually, would unwieldy make separate transaction for every cent transfer. allow value split and combined, transactions contain multiple inputs and outputs. normally there will either single input from larger previous transaction multiple inputs combining smaller amounts, and most two outputs: one for the payment, and one returning the change, any, back the sender. transaction out ... ... should noted that fan-out, where transaction depends several transactions, and those transactions depend many more, not problem here. there never the need extract complete standalone copy transaction's history. privacy the traditional banking model achieves level privacy limiting access information the parties involved and the trusted third party. the necessity announce all transactions publicly precludes this method, but privacy can still maintained breaking the flow information another place: keeping public keys anonymous. the public can see that someone sending amount someone else, but without information linking the transaction anyone. this similar the level information released stock exchanges, where the time and size individual trades, the "tape", made public, but without telling who the parties were. traditional privacy model identities transactions trusted third party counterparty public new privacy model identities transactions public additional firewall, new key pair should used for each transaction keep them from being linked common owner. some linking still unavoidable with multi-input transactions, which necessarily reveal that their inputs were owned the same owner. the risk that the owner key revealed, linking could reveal other transactions that belonged the same owner. calculations consider the scenario attacker trying generate alternate chain faster than the honest chain. even this accomplished, does not throw the system open arbitrary changes, such creating value out thin air taking money that never belonged the attacker. nodes are not going accept invalid transaction payment, and honest nodes will never accept block containing them. attacker can only try change one his own transactions take back money recently spent. the race between the honest chain and attacker chain can characterized binomial random walk. the success event the honest chain being extended one block, increasing its lead and the failure event the attacker's chain being extended one block, reducing the gap the probability attacker catching from given deficit analogous gambler's ruin problem. suppose gambler with unlimited credit starts deficit and plays potentially infinite number trials try reach breakeven. can calculate the probability ever reaches breakeven, that attacker ever catches with the honest chain, follows []: probability honest node finds the next block probability the attacker finds the next block probability the attacker will ever catch from blocks behind the probability drops exponentially the number blocks the attacker has catch with increases. with the odds against him, doesn't make lucky lunge forward early on, his chances become vanishingly small falls further behind. now consider how long the recipient new transaction needs wait before being sufficiently certain the sender can't change the transaction. assume the sender attacker who wants make the recipient believe paid him for while, then switch pay back himself after some time has passed. the receiver will alerted when that happens, but the sender hopes will too late. the receiver generates new key pair and gives the public key the sender shortly before signing. this prevents the sender from preparing chain blocks ahead time working continuously until lucky enough get far enough ahead, then executing the transaction that moment. once the transaction sent, the dishonest sender starts working secret parallel chain containing alternate version his transaction. the recipient waits until the transaction has been added block and blocks have been linked after it. doesn't know the exact amount progress the attacker has made, but assuming the honest blocks took the average expected time per block, the attacker's potential progress will poisson distribution with expected value: get the probability the attacker could still catch now, multiply the poisson density for each amount progress could have made the probability could catch from that point: z-k double attackersuccessprobability(double int double double lambda p); double sum int for k++) double poisson exp(-lambda); for i++) poisson lambda sum poisson pow(q k)); return sum; running some results, can see the probability drop off exponentially with q=. p=. p=. p=. p=. p=. p=. p=. p=. p=. p=. p=. q=. p=. p=. p=. p=. p=. p=. p=. p=. p=. p=. p=. solving for less than .%... q=. q=. q=. q=. q=. q=. q=. q=. conclusion have proposed system for electronic transactions without relying trust. started with the usual framework coins made from digital signatures, which provides strong control ownership, but incomplete without way prevent double-spending. solve this, proposed peer-to-peer network using proof-of-work record public history transactions that quickly becomes computationally impractical for attacker change honest nodes control majority cpu power. the network robust its unstructured simplicity. nodes work all once with little coordination. they not need identified, since messages are not routed any particular place and only need delivered best effort basis. nodes can leave and rejoin the network will, accepting the proof-of-work chain proof what happened while they were gone. they vote with their cpu power, expressing their acceptance valid blocks working extending them and rejecting invalid blocks refusing work them. any needed rules and incentives can enforced with this consensus mechanism. references dai, "b-money," http://www.weidai.com/bmoney.txt, massias, x.s. avila, and j.-j. quisquater, "design secure timestamping service with minimal trust requirements," symposium information theory the benelux, may haber, w.s. stornetta, "how time-stamp digital document," journal cryptology, vol pages bayer, haber, w.s. stornetta, "improving the efficiency and reliability digital time-stamping," sequences ii: methods communication, security and computer science, pages haber, w.s. stornetta, "secure names for bit-strings," proceedings the acm conference computer and communications security, pages april back, "hashcash denial service counter-measure," http://www.hashcash.org/papers/hashcash.pdf, r.c. merkle, "protocols for public key cryptosystems," proc. symposium security and privacy, ieee computer society, pages april feller, "an introduction probability theory and its applications,"