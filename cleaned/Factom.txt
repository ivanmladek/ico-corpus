factom business processes secured immutable audit trails the blockchain contributors: paul snow, brian deery, jack lu, david johnston, peter kirby advisors: adam stradling, shawn wilkinson, jeremy kandah, dexx, marv schneider, steven sprague, andrew yashchuk reviewers: vitalik buterin, luke dashjr, eykholt, ryan singer, ron gross, j.r. willett, dustin byington version april factom.com abstract "honesty subversive" paul snow today's global economy trust rare supply. this lack trust requires the devotion tremendous amount resources audit and verify records reducing global efficiency, return investment, and prosperity. moreover, incidents such the united states foreclosure crisis demonstrate that addition being inefficient, the current processes are also terribly inaccurate and prone failure. factom removes the need for blind trust providing the world with the very first precise, verifiable, and immutable audit trail. the past, records have been difficult protect, challenging synchronize, and impossible truly verify because the manual effort involved. computers automated some these tasks, but they are even harder protect, synchronize, and verify because computer records are easy change. authority fragmented across innumerable independent systems. blockchains provide distributed mechanism lock data, making data verifiable and independently auditable. bitcoin's blockchain the most trusted immutable data store existence; however, not very useful for non-bitcoin transactions. factom gives businesses access blockchain technology without getting bogged down currencies. this paper, describe how factom creates distributed, autonomous protocol cost effectively separate the bitcoin blockchain from the bitcoin cryptocurrency. discuss client-defined chains entries, client-side validation entries, distributed consensus algorithm for recording entries, and blockchain anchoring approach for security. design goals factom creates faster, cheaper, bloat-free way develop blockchain based applications when satoshi nakamoto launched the bitcoin blockchain revolutionized the way transactions were recorded. there had never before existed permanent, decentralized, and trustless ledger records. developers have rushed create applications built top this ledger. unfortunately, they have been running into few core constraints intrinsic the original design tradeoffs bitcoin. speed because the design the decentralized, proof-of-work consensus method used bitcoin, difficulty requirements are adjusted maintain roughly minute confirmation times. for applications that wish greater security, multiple confirmations may required. common requirement wait for confirmations, which can lead wait times over hour. cost the default transaction cost around mbtc (roughly usd november and much usd per transaction times the exchange price btc has been volatile throughout its history. the price btc rises, then the cost transactions can up. this can prove serious cost barrier applications that need manage very large numbers transactions. additionally, many factors including constraints block size and reward halving could act increase transaction fees. bloat with the bitcoin blockchain size limit per block, transaction throughput capped transactions per second. any application that wants write and store information using the blockchain will add the traffic. this problem has become politically charged various parties seek increase the block size limit and are met with resistance from those concerned about decentralization. factom protocol designed address these three core constraints. factom creates protocol for applications that provide functions and features beyond currency transactions. factom constructs standard, effective, and secure foundation for these applications run faster, cheaper, and without bloating bitcoin. the factom ecosystem there are several primary components the factom ecosystem, depicted below: once the system set up, including issuance factoids (i.e., the cryptocurrency factom) and user accounts, token value transferred among users, factom, and bitcoin with the following primary interactions: application owner purchases entry credits with factoid application records entry factom servers create entry blocks and directory blocks factom secures anchor (hash the directory block) onto the blockchain details these and other interactions are the upcoming sections. security and proofs how factom secures entries factom extends bitcoin's feature set record events outside monetary transfers. factom has minimal ruleset for adding permanent entries. factom pushes most data validation tasks the client side. the only validation factom enforces are those required the protocol trade factoids, convert factoids entry credits, and ensure entries are properly paid for and recorded. factom has few rules regarding token incentives for running the network and for internal consistency, but cannot check the validity statements recorded the chains used its users. bitcoin limits transactions those moving value from set inputs set outputs. satisfying the script required the inputs (generally requiring certain signatures) enough for the system ensure validity. this validation process that can automated, the auditing process easy. factom were used, for instance, record deed transfer real estate, factom would used simply record the process occurred. the rules for real estate transfers are very complex. for example, local jurisdiction may have special requirements for property the buyer foreigner, farmer, part time resident. property might also fall into number categories based location, price, architecture. each category could have its own rules reflecting the validation process for smart contracts. this example, cryptographic signature alone insufficient fully verify the validity transfer ownership. factom then used record the process occurred rather than validate transfers. bitcoin miners perform two primary tasks. first, they resolve double spends. seeing two conflicting transactions that spend the same funds twice, they resolve which one admissible. the second job miners perform (along with the other full nodes) auditing. since bitcoin miners only include valid transactions, one that included the blockchain can assumed have been audited. thin client does not need know the full history bitcoin see value they receive has already been spent. (see spv.) how factom servers and auditing servers validate entries factom splits the two roles that bitcoin miners into two tasks: recording entries final order and auditing entries for validity. the factom servers accept entries, assemble them into blocks, and fix their order. after minutes, the entry ordering made irreversible inserting anchor into the bitcoin blockchain. factom does this creating hash the data collected over the minutes, then recording the hash into the blockchain. the auditing entries separate process which can done either with without trust. auditing critical, since factom not able validate entries before they are included the factom dataset. with trust-based auditing, thin client could trust competent auditor they choose. after entry was entered into the system, auditor would verify the entry was valid. auditors would submit their own cryptographically signed entry. the signature would show that the entry passed all the checks the auditor deemed was required. the audit requirements could fact part factom chain well. the real estate example from earlier, the auditor would double check the transfer conformed local standards. the auditor would publicly attest that the transfer was valid. trustless auditing would similar bitcoin. system internally consistent with mathematical definition validity like bitcoin, can audited programmatically. the rules for transfer were able audited computer, then application could download the relevant data and run the audit itself. the application would build awareness the system state downloaded, verified, and decided which entries were valid not. mastercoin, counterparty, and colored coins have similar trust model. these are all client-side validated protocols, meaning transactions are embedded into the bitcoin blockchain. bitcoin miners not audit them for validity; therefore, invalid transactions designed look like transactions these protocols can inserted into the blockchain. clients that support one these protocols scan through the blockchain and find potential transactions, check them for validity, and build interpretation where the control these assets lie (usually bitcoin address). the clients their own auditing under these protocols. moving any these client-side validated protocols under factom would matter defining transaction per the protocol and establishing chain hold the transactions. the transaction protocols wouldn't much different under factom than under bitcoin, except where factom allows easy expression the information needed instead having encode some special way into bitcoin transaction. proving negative bitcoin, land registries, and many other systems need solve fundamental problem: proving negative. they prove some "thing" has been transferred one person, and prove that thing hasn't been transferred someone else. while proof the negative impossible unbounded system, quite possible bounded system. blockchain based cryptocurrencies solve this problem limiting the places where transactions can found. bitcoin transactions can only found the bitcoin blockchain. relevant transaction not found the blockchain, defined from the bitcoin protocol perspective not exist and thus the btc hasn't been sent twice (double spent). certain land ownership recording systems are similar. assume system where land transfer recorded governmental registry and where the legal system set that unrecorded transfers are assumed invalid (sans litigation). individual wanted check title clear (i.e., that one else claims the land) the answer would the governmental registry. the individual using the government records could prove the negative; the land wasn't owned third party. where registration title not required, the governmental registry could only attest what has been registered. private transfer might very well exist that invalidates the understanding the registry. both the above cases, the negative can proven within context. with mastercoin the case very strong. with land registry, limited the context the registry, which may open challenge. the real world messy, and factom designed accommodate not just the precision digital assets, but the real world's sometimes messy reality. factom, there hierarchy data categorization. factom only records entries chains; the various user-defined chains have dependencies that factom enforces the protocol level. this differs from bitcoin, where every transaction potentially double-spend, and must validated. organizing entries into chains, factom allows applications have smaller search spaces than all factom data were combined together into one ledger. factom were used manage land transfers, application using chain record such registries could safely ignore entries the other chains, such those used maintain security camera logs. were governmental court ruling change land registration, the relevant chain would updated reflect the ruling. the history would not lost, and where such changes are actually invalid from legal other perspective, the record cannot altered hide the order events factom. nick szabo has written about property clubs, which have many overlaps with this system. here nugget from his paper "secure property titles with owner authority": while thugs can still take physical property force, the continued existence correct ownership records will remain thorn the side usurping claimants. how applications validate factom chains factom doesn't validate entries; entries are instead validated client-side users and applications. long application understands and knows the rules chain should follow, then the existence invalid entries doesn't cause unreasonable disruption. entries chain that not follow the rules can disregarded the application. users can use any set rules for their chains, and any convention communicate their rules the users their chains. the first entry chain can hold set rules, hash audit program, etc. these rules then can understood applications running against factom ignore invalid entries client-side. enforced sequence can specified. entries that not meet the requirements the specified enforced sequence will rejected. however, entries that might rejected the rules the audit program will still recorded. users such chains will need run the audit program validate chain sequence this type. the factom servers will not validate rules using the audit program. validation the applications (in combination with user-defined chains) provides number advantages for applications written top factom: applications can put into factom whatever entries make sense for their application. so, list hashes validate list account statements can recorded easily exchanges asset. rule execution very efficient. where the distributed network must execute your validation rules, then validation requires all nodes all validation. client-side validation only requires the systems that care about those rules run them. factom allows chain define its rules whatever language the designers choose, run whatever platform they choose, and use any external data. none these decisions the part one application has any impact another application. factom servers have little knowledge about the entries being recorded. use commitment scheme limit knowledge, where the commitment record entry made prior revealing what the entry is. this makes factom's role recording entries very simple, and makes individual server processes public. factom servers accept information from the network full nodes, and their decisions and behavior are always view. failure perform can audited both from the network outside factom, and within factom. easy independently verify that factom server fulfilling its entry-recording responsibility; factom can't hide potentially errant behavior. recording speeds can very fast, since the number checks made the factom servers are minimal. proofs against any particular chain factom not require knowledge any other chains. users then only need the sections factom they are using and can ignore the rest. how factom authority servers manage chains its heart, factom decentralized way collect, package, and secure data into the bitcoin blockchain. factom accomplishes this with network authority servers. authority servers are the set federated servers and audit servers which share responsibility for different aspects the system. the federated servers actually acknowledge and order entries and transactions factom, and audit servers duplicate and audit the work done the federated servers and are always ready replace federated server that might offline. the design ensures decentralization. single server ever control the whole system, but only part the system. all servers verify and double check the work all other servers. and server permanently control any part the system; the responsibility for each part factom cycles among the federated servers each minute, and the role being federated server audit server shifts among the servers the authority set (the set all authority servers). the federated servers take very active role running the protocol. the federated servers each take responsibility for subsection the user chains the beginning the creation directory block. the process works like this: all servers reset their process lists empty. the user submits entry payment using public key associated with entry credits based the public key used pay for the entry, one the servers accepts the payment. that server broadcasts the acceptance the payment. the user sees the acceptance and submits the entry. based the chainid the entry, one the servers adds the entry its process list, and adds the entry the appropriate entry block for that chainid (creating one this the first entry for that entry block). the server broadcasts entry confirmation, containing the process list index the entry, the hash the entry (linked the payment), and the serial hash far the server's process list. all the other servers update their view the server's process list, validate the list, and update their view the entry block for that chainid. long the user can validate the relevant process list holds their entry, then they have fair level assurance will successfully entered into factom. the end the minute, each server confirms the end their section the process list. the end the minute marked the process list, and the responsibility for particular chains shifts around the authority set. the end the minute, directory block constructed from all the entry blocks defined the process lists built all the servers. so, each server has all entry blocks, all directory blocks, and all entries. deterministic method (that can computed all nodes protocol) will shift responsibility for particular chainids among the servers for the next round. the completion the directory block, the merkle root the directory block placed bitcoin transaction and submitted the bitcoin network for eventual confirmation. repeat. (go back the federated servers for their minute are constructing process list for the chains for which they are responsible, well constructing the entry blocks that will used create the directory block the end the minutes. the process list important for broadcasting decisions made server the rest the network. the servers the authority set are are re-ranked regular, scheduled basis. the ranking function support the standing parties, who must create profile chain factom. the profile contains any number signed public address entries. the weight standing party's support determined various public addresses and entries their profile. the function computing the weight standing party uses combination many factors. such weights may organized categories further distribute influence. factors that determine identity's weight include factors that can measured from the protocol, and audited the protocol. examples factors that might used calculate weight include:: weighted number entry credits purchased. weighted number entries used. tokens "staked" profile chain, and not moved transferred. tokens used build infrastructure, support the protocol, provide services providing guidance and facilitating the operation the protocol. support may specified the standing parties any time. regular intervals, the support all the servers the authority set will evaluated, and the membership the authority set adjusted. the same mechanism can used measure support the protocol for decisions about the protocol. maintain position the authority set, servers must continually demonstrate the ability maintain their ability monitor and keep with the operation the protocol. the federated servers this simply doing their job and syncing with the end minute operations with all other federated servers. performance the protocol's ecosystem may also factor into decisions support not support authority node. audit servers may have issue heartbeat message, that can monitored the network. other solutions are possible. managing timeouts and monitoring heartbeats will done according the needs and load the protocol. factom system overview factom constructed from set layered data structures factom constructed hierarchical set blocks, with the highest being directory blocks. they constitute micro-chain, consisting primarily compact references. keep the size small, each reference the directory block just hash the entry block plus its chainid. these entry blocks have references which point all the entries with particular chainid which arrived during time period. the entry block for chain also part micro-chain. the bulk the data factom the leaves, the entries themselves. these hierarchical data structures are rendered unchangeable bitcoin's hashpower. they can conceptualized different layers. the layers and concepts the factom system are: directory layer organizes the merkle roots entry blocks entry block layer organizes references entries entries contains application's raw data hash its private data chains grouping entries specific application directory layer: how the directory layer organizes merkle roots the directory layer the first level hierarchy the factom system. defines which entry chainids have been updated during the time period covered directory block. (chainids identify the user's chain entries; the generation the chainid discussed later.) mainly consists list pairing chainid and the merkle root the entry block containing data for that chainid. each entry block referenced the directory block takes bytes (two byte hashes, the chainid and the merkle root the entry block). million such entries would result set directory blocks roughly size. the average entry block had entries, directory blocks would provide the high level management million distinct entries. note that the exact implementation directory blocks vary build for greater scale the future. application only has the directory blocks, can find entry blocks interested without downloading every entry block. individual application would only interested small subset chainids being tracked factom. this greatly limits the amount bandwidth individual client would need use with factom their system record. for example, application monitoring real estate transfers could safely ignore video camera security logs. factom servers collect merkle roots entry blocks and package them into directory block. directory block the merkle roots are recorded into the bitcoin blockchain. this allows the most minimum expansion the blockchain, and still allows the ledger secured the bitcoin hash power. the process adding the merkle root into the bitcoin blockchain referred "anchoring". see the section "appendix: timestamping into bitcoin" for further details. data entered into directory blocks the most expensive, from bandwidth and storage perspective. all users factom wishing find data their chains need the full set directory blocks starting from when their chain began. activities that increase the directory block size include the creation and first update individual chains. these activities externalize costs applications attempting finer-grained organization. the applications must required expend more entry credits than simple entry would necessitate discourage bloating the directory blocks. entry block layer: how the entry block layer organizes hashes and data entry blocks are the second level hierarchy the system. individual applications will pay attention various chainids. entry blocks are the place where application looking for entries can expand its search from chainid discover all possibly relevant entries. there one entry block for each updated chainid per directory block. the entry blocks contain hashes individual entries. the hashes entries both prove the existence the data and give key find the entries distributed hash table (dht) network. (see the section "the factom peer-to-peer network" for more detail.) the entry blocks encompass the full extent possible entries related chainid. entry not referred entry block, can assumed not exist. this allows application prove negative, described the section security and proofs. the entry block intentionally does not contain the entries themselves. this allows the entry blocks much smaller than all the data was grouped together. separating the entries from the entry blocks also allows for easier auditing auditors. auditor can post entries separate chain that approves rejects entries common chain. the audit can add reasons for rejection its entry. application trusts the auditor, they can cross reference that the auditor has approved rejected every entry, without knowing what the entry is. the application would then only attempt download the entries which passed the audit. multiple auditors could reference the same entries, and the entries would only exist once the distributed hash table (dht). entries are expected significantly larger than the mere bytes hash takes up. lists things ignore not have have the full object being ignored for application know ignore it. the exact implementation entry blocks may vary the future response identified improvements possible the protocol. entry detailing the specifics land transfer would entered into chain where land transfers that type are expected found. one more auditors could then reference the hashes land transfer their own chains, adding cryptographic signatures indicating pass fail. the land transfer document would only need stored once, and would referenced multiple different chains. entries: how entries are created entries are constructed users and submitted factom. hashing encoding information, the user can ensure the privacy entries. the entries can instead plain text encoding obscuring the data isn't necessary. recording hash document, factom can provide basic proof publication. presenting the document later time allows one create its hash, and compare the hash recorded the past. there lots flexibility the data that accepted. can something short like hyperlink. could also larger, but not too large, since fees limit the size the data accepted. this similar bitcoin. large kb+ bitcoin transactions are possible, but would need pay proportionately greater transaction fee. this size, while gigantic bitcoin, would moderately sized for factom. since every bitcoin full node needs the entire blockchain fully validate, needs stay small. factom, only the highest level directory blocks are required fully validate chain. someone not specifically interested chain's data, they would not download it. take simple example uneditable twitter-like system. celebrity would craft entry piece text. they would then sign with private key show came from them. followers the celebrity would find which chain they publish and would monitor for updates. any new signed entries would recognized follower's application software tweet. others could tweet the celebrity adding entries the celebrity's chain. chains: how entries are organized into chains chains factom are sequences entries that reflect the events relevant application. these sequences are the heart bitcoin chains document these event sequences and provide audit trail recording that event sequence occurred. with the addition cryptographic signatures, those events would proof they originated from known source. chains are logical interpretations data placed inside directory blocks and entry blocks. the directory blocks indicate which chains are updated, and the entry blocks indicate which entries have been added the chain. this somewhat analogous how bitcoin full clients maintain local idea the utxo (unspent transaction output) set. the utxo set not (currently) the blockchain itself, but interpreted the full client. the factom peer-to-peer network factom will have peer-to-peer (pp) network which accomplishes two goals: communication and data preservation. factom peer-to-peer communications factom will have network very similar bitcoin's. will consist full nodes which have all the factom data. the full nodes create gossip network which will flood fill valid data throughout the network. the authority servers would full nodes, but not all full nodes are authority servers. this very much like bitcoin, where miners are full nodes, but not all full nodes are miners. this will limit the ability ddos the authority servers individually. they can connect anywhere inside the network acquire the data needed build the data structures. the servers are coming consensus and disseminate their signed data, they would publish the data over the network. the flood filling also limits the ability authority servers censor based addresses, since valid traffic mixed together the nodes they connect to. also helps prevent censorship, since all servers can see the entries which should included the entry blocks. outside organizations campaigning become authority servers have incentive bring bad behavior light, they can gain support and move into the set authority servers. data preservation and dissemination factom data structures (directory blocks, entry blocks, entries) are needed for factom useful. they are public and will preserved two places. the authority servers need maintain this data make correct decisions about adding new entries. since they have this data, they can provide service, part being full node. the protocol grows the protocol will able support partial nodes, which share only part the factom dataset. the partial nodes could share only the data which relevant their specific application. peer discovery for the partial nodes may handled any sort directory service, such distributed hash table (dht). this setup allows for efficient peer distribution data even the entire factom dataset grows unwieldy sizes. the directory service also allows the data preserved independent any authority servers full nodes. even all the full nodes were removed from the network, the data could still shared more numerous set parties interested specific subsets the data. deeper discussion factom how name factom chains factom groups all entries under chainid. the chainid computed from chain name. the chainid hash the chain name. the chain name byte array arbitrarily long length. see figure below. since the conversion from chain name chainid hash operation, simple process. deriving chain name from chainid not simple, lookup table would needed. the user must provide chain name, that the chainid can shown hash something. this prevents unhashed data from being chainid, which stored all the way the directory blocks. this convention eliminates insertion obscene plaintext the block structure. the chain name fairly arbitrary. could random number, string text, public key. individual application could derive meaning from different chain names. one possible convention would use human readable text for the chain name. this would allow for the structuring chains logical hierarchy, even though chains are not hierarchical nature. users can even use the same naming conventions, but making simple modifications, ensure that there are accidental intersections between their chains and other chains. consider the following path: myfavoriteapp/bin where the slash convention for another level hierarchy. the slash separating ascii strings "myfavoriteapp" and "bin" represents transitioning deeper level. these two strings must converted bytes, and there are many options for doing so. the strings could encoded utf-, utf-, ascii, even something like ibm's epcdic. each these encodings would result entirely different chainids for the same string, since the computation the chainid done from the bytes. furthermore, the application could utilize globally unique identifier (guid) number the first byte array their naming convention. this would eliminate overlap one application's chainid "space" with another, the expense just few more bytes the chain creation. using factoids purchase entry credits factoids are the main internal scarcity token used moderate and reward the system actors. the right put entries into factom represented entry credits. factom separates the two value-holding mechanisms, they serve different purposes. factoids can converted into entry credits, but not vice versa. factoids are implemented much the same way bitcoin implemented, allowing multiple inputs, multiple outputs, etc. where each input requires the proper signature for the transaction valid. other sorts validation including multisig possible. factoid transactions are managed special factoid chain. this factoid chain handled more restrictively than other chains. entries the factoid chain must valid factoid transactions, the factom servers will reject the entries. factoids are included into the protocol completely decentralize factom, and reduce bloat and spam both factom and bitcoin. factoids can converted entry credits the protocol, and paid out factom servers from the protocol. factoids budgeted but not paid out can remain "grant pool". these tokens can issued support and develop the protocol from the protocol. factoids also help bind consensus. consensus lost, then the factoids will fall value, incentivizing the support the protocol. the conversion factoid entry credits will done via special purchase transaction the factoid chain. this purchase transaction will include: output directing factoid amount converted the public key that receive the entry credits the entry credits, once purchased, cannot transferred another public key. they can only used pay for entries. this greatly reduces their value thieves, since they cannot resold. entry credit private keys can held low security areas with minimal risk. using entry credits write entries adding entries into factom requires giving scarce resource. that resource entry credits, which are derived from factoids. adding entries factom two step process. first the entry paid for (committed). the payment accomplishes two things. decrements the entry credits associated with user's public key. the same operation, the hash the entry specified. after the entry paid for, the server will wait for the unhashed entry and include once seen (revealed). pay for entry decrement entry credits owned user user specifies hash entry payment insert entry user publishes entry for inclusion entry block there are many benefits this two step process. one benefit separate the payment overhead from the recorded data. future users will not forced download the data generated payment minutia. they only need download the minimum data validate their system. allows users safely and easily ignore the payment information. another benefit censorship resistance. committing accept entry before knowing the content makes censorship the factom servers obvious. adam back has advocated for similar mechanism for bitcoin post titled "blind symmetric commitment for stronger byzantine voting resilience". user audit server can show entry which has been properly been paid for, but none the federated servers are accepting it, then the censorship provable. the transactions deducting entry credits will recorded special chain, similar the factoid chain. the federated servers will only fill the chain with valid entry credit transactions. setting the cost entries with central server oracle the conversion rate factoids entry credits will determined first choosing target real world value for entry credit. this target will determined distributed and autonomous process. minimum will agreed upon some process driven the authority set. other parties might involved through various auditable processes factom further decentralize the decision. once target real world target price entry credit has been chosen, oracle required record into factom the conversion value between factoids and that price. that specification and implementation will also through decentralized decision process. the actual implementation the target price, oracle implementation, and exchange rate adjustment can vary widely, but will optimized for decentralization, security, and regulatory compliance. note that fee calculations and rates are subject change, and don't materially impact the utility the factom protocol. using factom without factoids many users factom may not want wallet, and will not want hold any cryptocurrency asset. but they will want create their chains (ledgers) and add their entries. factom's two step recording process allows for the separation factoids, factom's tradable token, from the opportunity post entries factom, represented entry credits. servers and other recipients factom tokens can sell entry credits customers for payment via bitcoin, conventional credit card payments, etc. the user would provide public key hold the entry credits. the seller would convert the appropriate amount factoids entry credits and assign those rights the user's public key. users could thus buy entries credits for factom without ever owning the factoids that drive the factom servers. from regulation point view, this powerful. the servers earn factoids from the protocol. the only parties that transaction are the server and the protocol. then the server sells entry credits users, who eventually return factoids the rest the system. entry credits are non transferable, the user cannot assign them another user's public key, and selling private keys isn't practical useful. neither transaction tradable token (the factoid) transferred between two parties. conclusion factom distributed, autonomous layer residing top the bitcoin blockchain. the goal factom provide the power bitcoin's blockchain nearly unlimited range applications and uses. further, factom architected such that its users not need any cryptocurrency whatsoever. distributed, immutable ledger the radical, foundational, and unprecedented technology represented the bitcoin blockchain. the dream many extend the honesty inherent immutable ledger validated math chaotic, real-world interactions. allowing the construction unbounded ledgers backed the blockchain, factom extends the benefits the blockchain the real world. bibliography "bitcoin: peer-to-peer electronic cash system" nakamoto, satoshi. web. nov. https://bitcoin.org/bitcoin.pdf "can blocks remain capped forever?" transactions. web. nov. http://bitcoin.stackexchange.com/questions//can-blocks-remain-capped-to-mb-forever "thin client security." bitcoin. web. nov. https://en.bitcoin.it/wiki/thin_client_security#simplified_payment_verification_.spv. "evidence absence." wikipedia. wikimedia foundation, july web. nov. http://en.wikipedia.org/wiki/evidence_of_absence "recording (real estate)." wikipedia. wikimedia foundation, nov. web. nov. http://en.wikipedia.org/wiki/recording_(real_estate) "secure property titles with owner authority." secure property titles with owner authority. web. nov. http://szabo.best.vwh.net/securetitle.html "patent method providing digital signatures." google books. web. nov. http://www.google.com/patents/us "block timestamp." bitcoin. web. nov. https://en.bitcoin.it/wiki/block_timestamp "op_return and the future bitcoin." bitzuma. web. nov. http://bitzuma.com/posts/op-return-and-the-future-of-bitcoin/ "goblin/chronobit." github. web. nov. https://github.com/goblin/chronobit "how can one embed custom data block headers?" mining. web. nov. http://bitcoin.stackexchange.com/questions//how-can-one-embed-custom-data-in-block-head ers "headers-first synchronization coming soon bitcoin core cryptocoinsnews." cryptocoinsnews. web. nov. https://www.cryptocoinsnews.com/headers-first-synchronization-coming-soon-bitcoin-core/ "enabling blockchain innovations with pegged sidechains block stream web. nov. http://www.blockstream.com/sidechains.pdf "[bitcoin-development] -way pegging (re: there way bitcoin-staging?)" mailing lists. web. may. http://sourceforge.net/p/bitcoin/mailman/message//. "could the bitcoin network used ultrasecure notary service?" computerworld. accessed may. http://www.computerworld.com/s/article//could_the_bitcoin_network_be_used_as_an_ ultrasecure_notary_service_. "proof existence." proof existence. web. may. http://www.proofofexistence.com/. "virtual-notary." virtual-notary. web. may http://virtual-notary.org/. "commitment scheme" web. november. http://en.wikipedia.org/wiki/commitment_scheme "foundations cryptography: volume basic tools, (draft available from author's site)." cambridge university press. isbn ---. november. (see also http://www.wisdom.weizmann.ac.il/~oded/foc-book.html "real-world sybil attacks bittorrent mainline dht wang liang. jussi kangasharju. university helsinki. web. nov. http://www.cs.helsinki.fi/u/lxwang/publications/security.pdf "sybil-resident dht routing" university cambridge. danezis george. chris lesniewski-laas. kaashoek frans. anderson ross. web. nov. https://www.cl.cam.ac.uk/~rja/papers/sybildht.pdf sybil-proof one-drop dht" lesniewski-laas chris. web. nov. http://pdos.csail.mit.edu/papers/sybil-dht-socialnets.pdf "art provenance: what and how verify it" web. nov. http://www.artbusiness.com/provwarn.html "equine appraisal: the value our horses" web. nov. http://www.hgexperts.com/article.asp?id= "proof work" web. nov. https://en.bitcoin.it/wiki/proof_of_work "why one time passwords using nested hash chain are not used" web. nov. http://security.stackexchange.com/questions//why-one-time-passwords-using-nested-has h-chain-are-not-used "proving your bitcoin reserves" web. nov. https://iwilcox.me.uk//proving-bitcoin-reserves "distributed consensus from proof stake impossible" web. nov. https://download.wpsoftware.net/bitcoin/pos.pdf appendix audit application examples: what could useful today? how create useful applications today using the factom protocol 'application' generic term for user-side software that reads from and/or writes the factom system. could software with human interface, could completely automated. the application interested the data organized the chains needs. applications are possibly distributed applications (dapps) interacting with factom provide additional services. for example, one might imagine trading engine that processes transactions very fast, with very accurate timestamping. such application may nonetheless stream transactions out into factom chains document and secure the ledger for the engine. such mechanism could provide real-time cryptographic proof process, reserves, and communications. let explore two separate applications that could have immediate demand the current bitcoin ecosystem. let see how implement secure and distributed log platform. log analysis complex task. additionally, logs tend easily forgeable and also heterogeneous they are produced each system independently and stored variety media (files, databases, cloud services etc.). with factom and few uniquely designed crypto-audit tools entities log analysis can become safer, simpler, and much more powerful. let's see this with example. suppose bank (b), payment provider (pp), and bitcoin company (bc) are interacting together follows: the user goes the website and wants buy some bitcoins asks for quote, which valid for minutes then redirected the website then the connects with the platform that the money the user account debited notifies that the user account has been debited notifies sends the bitcoins the user this the normal scenario for many fixed-rate bitcoin exchanges globally. but assume now that for some reason the receives the payment notification hours after the user transfers via the pp. who faulty? the user? the bank? the payment provider? what similar payment problem happened for hundreds thousands payments over period days weeks before the issue was identified and resolved? who "provably" liable for those loses/damages? with current techniques manual auditing logs would necessary and would probably require legal authorizations. with factom and the right audit applications, would trivial detect where the problem came from, and also make the changing records impossible post-issue. basically, every system (bb, pp, bc) will publish their relevant traces the secure broadcast channel (factom) real time. here's another example how factom will useful for bitcoin exchanges audits. the so-called "proof solvency" method for conducting bitcoin exchange audits growing and important trend. however, there are significant weaknesses this approach only solved having the factom secure broadcast channel functioning properly. the merkle tree approach for solvency proofs suggested the maxwell-todd proposal, users must manually report that their balances (user's leaf) have been correctly incorporated the liability declaration the financial institution (fi) (the merkle hash the fi's database user balances). the proposed solution works enough users verify that their account was included the tree, and case where their account not included, it's assumed that this instance would reported. one potential risk with this process that exchange database owner could produce hash that not the true representation the database all; the exchange hashes incomplete database which would reduce its apparent liabilities customers, thereby making them appear solvent verifying party. here are some scenarios where fraudulent exchange could easily exclude accounts: "colluding whales" attack: there evidence that large bitcoin traders are operating various exchanges and moving markets significantly. such traders need have capital reserves the largest exchanges quickly execute orders. often, traders choose exchanges that they "trust". this way they can assured that should hack liquidity issue arise, they have priority get their money out first. this case, the exchange and trader could collude remove the whales account balance from the database before it's hashed. exchange's top whales could easily represent exchanges liabilities, colluding with just few them could have significant impact. "site manipulation" attack: date, each proof solvency audit has reported (the hash tree) the institution's website. this gives guarantee all users, since malicious exchange could publish different states/balances different groups users, retroactively change the state. thus fundamental publish this data through factom's secure broadcast channel, and publish frequently. the second attack obviously solved using factom, while the first not obvious. this paper doesn't focus the mechanics exchanges audits, won't delve the nitty-gritty details. however, the basic concept that having frequent time-stamped copies the exchanges database merkle hash, one could detect the inclusion exclusive large balances before after audits. then, the auditor could simply look into those large inclusions exclusions, manually. remember, the trader will ultimately need get his money off the exchange some point, and that'll show either the bank history the bitcoin transfer history. there are established process for detecting such fraudulent tactics the traditional audit industry; however, all starts with having accurate, verifiable, immutable time-series the information question. appendix attacks factom denial service from spam since factom open system, any user can put entries into almost any chain. bitcoin has similar phenomenon. order for application reject those transactions, the application would first need download and process them. large number bogus entries could slow down the initial processing the application's transactions. this threat mitigated attacker needing spend money (resources) carry out. this similar adam back's hashcash solution email spam. audits are another useful tool against spam, the application willing trade off security versus convenience. auditors could post "ignore" lists the same chain, create their own audit chains with those lists. auditor could use profile chain develop their reputation, which would also allow review other auditors. any auditor made bad call, would easily verifiable and the record would permanent. some validity processing gray, the sense that opinions may vary. solving that problem would implementation specific. sybil attack the dht distributed hash tables general are particularly susceptible sybil attacks. attacker could create many peers which make difficult for honest nodes communicate. simplistic dht architecture, attackers can isolate required piece data from honest nodes. sybil attacks have been observed the bittorrent network routing table. the paper "real-world sybil attacks bittorrent mainline dht" detail these attacks. fighting this type attack active topic academic research. one mitigation technique uses complex lookup techniques find honest nodes among the sybils, studied "sybil-resistant dht routing". some sybil mitigation techniques rely web-of-trust adding social network the routing table, explored sybil-proof one-hop dht". factom will rely the latest academic and open-source research this topic secure its dht. dictionary attack this case, the attacker runs through all the chain names deemed possible desirable and creates their chainids, and the hashes those chainids. then they watch for someone trying create those chains. now the attacker can front run match. because match, they know the chainid, they can construct proper, but malicious entry their own, create the proper chain payment and submit rather than the users payment. the attacker gets ahead the user, then they will win. the defense against dictionary attack avoid common name spaces and submit your payment multiple, long standing nodes the network. factom, the flexibility defining the chain namespace makes efforts hog the namespace ineffective. fraudulent servers all entries factom require signatures from the users, must match hash that has been signed the users. this means that fraudulent federated servers the federation pool have very limited attacks they can make the protocol. invalid entries not validate, and upon broadcasting invalid entry, the honest federated servers will immediately broadcast server fault message (sfm) the fraudulent server. majority detect fault, the faulty server removed. long the majority not collude, then the protocol will remain honest. any federated server that failed detect the fault likewise risks losing its support from factom users, and dropping from the federated server pool. federated servers can delay recording entry payments. but because entry payments are submitted via distributed set factom nodes, delaying entry payments will noted. users may withdraw support from servers without reasonable performance compared the rest the network. federated servers can delay the recording entries. here the payment accepted (generally another server) fairly quickly. but for one reason another, federated server refuses record the entry. the next minute, responsibility for that chain will shift another server. long most servers are honest, the entry will recorded. then the data over time will show that server delaying entries. this will cause them potentially lose support. federated servers can any point send false messages. the other federated servers then would issue sfr the the rogue server when those messages didn't make sense. majority the servers issuing sfr would boot the rogue server, then the network would ignore their messages and not forward them on. federated servers can refuse accept valid entry payment messages based the public address, under the assumption that the public address associated with some party. again, assuming majority servers are honest, the payment will accepted when the control shifts honest server. furthermore, nodes watching will see the delay, and perhaps pattern delays, and support will lost for the misbehaving servers. appendix timestamping into bitcoin how the factom timestamping mechanism secures transactions the blockchain factom data timestamped and made irreversible the bitcoin network. user's data secure any other bitcoin transaction, once published the bitcoin blockchain. compact proof publication possible for any data entered into the factom system. data organized into block structures, the highest level being directory blocks, which are created using merkle trees. every minutes, the data set frozen and submitted the bitcoin network. since bitcoin has unpredictable block time, there may more fewer than one factom timestamp per bitcoin block. bitcoin internal header block times themselves have fluid idea time. they have hour possible drift from reality. factom will provide its own internal timestamps, adhering with standard time systems. the user data ordering will assigned when received the federated servers. factom organizes the submitted entry references into sets blocks. the block time for factom ten minutes. closing, the federated server network generates consensus and the entries that are part that block structure are timestamped minute within the block. general note, the data could have existed long before was timestamped. application running top factom could provide finer and more accurate timestamping services prior entries being recorded factom. the factom timestamp only proves the data did not originate after the factom timestamp. the merkle root the directory block entered into the bitcoin blockchain with spending transaction. the spend includes output with op_return. refer this "anchoring" the directory block the bitcoin blockchain. this method the least damaging the bitcoin network the various ways timestamp data. two possible alternatives the op_return data the blockchain anchored the ppool headers (as chronobit) the bitcoin block header coinbase. the ppool headers would require several hours mining find block which satisfies the ppool rules, and the added complexity the factom protocol would not worth the benefits. including the merkle root into the coinbase block would require cooperation with miners, above and beyond the transaction processing they are already doing. the coinbase entry would still need have crypto signature from the factom system, would not save much space relative signed transaction. the first two bytes the available the anchor will designator tag bytes with the value "fa"). the factom anchor bytes) concatenated onto the tag, then the block height added (up bytes, allowing for years). the designator tag indicates the transaction could factom anchor. other qualifiers are required, but the tag and factom block height eliminates most the op_return transactions that would otherwise need inspected. the block height the op_return helps fix the order those cases where the bitcoin blockchain records the anchors out order. the anchored data the merkle root list containing the directory block's merkle root. querying database dht for the anchored data will return the directory block which can used find the rest the data the block. the merkle root timestamp will entered into the bitcoin blockchain one the federated servers. the server delegated timestamp the federation's collected data creates bitcoin transaction. the transaction will broadcast the bitcoin network, and included bitcoin block. bitcoin transactions that look like factom anchor, but are not spent from address known factom server would either junk, attempt fork factom. most users/applications would ignore such anchors. bitcoin blocks are generated with statistical process, and such their timing cannot predicted. this means that the anchors are only roughly time-bound the op_returns inserted into the bitcoin blockchain, and its timestamping mechanism. the real value anchoring factom bitcoin prevent anyone from generating false factom histories. due bad luck bitcoin miners, delayed inclusion factom transactions, the time between when the factom state frozen for particular minute period and when the anchor appears bitcoin can vary, perhaps significantly. the ramifications federated servers and anchoring proof work proof work (pow) optimized for permissionless participation and validation the historical record blockchain. the typical implementation proof work repeatedly hash blocks until one the parties mining finds hash with the difficulty required the current requirements blockchain. this allows anyone serve miner, collect and validate transactions, pack them into blocks, and repeatedly hash that block looking for solution that meets the difficulty requirement. the shortcomings pow have been widely discussed the media requiring unnecessary amounts power, when other sorts problem solving and work could result benefits blockchain users, the ecosystem, and society. such the goal various proof stake (pos) systems used various blockchains. but proof stake alone makes the historical record hard validate, and does not work well for data recording system like factom. this because validating the historical stake parties involved the entire blockchain, and understanding the stake that existed each point time historically. factom needs small cryptographic proofs that validate sets data, which pow provides. because pow validated solely evaluating the difficulty hash. anchoring the solution factom uses secure the historical record, and the same time avoid duplicating the massive expenditure resources required mining. system like pos can used the present, while anchoring secures the historical record. the idea supporting parties allows permissionless participation the factom protocol beyond that the authority set. the authority set and anchoring means that running the authority servers less expensive resources orders magnitude compared mining. greater efficiency means that the rewards paid out the factom protocol can more for the ecosystem than pay very large utility bills. factom may use various voluntary but auditable methods incentivize using the efficiency the authority set set aside resources within the protocol for productive real world work. sort proof development could used receive these rewards using distributed support identify work done, and evaluate the quality the work that results. such system could provide rewards for development alongside the rewards generated for the authority set. "proof development" comes with its own issues. the main issue the "oracle problem," where very hard know from within the programming blockchain protocol what might useful development the real-world and evaluate the quality such development once done. factom may develop mechanisms incentivize supporting parties the protocol create evaluation processes, audit trails, and certifications every stage development address the oracle problem, and allow self-correcting process manage viable "proof development" that more productive and ecologically friendly than simply rewarding the burning energy resources for security. appendix comparing factom with other blockchain technologies how factom differs from bitcoin and sidechains factom very different from bitcoin, and fact very different from any current cryptocurrency project. cryptocurrencies like bitcoin implement strict, distributed method for the validation transactions, where anyone can validate each transaction, and the validity every input into transaction can verified. because each transaction authorized via cryptographic proof, transaction can forged. each transaction can checked for validity verifying signatures each transaction, and the miners hold each other accountable for only including valid transactions. the bitcoin protocol transactionally complete. other words, the creation and distribution bitcoins through transactions completely defined within the bitcoin protocol. transactions (which specify movement bitcoin) and block discovery (which move bitcoin via mining fees and provide block rewards) are the only inputs into the bitcoin protocol, and nothing leaves the bitcoin protocol. other words, the million bitcoins that will ultimately exist will always and forever exist within the protocol. pegged sidechains, when implemented, will provide additional movement bitcoin value outside the blockchain, while the pegged value stasis the blockchain. the sidechains proposal describes solution increase the scalability bitcoin allowing value control move off the blockchain and onto sidechain. the sidechain, many trades can occur. later, cryptographic proof (not all the transactions between) can recorded the blockchain which moves the btc out stasis bitcoin. this proof would have available the bitcoin miners, but the bulk the transaction data would left behind the sidechain. factom some sense attempting increase scalability, but not enabling more value transactions, but moving non-btc transactions off blockchain. this would transactions that are not primarily intended transfer bitcoin value. for example transactions could manage domain name registrations, log security camera footage, track the provenance for art work, and even establish the value show horses documenting their history. some these not move value all, like transactions establishing proof publication. sidechains and factom are both trying move transactions off the blockchain, but achieve similar ends via completely different mechanisms. some point, factom may integrate with bitcoin sidechain order take advantage the atomic swaps from btc factoids. how factom different from other blockchain technologies many different groups are looking find ways leverage the bitcoin approach for managing other sorts transactions besides tracking bitcoin balances. for example, the trading assets such houses cars can done digitally using bitcoin extensions. even the trading commodities such precious metals, futures, securities might done via clever encoding and inserting information into the bitcoin blockchain. efforts expand bitcoin cover these kinds trades include colored coins, mastercoin, and counterparty. some developers choose build their own cryptocurrency with more flexible protocol that can handle trades beyond currency. these include namecoin, ripple, ethereum, bitshares, nxt, and others. open transactions (ot) uses cryptographic signatures, signed receipts and proof balance for users (i.e., user does not need the transaction history prove their balance, just the last receipt). this way, can provide the spend centralized servers without the risk centralized server that can alter client balances. factom decentralized, and only records entries. factom can record data that would not meet ot's rules. but factom will not execute the rate can initially. factom distributed, and expect that some, but not all users will employ cryptographic techniques similar with their records. the great advantage independent platform over trying build upon bitcoin found flexibility. the bitcoin protocol isn't optimized allow for recording arbitrary pieces data, the "bookkeeping" necessary for non-bitcoin type transactions isn't necessarily supported bitcoin. furthermore, bitcoin's proof work (pow) based consensus method not "one size fits all" solution, given that some transactions must resolve much faster than minutes. ripple and open transactions vastly speed confirmation times changing the consensus method. application built upon factom seeks gain the ability track assets and implement contracts, leveraging the blockchain directly. instead inserting transactions into the blockchain (viewed "blockchain bloat" many), factom records its entries within its own structures. the base level, factom records what chains have had entries added factom within the directory block time. scanning these records, applications can pick out the chains which they are interested. factom records each chain independently, applications can then pull the chain data they need. factom organized way that minimizes connections between user chains. chain factom can validated without any the information held other, unrelated chains. this minimizes the information factom user has maintain validate the chains they are interested in. appendix proof stake similarities factom consensus similarities and differences from proof stake the policy and reward mechanism factom similar proof stake (pos). factom differs from most pos systems that many subsets user stake and/or contribution may recognized. individual categories stake can weighted against each other further decentralized factom. this attempt make the servers answerable the users actively using and contributing the protocol. the individual users would delegate their support server. the federated servers with the top numbers support would responsible for coming consensus. some with deep understand bitcoin have recognized that pure pos consensus mechanisms are fundamentally flawed. there are two attacks that make pure pos unworkable. the problems are referred "stake grinding" and "nothing stake". although factom has pos elements, does not suffer from these problems. stake grinding stake grinding problem where attacker with sizable (say %), but not majority share can formulate false histories. from some point history, they can costlessly fork the blockchain, choosing reorder past transactions such that their stake always selected create the subsequent blocks. they would able present this alternate version history part attack steal value double spending. bitcoin solves this problem strongly linking the information domain, where computers make decisions, with the thermodynamic domain, where humans burn energy. considerable resources are expended the thermodynamic domain, and provable the information domain. bitcoin makes forming false histories hugely expensive. factom unable create alternate histories after the fact, since unable insert transactions into historical bitcoin blocks. also unable create parallel histories without being detected, since factom linked bitcoin with known bitcoin private keys. nothing stake the nothing stake problem more subtle. with policy disagreement bitcoin, miners must choose either one policy the other. they choose against the majority, they will burning lots electricity without chance recouping costs. pos miners not face this dilemma. they can hedge their bets and costlessly create forks complying with each side the policy. they would simultaneously agree with both sides the disagreement. this would open the economy double spend attacks. one two merchants following different forks will ultimately have that money becomes worthless. bitcoin solves this problem having unintelligent unambiguous automatable rules for selecting the correct fork. bitcoin, the correct fork the one with the most proof work (pow). factom will also have unintelligent unambiguous automatable rules select correct fork, should one arise.